{"version":3,"sources":["../src/cli.ts","../src/hysteria_cli/migration_create_connector.ts","../src/hysteria_cli/resources/migration_templates.ts","../src/utils/logger.ts","../src/hysteria_cli/migration_run_connector.ts","../src/hysteria_cli/postgres/run_migration.ts","../src/sql/migrations/migration_controller.ts","../src/sql/resources/query/TRANSACTION.ts","../src/data_source.ts","../src/drivers/driver.ts","../src/drivers/driver_constants.ts","../src/drivers/pg_driver.ts","../src/drivers/mongo_driver.ts","../src/drivers/mysql_driver.ts","../src/drivers/redis_driver.ts","../src/drivers/sqlite3_driver.ts","../src/drivers/drivers_factory.ts","../src/sql/models/model.ts","../src/utils/case_utils.ts","../src/utils/json_utils.ts","../src/sql/models/relations/relation.ts","../src/sql/models/relations/belongs_to.ts","../src/sql/models/relations/has_many.ts","../src/sql/models/relations/has_one.ts","../src/sql/models/relations/many_to_many.ts","../src/sql/models/model_decorators.ts","../src/sql/serializer.ts","../src/entity.ts","../src/utils/date_utils.ts","../src/sql/models/model_manager/model_manager.ts","../src/sql/resources/query/DELETE.ts","../src/sql/resources/query/INSERT.ts","../src/sql/resources/utils.ts","../src/sql/resources/query/RELATION.ts","../src/sql/resources/query/UPDATE.ts","../src/sql/models/model_manager/model_manager_utils.ts","../src/sql/pagination.ts","../src/sql/resources/query/SELECT.ts","../src/sql/resources/query/WHERE.ts","../src/sql/query_builder/where_query_builder.ts","../src/sql/query_builder/query_builder.ts","../src/sql/resources/query/JOIN.ts","../src/sql/mysql/mysql_query_builder.ts","../src/sql/mysql/mysql_model_manager.ts","../src/sql/postgres/postgres_query_builder.ts","../src/sql/postgres/postgres_model_manager.ts","../src/sql/sqlite/sql_lite_query_builder.ts","../src/sql/sqlite/sql_lite_model_manager.ts","../src/sql/transactions/transaction.ts","../src/sql/sql_data_source.ts","../src/hysteria_cli/migration_utils.ts","../src/hysteria_cli/mysql/run_migration.ts","../src/hysteria_cli/sqlite/run_migration.ts","../src/hysteria_cli/migration_rollback_connector.ts","../src/hysteria_cli/mysql/rollback_migration.ts","../src/hysteria_cli/postgres/rollback_migration.ts","../src/hysteria_cli/sqlite/rollback_migration.ts"],"sourcesContent":["import { Command } from \"commander\";\nimport migrationCreateConnector from \"./hysteria_cli/migration_create_connector\";\nimport runMigrationsConnector from \"./hysteria_cli/migration_run_connector\";\nimport rollbackMigrationsConnector from \"./hysteria_cli/migration_rollback_connector\";\n\nconst program = new Command();\n\nprogram\n  .command(\"create:migration <name>\")\n  .description(\n    \"Create a new migration file, standard folder is database/migrations from the current directory you are now, you can change it in the env MIGRATION_PATH\",\n  )\n  .option(\n    \"-j, --javascript\",\n    \"Generate a javascript file instead of a default typescript one\",\n    false,\n  )\n  .action((name: string, option: { javascript: boolean }) => {\n    if (!name) {\n      console.error(\"Error: migrations name is required.\");\n      process.exit(1);\n    }\n\n    migrationCreateConnector(name, option.javascript);\n  });\n\nprogram\n  .command(\"run:migrations [runUntil]\")\n  .description(\n    \"Run pending migrations, if runUntil is provided, it will run all migrations until the provided migration name\",\n  )\n  .action(async (runUntil: string) => {\n    await runMigrationsConnector(runUntil);\n  });\n\nprogram\n  .command(\"rollback:migrations [rollbackUntil]\")\n  .description(\n    \"Rollbacks every migration that has been run, if rollbackUntil is provided, it will rollback all migrations until the provided migration name\",\n  )\n  .action(async (rollbackUntil: string) => {\n    await rollbackMigrationsConnector(rollbackUntil);\n  });\n\nprogram\n  .command(\"refresh:migrations\")\n  .description(\n    \"Rollbacks every migration that has been run and then run the migrations\",\n  )\n  .action(async () => {\n    await rollbackMigrationsConnector();\n    await runMigrationsConnector();\n  });\n\nprogram.parse(process.argv);\n","import dotenv from \"dotenv\";\nimport path from \"path\";\nimport MigrationTemplates from \"./resources/migration_templates\";\nimport fs from \"fs\";\nimport logger from \"../utils/logger\";\n\ndotenv.config();\n\nfunction getOrCreateMigrationPath(): string {\n  let migrationPath = process.env.MIGRATION_PATH || \"database/migrations\";\n  let currentPath = path.resolve(process.cwd(), migrationPath);\n\n  if (!fs.existsSync(currentPath)) {\n    fs.mkdirSync(currentPath, { recursive: true });\n  }\n\n  return currentPath;\n}\n\nexport default function migrationCreateConnector(\n  name: string,\n  js: boolean = false,\n) {\n  const migrationFolderPath = getOrCreateMigrationPath();\n  const timestamp = new Date().getTime();\n  const migrationFileName = !js\n    ? `${timestamp}_${name}.ts`\n    : `${timestamp}_${name}.js`;\n  const migrationFilePath = path.join(migrationFolderPath, migrationFileName);\n\n  const migrationTemplate = MigrationTemplates.basicMigrationTemplate(js);\n  fs.writeFileSync(migrationFilePath, migrationTemplate);\n  logger.info(`Migration created successfully at '${migrationFilePath}'.`);\n}\n","class Migration_templates {\n  basicMigrationTemplate(js: boolean = false): string {\n    if (js) {\n      return `import { Migration } from 'hysteria-orm';\n\nexport default class extends Migration {\n  async up() {\n    // Your migration logic here\n  }\n\n  async down() {\n    // Your rollback logic here\n  }\n}\n`;\n    }\n    return `import { Migration } from 'hysteria-orm';\n\nexport default class extends Migration {\n  async up(): Promise<void> {\n    // Your migration logic here\n  }\n\n  async down(): Promise<void> {\n    // Your rollback logic here\n  }\n}\n`;\n  }\n\n  selectAllFromMigrationsTemplate(): string {\n    return `SELECT * FROM migrations;`;\n  }\n\n  migrationTableTemplateMysql(): string {\n    return `CREATE TABLE IF NOT EXISTS \\`migrations\\`(\n    \\`id\\` INT NOT NULL AUTO_INCREMENT,\n    \\`name\\` VARCHAR(255) NOT NULL,\n    \\`timestamp\\` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (\\`id\\`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n`;\n  }\n\n  migrationTableTemplatePg(): string {\n    return `CREATE TABLE IF NOT EXISTS migrations (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n`;\n  }\n\n  migrationTableTemplateSQLite(): string {\n    const now = new Date().toISOString();\n    return `CREATE TABLE IF NOT EXISTS migrations (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL,\n    timestamp TEXT NOT NULL DEFAULT '${now}'\n);`;\n  }\n}\n\nexport default new Migration_templates();\n","import winston from \"winston\";\n\ninterface LogColors {\n  info: string;\n  warn: string;\n  error: string;\n  [key: string]: string;\n}\n\nconst colors: LogColors = {\n  info: \"\\x1b[32m\",\n  warn: \"\\x1b[33m\",\n  error: \"\\x1b[31m\",\n};\n\nconst logFormat = winston.format.combine(\n  winston.format.timestamp({ format: \"YYYY-MM-DD HH:mm:ss\" }),\n  winston.format.printf(({ level, message, timestamp }) => {\n    const color = colors[level] || \"\\x1b[0m\";\n    return `${timestamp} ${color}${level}\\x1b[0m: ${color}${message}\\x1b[0m`;\n  }),\n);\n\nconst consoleTransport = new winston.transports.Console();\nconst fileTransport = new winston.transports.File({ filename: \"logfile.log\" });\n\nconst logger = winston.createLogger({\n  format: logFormat,\n  transports: [consoleTransport, fileTransport],\n});\n\nexport function log(query: string, logs: boolean, params?: any[]) {\n  if (!logs) {\n    return;\n  }\n\n  if (params && params.length) {\n    params.forEach((param, index) => {\n      let formattedParam: any = null;\n\n      if (typeof param === \"string\") {\n        // Format string parameters\n        formattedParam = `'${param}'`;\n      } else if (\n        typeof param === \"object\" &&\n        param !== null &&\n        Object.keys(param).length > 0\n      ) {\n        // Format object parameters\n        formattedParam = `'${JSON.stringify(param)}'`;\n      } else {\n        // Use the parameter as is for other types (e.g., numbers)\n        formattedParam = param;\n      }\n\n      // Replace MySQL-style placeholders\n      query = query.replace(/\\?/, formattedParam);\n\n      // Replace PostgreSQL-style placeholders\n      const pgPlaceholder = new RegExp(`\\\\$${index + 1}`, \"g\");\n      query = query.replace(pgPlaceholder, formattedParam);\n    });\n  }\n\n  logger.info(\"\\n\" + query);\n}\n\nexport function queryError(error: any) {\n  logger.error(\"query Failed \", error);\n}\n\nexport default logger;\n","import dotenv from \"dotenv\";\nimport { runMigrationsPg } from \"./postgres/run_migration\";\nimport { runMigrationsSql } from \"./mysql/run_migration\";\nimport { runMigrationsSQLite } from \"./sqlite/run_migration\";\nimport logger from \"../utils/logger\";\n\ndotenv.config();\n\nexport default async function runMigrationsConnector(runUntil?: string) {\n  const databaseType = process.env.DB_TYPE;\n  if (!databaseType) {\n    throw new Error(\"Run migrations error: DB_TYPE env not set\");\n  }\n\n  logger.info(`Running migrations for ${databaseType}`);\n  switch (databaseType) {\n    case \"mariadb\":\n    case \"mysql\":\n      await runMigrationsSql(runUntil);\n      break;\n    case \"postgres\":\n      await runMigrationsPg(runUntil);\n      break;\n    case \"sqlite\":\n      await runMigrationsSQLite(runUntil);\n      break;\n    default:\n      throw new Error(\n        \"Invalid database type, must be mysql, postgres or sqlite, got: \" +\n          databaseType,\n      );\n  }\n\n  logger.info(\"Migrations ran successfully\");\n}\n","#!/usr/bin/env node\n\nimport dotenv from \"dotenv\";\nimport { MigrationTableType } from \"../resources/migration_table_type\";\nimport { Migration } from \"../../sql/migrations/migration\";\nimport { MigrationController } from \"../../sql/migrations/migration_controller\";\nimport {\n  BEGIN_TRANSACTION,\n  COMMIT_TRANSACTION,\n  ROLLBACK_TRANSACTION,\n} from \"../../sql/resources/query/TRANSACTION\";\nimport logger, { log } from \"../../utils/logger\";\nimport { SqlDataSource } from \"../../sql/sql_data_source\";\nimport { getMigrationTable, getMigrations } from \"../migration_utils\";\nimport { PgClientInstance } from \"../../sql/sql_data_source_types\";\n\ndotenv.config();\n\nexport async function runMigrationsPg(runUntil?: string): Promise<void> {\n  const sql = await SqlDataSource.connect();\n  const sqlConnection = sql.getCurrentConnection() as PgClientInstance;\n  try {\n    log(BEGIN_TRANSACTION, true);\n    await sqlConnection.query(BEGIN_TRANSACTION);\n\n    const migrationTable: MigrationTableType[] =\n      await getMigrationTable(sqlConnection);\n    const migrations: Migration[] = await getMigrations();\n    const pendingMigrations = migrations.filter(\n      (migration) =>\n        !migrationTable\n          .map((table) => table.name)\n          .includes(migration.migrationName),\n    );\n\n    if (pendingMigrations.length === 0) {\n      logger.info(\"No pending migrations.\");\n      await sql.closeConnection();\n      process.exit(0);\n    }\n\n    if (runUntil) {\n      const runUntilIndex = pendingMigrations.findIndex(\n        (migration) => migration.migrationName === runUntil,\n      );\n\n      if (runUntilIndex === -1) {\n        throw new Error(`Migration ${runUntil} not found.`);\n      }\n\n      const filteredMigrations = pendingMigrations.slice(0, runUntilIndex + 1);\n      const migrationController = new MigrationController(\n        sql,\n        sqlConnection,\n        \"postgres\",\n      );\n\n      await migrationController.upMigrations(filteredMigrations);\n      log(COMMIT_TRANSACTION, true);\n      await sqlConnection.query(COMMIT_TRANSACTION);\n      return;\n    }\n\n    const migrationController = new MigrationController(\n      sql,\n      sqlConnection,\n      \"postgres\",\n    );\n\n    await migrationController.upMigrations(pendingMigrations);\n\n    log(COMMIT_TRANSACTION, true);\n    await sqlConnection.query(COMMIT_TRANSACTION);\n  } catch (error: any) {\n    log(ROLLBACK_TRANSACTION, true);\n    await sqlConnection.query(ROLLBACK_TRANSACTION);\n    throw error;\n  } finally {\n    await sql.closeConnection();\n  }\n}\n","import { SqlDataSource } from \"../sql_data_source\";\nimport { Migration } from \"./migration\";\nimport { log } from \"../../utils/logger\";\nimport {\n  MysqlConnectionInstance,\n  PgClientInstance,\n  SqlConnectionType,\n  SqlDataSourceType,\n  SqliteConnectionInstance,\n} from \"../sql_data_source_types\";\n\nexport class MigrationController {\n  protected sqlDataSource: SqlDataSource;\n  protected sqlConnection: SqlConnectionType;\n  private sqlType: SqlDataSourceType;\n\n  constructor(\n    sqlDataSource: SqlDataSource,\n    sqlConnection: SqlConnectionType,\n    sqlType: SqlDataSourceType,\n  ) {\n    this.sqlConnection = sqlConnection;\n    this.sqlType = sqlType;\n    this.sqlDataSource = sqlDataSource;\n  }\n\n  async upMigrations(migrations: Migration[]): Promise<void> {\n    try {\n      for (const migration of migrations) {\n        await migration.up();\n        const statements = migration.schema.queryStatements;\n        for (const statement of statements) {\n          if (\n            !statement ||\n            statement === \"\" ||\n            statement === \";\" ||\n            statement === \",\"\n          ) {\n            continue;\n          }\n          await this.localQuery(statement);\n        }\n\n        await this.addMigrationToMigrationTable(migration);\n        if (migration.afterUp) {\n          await migration.afterUp(this.sqlDataSource);\n        }\n      }\n    } catch (error: any) {\n      throw error;\n    }\n  }\n\n  async downMigrations(migrations: Migration[]): Promise<void> {\n    migrations = migrations.reverse();\n    try {\n      for (const migration of migrations) {\n        await migration.down();\n        const statements = migration.schema.queryStatements;\n        for (const statement of statements) {\n          if (\n            !statement ||\n            statement === \"\" ||\n            statement === \";\" ||\n            statement === \",\"\n          ) {\n            continue;\n          }\n          await this.localQuery(statement);\n        }\n        await this.deleteMigrationFromMigrationTable(migration);\n        if (migration.afterDown) {\n          await migration.afterDown(this.sqlDataSource);\n        }\n      }\n    } catch (error: any) {\n      throw new Error(error);\n    }\n  }\n\n  private async localQuery(text: string, params: any[] = []): Promise<void> {\n    if (this.sqlType === \"mysql\" || this.sqlType === \"mariadb\") {\n      text = text.replace(/PLACEHOLDER/g, \"?\");\n      log(text, true, params);\n      await (this.sqlConnection as MysqlConnectionInstance).query(text, params);\n      return;\n    } else if (this.sqlType === \"postgres\") {\n      let index = 1;\n      text = text.replace(/PLACEHOLDER/g, () => `$${index++}`);\n      log(text, true, params);\n      await (this.sqlConnection as PgClientInstance).query(text, params);\n      return;\n    } else if (this.sqlType === \"sqlite\") {\n      text = text.replace(/PLACEHOLDER/g, \"?\");\n      log(text, true, params);\n      await new Promise<void>((resolve, reject) => {\n        (this.sqlConnection as SqliteConnectionInstance).run(\n          text,\n          params,\n          (error) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          },\n        );\n      });\n      return;\n    }\n\n    throw new Error(\"No database connection found while running migration\");\n  }\n\n  async addMigrationToMigrationTable(migration: Migration) {\n    const completeUtcTimestamp = new Date();\n    const timestamp = completeUtcTimestamp\n      .toISOString()\n      .replace(\"T\", \" \")\n      .replace(/\\.\\d{3}Z$/, \"\");\n\n    const insertMigrationSql = `INSERT INTO migrations (name, timestamp) VALUES (PLACEHOLDER, PLACEHOLDER)`;\n\n    await this.localQuery(insertMigrationSql, [\n      migration.migrationName,\n      timestamp,\n    ]);\n  }\n\n  async deleteMigrationFromMigrationTable(migration: Migration) {\n    const deleteMigrationSql = `DELETE FROM migrations WHERE name = PLACEHOLDER`;\n\n    await this.localQuery(deleteMigrationSql, [migration.migrationName]);\n  }\n\n  async removeMigrationTable() {\n    const dropMigrationTableSql = `\n      DROP TABLE IF EXISTS migrations\n    `;\n\n    log(dropMigrationTableSql, true);\n    await this.localQuery(dropMigrationTableSql);\n  }\n}\n","export const BEGIN_TRANSACTION = \"BEGIN; \\n\";\nexport const COMMIT_TRANSACTION = \"COMMIT; \\n\";\nexport const ROLLBACK_TRANSACTION = \"ROLLBACK; \\n\";\n","import dotenv from \"dotenv\";\nimport {\n  MongoClientImport,\n  Mysql2Import,\n  MysqlCreateConnectionOptions,\n  PgClientOptions,\n  PgImport,\n} from \"./drivers/driver_constants\";\nimport { MongoOptions } from \"mongodb\";\n\ndotenv.config();\n\n/*\n * Creates a datasource for the selected database type with the provided credentials\n */\nexport type DataSourceType =\n  | \"mysql\"\n  | \"postgres\"\n  | \"mariadb\"\n  | \"sqlite\"\n  | \"mongo\";\n\n/**\n * @description By default the connection details can be provided in the .env file, you can still override each prop with your actual connection details in the input\n */\nexport interface DataSourceInput {\n  type?: DataSourceType;\n  readonly host?: string;\n  readonly port?: number;\n  readonly username?: string;\n  readonly password?: string;\n  readonly database?: string;\n  readonly logs?: boolean;\n  readonly mysqlOptions?: MysqlCreateConnectionOptions;\n  readonly pgOptions?: PgClientOptions;\n  readonly mongoOptions?: MongoOptions;\n\n  /**\n   * @description Mongo specific option, sql databases won't use this property\n   */\n  readonly url?: string;\n}\nexport abstract class DataSource {\n  protected type!: DataSourceType;\n  protected host!: string;\n  protected port!: number;\n  protected username!: string;\n  protected password!: string;\n  protected database!: string;\n  protected url!: string;\n  logs!: boolean;\n\n  protected constructor(input?: DataSourceInput) {\n    if (this.type === \"mongo\") {\n      this.handleMongoSource(input?.url);\n      return;\n    }\n\n    this.handleSqlSource(input);\n  }\n\n  protected handleMongoSource(url?: string) {\n    this.type = \"mongo\";\n  }\n\n  protected handleSqlSource(input?: DataSourceInput) {\n    this.type = (input?.type || process.env.DB_TYPE) as DataSourceType;\n    this.host = (input?.host || process.env.DB_HOST) as string;\n    this.port = +(input?.port as number) || +(process.env.DB_PORT as string);\n    this.username = (input?.username || process.env.DB_USER) as string;\n    this.password = (input?.password || process.env.DB_PASSWORD) as string;\n    this.database = (input?.database || process.env.DB_DATABASE) as string;\n    this.logs = Boolean(input?.logs) || Boolean(process.env.DB_LOGS) || false;\n\n    if (!this.port) {\n      switch (this.type) {\n        case \"mysql\":\n        case \"mariadb\":\n          this.port = 3306;\n          break;\n        case \"postgres\":\n          this.port = 5432;\n          break;\n        case \"mongo\":\n          this.port = 27017;\n          break;\n        case \"sqlite\":\n          break;\n        default:\n          throw new Error(\n            \"Database type not provided in the envs nor in the connection details\",\n          );\n      }\n    }\n  }\n}\n","import { DataSourceType } from \"../data_source\";\nimport { DriverImport, DriverSpecificOptions } from \"./driver_constants\";\n\nexport abstract class Driver {\n  abstract type: DataSourceType | \"redis\";\n  abstract client: DriverImport;\n  options?: DriverSpecificOptions;\n\n  constructor(driverSpecificOptions?: DriverSpecificOptions) {\n    this.options = driverSpecificOptions;\n  }\n\n  static async createDriver(\n    _driverSpecificOptions: DriverSpecificOptions,\n  ): Promise<Driver> {\n    throw new Error(\"Cannot be used by abstract class\");\n  }\n}\n","export type Mysql2Import = typeof import(\"mysql2/promise\");\nexport type PgImport = typeof import(\"pg\");\nexport type Sqlite3Import = typeof import(\"sqlite3\");\nexport type MongoClientImport = typeof import(\"mongodb\");\nexport type RedisImport = typeof import(\"ioredis\");\n\ntype ExcludeStringFromOptions<T> = T extends string ? never : T;\n\nexport type MysqlCreateConnectionOptions = Parameters<\n  Mysql2Import[\"createConnection\"]\n>[0];\nexport type PgClientOptions = ExcludeStringFromOptions<\n  ConstructorParameters<PgImport[\"Client\"]>[0]\n>;\nexport type MongoConnectionOptions =\n  | ConstructorParameters<MongoClientImport[\"MongoClient\"]>[0]\n  | ConstructorParameters<MongoClientImport[\"MongoClient\"]>[1];\nexport type RedisOptions = ConstructorParameters<RedisImport[\"default\"]>; // TODO: This is not correct, but it's a start\n\nexport type DriverSpecificOptions = {\n  mysqlOptions?: MysqlCreateConnectionOptions;\n  pgOptions?: PgClientOptions;\n  mongoOptions?: MongoConnectionOptions;\n  redisOptions?: RedisOptions;\n};\n\nexport type DriverImport =\n  | Mysql2Import\n  | PgImport\n  | Sqlite3Import\n  | MongoClientImport\n  | RedisImport;\n\nexport class DriverNotFoundError extends Error {\n  constructor(driverName: string) {\n    super(driverName);\n    this.name = `Driver ${driverName} not found, it's likely not installed, try running npm install ${driverName}`;\n  }\n}\n","import { DataSourceType } from \"../data_source\";\nimport { Driver } from \"./driver\";\nimport {\n  DriverSpecificOptions,\n  DriverNotFoundError,\n  PgImport,\n} from \"./driver_constants\";\n\nexport class PgDriver extends Driver {\n  override type: DataSourceType | \"redis\" = \"postgres\";\n  override client: PgImport;\n\n  constructor(client: PgImport, driverSpecificOptions?: DriverSpecificOptions) {\n    super(driverSpecificOptions);\n    this.client = client;\n  }\n\n  static async createDriver(\n    driverSpecificOptions?: DriverSpecificOptions,\n  ): Promise<Driver> {\n    const pg = await import(\"pg\").catch(() => {\n      throw new DriverNotFoundError(\"pg\");\n    });\n    if (!pg) {\n      throw new DriverNotFoundError(\"pg\");\n    }\n\n    return new PgDriver(pg.default, driverSpecificOptions);\n  }\n}\n","import { DataSourceType } from \"../data_source\";\nimport { Driver } from \"./driver\";\nimport {\n  DriverSpecificOptions,\n  DriverNotFoundError,\n  MongoClientImport,\n} from \"./driver_constants\";\n\nexport class MongoDriver extends Driver {\n  override type: DataSourceType | \"redis\" = \"postgres\";\n  override client: MongoClientImport;\n\n  constructor(\n    client: MongoClientImport,\n    driverSpecificOptions?: DriverSpecificOptions,\n  ) {\n    super(driverSpecificOptions);\n    this.client = client;\n  }\n\n  static async createDriver(\n    driverSpecificOptions?: DriverSpecificOptions,\n  ): Promise<Driver> {\n    const mongo = await import(\"mongodb\").catch(() => {\n      throw new DriverNotFoundError(\"mongodb\");\n    });\n    if (!mongo) {\n      throw new DriverNotFoundError(\"mongodb\");\n    }\n\n    return new MongoDriver(mongo, driverSpecificOptions);\n  }\n}\n","import { DataSourceType } from \"../data_source\";\nimport { Driver } from \"./driver\";\nimport {\n  Mysql2Import,\n  DriverSpecificOptions,\n  DriverNotFoundError,\n} from \"./driver_constants\";\n\nexport class MysqlDriver extends Driver {\n  override type: DataSourceType | \"redis\" = \"mysql\";\n  override client: Mysql2Import;\n\n  constructor(\n    client: Mysql2Import,\n    driverSpecificOptions?: DriverSpecificOptions,\n  ) {\n    super(driverSpecificOptions);\n    this.client = client;\n  }\n\n  static async createDriver(\n    driverSpecificOptions?: DriverSpecificOptions,\n  ): Promise<Driver> {\n    const mysql2 = await import(\"mysql2/promise\").catch(() => {\n      throw new DriverNotFoundError(\"mysql2\");\n    });\n    if (!mysql2) {\n      throw new DriverNotFoundError(\"mysql\");\n    }\n\n    return new MysqlDriver(mysql2.default, driverSpecificOptions);\n  }\n}\n","import { DataSourceType } from \"../data_source\";\nimport { Driver } from \"./driver\";\nimport {\n  DriverSpecificOptions,\n  DriverNotFoundError,\n  RedisImport,\n} from \"./driver_constants\";\n\nexport class RedisDriver extends Driver {\n  override type: DataSourceType | \"redis\" = \"postgres\";\n  override client: RedisImport;\n\n  constructor(\n    client: RedisImport,\n    driverSpecificOptions?: DriverSpecificOptions,\n  ) {\n    super(driverSpecificOptions);\n    this.client = client;\n  }\n\n  static async createDriver(\n    driverSpecificOptions?: DriverSpecificOptions,\n  ): Promise<Driver> {\n    const redis = await import(\"ioredis\").catch(() => {\n      throw new DriverNotFoundError(\"ioredis\");\n    });\n    if (!redis) {\n      throw new DriverNotFoundError(\"ioredis\");\n    }\n\n    return new RedisDriver(redis, driverSpecificOptions);\n  }\n}\n","import { DataSourceType } from \"../data_source\";\nimport { Driver } from \"./driver\";\nimport {\n  DriverSpecificOptions,\n  DriverNotFoundError,\n  Sqlite3Import,\n} from \"./driver_constants\";\n\nexport class Sqlite3Driver extends Driver {\n  override type: DataSourceType | \"redis\" = \"postgres\";\n  override client: Sqlite3Import;\n\n  constructor(\n    client: Sqlite3Import,\n    driverSpecificOptions?: DriverSpecificOptions,\n  ) {\n    super(driverSpecificOptions);\n    this.client = client;\n  }\n\n  static async createDriver(\n    driverSpecificOptions?: DriverSpecificOptions,\n  ): Promise<Driver> {\n    const sqlite3 = await import(\"sqlite3\").catch(() => {\n      throw new DriverNotFoundError(\"sqlite3\");\n    });\n    if (!sqlite3) {\n      throw new DriverNotFoundError(\"sqlite3\");\n    }\n\n    return new Sqlite3Driver(sqlite3.default, driverSpecificOptions);\n  }\n}\n","import { DataSourceType } from \"../data_source\";\nimport { Driver } from \"./driver\";\nimport { DriverSpecificOptions } from \"./driver_constants\";\nimport { PgDriver } from \"./pg_driver\";\nimport { MongoDriver } from \"./mongo_driver\";\nimport { MysqlDriver } from \"./mysql_driver\";\nimport { RedisDriver } from \"./redis_driver\";\nimport { Sqlite3Driver } from \"./sqlite3_driver\";\n\nexport class DriverFactory {\n  static async getDriver(\n    client: DataSourceType | \"redis\",\n    driverSpecificOptions?: DriverSpecificOptions,\n  ): Promise<Driver> {\n    switch (client) {\n      case \"mysql\":\n      case \"mariadb\":\n        return MysqlDriver.createDriver(driverSpecificOptions);\n      case \"postgres\":\n        return PgDriver.createDriver(driverSpecificOptions);\n      case \"sqlite\":\n        return Sqlite3Driver.createDriver(driverSpecificOptions);\n      case \"mongo\":\n        return MongoDriver.createDriver(driverSpecificOptions);\n      case \"redis\":\n        return RedisDriver.createDriver(driverSpecificOptions);\n      default:\n        throw new Error(\n          `Driver ${client} not found, il likely not installed, try running npm install ${client}`,\n        );\n    }\n  }\n}\n","import \"reflect-metadata\";\nimport { convertCase } from \"../../utils/case_utils\";\nimport { PaginatedData } from \"../pagination\";\nimport { ModelQueryBuilder, OneOptions } from \"../query_builder/query_builder\";\nimport {\n  parseDatabaseDataIntoModelResponse,\n  addDynamicColumnsToModel,\n} from \"../serializer\";\nimport { SqlDataSource } from \"../sql_data_source\";\nimport {\n  belongsTo,\n  column,\n  ColumnOptions,\n  dynamicColumn,\n  getPrimaryKey,\n  hasMany,\n  hasOne,\n  manyToMany,\n} from \"./model_decorators\";\nimport {\n  FindType,\n  UnrestrictedFindType,\n  FindOneType,\n  UnrestrictedFindOneType,\n  SelectableType,\n  DynamicColumnType,\n} from \"./model_manager/model_manager_types\";\nimport { Transaction } from \"../transactions/transaction\";\nimport { Entity } from \"../../entity\";\nimport { baseSoftDeleteDate } from \"../../utils/date_utils\";\nimport { ModelManager } from \"../sql_data_source_types\";\n\nexport type ModelWithoutExtraColumns<T extends Model> = Omit<\n  Partial<T>,\n  \"$additionalColumns\"\n>;\n\nexport type BaseModelMethodOptions = {\n  useConnection?: SqlDataSource;\n  trx?: Transaction;\n};\n\nexport function getBaseTableName(target: typeof Model): string {\n  const className = target.name;\n  return className.endsWith(\"s\")\n    ? convertCase(className, \"snake\")\n    : convertCase(className, \"snake\") + \"s\";\n}\n\nexport function getBaseModelInstance<T extends Model>(): T {\n  return { $additionalColumns: {} } as T;\n}\n\nconst tableMap = new Map<typeof Model, string>();\nconst primaryKeyMap = new Map<typeof Model, string>();\n\n/**\n * @description Represents a Table in the Database\n */\nexport abstract class Model extends Entity {\n  /**\n   * @description The sql sqlInstance generated by SqlDataSource.connect\n   */\n  static sqlInstance: SqlDataSource;\n\n  /**\n   * @description Table name for the model, if not set it will be the plural snake case of the model name given that is in PascalCase (es. User -> users)\n   */\n  static tableName: string;\n\n  /**\n   * @description Static getter for table;\n   * @internal\n   */\n  static get table(): string {\n    if (!tableMap.has(this)) {\n      tableMap.set(this, this.tableName || getBaseTableName(this));\n    }\n\n    return tableMap.get(this)!;\n  }\n\n  /**\n   * @description Getter for the primary key of the model\n   */\n  static get primaryKey(): string | undefined {\n    if (!primaryKeyMap.has(this)) {\n      primaryKeyMap.set(this, getPrimaryKey(this));\n    }\n\n    return primaryKeyMap.get(this)!;\n  }\n\n  /**\n   * @description Constructor for the model, it's not meant to be used directly, it just initializes the $additionalColumns, it's advised to only use the static methods to interact with the database to save the model\n   * @description Using the constructor could lead to unexpected behavior, if you want to create a new record use the insert method\n   * @deprecated\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * @description Returns all the records for the given model\n   */\n  static async all<T extends Model>(\n    this: new () => T | typeof Model,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T[]> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return await modelManager.find();\n  }\n\n  /**\n   * @description Gives a query sqlInstance for the given model\n   */\n  static query<T extends Model>(\n    this: new () => T | typeof Model,\n    options: BaseModelMethodOptions = {},\n  ): ModelQueryBuilder<T> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.query();\n  }\n\n  /**\n   * @description Finds the first record in the database\n   * @deprecated Used only for debugging purposes, use findOne or query instead\n   */\n  static async first<T extends Model>(\n    this: new () => T | typeof Model,\n    options: OneOptions & BaseModelMethodOptions = {},\n  ): Promise<T | null> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.query().one(options);\n  }\n\n  /**\n   * @description Finds records for the given model\n   */\n  static async find<T extends Model>(\n    this: new () => T | typeof Model,\n    findOptions?: FindType<T> | UnrestrictedFindType<T>,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T[]> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.find(findOptions);\n  }\n\n  /**\n   * @description Finds a record for the given model or throws an error if it doesn't exist\n   */\n  static async findOneOrFail<T extends Model>(\n    this: new () => T | typeof Model,\n    findOneOptions: (FindOneType<T> | UnrestrictedFindOneType<T>) & {\n      customError?: Error;\n    },\n    options: BaseModelMethodOptions = {},\n  ): Promise<T | null> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.findOneOrFail(findOneOptions);\n  }\n\n  /**\n   * @description Finds a record for the given model\n   */\n  static async findOne<T extends Model>(\n    this: new () => T | typeof Model,\n    findOneOptions: (FindOneType<T> | UnrestrictedFindOneType<T>) &\n      BaseModelMethodOptions,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T | null> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.findOne(findOneOptions);\n  }\n\n  /**\n   * @description Finds a record for the given model for the given id, \"id\" must be set in the model in order for it to work\n   */\n  static async findOneByPrimaryKey<T extends Model>(\n    this: new () => T | typeof Model,\n    value: string | number | boolean,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T | null> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.findOneByPrimaryKey(value);\n  }\n\n  /**\n   * @description Refreshes a model from the database, the model must have a primary key defined\n   */\n  static async refresh<T extends Model>(\n    this: new () => T | typeof Model,\n    model: T,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T | null> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    const primaryKey = typeofModel.primaryKey as keyof T;\n    const primaryKeyValue = model[primaryKey];\n    const refreshedModel = await modelManager.findOneByPrimaryKey(\n      primaryKeyValue as string,\n    );\n    if (!refreshedModel) {\n      return null;\n    }\n\n    refreshedModel.$additionalColumns = model.$additionalColumns;\n    return refreshedModel;\n  }\n\n  /**\n   * @description Saves a new record to the database\n   * @description $additionalColumns will be ignored if set in the modelData and won't be returned in the response\n   */\n  static async insert<T extends Model>(\n    this: new () => T | typeof Model,\n    modelData: ModelWithoutExtraColumns<T>,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T | null> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.insert(modelData as T);\n  }\n\n  /**\n   * @description Saves multiple records to the database\n   */\n  static async insertMany<T extends Model>(\n    this: new () => T | typeof Model,\n    modelsData: ModelWithoutExtraColumns<T>[],\n    options: BaseModelMethodOptions = {},\n  ): Promise<T[]> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.insertMany(modelsData as T[]);\n  }\n\n  /**\n   * @description Updates a record to the database\n   */\n  static async updateRecord<T extends Model>(\n    this: new () => T | typeof Model,\n    modelSqlInstance: T,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T | null> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    const updatedModel = await modelManager.updateRecord(modelSqlInstance);\n    if (!updatedModel) {\n      return null;\n    }\n\n    updatedModel.$additionalColumns = modelSqlInstance.$additionalColumns;\n    return updatedModel;\n  }\n\n  /**\n   * @description Finds the first record or creates a new one if it doesn't exist\n   */\n  static async firstOrCreate<T extends Model>(\n    this: new () => T | typeof Model,\n    searchCriteria: ModelWithoutExtraColumns<T>,\n    createData: ModelWithoutExtraColumns<T>,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    const doesExist = await modelManager.findOne({\n      where: searchCriteria,\n    });\n\n    if (doesExist) {\n      return doesExist;\n    }\n\n    return (await modelManager.insert(createData as T)) as T;\n  }\n\n  /**\n   * @description Updates or creates a new record\n   */\n  static async upsert<T extends Model>(\n    this: new () => T | typeof Model,\n    searchCriteria: ModelWithoutExtraColumns<T>,\n    data: ModelWithoutExtraColumns<T>,\n    options: { updateOnConflict?: boolean } & BaseModelMethodOptions = {\n      updateOnConflict: true,\n    },\n  ): Promise<T> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    const doesExist = await modelManager.findOne({\n      where: searchCriteria,\n    });\n\n    if (doesExist) {\n      (data as T)[typeofModel.primaryKey as keyof T] =\n        doesExist[typeofModel.primaryKey as keyof T];\n\n      if (options.updateOnConflict) {\n        return (await modelManager.updateRecord(data as T)) as T;\n      }\n\n      return doesExist;\n    }\n\n    return (await modelManager.insert(data as T)) as T;\n  }\n\n  /**\n   * @description Updates or creates multiple records\n   */\n  static async upsertMany<T extends Model>(\n    this: new () => T | typeof Model,\n    searchCriteria: SelectableType<T>[],\n    data: ModelWithoutExtraColumns<T>[],\n    options: { updateOnConflict?: boolean } & BaseModelMethodOptions = {\n      updateOnConflict: true,\n    },\n  ): Promise<T[]> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n\n    if (\n      !data.every((record) =>\n        searchCriteria.every((column) => column in record),\n      )\n    ) {\n      throw new Error(\n        \"Conflict columns are not present in the data, please make sure to include them in the data, \" +\n          searchCriteria.join(\", \"),\n      );\n    }\n\n    const results: T[] = [];\n\n    for (let i = 0; i < data.length; i++) {\n      const record = data[i];\n      const search = searchCriteria.reduce((acc, column) => {\n        acc[column] = record[column];\n        return acc;\n      }, {} as ModelWithoutExtraColumns<T>);\n\n      const doesExist = await modelManager.findOne({\n        where: search,\n      });\n\n      if (doesExist) {\n        (record as T)[typeofModel.primaryKey as keyof T] =\n          doesExist[typeofModel.primaryKey as keyof T];\n\n        if (options.updateOnConflict) {\n          results.push((await modelManager.updateRecord(record as T)) as T);\n          continue;\n        }\n\n        results.push(doesExist);\n        continue;\n      }\n\n      results.push((await modelManager.insert(record as T)) as T);\n    }\n\n    return results;\n  }\n\n  /**\n   * @description Deletes a record to the database\n   */\n  static async deleteRecord<T extends Model>(\n    this: new () => T | typeof Model,\n    modelSqlInstance: T,\n    options: BaseModelMethodOptions = {},\n  ): Promise<T | null> {\n    const typeofModel = this as unknown as typeof Model;\n    const modelManager = typeofModel.dispatchModelManager<T>(options);\n    return modelManager.deleteRecord(modelSqlInstance);\n  }\n\n  /**\n   * @description Soft Deletes a record to the database\n   */\n  static async softDelete<T extends Model>(\n    this: new () => T | typeof Model,\n    modelSqlInstance: T,\n    options?: {\n      column?: string;\n      value?: string | number | boolean;\n    } & BaseModelMethodOptions,\n  ): Promise<T> {\n    const typeofModel = this as unknown as typeof Model;\n    const {\n      column = \"deletedAt\" as SelectableType<T>,\n      value = baseSoftDeleteDate(new Date()),\n    } = options || {};\n\n    modelSqlInstance[column as keyof T] = value as T[keyof T];\n    const modelManager = typeofModel.dispatchModelManager<T>({\n      trx: options?.trx,\n      useConnection: options?.useConnection,\n    });\n    await modelManager.updateRecord(modelSqlInstance);\n\n    if (typeof value === \"string\") {\n      modelSqlInstance[column as keyof T] = new Date(value) as T[keyof T];\n    }\n\n    modelSqlInstance[column as keyof T] = value as T[keyof T];\n    return (await parseDatabaseDataIntoModelResponse(\n      [modelSqlInstance],\n      typeofModel,\n    )) as T;\n  }\n\n  /**\n   * @description Adds dynamic columns to the model that are not defined in the Table and are defined in the model\n   * @description It does not support custom connection or transaction\n   */\n  static async addDynamicColumns<T extends Model>(\n    this: new () => T | typeof Model,\n    data: T | T[] | PaginatedData<T>,\n    dynamicColumns: DynamicColumnType<T>[],\n  ): Promise<T | T[] | PaginatedData<T>> {\n    const typeofModel = this as unknown as typeof Model;\n    typeofModel.establishConnection();\n    if (Array.isArray(data)) {\n      for (const model of data) {\n        await addDynamicColumnsToModel(\n          typeofModel,\n          model,\n          dynamicColumns as string[],\n        );\n      }\n\n      return data as T[];\n    }\n\n    if (!Array.isArray(data)) {\n      await addDynamicColumnsToModel(\n        typeofModel,\n        data,\n        dynamicColumns as string[],\n      );\n\n      return data as T;\n    }\n\n    for (const model of (data as PaginatedData<T>).data) {\n      await addDynamicColumnsToModel(\n        typeofModel,\n        model,\n        dynamicColumns as string[],\n      );\n    }\n\n    return data as PaginatedData<T>;\n  }\n\n  /**\n   * @description Merges the provided data with the sqlInstance\n   */\n  static combineProps<T extends Model>(sqlInstance: T, data: Partial<T>): void {\n    for (const key in data) {\n      Object.assign(sqlInstance, { [key]: data[key] });\n    }\n  }\n\n  /**\n   * @description Adds a beforeFetch clause to the model, adding the ability to modify the query before fetching the data\n   */\n  static beforeFetch(queryBuilder: ModelQueryBuilder<any>): void {\n    queryBuilder;\n  }\n\n  /**\n   * @description Adds a beforeInsert clause to the model, adding the ability to modify the data after fetching the data\n   */\n  static beforeInsert(data: any): void {\n    return data;\n  }\n\n  /**\n   * @description Adds a beforeUpdate clause to the model, adding the ability to modify the query before updating the data\n   */\n  static beforeUpdate(queryBuilder: ModelQueryBuilder<any>): void {\n    queryBuilder;\n  }\n\n  /**\n   * @description Adds a beforeDelete clause to the model, adding the ability to modify the query before deleting the data\n   */\n  static beforeDelete(queryBuilder: ModelQueryBuilder<any>): void {\n    queryBuilder;\n  }\n\n  /**\n   * @description Adds a afterFetch clause to the model, adding the ability to modify the data after fetching the data\n   */\n  static async afterFetch(data: Model[]): Promise<Model[]> {\n    return data;\n  }\n\n  // JS Static methods\n\n  /**\n   * @description Defines a column in the model, useful in javascript in order to not have to rely on decorators since are not supported without a transpiler like babel\n   * @javascript\n   */\n  static column(columnName: string, options: ColumnOptions = {}): void {\n    // take the column decorator and apply it automatically\n    column(options)(this.prototype, columnName);\n  }\n\n  /**\n   * @description Defines a dynamic column in the model, useful in javascript in order to not have to rely on decorators since are not supported without a transpiler like babel\n   * @javascript\n   */\n  static hasOne(\n    columnName: string,\n    model: () => typeof Model,\n    foreignKey: string,\n  ): void {\n    hasOne(model, foreignKey)(this.prototype, columnName);\n  }\n\n  /**\n   * @description Defines a dynamic column in the model, useful in javascript in order to not have to rely on decorators since are not supported without a transpiler like babel\n   * @javascript\n   */\n  static hasMany(\n    columnName: string,\n    model: () => typeof Model,\n    foreignKey: string,\n  ): void {\n    hasMany(model, foreignKey)(this.prototype, columnName);\n  }\n\n  /**\n   * @description Defines a dynamic column in the model, useful in javascript in order to not have to rely on decorators since are not supported without a transpiler like babel\n   * @javascript\n   */\n  static belongsTo(\n    columnName: string,\n    model: () => typeof Model,\n    foreignKey: string,\n  ): void {\n    belongsTo(model, foreignKey)(this.prototype, columnName);\n  }\n\n  /**\n   * @description Defines a dynamic column in the model, useful in javascript in order to not have to rely on decorators since are not supported without a transpiler like babel\n   * @javascript\n   */\n  static manyToMany(\n    columnName: string,\n    model: () => typeof Model,\n    throughModel: string,\n    foreignKey: string,\n  ): void {\n    manyToMany(model, throughModel, foreignKey)(this.prototype, columnName);\n  }\n\n  /**\n   * @description Defines a dynamic column in the model, useful in javascript in order to not have to rely on decorators since are not supported without a transpiler like babel\n   * @javascript\n   */\n  static dynamicColumn(columnName: string, func: () => any): void {\n    dynamicColumn(columnName)(this.prototype, func.name);\n  }\n\n  /**\n   * @description Establishes a connection to the database instantiated from the SqlDataSource.connect method, this is done automatically when using the static methods\n   * @description This method is meant to be used only if you want to establish sql sqlInstance of the model directly\n   * @internal\n   */\n  private static establishConnection(): void {\n    const sql = SqlDataSource.getInstance();\n    if (!sql) {\n      throw new Error(\n        \"sql sqlInstance not initialized, did you defined it in SqlDataSource.connect static method?\",\n      );\n    }\n\n    this.sqlInstance = sql;\n  }\n\n  /**\n   * @description Gives the correct model manager with the correct connection based on the options provided\n   */\n  private static dispatchModelManager<T extends Model>(\n    this: typeof Model,\n    options?: BaseModelMethodOptions,\n  ): ModelManager<T> {\n    if (options?.useConnection) {\n      return options.useConnection.getModelManager<T>(\n        this as unknown as typeof Model,\n      );\n    }\n\n    if (options?.trx) {\n      return options.trx.sqlDataSource.getModelManager<T>(\n        this as unknown as typeof Model,\n      );\n    }\n\n    const typeofModel = this as unknown as typeof Model;\n    typeofModel.establishConnection();\n    return typeofModel.sqlInstance.getModelManager<T>(typeofModel);\n  }\n}\n","export type CaseConvention =\n  | \"camel\"\n  | \"snake\"\n  | \"none\"\n  | RegExp\n  | ((column: string) => string);\n\nfunction camelToSnakeCase(camelCase: any) {\n  if (typeof camelCase !== \"string\" || !camelCase) {\n    return camelCase;\n  }\n\n  if (camelCase === camelCase.toLowerCase()) {\n    return camelCase;\n  }\n\n  return camelCase.replace(/([a-z0-9])([A-Z])/g, \"$1_$2\").toLowerCase();\n}\n\nfunction fromSnakeToCamelCase(snake: any) {\n  if (typeof snake !== \"string\" || !snake) {\n    return snake;\n  }\n\n  if (snake === snake.toUpperCase()) {\n    return snake;\n  }\n\n  return snake.replace(/(_\\w)/g, (x) => x[1].toUpperCase());\n}\n\nexport function convertCase(value: any, to: CaseConvention) {\n  if (to === \"none\") {\n    return value;\n  }\n\n  if (to === \"snake\") {\n    return camelToSnakeCase(value);\n  }\n\n  if (to === \"camel\") {\n    return fromSnakeToCamelCase(value);\n  }\n\n  if (to instanceof RegExp) {\n    return value.replace(to, (x: string) => x[1].toUpperCase());\n  }\n\n  return to(value);\n}\n","export function isNestedObject(value: any): boolean {\n  return (\n    typeof value === \"object\" &&\n    !Array.isArray(value) &&\n    value !== null &&\n    Object.keys(value).length > 0\n  );\n}\n","import { Model } from \"../model\";\n\n/**\n * @description Options for the relation\n * @property {string} softDeleteColumn - The column name for the soft delete column, if set, the relation will only return rows that have not been soft deleted\n * @property {string} softDeleteType - The type of the soft delete column\n */\n\nexport enum RelationEnum {\n  hasOne = \"hasOne\", // One to One without foreign key\n  belongsTo = \"belongsTo\", // One to One with foreign key\n  hasMany = \"hasMany\",\n  manyToMany = \"manyToMany\",\n}\n\nexport function isRelationDefinition(\n  originalValue: any,\n): originalValue is Relation {\n  return (\n    originalValue.hasOwnProperty(\"type\") &&\n    originalValue.hasOwnProperty(\"relatedModel\") &&\n    originalValue.hasOwnProperty(\"foreignKey\")\n  );\n}\n\n/**\n * Main Model -> Related Model\n */\n\nexport abstract class Relation {\n  abstract type: RelationEnum;\n  model: typeof Model = Model;\n  columnName: string = \"\";\n  foreignKey?: string;\n  relatedModel: string = \"\";\n\n  protected constructor(model: typeof Model, columnName: string) {\n    this.model = model;\n    this.columnName = columnName;\n    this.relatedModel = this.model.table;\n  }\n}\n","import { Model } from \"../model\";\nimport { Relation, RelationEnum } from \"./relation\";\n\nexport class BelongsTo extends Relation {\n  type: RelationEnum;\n  foreignKey: string;\n\n  constructor(\n    relatedModel: typeof Model,\n    columnName: string,\n    foreignKey: string,\n  ) {\n    super(relatedModel, columnName);\n    this.foreignKey = foreignKey;\n    this.type = RelationEnum.belongsTo;\n  }\n}\n","import { Model } from \"../model\";\nimport { Relation, RelationEnum } from \"./relation\";\n\nexport class HasMany extends Relation {\n  type: RelationEnum = RelationEnum.hasMany;\n  foreignKey: string;\n\n  constructor(\n    relatedModel: typeof Model,\n    columnName: string,\n    foreignKey: string,\n  ) {\n    super(relatedModel, columnName);\n    this.foreignKey = foreignKey;\n    this.type = RelationEnum.hasMany;\n  }\n}\n","import { Model } from \"../model\";\nimport { Relation, RelationEnum } from \"./relation\";\n\nexport class HasOne extends Relation {\n  type: RelationEnum;\n  foreignKey: string;\n\n  constructor(\n    relatedModel: typeof Model,\n    columnName: string,\n    foreignKey: string,\n  ) {\n    super(relatedModel, columnName);\n    this.foreignKey = foreignKey;\n    this.type = RelationEnum.hasOne;\n  }\n}\n","import { Model } from \"../model\";\nimport { Relation, RelationEnum } from \"./relation\";\n\nexport class ManyToMany extends Relation {\n  type = RelationEnum.manyToMany;\n  throughModel: string = \"\";\n  foreignKey: string = \"\";\n  relatedModelForeignKey: string = \"\";\n\n  constructor(\n    model: typeof Model,\n    columnName: string,\n    throughModel: string,\n    foreignKey: string,\n  ) {\n    super(model, columnName);\n    this.columnName = columnName;\n    this.foreignKey = foreignKey;\n    this.throughModel = throughModel;\n  }\n}\n","import { Model } from \"./model\";\nimport { BelongsTo } from \"./relations/belongs_to\";\nimport { HasMany } from \"./relations/has_many\";\nimport { HasOne } from \"./relations/has_one\";\nimport { ManyToMany } from \"./relations/many_to_many\";\nimport { RelationEnum, Relation } from \"./relations/relation\";\n\ntype LazyRelationEnum = {\n  type: RelationEnum;\n  columnName: string;\n  model: () => typeof Model;\n  foreignKey: string;\n\n  // Only for many to many\n  manyToManyOptions?: {\n    throughModel: string;\n  };\n};\n\n/**\n * columns\n * @description Options for the column decorator\n * @param primaryKey: boolean - If the column is the primary key\n * @param serialize: (value: any) => any - Function to serialize the value after it is retrieved from the database\n * @param prepare: (value: any) => any - Function to prepare the value before it is inserted or updated in the database\n */\nexport interface ColumnOptions {\n  primaryKey?: boolean;\n  serialize?: (value: any) => void;\n  prepare?: (value: any) => void;\n  hidden?: boolean;\n}\n\nconst COLUMN_METADATA_KEY = Symbol(\"columns\");\nconst DYNAMIC_COLUMN_METADATA_KEY = Symbol(\"dynamicColumns\");\nconst PRIMARY_KEY_METADATA_KEY = Symbol(\"primaryKey\");\nconst RELATION_METADATA_KEY = Symbol(\"relations\");\n\n/**\n * @description Decorator to define a column in the model\n */\nexport function column(\n  options: ColumnOptions = {\n    primaryKey: false,\n  },\n): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    if (options.primaryKey) {\n      const primaryKey = Reflect.getMetadata(PRIMARY_KEY_METADATA_KEY, target);\n      if (primaryKey) {\n        throw new Error(\"Multiple primary keys are not allowed\");\n      }\n      Reflect.defineMetadata(PRIMARY_KEY_METADATA_KEY, propertyKey, target);\n    }\n\n    const column = {\n      columnName: propertyKey,\n      serialize: options.serialize,\n      prepare: options.prepare,\n      hidden: options.hidden,\n    };\n\n    const existingColumns =\n      Reflect.getMetadata(COLUMN_METADATA_KEY, target) || [];\n    existingColumns.push(column);\n    Reflect.defineMetadata(COLUMN_METADATA_KEY, existingColumns, target);\n  };\n}\n\n/**\n * @description Defines a dynamic calculated column that is not defined inside the Table, it must be added to a query in order to be retrieved\n */\nexport function dynamicColumn(columnName: string): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    const dynamicColumn = {\n      columnName: columnName,\n      functionName: propertyKey,\n      dynamicColumnFn: target.constructor.prototype[propertyKey],\n    };\n\n    const existingColumns =\n      Reflect.getMetadata(DYNAMIC_COLUMN_METADATA_KEY, target) || [];\n    existingColumns.push(dynamicColumn);\n    Reflect.defineMetadata(\n      DYNAMIC_COLUMN_METADATA_KEY,\n      existingColumns,\n      target,\n    );\n  };\n}\n\n/**\n * @description Returns the columns of the model, columns must be decorated with the column decorator\n */\nexport function getModelColumns(target: typeof Model): {\n  columnName: string;\n  serialize?: (value: any) => any;\n  prepare?: (value: any) => any;\n  hidden?: boolean;\n}[] {\n  return Reflect.getMetadata(COLUMN_METADATA_KEY, target.prototype) || [];\n}\n\n/**\n * relations\n */\n\n/**\n * @description Establishes a belongs to relation with the given model\n */\nexport function belongsTo(\n  model: () => typeof Model,\n  foreignKey: string,\n): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    const relation = {\n      type: RelationEnum.belongsTo,\n      columnName: propertyKey as string,\n      model,\n      foreignKey,\n    };\n    const relations = Reflect.getMetadata(RELATION_METADATA_KEY, target) || [];\n    relations.push(relation);\n    Reflect.defineMetadata(RELATION_METADATA_KEY, relations, target);\n  };\n}\n\n/**\n * @description Establishes a has one relation with the given model\n */\nexport function hasOne(\n  model: () => typeof Model,\n  foreignKey: string,\n): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    const relation = {\n      type: RelationEnum.hasOne,\n      columnName: propertyKey as string,\n      model,\n      foreignKey,\n    };\n    const relations = Reflect.getMetadata(RELATION_METADATA_KEY, target) || [];\n    relations.push(relation);\n    Reflect.defineMetadata(RELATION_METADATA_KEY, relations, target);\n  };\n}\n\n/**\n * @description Establishes a has many relation with the given model\n */\nexport function hasMany(\n  model: () => typeof Model,\n  foreignKey: string,\n): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    const relation = {\n      type: RelationEnum.hasMany,\n      columnName: propertyKey,\n      model,\n      foreignKey,\n    };\n    const relations = Reflect.getMetadata(RELATION_METADATA_KEY, target) || [];\n    relations.push(relation);\n    Reflect.defineMetadata(RELATION_METADATA_KEY, relations, target);\n  };\n}\n\n/**\n * @description Establishes a many to many relation with the given model\n */\nexport function manyToMany(\n  model: () => typeof Model,\n  throughModel: (() => typeof Model) | string,\n  foreignKey: string,\n): PropertyDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    if (!(typeof throughModel === \"string\")) {\n      throughModel = throughModel().table;\n    }\n\n    const relation: LazyRelationEnum = {\n      type: RelationEnum.manyToMany,\n      columnName: propertyKey as string,\n      model,\n      foreignKey,\n      manyToManyOptions: {\n        throughModel,\n      },\n    };\n\n    const relations = Reflect.getMetadata(RELATION_METADATA_KEY, target) || [];\n    relations.push(relation);\n    Reflect.defineMetadata(RELATION_METADATA_KEY, relations, target);\n  };\n}\n\n/**\n * @description Returns the relations of the model\n */\nexport function getRelations(target: typeof Model): Relation[] {\n  const relations =\n    Reflect.getMetadata(RELATION_METADATA_KEY, target.prototype) || [];\n  return relations.map((relation: LazyRelationEnum) => {\n    const { type, model, columnName, foreignKey } = relation;\n    switch (type) {\n      case RelationEnum.belongsTo:\n        return new BelongsTo(model(), columnName, foreignKey);\n      case RelationEnum.hasOne:\n        return new HasOne(model(), columnName, foreignKey);\n      case RelationEnum.hasMany:\n        return new HasMany(model(), columnName, foreignKey);\n      case RelationEnum.manyToMany:\n        if (!relation.manyToManyOptions) {\n          throw new Error(\"Many to many relation must have a through model\");\n        }\n\n        return new ManyToMany(\n          model(),\n          columnName,\n          relation.manyToManyOptions.throughModel,\n          relation.foreignKey,\n        );\n      default:\n        throw new Error(`Unknown relation type: ${type}`);\n    }\n  });\n}\n\n/**\n * @description Returns the primary key of the model\n */\nexport function getPrimaryKey(target: typeof Model): string {\n  return Reflect.getMetadata(PRIMARY_KEY_METADATA_KEY, target.prototype);\n}\n\n/**\n * @description Returns every dynamicColumn definition\n */\nexport function getDynamicColumns(target: typeof Model): {\n  columnName: string;\n  functionName: string;\n  dynamicColumnFn: (...args: any[]) => any;\n}[] {\n  return Reflect.getMetadata(DYNAMIC_COLUMN_METADATA_KEY, target.prototype);\n}\n","import { convertCase } from \"../utils/case_utils\";\nimport { isNestedObject } from \"../utils/json_utils\";\nimport { Model } from \"./models/model\";\nimport {\n  getRelations,\n  getModelColumns,\n  getDynamicColumns,\n} from \"./models/model_decorators\";\nimport {\n  isRelationDefinition,\n  Relation,\n  RelationEnum,\n} from \"./models/relations/relation\";\n\nexport async function parseDatabaseDataIntoModelResponse<T extends Model>(\n  models: T[],\n  typeofModel: typeof Model,\n  relationModels: { [relationName: string]: Model[] }[] = [],\n  modelSelectedColumns: string[] = [],\n): Promise<T | T[] | null> {\n  if (!models.length) {\n    return null;\n  }\n\n  const relations = getRelations(typeofModel);\n\n  const serializedModels = models.map((model) => {\n    const serializedModel = serializeModel(\n      model,\n      typeofModel,\n      modelSelectedColumns,\n    );\n    processRelation(serializedModel, typeofModel, relations, relationModels);\n\n    return serializedModel;\n  });\n\n  return serializedModels.length === 1 ? serializedModels[0] : serializedModels;\n}\n\nfunction serializeModel<T extends Record<string, any>>(\n  model: T,\n  typeofModel: typeof Model,\n  modelSelectedColumns: string[] = [],\n): T {\n  const casedModel: Record<string, any> = {};\n  const columns = getModelColumns(typeofModel);\n  const hiddenColumns = columns\n    .filter((column) => column.hidden)\n    .map((column) => column.columnName);\n\n  for (const key in model) {\n    if (key === \"$additionalColumns\") {\n      processAdditionalColumns(model, key, casedModel, typeofModel);\n      continue;\n    }\n\n    if (\n      !model.hasOwnProperty(key) ||\n      hiddenColumns.includes(key) ||\n      (modelSelectedColumns.length && !modelSelectedColumns.includes(key))\n    ) {\n      continue;\n    }\n\n    const originalValue = model[key];\n    // Include null values\n    if (originalValue == null) {\n      casedModel[convertCase(key, typeofModel.modelCaseConvention)] =\n        originalValue;\n      continue;\n    }\n\n    if (isRelationDefinition(originalValue)) {\n      continue;\n    }\n\n    const camelCaseKey = convertCase(key, typeofModel.modelCaseConvention);\n    if (isNestedObject(originalValue) && !Array.isArray(originalValue)) {\n      casedModel[camelCaseKey] = convertToModelCaseConvention(\n        originalValue,\n        typeofModel,\n      );\n      continue;\n    }\n\n    if (Array.isArray(originalValue)) {\n      continue;\n    }\n\n    const modelColumn = columns.find((column) => column.columnName === key);\n    if (modelColumn && modelColumn.serialize) {\n      casedModel[camelCaseKey] = modelColumn.serialize(originalValue);\n      continue;\n    }\n\n    casedModel[camelCaseKey] = originalValue;\n  }\n\n  return casedModel as T;\n}\n\nfunction processAdditionalColumns(\n  model: Record<string, any>,\n  key: string,\n  casedModel: Record<string, any>,\n  typeofModel: typeof Model,\n) {\n  if (!Object.keys(model[key]).length) {\n    return;\n  }\n\n  const $additionalColumns = Object.keys(model[key]).reduce(\n    (acc, objKey) => {\n      acc[convertCase(objKey, typeofModel.modelCaseConvention)] =\n        model[key][objKey];\n      return acc;\n    },\n    {} as Record<string, any>,\n  );\n\n  casedModel[key] = $additionalColumns;\n}\n\nfunction processRelation(\n  serializedModel: Record<string, any>,\n  typeofModel: typeof Model,\n  relations: Relation[],\n  relationModels: { [relationName: string]: Model[] }[],\n) {\n  relations.forEach((relation: Relation) => {\n    const relationModel = relationModels.find(\n      (relationModel) => relationModel[relation.columnName],\n    );\n\n    if (!relationModel) {\n      return;\n    }\n\n    const relatedModels = relationModel[relation.columnName];\n    const foreignKey = convertCase(\n      relation.foreignKey,\n      typeofModel.modelCaseConvention,\n    ) as string;\n    const primaryKey = convertCase(\n      typeofModel.primaryKey,\n      typeofModel.modelCaseConvention,\n    ) as string;\n\n    switch (relation.type) {\n      case RelationEnum.belongsTo:\n        const relatedModelMap = new Map<any, Model>();\n        const casedPrimaryKey = convertCase(\n          primaryKey,\n          typeofModel.databaseCaseConvention,\n        ) as keyof Model;\n\n        relatedModels.forEach((model) => {\n          relatedModelMap.set(model[casedPrimaryKey as keyof Model], model);\n        });\n\n        const retrievedRelatedModel = relatedModelMap.get(\n          serializedModel[foreignKey as keyof Model],\n        );\n\n        if (!retrievedRelatedModel) {\n          serializedModel[relation.columnName] = null;\n          return;\n        }\n\n        serializedModel[relation.columnName] = serializeModel(\n          retrievedRelatedModel,\n          relation.model,\n        );\n        break;\n\n      case RelationEnum.hasOne:\n        const relatedModelMapHasOne = new Map<any, Model>();\n        const casedForeignKey = convertCase(\n          foreignKey,\n          typeofModel.databaseCaseConvention,\n        ) as keyof Model;\n\n        relatedModels.forEach((model) => {\n          relatedModelMapHasOne.set(\n            model[casedForeignKey as keyof Model],\n            model,\n          );\n        });\n\n        const retrievedRelatedModelHasOne = relatedModelMapHasOne.get(\n          serializedModel[primaryKey as keyof Model],\n        );\n\n        if (!retrievedRelatedModelHasOne) {\n          serializedModel[relation.columnName] = null;\n          return;\n        }\n\n        serializedModel[relation.columnName] = serializeModel(\n          retrievedRelatedModelHasOne,\n          relation.model,\n        );\n        break;\n\n      case RelationEnum.hasMany:\n        const retrievedRelatedModels = relatedModels.filter(\n          (item) =>\n            // Since it's still raw data and it's not yet been converted to camel case (it will soon in the serializeModel call)m it's matched with the camel case key\n            item[\n              convertCase(\n                foreignKey,\n                typeofModel.databaseCaseConvention,\n              ) as keyof Model\n            ] === serializedModel[primaryKey as keyof Model],\n        );\n\n        serializedModel[relation.columnName] = retrievedRelatedModels.map(\n          (model) => serializeModel(model, relation.model),\n        );\n        break;\n\n      case RelationEnum.manyToMany:\n        const relatedModelMapManyToMany = new Map<any, Model>();\n        relatedModels.forEach((model) => {\n          relatedModelMapManyToMany.set(\n            model[primaryKey as keyof Model],\n            model,\n          );\n        });\n\n        const currentModelId = serializedModel[primaryKey as keyof Model];\n        const relatedModel = relatedModelMapManyToMany.get(currentModelId);\n\n        if (!relatedModel) {\n          serializedModel[relation.columnName] = [];\n          return;\n        }\n\n        let relatedColumnValue =\n          relatedModel[relation.columnName as keyof Model];\n        if (!relatedColumnValue) {\n          relatedColumnValue = [];\n        }\n\n        if (!Array.isArray(relatedColumnValue)) {\n          relatedColumnValue = [relatedColumnValue];\n        }\n\n        serializedModel[relation.columnName] = relatedColumnValue.map(\n          (relatedItem: Model) => serializeModel(relatedItem, relation.model),\n        );\n        break;\n      default:\n        throw new Error(\"Relation type not supported\");\n    }\n  });\n}\n\nfunction convertToModelCaseConvention(\n  originalValue: Record<string, any>,\n  typeofModel: typeof Model,\n): Record<string, any> {\n  return Object.keys(originalValue).reduce(\n    (acc, objKey) => {\n      acc[convertCase(objKey, typeofModel.modelCaseConvention)] =\n        originalValue[objKey];\n      return acc;\n    },\n    {} as Record<string, any>,\n  );\n}\n\nexport async function addDynamicColumnsToModel(\n  typeofModel: typeof Model,\n  model: Record<string, any>,\n  dynamicColumnsToAdd: string[],\n): Promise<void> {\n  const dynamicColumns = getDynamicColumns(typeofModel);\n  if (!dynamicColumns || !dynamicColumns.length) {\n    return;\n  }\n\n  const dynamicColumnMap = new Map<\n    string,\n    {\n      columnName: string;\n      dynamicColumnFn: (...args: any[]) => any;\n    }\n  >();\n\n  for (const dynamicColumn of dynamicColumns) {\n    dynamicColumnMap.set(dynamicColumn.functionName, {\n      columnName: dynamicColumn.columnName,\n      dynamicColumnFn: dynamicColumn.dynamicColumnFn,\n    });\n  }\n\n  const promises = dynamicColumnsToAdd.map(async (dynamicColumn: string) => {\n    const dynamic = dynamicColumnMap.get(dynamicColumn);\n    const casedKey = convertCase(\n      dynamic?.columnName,\n      typeofModel.modelCaseConvention,\n    );\n\n    Object.assign(model, { [casedKey]: await dynamic?.dynamicColumnFn() });\n  });\n\n  await Promise.all(promises);\n}\n","import { CaseConvention } from \"./utils/case_utils\";\n\n/**\n * @description The most basic class for all models for both SQL and NoSQL databases\n * @internal Not meant to be used outside of the library\n */\nexport abstract class Entity {\n  /**\n   * @description Extra columns for the model, all data retrieved from the database that is not part of the model will be stored here\n   */\n  $additionalColumns: { [key: string]: any };\n\n  /**\n   * @description Defines the case convention for the model\n   * @type {CaseConvention}\n   */\n  static modelCaseConvention: CaseConvention = \"camel\";\n\n  /**\n   * @description Defines the case convention for the database, this should be the case convention you use in your database\n   * @type {CaseConvention}\n   */\n  static databaseCaseConvention: CaseConvention = \"snake\";\n\n  constructor() {\n    this.$additionalColumns = {};\n  }\n}\n","export function baseSoftDeleteDate(date: Date): string {\n  const pad = (n: number) => n.toString().padStart(2, \"0\");\n\n  const year = date.getUTCFullYear();\n  const month = pad(date.getUTCMonth() + 1);\n  const day = pad(date.getUTCDate());\n  const hours = pad(date.getUTCHours());\n  const minutes = pad(date.getUTCMinutes());\n  const seconds = pad(date.getUTCSeconds());\n\n  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;\n}\n","import { QueryBuilder } from \"../../query_builder/query_builder\";\nimport { SqlDataSource } from \"../../sql_data_source\";\nimport { Model, getBaseModelInstance } from \"../model\";\nimport {\n  FindType,\n  UnrestrictedFindType,\n  UnrestrictedFindOneType,\n  FindOneType,\n} from \"./model_manager_types\";\n\nexport abstract class ModelManager<T extends Model> {\n  protected logs: boolean;\n  protected sqlDataSource: SqlDataSource;\n  protected model: typeof Model;\n  protected modelInstance: T;\n  protected throwError: boolean;\n\n  /**\n   * @param model\n   * @param logs\n   * @param sqlDataSource Passed if a custom connection is provided\n   */\n  protected constructor(\n    model: typeof Model,\n    logs: boolean,\n    sqlDataSource: SqlDataSource,\n  ) {\n    this.logs = logs;\n    this.model = model;\n    this.throwError = false;\n    this.modelInstance = getBaseModelInstance<T>();\n    this.sqlDataSource = sqlDataSource;\n  }\n\n  /**\n   * @description Finds all records that match the input\n   * @param input\n   */\n  abstract find(input?: FindType<T>): Promise<T[]>;\n  abstract find(input?: UnrestrictedFindType<T>): Promise<T[]>;\n  abstract find(input?: FindType<T> | UnrestrictedFindType<T>): Promise<T[]>;\n\n  /**\n   * @description Finds the first record that matches the input\n   * @param input\n   */\n  abstract findOne(input: UnrestrictedFindOneType<T>): Promise<T | null>;\n  abstract findOne(input: FindOneType<T>): Promise<T | null>;\n  abstract findOne(\n    input: FindOneType<T> | UnrestrictedFindOneType<T>,\n  ): Promise<T | null>;\n\n  /**\n   * @description Finds the first record that matches the input or throws an error\n   */\n  async findOneOrFail(\n    input: (FindOneType<T> | UnrestrictedFindOneType<T>) & {\n      customError?: Error;\n    },\n  ): Promise<T> {\n    const result = await this.findOne(input);\n    if (result === null) {\n      if (input.customError) {\n        throw input.customError;\n      }\n\n      throw new Error(\"ROW_NOT_FOUND\");\n    }\n\n    return result;\n  }\n\n  /**\n   * @description Finds a record by its primary key\n   * @param value\n   * @param throwErrorOnNull\n   */\n  abstract findOneByPrimaryKey(\n    value: string | number | boolean,\n    throwErrorOnNull: boolean,\n  ): Promise<T | null>;\n\n  /**\n   * @description Creates a new record\n   * @param model\n   * @param trx\n   */\n  abstract insert(model: Partial<T>): Promise<T | null>;\n\n  /**\n   * @description Creates multiple records\n   * @param model\n   * @param trx\n   */\n  abstract insertMany(model: Partial<T>[]): Promise<T[]>;\n\n  /**\n   * @description Updates a record\n   * @param model\n   * @param trx\n   */\n  abstract updateRecord(model: T): Promise<T | null>;\n\n  /**\n   * @description Deletes a record\n   * @param model\n   * @param trx\n   */\n  abstract deleteRecord(model: T): Promise<T | null>;\n\n  /**\n   * @description Returns a query builder\n   */\n  abstract query(): QueryBuilder<T>;\n}\n","import { SqlDataSourceType } from \"../../sql_data_source_types\";\n\nconst deleteTemplate = (table: string, dbType: SqlDataSourceType) => {\n  return {\n    delete: (column: string, value: string | number | boolean | Date) => {\n      let baseQuery = `DELETE FROM ${table} WHERE ${column} = PLACEHOLDER`;\n      switch (dbType) {\n        case \"mariadb\":\n        case \"sqlite\":\n        case \"mysql\":\n          baseQuery = baseQuery.replace(\"PLACEHOLDER\", \"?\");\n          break;\n        case \"postgres\":\n          baseQuery = baseQuery.replace(\"PLACEHOLDER\", \"$1\");\n          break;\n        default:\n          throw new Error(\"Unsupported database type\");\n      }\n\n      return { query: baseQuery, params: [value] };\n    },\n    massiveDelete: (whereClause: string, joinClause: string = \"\") => {\n      return `DELETE FROM ${table} ${joinClause} ${whereClause}`;\n    },\n  };\n};\n\nexport default deleteTemplate;\n","import { convertCase } from \"../../../utils/case_utils\";\nimport { isNestedObject } from \"../../../utils/json_utils\";\nimport { Model } from \"../../models/model\";\nimport { getModelColumns } from \"../../models/model_decorators\";\nimport { SqlDataSourceType } from \"../../sql_data_source_types\";\n\ntype BaseValues = string | number | boolean | Date | null | object | undefined;\n\nconst insertTemplate = (\n  dbType: SqlDataSourceType,\n  typeofModel: typeof Model,\n) => {\n  const table = typeofModel.table;\n  const modelColumns = getModelColumns(typeofModel);\n\n  return {\n    insert: (columns: string[], values: BaseValues[]) => {\n      if (columns.includes(\"$additionalColumns\")) {\n        const $additionalColumnsIndex = columns.indexOf(\"$additionalColumns\");\n        columns.splice(columns.indexOf(\"$additionalColumns\"), 1);\n        values.splice($additionalColumnsIndex, 1);\n      }\n\n      for (let i = 0; i < values.length; i++) {\n        const column = columns[i];\n        const modelColumn = modelColumns.find(\n          (modelColumn) => modelColumn.columnName === column,\n        );\n        if (modelColumn && modelColumn.prepare) {\n          values[i] = modelColumn.prepare(values[i]);\n        }\n      }\n\n      columns = columns.map((column) =>\n        convertCase(column, typeofModel.databaseCaseConvention),\n      );\n      let placeholders: string;\n      let params: BaseValues[];\n\n      switch (dbType) {\n        case \"mysql\":\n        case \"mariadb\":\n          placeholders = columns\n            .map((_, index) => {\n              if (isNestedObject(values[index])) {\n                return `?`;\n              }\n              return `?`;\n            })\n            .join(\", \");\n          params = values.map((value) =>\n            isNestedObject(value) ? JSON.stringify(value) : value,\n          );\n          break;\n        case \"sqlite\":\n          placeholders = columns.map(() => \"?\").join(\", \");\n          params = values;\n          break;\n        case \"postgres\":\n          placeholders = columns\n            .map((_, index) => {\n              if (isNestedObject(values[index])) {\n                return `$${index + 1}::jsonb`;\n              }\n              return `$${index + 1}`;\n            })\n            .join(\", \");\n          params = values.map((value) =>\n            isNestedObject(value) ? JSON.stringify(value) : value,\n          );\n          break;\n        default:\n          throw new Error(\"Unsupported database type\");\n      }\n\n      const query =\n        dbType !== \"postgres\"\n          ? `INSERT INTO ${table} (${columns.join(\", \")})\nVALUES (${placeholders});`\n          : `INSERT INTO ${table} (${columns.join(\", \")})\nVALUES (${placeholders}) RETURNING *;`;\n\n      return { query, params };\n    },\n    insertMany: (columns: string[], values: BaseValues[][]) => {\n      columns = columns.map((column) =>\n        convertCase(column, typeofModel.databaseCaseConvention),\n      );\n      let valueSets: string[];\n      let params: BaseValues[] = [];\n\n      for (let i = 0; i < values.length; i++) {\n        for (let j = 0; j < values[i].length; j++) {\n          const column = columns[j];\n          const modelColumn = modelColumns.find(\n            (modelColumn) => modelColumn.columnName === column,\n          );\n          if (modelColumn && modelColumn.prepare) {\n            values[i][j] = modelColumn.prepare(values[i][j]);\n          }\n        }\n      }\n\n      switch (dbType) {\n        case \"mysql\":\n        case \"mariadb\":\n          valueSets = values.map((valueSet) => {\n            params.push(\n              ...valueSet.map((value) =>\n                isNestedObject(value) ? JSON.stringify(value) : value,\n              ),\n            );\n            return `(${valueSet.map(() => \"?\").join(\", \")})`;\n          });\n          break;\n        case \"sqlite\":\n          valueSets = values.map((valueSet) => {\n            params.push(...valueSet);\n            return `(${valueSet.map(() => \"?\").join(\", \")})`;\n          });\n          break;\n        case \"postgres\":\n          valueSets = values.map((valueSet, rowIndex) => {\n            params.push(\n              ...valueSet.map((value) =>\n                isNestedObject(value) ? JSON.stringify(value) : value,\n              ),\n            );\n            return `(${valueSet\n              .map((value, colIndex) => {\n                if (isNestedObject(value)) {\n                  return `$${rowIndex * columns.length + colIndex + 1}::jsonb`;\n                }\n                return `$${rowIndex * columns.length + colIndex + 1}`;\n              })\n              .join(\", \")})`;\n          });\n          break;\n        default:\n          throw new Error(\"Unsupported database type\");\n      }\n\n      const query =\n        dbType !== \"postgres\"\n          ? `INSERT INTO ${table} (${columns.join(\", \")})\nVALUES ${valueSets.join(\", \")};`\n          : `INSERT INTO ${table} (${columns.join(\", \")})\nVALUES ${valueSets.join(\", \")} RETURNING *;`;\n\n      return { query, params };\n    },\n  };\n};\n\nexport default insertTemplate;\n","import { convertCase } from \"../../utils/case_utils\";\nimport { SqlDataSourceType } from \"../sql_data_source_types\";\n\nexport function generateManyToManyQuery({\n  dbType,\n  relationName,\n  selectedColumns,\n  leftTable,\n  leftTablePrimaryColumn,\n  rightTablePrimaryColumn,\n  pivotLeftTableColumn,\n  pivotRightTableColumn,\n  rightTable,\n  pivotTable,\n  whereCondition,\n  relatedModelColumns,\n  havingQuery,\n  limit,\n  offset,\n  orderBy,\n}: {\n  dbType: SqlDataSourceType;\n  relationName: string;\n  selectedColumns: string[];\n  leftTable: string;\n  leftTablePrimaryColumn: string;\n  rightTablePrimaryColumn: string;\n  pivotLeftTableColumn: string;\n  pivotRightTableColumn: string;\n  rightTable: string;\n  pivotTable: string;\n  relatedModelColumns: string[];\n  whereCondition: string;\n  havingQuery: string;\n  limit?: number;\n  offset: number;\n  orderBy: string;\n}): string {\n  let jsonAggFunction = \"\";\n  let jsonObjectFunction = \"\";\n  let jsonAlias = \"\";\n\n  switch (dbType) {\n    case \"postgres\":\n      jsonAggFunction = \"json_agg\";\n      jsonObjectFunction = \"json_build_object\";\n      jsonAlias = \"t.json_data\";\n      break;\n    case \"mysql\":\n    case \"mariadb\":\n      jsonAggFunction = \"JSON_ARRAYAGG\";\n      jsonObjectFunction = \"JSON_OBJECT\";\n      jsonAlias = \"t.json_data\";\n      break;\n    case \"sqlite\":\n      jsonAggFunction = \"JSON_GROUP_ARRAY\";\n      jsonObjectFunction = \"JSON_OBJECT\";\n      jsonAlias = \"JSON(t.json_data)\";\n      break;\n    default:\n      throw new Error(\"Unsupported database type\");\n  }\n\n  // Prepare selected columns\n  const columnsList = selectedColumns\n    .map((col) => {\n      if (col.includes(\"*\")) {\n        return relatedModelColumns\n          .map((column) => {\n            return `'${column}', ${rightTable}.${column}`;\n          })\n          .join(\",\\n            \");\n      }\n\n      if (col.toLowerCase().includes(\"as\")) {\n        const [column, alias] = col.split(\" as \");\n        return `'${alias}', ${column}`;\n      }\n\n      if (!col.includes(\".\")) {\n        return `'${col}', ${rightTable}.${col}`;\n      }\n\n      const alias = col.split(\".\").pop();\n      return `'${alias}', ${col}`;\n    })\n    .join(\",\\n            \");\n\n  let limitOffsetClause = \"\";\n  if (limit) {\n    limitOffsetClause += `LIMIT ${limit}`;\n  }\n\n  if (offset) {\n    limitOffsetClause += ` OFFSET ${offset}`;\n  }\n\n  let query = `\n  SELECT\n    ${leftTable}.id AS ${leftTablePrimaryColumn},\n    '${relationName}' AS relation_name,\n    (\n      SELECT ${jsonAggFunction}(${jsonAlias})\n      FROM (\n        SELECT ${jsonObjectFunction}(\n          ${columnsList}\n        ) AS json_data\n        FROM ${rightTable}\n        JOIN ${pivotTable} ON ${pivotTable}.${pivotRightTableColumn} = ${rightTable}.${rightTablePrimaryColumn}\n        ${dbType === \"mariadb\" ? `JOIN ${leftTable} ON ${pivotTable}.${pivotLeftTableColumn} = ${leftTable}.${leftTablePrimaryColumn}` : \"\"}\n        WHERE ${pivotTable}.${pivotLeftTableColumn} = ${leftTable}.${leftTablePrimaryColumn}`;\n\n  if (whereCondition) {\n    query += ` AND ${whereCondition.replace(\"WHERE\", \"\")}`;\n  }\n\n  if (havingQuery) {\n    query += ` HAVING ${havingQuery}`;\n  }\n\n  if (orderBy) {\n    query += ` ${orderBy}`;\n  }\n\n  query += ` ${limitOffsetClause}\n      ) t\n    ) AS ${relationName}\n  FROM ${leftTable};\n  `;\n\n  return query.trim();\n}\n\nexport function generateHasManyQuery({\n  selectQuery,\n  relationName,\n  relatedModel,\n  foreignKey,\n  typeofModel,\n  primaryKeyValues,\n  joinQuery,\n  whereQuery,\n  groupByQuery,\n  havingQuery,\n  orderByQuery,\n  extractedOffsetValue,\n  extractedLimitValue,\n  databaseType,\n}: {\n  selectQuery: string;\n  relationName: string;\n  relatedModel: string;\n  foreignKey: string;\n  typeofModel: any;\n  primaryKeyValues: Array<{ value: any; type: string }>;\n  joinQuery: string;\n  whereQuery: string;\n  groupByQuery: string;\n  havingQuery: string;\n  orderByQuery: string;\n  extractedOffsetValue: number;\n  extractedLimitValue: number;\n  databaseType: string;\n}): string {\n  const foreignKeyConverted = convertCase(\n    foreignKey,\n    typeofModel.databaseCaseConvention,\n  );\n  const primaryKeyValuesSQL = primaryKeyValues\n    .map(({ value, type }) => convertValueToSQL(value, type))\n    .join(\", \");\n\n  let rowNumberClause;\n  if (databaseType === \"mysql\" || databaseType === \"mariadb\") {\n    rowNumberClause = `ROW_NUMBER() OVER (PARTITION BY ${relatedModel}.${foreignKeyConverted} ORDER BY ${orderByQuery || `${relatedModel}.${foreignKeyConverted}`}) as row_num`;\n  } else {\n    rowNumberClause = `ROW_NUMBER() OVER (PARTITION BY ${relatedModel}.${foreignKeyConverted} ORDER BY ${orderByQuery || \"1\"}) as row_num`;\n  }\n\n  const hasManyQuery = `\n    WITH CTE AS (\n      SELECT ${selectQuery}, '${relationName}' as relation_name,\n             ${rowNumberClause}\n      FROM ${relatedModel}\n      ${joinQuery}\n      WHERE ${relatedModel}.${foreignKeyConverted} IN (${primaryKeyValuesSQL})\n      ${whereQuery} ${groupByQuery} ${havingQuery}\n    )\n    SELECT * FROM CTE\n    WHERE row_num > ${extractedOffsetValue || 0}\n    ${extractedLimitValue ? `AND row_num <= (${extractedOffsetValue || 0} + ${extractedLimitValue})` : \"\"};\n  `;\n\n  return hasManyQuery;\n}\n\nexport function convertValueToSQL(value: any, type: string): string {\n  switch (type) {\n    case \"string\":\n      return `'${value}'`;\n    case \"number\":\n    case \"boolean\":\n      return `${value}`;\n    default:\n      throw new Error(`Unsupported value type: ${type}`);\n  }\n}\n","import { convertCase } from \"../../../utils/case_utils\";\nimport logger from \"../../../utils/logger\";\nimport { Model } from \"../../models/model\";\nimport { getModelColumns, getRelations } from \"../../models/model_decorators\";\nimport { ManyToMany } from \"../../models/relations/many_to_many\";\nimport { Relation, RelationEnum } from \"../../models/relations/relation\";\nimport { RelationQueryBuilder } from \"../../query_builder/query_builder\";\nimport { SqlDataSourceType } from \"../../sql_data_source_types\";\nimport {\n  convertValueToSQL,\n  generateHasManyQuery,\n  generateManyToManyQuery,\n} from \"../utils\";\n\nfunction parseValueType(value: any): string {\n  return typeof value;\n}\n\nfunction parseRelationQuery(relationQuery: RelationQueryBuilder): {\n  selectQuery: string;\n  whereQuery: string;\n  joinQuery: string;\n  orderByQuery: string;\n  groupByQuery: string;\n  limitQuery: string;\n  offsetQuery: string;\n  havingQuery: string;\n} {\n  const selectQuery = relationQuery.selectedColumns?.join(\", \") || \"*\";\n  const joinQuery = relationQuery.joinQuery ? relationQuery.joinQuery : \"\";\n  const orderByQuery = relationQuery.orderByQuery\n    ? `ORDER BY ${relationQuery.orderByQuery}`\n    : \"\";\n  const groupByQuery = relationQuery.groupByQuery\n    ? `GROUP BY ${relationQuery.groupByQuery}`\n    : \"\";\n  const limitQuery = relationQuery.limitQuery\n    ? `LIMIT ${relationQuery.limitQuery}`\n    : \"\";\n  const offsetQuery = relationQuery.offsetQuery\n    ? `OFFSET ${relationQuery.offsetQuery}`\n    : \"\";\n  const havingQuery = relationQuery.havingQuery\n    ? `HAVING ${relationQuery.havingQuery}`\n    : \"\";\n\n  return {\n    selectQuery,\n    whereQuery: relationQuery.whereQuery || \"\",\n    joinQuery,\n    orderByQuery,\n    groupByQuery,\n    limitQuery,\n    offsetQuery,\n    havingQuery,\n  };\n}\n\nfunction relationTemplates<T extends Model>(\n  models: T[],\n  relation: Relation,\n  relationName: string,\n  relationQuery: RelationQueryBuilder,\n  typeofModel: typeof Model,\n  dbType: SqlDataSourceType,\n): {\n  query: string;\n  params: any[];\n} {\n  const primaryKey = relation.model.primaryKey;\n  const foreignKey = relation.foreignKey as keyof T;\n  const relatedModel = relation.relatedModel;\n  const {\n    selectQuery,\n    whereQuery,\n    joinQuery,\n    orderByQuery,\n    groupByQuery,\n    limitQuery,\n    offsetQuery,\n    havingQuery,\n  } = parseRelationQuery(relationQuery);\n  const params = relationQuery.params || [];\n  const extractedLimitValue = limitQuery.match(/\\d+/)?.[0] as\n    | number\n    | undefined;\n  const extractedOffsetValue = offsetQuery.match(/\\d+/)?.[0] || 0;\n\n  const primaryKeyValues = models.map((model) => {\n    const value =\n      model[\n        convertCase(primaryKey, typeofModel.modelCaseConvention) as keyof T\n      ];\n    return { value, type: parseValueType(value) };\n  });\n\n  const foreignKeyValues = models.map((model) => {\n    const value =\n      model[\n        convertCase(foreignKey, typeofModel.modelCaseConvention) as keyof T\n      ];\n    return { value, type: parseValueType(value) };\n  });\n\n  switch (relation.type) {\n    case RelationEnum.hasOne:\n      if (primaryKeyValues.some(({ value }) => !value)) {\n        logger.error(\n          `Foreign key values are missing for has one relation: ${relationName} ${foreignKeyValues}`,\n        );\n        throw new Error(\n          `Foreign key values are missing for has one relation: ${relationName} ${foreignKeyValues}`,\n        );\n      }\n\n      if (!primaryKey) {\n        throw new Error(\n          `Related Model ${relatedModel} does not have a primary key`,\n        );\n      }\n\n      if (!foreignKeyValues.length) {\n        return {\n          query: \"\",\n          params: params,\n        };\n      }\n\n      const query = `SELECT ${selectQuery}, '${relationName}' as relation_name FROM ${relatedModel}\n${joinQuery} WHERE ${relatedModel}.${convertCase(\n        foreignKey,\n        typeofModel.databaseCaseConvention,\n      )} IN (${primaryKeyValues\n        .map(({ value, type }) => convertValueToSQL(value, type))\n        .join(\", \")}) ${whereQuery};\n      `;\n\n      return {\n        query,\n        params,\n      };\n\n    case RelationEnum.belongsTo:\n      if (foreignKeyValues.some(({ value }) => !value)) {\n        logger.error(\n          `Foreign key values are missing for belongs to relation: ${relationName} ${foreignKeyValues}`,\n        );\n        throw new Error(\n          `Foreign key values are missing for belongs to relation: ${relationName} ${foreignKeyValues}`,\n        );\n      }\n\n      if (!primaryKey) {\n        throw new Error(\n          `Related Model ${relatedModel} does not have a primary key`,\n        );\n      }\n\n      if (!foreignKeyValues.length) {\n        return {\n          query: \"\",\n          params: [],\n        };\n      }\n\n      const belongsToQuery = `SELECT ${selectQuery}, '${relationName}' as relation_name FROM ${relatedModel}\n${joinQuery}  WHERE ${relatedModel}.${primaryKey} IN (${foreignKeyValues\n        .map(({ value, type }) => convertValueToSQL(value, type))\n        .join(\n          \", \",\n        )}) ${whereQuery} ${groupByQuery} ${havingQuery} ${orderByQuery} ${limitQuery} ${offsetQuery};\n`;\n\n      return {\n        query: belongsToQuery,\n        params: params,\n      };\n\n    case RelationEnum.hasMany:\n      if (primaryKeyValues.some(({ value }) => !value)) {\n        logger.error(\n          `Primary key values are missing for has many relation: ${relationName} ${primaryKeyValues}`,\n        );\n        throw new Error(\n          `Primary key values are missing for has many relation: ${relationName} ${primaryKeyValues}`,\n        );\n      }\n\n      if (!primaryKeyValues.length) {\n        return {\n          query: \"\",\n          params: [],\n        };\n      }\n\n      return {\n        query: generateHasManyQuery({\n          selectQuery,\n          relationName,\n          relatedModel,\n          foreignKey: foreignKey as string,\n          typeofModel,\n          primaryKeyValues,\n          joinQuery,\n          whereQuery,\n          groupByQuery,\n          havingQuery,\n          orderByQuery,\n          extractedOffsetValue: extractedOffsetValue as number,\n          extractedLimitValue: extractedLimitValue as number,\n          databaseType: dbType,\n        }),\n\n        params: params,\n      };\n\n    case RelationEnum.manyToMany:\n      if (primaryKeyValues.some(({ value }) => !value)) {\n        logger.error(\n          `Primary key values are missing for many to many relation: ${relationName} ${primaryKeyValues}`,\n        );\n        throw new Error(\n          `Primary key values are missing for many to many relation: ${relationName} ${primaryKeyValues}`,\n        );\n      }\n\n      if (!primaryKeyValues.length) {\n        return {\n          query: \"\",\n          params: [],\n        };\n      }\n\n      const throughModel = (relation as ManyToMany).throughModel;\n      const throughModelPrimaryKey = (relation as ManyToMany).foreignKey;\n      const relatedModelTable = (relation as ManyToMany).relatedModel;\n      const relatedModelPrimaryKey = (relation as ManyToMany).model.primaryKey;\n\n      const relatedModeRelations = getRelations(relation.model);\n      const relatedModelManyToManyRelation = relatedModeRelations.find(\n        (relation) =>\n          relation.type === RelationEnum.manyToMany &&\n          (relation as ManyToMany).throughModel === throughModel,\n      );\n\n      if (\n        !relatedModelManyToManyRelation ||\n        !relatedModelManyToManyRelation.foreignKey\n      ) {\n        throw new Error(\n          `Many to many relation not found for related model ${relatedModel} and through model ${throughModel}, the error is likely in the relation definition and was called by relation ${relationName} in model ${typeofModel.tableName}`,\n        );\n      }\n\n      const relatedModelForeignKey = relatedModelManyToManyRelation.foreignKey;\n      const relatedModelColumns = getModelColumns(relation.model).map(\n        (column) => column.columnName,\n      );\n\n      return {\n        query: generateManyToManyQuery({\n          dbType: dbType,\n          relationName: relationName,\n          leftTablePrimaryColumn: convertCase(\n            primaryKey,\n            typeofModel.databaseCaseConvention,\n          ),\n          rightTablePrimaryColumn: convertCase(\n            relatedModelPrimaryKey,\n            typeofModel.databaseCaseConvention,\n          ),\n          pivotLeftTableColumn: convertCase(\n            throughModelPrimaryKey,\n            typeofModel.databaseCaseConvention,\n          ),\n          pivotRightTableColumn: convertCase(\n            relatedModelForeignKey,\n            typeofModel.databaseCaseConvention,\n          ),\n          selectedColumns: relationQuery.selectedColumns?.length\n            ? relationQuery.selectedColumns\n            : relatedModelColumns.map((column) =>\n                convertCase(column, typeofModel.databaseCaseConvention),\n              ),\n          relatedModelColumns: relatedModelColumns.map((column) =>\n            convertCase(column, typeofModel.databaseCaseConvention),\n          ),\n          leftTable: typeofModel.tableName,\n          rightTable: relatedModelTable,\n          pivotTable: throughModel,\n          whereCondition: whereQuery,\n          orderBy: orderByQuery,\n          havingQuery: havingQuery,\n          limit: extractedLimitValue ? +extractedLimitValue : undefined,\n          offset: +extractedOffsetValue || 0,\n        }),\n        params: params,\n      };\n\n    default:\n      throw new Error(`Unknown relation type: ${relation.type}`);\n  }\n}\n\nexport default relationTemplates;\n","import { convertCase } from \"../../../utils/case_utils\";\nimport { isNestedObject } from \"../../../utils/json_utils\";\nimport { Model } from \"../../models/model\";\nimport { getModelColumns } from \"../../models/model_decorators\";\nimport { SqlDataSourceType } from \"../../sql_data_source_types\";\n\nconst updateTemplate = (\n  dbType: SqlDataSourceType,\n  typeofModel: typeof Model,\n) => {\n  const table = typeofModel.table;\n  const modelColumns = getModelColumns(typeofModel);\n\n  return {\n    update: (\n      columns: string[],\n      values: any[],\n      primaryKey?: string,\n      primaryKeyValue?: string | undefined,\n    ) => {\n      if (columns.includes(\"$additionalColumns\")) {\n        const $additionalColumnsIndex = columns.indexOf(\"$additionalColumns\");\n        columns.splice(columns.indexOf(\"$additionalColumns\"), 1);\n        values.splice($additionalColumnsIndex, 1);\n      }\n\n      for (let i = 0; i < values.length; i++) {\n        const column = columns[i];\n        const modelColumn = modelColumns.find(\n          (modelColumn) => modelColumn.columnName === column,\n        );\n        if (modelColumn && modelColumn.prepare) {\n          values[i] = modelColumn.prepare(values[i]);\n        }\n      }\n\n      values = values.map((value) => {\n        if (isNestedObject(value)) {\n          return JSON.stringify(value);\n        }\n\n        return value;\n      });\n\n      columns = columns.map((column) =>\n        convertCase(column, typeofModel.databaseCaseConvention),\n      );\n\n      let setClause: string;\n      let params: (any | null)[];\n\n      switch (dbType) {\n        case \"mysql\":\n        case \"sqlite\":\n        case \"mariadb\":\n          setClause = columns.map((column) => `\\`${column}\\` = ?`).join(\", \");\n          params = [...values, primaryKeyValue];\n          break;\n        case \"postgres\":\n          setClause = columns\n            .map((column, index) => `\"${column}\" = $${index + 1}`)\n            .join(\", \");\n          params = [...values, primaryKeyValue];\n          break;\n        default:\n          throw new Error(\"Unsupported database type\");\n      }\n\n      const primaryKeyPlaceholder =\n        dbType === \"postgres\" ? `$${columns.length + 1}` : \"?\";\n      const query = `UPDATE ${table}\nSET ${setClause}\nWHERE ${primaryKey} = ${primaryKeyPlaceholder};`;\n\n      return { query, params };\n    },\n    massiveUpdate: (\n      columns: string[],\n      values: any[],\n      whereClause: string,\n      joinClause: string = \"\",\n    ) => {\n      columns = columns.map((column) =>\n        convertCase(column, typeofModel.databaseCaseConvention),\n      );\n\n      if (columns.includes(\"$additionalColumns\")) {\n        const $additionalColumnsIndex = columns.indexOf(\"$additionalColumns\");\n        columns.splice(columns.indexOf(\"$additionalColumns\"), 1);\n        values.splice($additionalColumnsIndex, 1);\n      }\n\n      for (let i = 0; i < values.length; i++) {\n        const column = columns[i];\n        const modelColumn = modelColumns.find(\n          (modelColumn) => modelColumn.columnName === column,\n        );\n        if (modelColumn && modelColumn.prepare) {\n          values[i] = modelColumn.prepare(values[i]);\n        }\n      }\n\n      let setClause: string;\n      const params: any[] = [];\n\n      switch (dbType) {\n        case \"mysql\":\n        case \"sqlite\":\n        case \"mariadb\":\n          setClause = columns.map((column) => `\\`${column}\\` = ?`).join(\", \");\n          values.forEach((value) => {\n            if (isNestedObject(value)) {\n              params.push(JSON.stringify(value));\n              return;\n            }\n\n            params.push(value ?? null);\n          });\n          break;\n        case \"postgres\":\n          setClause = columns\n            .map((column, index) => `\"${column}\" = $${index + 1}`)\n            .join(\", \");\n          values.forEach((value) => {\n            if (isNestedObject(value)) {\n              params.push(JSON.stringify(value));\n              return;\n            }\n\n            params.push(value ?? null);\n          });\n          break;\n        default:\n          throw new Error(\"Unsupported database type\");\n      }\n\n      const query = `UPDATE ${table} ${joinClause}\nSET ${setClause} ${whereClause}`;\n\n      return { query, params };\n    },\n  };\n};\n\nexport default updateTemplate;\n","import { log } from \"../../../utils/logger\";\nimport deleteTemplate from \"../../resources/query/DELETE\";\nimport insertTemplate from \"../../resources/query/INSERT\";\nimport relationTemplates from \"../../resources/query/RELATION\";\nimport updateTemplate from \"../../resources/query/UPDATE\";\nimport { Model } from \"../model\";\nimport { getRelations } from \"../model_decorators\";\nimport { Relation } from \"../relations/relation\";\nimport { RelationQueryBuilder } from \"../../query_builder/query_builder\";\nimport {\n  SqlDataSourceType,\n  SqlConnectionType,\n  MysqlConnectionInstance,\n  SqliteConnectionInstance,\n  PgClientInstance,\n} from \"../../sql_data_source_types\";\n\nexport default class SqlModelManagerUtils<T extends Model> {\n  private dbType: SqlDataSourceType;\n  private sqlConnection: SqlConnectionType;\n\n  constructor(dbType: SqlDataSourceType, sqlConnection: SqlConnectionType) {\n    this.dbType = dbType;\n    this.sqlConnection = sqlConnection;\n  }\n\n  parseInsert(\n    model: T,\n    typeofModel: typeof Model,\n    dbType: SqlDataSourceType,\n  ): { query: string; params: any[] } {\n    const filteredModel = this.filterRelationsAndMetadata(model);\n    const keys = Object.keys(filteredModel);\n    const values = Object.values(filteredModel);\n    const insert = insertTemplate(dbType, typeofModel);\n\n    return insert.insert(keys, values);\n  }\n\n  parseMassiveInsert(\n    models: T[],\n    typeofModel: typeof Model,\n    dbType: SqlDataSourceType,\n  ): { query: string; params: any[] } {\n    const filteredModels = models.map((m) =>\n      this.filterRelationsAndMetadata(m),\n    );\n    const insert = insertTemplate(dbType, typeofModel);\n    const keys = Object.keys(filteredModels[0]);\n    const values = filteredModels.map((model) => Object.values(model));\n\n    return insert.insertMany(keys, values);\n  }\n\n  parseUpdate(\n    model: T,\n    typeofModel: typeof Model,\n    dbType: SqlDataSourceType,\n  ): { query: string; params: any[] } {\n    const update = updateTemplate(dbType, typeofModel);\n    const filteredModel = this.filterRelationsAndMetadata(model);\n    const keys = Object.keys(filteredModel);\n    const values = Object.values(filteredModel);\n\n    const primaryKeyValue = filteredModel[typeofModel.primaryKey as keyof T];\n\n    return update.update(\n      keys,\n      values,\n      typeofModel.primaryKey,\n      primaryKeyValue as string,\n    );\n  }\n\n  private filterRelationsAndMetadata(model: T): T {\n    const filteredModel = {};\n\n    const keys = Object.keys(model);\n    const isRelation = (value: any) => value instanceof Relation;\n    for (const key of keys) {\n      if (isRelation(model[key as keyof T])) {\n        continue;\n      }\n\n      Object.assign(filteredModel, { [key]: model[key as keyof T] });\n    }\n\n    return filteredModel as T;\n  }\n\n  parseDelete(\n    table: string,\n    column: string,\n    value: string | number | boolean,\n  ): { query: string; params: any[] } {\n    return deleteTemplate(table, this.dbType).delete(column, value);\n  }\n\n  private getRelationFromModel(\n    relationField: string,\n    typeofModel: typeof Model,\n  ): Relation {\n    const relations = getRelations(typeofModel);\n    const relation = relations.find(\n      (relation) => relation.columnName === relationField,\n    );\n    if (!relation) {\n      throw new Error(\n        `Relation ${relationField} not found in model ${typeofModel}`,\n      );\n    }\n\n    return relation;\n  }\n\n  async parseQueryBuilderRelations(\n    models: T[],\n    typeofModel: typeof Model,\n    input: RelationQueryBuilder[],\n    dbType: SqlDataSourceType,\n    logs: boolean,\n  ): Promise<{ [relationName: string]: Model[] }[]> {\n    if (!input.length) {\n      return [];\n    }\n\n    if (!typeofModel.primaryKey) {\n      throw new Error(`Model ${typeofModel} does not have a primary key`);\n    }\n\n    const resultMap: { [key: string]: any[] } = {};\n\n    for (const inputRelation of input) {\n      const relation = this.getRelationFromModel(\n        inputRelation.relation,\n        typeofModel,\n      );\n      const { query, params } = relationTemplates(\n        models,\n        relation,\n        inputRelation.relation,\n        inputRelation,\n        typeofModel,\n        dbType,\n      );\n\n      if (!query) {\n        resultMap[inputRelation.relation] = [];\n        continue;\n      }\n\n      log(query, logs, params);\n      let result = await this.getQueryResult(query, params);\n      if (!result) {\n        result = [];\n      } else if (!Array.isArray(result)) {\n        result = [result];\n      }\n\n      // Dynamic columns are added to the model after the query\n      for (const row of result) {\n        if (inputRelation.dynamicColumns?.length) {\n          await (relation.model as any).addDynamicColumns(\n            row[row[\"relation_name\"]],\n            inputRelation.dynamicColumns,\n          );\n        }\n      }\n\n      // after fetch hook\n      if (!inputRelation.ignoreAfterFetchHook) {\n        result = await (relation.model as any).afterFetch(result);\n      }\n\n      // Group the result by relation name\n      result.forEach((row: any) => {\n        const relationName = row.relation_name;\n        delete row.relation_name;\n        if (!resultMap[relationName]) {\n          resultMap[relationName] = [];\n        }\n\n        resultMap[relationName].push(row);\n      });\n    }\n\n    // Map the result to the expected format\n    const resultArray: { [relationName: string]: any[] }[] = input.map(\n      (inputRelation) => {\n        const modelsForRelation = resultMap[inputRelation.relation] || [];\n\n        // Some databases return JSON as string so we need to parse it\n        modelsForRelation.forEach((model) => {\n          if (typeof model[inputRelation.relation] === \"string\") {\n            model[inputRelation.relation] = JSON.parse(\n              model[inputRelation.relation],\n            );\n          }\n        });\n\n        return {\n          [inputRelation.relation]: modelsForRelation,\n        };\n      },\n    );\n\n    return resultArray;\n  }\n\n  private async getQueryResult(\n    query: string,\n    params: any[] = [],\n  ): Promise<any> {\n    switch (this.dbType) {\n      case \"mysql\":\n      case \"mariadb\":\n        const resultMysql = await (\n          this.sqlConnection as MysqlConnectionInstance\n        ).query(query, params);\n        return resultMysql[0];\n      case \"postgres\":\n        const resultPg = await (this.sqlConnection as PgClientInstance).query(\n          query,\n          params,\n        );\n        return resultPg.rows;\n      case \"sqlite\":\n        return await new Promise((resolve, reject) => {\n          (this.sqlConnection as SqliteConnectionInstance).all(\n            query,\n            params,\n            (err, result) => {\n              if (err) {\n                reject(err);\n              }\n\n              resolve(result);\n            },\n          );\n        });\n      default:\n        throw new Error(`Unsupported data source type: ${this.dbType}`);\n    }\n  }\n}\n","export type PaginationMetadata = {\n  perPage: number;\n  currentPage: number;\n  firstPage: number;\n  isEmpty: boolean;\n  total: number;\n  hasTotal: boolean;\n  lastPage: number;\n  hasMorePages: boolean;\n  hasPages: boolean;\n};\n\nexport type PaginatedData<T> = {\n  paginationMetadata: PaginationMetadata;\n  data: T[];\n};\n\nexport function getPaginationMetadata(\n  page: number,\n  limit: number,\n  total: number,\n) {\n  return {\n    total: total,\n    perPage: limit,\n    currentPage: page,\n    firstPage: 1,\n    isEmpty: total === 0,\n    lastPage: Math.max(1, Math.ceil(total / limit)),\n    hasMorePages: page < Math.max(1, Math.ceil(total / limit)),\n    hasPages: total > limit,\n  };\n}\n","import { convertCase } from \"../../../utils/case_utils\";\nimport { Model } from \"../../models/model\";\nimport { SqlDataSourceType } from \"../../sql_data_source_types\";\n\nconst baseSelectMethods = [\n  \"*\",\n  \"COUNT\",\n  \"DISTINCT\",\n  \"CONCAT\",\n  \"GROUP_CONCAT\",\n  \"AVG\",\n  \"MAX\",\n  \"MIN\",\n  \"SUM\",\n  \"AS\",\n  \"CONVERT\",\n  \"CAST\",\n  \"CONVERT_TZ\",\n  \"DATE_FORMAT\",\n  \"CURDATE\",\n  \"CURRENT_DATE\",\n  \"CURRENT_TIME\",\n  \"CURRENT_TIMESTAMP\",\n  \"CURTIME\",\n  \"DAYNAME\",\n  \"DAYOFMONTH\",\n  \"DAYOFWEEK\",\n  \"DAYOFYEAR\",\n  \"EXTRACT\",\n  \"HOUR\",\n  \"LOCALTIME\",\n  \"LOCALTIMESTAMP\",\n  \"MICROSECOND\",\n  \"MINUTE\",\n  \"MONTH\",\n  \"QUARTER\",\n  \"SECOND\",\n  \"STR_TO_DATE\",\n  \"TIME\",\n  \"TIMESTAMP\",\n  \"WEEK\",\n  \"YEAR\",\n  \"NOW\",\n  \"UTC_DATE\",\n  \"UTC_TIME\",\n  \"UTC_TIMESTAMP\",\n  \"DATE_ADD\",\n  \"DATE_SUB\",\n  \"DATE\",\n  \"DATEDIFF\",\n  \"DATE_FORMAT\",\n  \"DISTINCTROW\",\n];\n\nconst selectTemplate = (\n  dbType: SqlDataSourceType,\n  typeofModel: typeof Model,\n) => {\n  const table = typeofModel.table;\n  const escapeIdentifier = (identifier: string) => {\n    switch (dbType) {\n      case \"mysql\":\n      case \"sqlite\":\n      case \"mariadb\":\n        return `\\`${identifier.replace(/`/g, \"``\")}\\``;\n      case \"postgres\":\n        return `\"${identifier.replace(/\"/g, '\"\"')}\"`;\n      default:\n        throw new Error(\"Unsupported database type\");\n    }\n  };\n\n  return {\n    selectAll: `SELECT * FROM ${table} `,\n    selectById: (id: string) => `SELECT * FROM ${table} WHERE id = ${id}`,\n    selectByIds: (ids: string[]) => {\n      ids = ids.map((id) => escapeIdentifier(id) as string);\n      return `SELECT * FROM ${table} WHERE id IN (${ids.join(\", \")})`;\n    },\n    selectColumns: (...columns: string[]) => {\n      columns = columns.map((column) => {\n        const columnCase = typeofModel.databaseCaseConvention;\n        let tableName = \"\";\n        let columnName = column;\n        let alias = \"\";\n\n        if (column.toUpperCase().includes(\" AS \")) {\n          [columnName, alias] = column.split(/ AS /i);\n        }\n        alias = convertCase(alias, columnCase);\n\n        if (columnName.includes(\".\")) {\n          [tableName, columnName] = columnName.split(\".\");\n        }\n\n        if (\n          baseSelectMethods.includes(columnName.toUpperCase()) ||\n          columnName.includes(\"(\")\n        ) {\n          return alias ? `${columnName} AS ${alias}` : columnName;\n        }\n\n        let finalColumn = columnName;\n        if (!alias) {\n          const processedColumnName = escapeIdentifier(\n            convertCase(columnName, columnCase),\n          ) as string;\n          finalColumn = tableName\n            ? `${tableName}.${processedColumnName}`\n            : processedColumnName;\n        } else if (tableName) {\n          finalColumn = `${tableName}.${columnName}`;\n        }\n\n        return alias ? `${finalColumn} AS ${alias}` : finalColumn;\n      });\n\n      return `SELECT ${columns.join(\", \")} FROM ${table} `;\n    },\n    distinct: `DISTINCT`,\n    distinctOn: (...columns: string[]) => {\n      if (dbType !== \"postgres\") {\n        throw new Error(\"DISTINCT ON is only supported in postgres\");\n      }\n\n      columns = columns.map((column) =>\n        escapeIdentifier(\n          convertCase(column, typeofModel.databaseCaseConvention),\n        ),\n      ) as string[];\n\n      return `DISTINCT ON (${columns.join(\", \")})`;\n    },\n    selectCount: `SELECT COUNT(*) FROM ${table} `,\n    selectDistinct: (...columns: string[]) => {\n      columns = columns.map((column) =>\n        escapeIdentifier(\n          convertCase(column, typeofModel.databaseCaseConvention),\n        ),\n      ) as string[];\n      return `SELECT DISTINCT ${columns.join(\", \")} FROM ${table} `;\n    },\n    selectSum: (column: string) =>\n      `SELECT SUM(${escapeIdentifier(\n        convertCase(column, typeofModel.databaseCaseConvention),\n      )}) FROM ${table} `,\n    _orderBy: (columns: string[], order: \"ASC\" | \"DESC\" = \"ASC\") => {\n      columns = columns.map((column) => {\n        let tableName = \"\";\n        let columnName = column;\n\n        if (column.includes(\".\")) {\n          [tableName, columnName] = column.split(\".\");\n        }\n\n        const processedColumnName = convertCase(\n          columnName,\n          typeofModel.databaseCaseConvention,\n        );\n\n        return tableName\n          ? `${tableName}.${processedColumnName}`\n          : processedColumnName;\n      }) as string[];\n\n      return ` ORDER BY ${columns.join(\", \")} ${order}`;\n    },\n    groupBy: (...columns: string[]) => {\n      columns = columns.map((column) => {\n        let tableName = \"\";\n        let columnName = column;\n\n        if (column.includes(\".\")) {\n          [tableName, columnName] = column.split(\".\");\n        }\n\n        const processedColumnName = convertCase(\n          columnName,\n          typeofModel.databaseCaseConvention,\n        );\n\n        return tableName\n          ? `${tableName}.${processedColumnName}`\n          : processedColumnName;\n      }) as string[];\n\n      return ` GROUP BY ${columns.join(\", \")}`;\n    },\n    limit: (limit: number) => {\n      return ` LIMIT ${limit}`;\n    },\n    offset: (offset: number) => {\n      return ` OFFSET ${offset}`;\n    },\n  };\n};\n\nexport default selectTemplate;\n","import { convertCase } from \"../../../utils/case_utils\";\nimport { Model } from \"../../models/model\";\nimport { SqlDataSourceType } from \"../../sql_data_source_types\";\n\nexport type BinaryOperatorType =\n  | \"=\"\n  | \"!=\"\n  | \"<>\"\n  | \">\"\n  | \"<\"\n  | \">=\"\n  | \"<=\"\n  | \"LIKE\"\n  | \"ILIKE\"\n  | \"NOT LIKE\"\n  | \"NOT ILIKE\"\n  | \"IN\"\n  | \"NOT IN\"\n  | \"BETWEEN\"\n  | \"NOT BETWEEN\";\n\nexport type BaseValues = string | number | boolean | object;\n\nconst whereTemplate = (\n  dbType: SqlDataSourceType,\n  typeofModel: typeof Model,\n) => {\n  return {\n    convertPlaceHolderToValue: (query: string, startIndex: number = 1) => {\n      switch (dbType) {\n        case \"mysql\":\n        case \"sqlite\":\n        case \"mariadb\":\n          return query.replace(/PLACEHOLDER/g, () => \"?\");\n        case \"postgres\":\n          let index = startIndex;\n          return query.replace(/PLACEHOLDER/g, () => `$${index++}`);\n        default:\n          throw new Error(\"Unsupported database type\");\n      }\n    },\n    where: (\n      column: string,\n      value: BaseValues,\n      operator: BinaryOperatorType = \"=\",\n    ) => {\n      let query = `\\nWHERE ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} ${operator} PLACEHOLDER`;\n      let params = [value];\n\n      if (typeof value === \"object\" && value !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = `\\nWHERE JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) ${operator} PLACEHOLDER`;\n            params = [value];\n            break;\n          case \"postgres\":\n            query = `\\nWHERE ${column}::jsonb ${operator} PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    andWhere: (\n      column: string,\n      value: BaseValues,\n      operator: BinaryOperatorType = \"=\",\n    ) => {\n      let query = ` AND ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} ${operator} PLACEHOLDER`;\n      let params = [value];\n\n      if (typeof value === \"object\" && value !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) ${operator} PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = ` AND ${column}::jsonb ${operator} PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    orWhere: (\n      column: string,\n      value: BaseValues,\n      operator: BinaryOperatorType = \"=\",\n    ) => {\n      let query = ` OR ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} ${operator} PLACEHOLDER`;\n      let params = [value];\n\n      if (typeof value === \"object\" && value !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) ${operator} PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = ` OR ${column}::jsonb ${operator} PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    whereNot: (column: string, value: BaseValues) => {\n      let query = `\\nWHERE ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} != PLACEHOLDER`;\n      let params = [value];\n\n      if (typeof value === \"object\" && value !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = `\\nWHERE JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) != PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = `\\nWHERE ${column}::jsonb != PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    andWhereNot: (column: string, value: BaseValues) => {\n      let query = ` AND ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} != PLACEHOLDER`;\n      let params = [value];\n\n      if (typeof value === \"object\" && value !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) != PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = ` AND ${column}::jsonb != PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    orWhereNot: (column: string, value: BaseValues) => {\n      let query = ` OR ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} != PLACEHOLDER`;\n      let params = [value];\n\n      if (typeof value === \"object\" && value !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) != PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = ` OR ${column}::jsonb != PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    whereBetween: (column: string, min: BaseValues, max: BaseValues) => {\n      let query = `\\nWHERE ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n      let params = [min, max];\n\n      if (typeof min === \"object\" && min !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = `\\nWHERE JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = `\\nWHERE ${column}::jsonb BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    andWhereBetween: (column: string, min: BaseValues, max: BaseValues) => {\n      let query = ` AND ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n      let params = [min, max];\n\n      if (typeof min === \"object\" && min !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = ` AND ${column}::jsonb BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    orWhereBetween: (column: string, min: BaseValues, max: BaseValues) => {\n      let query = ` OR ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n      let params = [min, max];\n\n      if (typeof min === \"object\" && min !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = ` OR ${column}::jsonb BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    whereNotBetween: (column: string, min: BaseValues, max: BaseValues) => {\n      let query = `\\nWHERE ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n      let params = [min, max];\n\n      if (typeof min === \"object\" && min !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = `\\nWHERE JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = `\\nWHERE ${column}::jsonb NOT BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    andWhereNotBetween: (column: string, min: BaseValues, max: BaseValues) => {\n      let query = ` AND ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n      let params = [min, max];\n\n      if (typeof min === \"object\" && min !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = ` AND ${column}::jsonb NOT BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    orWhereNotBetween: (column: string, min: BaseValues, max: BaseValues) => {\n      let query = ` OR ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n      let params = [min, max];\n\n      if (typeof min === \"object\" && min !== null) {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;\n            break;\n          case \"postgres\":\n            query = ` OR ${column}::jsonb NOT BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    whereIn: (column: string, values: BaseValues[]) => {\n      let query = `\\nWHERE ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n      let params = values;\n\n      if (values[0] && typeof values[0] === \"object\") {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = `\\nWHERE JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) IN (${values\n              .map((_) => \"PLACEHOLDER\")\n              .join(\", \")})`;\n            break;\n          case \"postgres\":\n            query = `\\nWHERE ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )}::jsonb IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    andWhereIn: (column: string, values: BaseValues[]) => {\n      let query = ` AND ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n      let params = values;\n\n      if (values[0] && typeof values[0] === \"object\") {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) IN (${values\n              .map((_) => \"PLACEHOLDER\")\n              .join(\", \")})`;\n            break;\n          case \"postgres\":\n            query = ` AND ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )}::jsonb IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    orWhereIn: (column: string, values: BaseValues[]) => {\n      let query = ` OR ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n      let params = values;\n\n      if (values[0] && typeof values[0] === \"object\") {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) IN (${values\n              .map((_) => \"PLACEHOLDER\")\n              .join(\", \")})`;\n            break;\n          case \"postgres\":\n            query = ` OR ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )}::jsonb IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    whereNotIn: (column: string, values: BaseValues[]) => {\n      let query = `\\nWHERE ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} NOT IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n      let params = values;\n\n      if (values[0] && typeof values[0] === \"object\") {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = `\\nWHERE JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) NOT IN (${values\n              .map((_) => \"PLACEHOLDER\")\n              .join(\", \")})`;\n            break;\n          case \"postgres\":\n            query = `\\nWHERE ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )}::jsonb NOT IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    andWhereNotIn: (column: string, values: BaseValues[]) => {\n      let query = ` AND ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} NOT IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n      let params = values;\n\n      if (values[0] && typeof values[0] === \"object\") {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) NOT IN (${values\n              .map((_) => \"PLACEHOLDER\")\n              .join(\", \")})`;\n            break;\n          case \"postgres\":\n            query = ` AND ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )}::jsonb NOT IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    orWhereNotIn: (column: string, values: BaseValues[]) => {\n      let query = ` OR ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} NOT IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n      let params = values;\n\n      if (values[0] && typeof values[0] === \"object\") {\n        switch (dbType) {\n          case \"mariadb\":\n          case \"mysql\":\n          case \"sqlite\":\n            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column}, '$')) NOT IN (${values\n              .map((_) => \"PLACEHOLDER\")\n              .join(\", \")})`;\n            break;\n          case \"postgres\":\n            query = ` OR ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )}::jsonb NOT IN (${values.map((_) => \"PLACEHOLDER\").join(\", \")})`;\n            break;\n          default:\n            throw new Error(`Unsupported database type: ${dbType}`);\n        }\n      }\n\n      return {\n        query,\n        params,\n      };\n    },\n    whereNull: (column: string) => ({\n      query: `\\nWHERE ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IS NULL`,\n      params: [],\n    }),\n    andWhereNull: (column: string) => ({\n      query: ` AND ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IS NULL`,\n      params: [],\n    }),\n    orWhereNull: (column: string) => ({\n      query: ` OR ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IS NULL`,\n      params: [],\n    }),\n    whereNotNull: (column: string) => ({\n      query: `\\nWHERE ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IS NOT NULL`,\n      params: [],\n    }),\n    andWhereNotNull: (column: string) => ({\n      query: ` AND ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IS NOT NULL`,\n      params: [],\n    }),\n    orWhereNotNull: (column: string) => ({\n      query: ` OR ${convertCase(\n        column,\n        typeofModel.databaseCaseConvention,\n      )} IS NOT NULL`,\n      params: [],\n    }),\n    rawWhere: (query: string, params: any[]) => ({\n      query: `\\nWHERE ${query}`,\n      params,\n    }),\n    rawAndWhere: (query: string, params: any[]) => ({\n      query: ` AND ${query}`,\n      params,\n    }),\n    rawOrWhere: (query: string, params: any[]) => ({\n      query: ` OR ${query}`,\n      params,\n    }),\n    whereRegex: (column: string, regex: RegExp) => {\n      switch (dbType) {\n        case \"postgres\":\n          return {\n            query: `\\nWHERE ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )} ~ PLACEHOLDER`,\n            params: [regex.source],\n          };\n        case \"mysql\":\n        case \"mariadb\":\n          return {\n            query: `\\nWHERE ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )} REGEXP PLACEHOLDER`,\n            params: [regex.source],\n          };\n        case \"sqlite\":\n          throw new Error(\"SQLite does not support REGEXP out of the box\");\n        default:\n          throw new Error(`Unsupported database type: ${dbType}`);\n      }\n    },\n    andWhereRegex: (column: string, regex: RegExp) => {\n      switch (dbType) {\n        case \"postgres\":\n          return {\n            query: ` AND ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )} ~ PLACEHOLDER`,\n            params: [regex.source],\n          };\n        case \"mysql\":\n        case \"mariadb\":\n          return {\n            query: ` AND ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )} REGEXP PLACEHOLDER`,\n            params: [regex.source],\n          };\n        case \"sqlite\":\n          throw new Error(\"SQLite does not support REGEXP out of the box\");\n        default:\n          throw new Error(`Unsupported database type: ${dbType}`);\n      }\n    },\n    orWhereRegex: (column: string, regex: RegExp) => {\n      switch (dbType) {\n        case \"postgres\":\n          return {\n            query: ` OR ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )} ~ PLACEHOLDER`,\n            params: [regex.source],\n          };\n        case \"mysql\":\n        case \"mariadb\":\n          return {\n            query: ` OR ${convertCase(\n              column,\n              typeofModel.databaseCaseConvention,\n            )} REGEXP PLACEHOLDER`,\n            params: [regex.source],\n          };\n        case \"sqlite\":\n          throw new Error(\"SQLite does not support REGEXP out of the box\");\n        default:\n          throw new Error(`Unsupported database type: ${dbType}`);\n      }\n    },\n  };\n};\n\nexport default whereTemplate;\n","import { Model } from \"../models/model\";\nimport { SelectableType } from \"../models/model_manager/model_manager_types\";\nimport whereTemplate, {\n  BaseValues,\n  BinaryOperatorType,\n} from \"../resources/query/WHERE\";\nimport { SqlDataSource } from \"../sql_data_source\";\n\nexport class WhereQueryBuilder<T extends Model> {\n  protected sqlDataSource: SqlDataSource;\n  protected whereQuery: string = \"\";\n  protected params: BaseValues[] = [];\n  protected model: typeof Model;\n  protected table: string;\n  protected logs: boolean;\n\n  protected whereTemplate: ReturnType<typeof whereTemplate>;\n  protected isNestedCondition = false;\n\n  /**\n   * @description Constructs a query_builder instance.\n   */\n  constructor(\n    model: typeof Model,\n    table: string,\n    logs: boolean,\n    isNestedCondition = false,\n    sqlDataSource: SqlDataSource,\n  ) {\n    this.model = model;\n    this.sqlDataSource = sqlDataSource;\n    this.logs = logs;\n    this.table = table;\n    this.whereTemplate = whereTemplate(\n      this.sqlDataSource.getDbType(),\n      this.model,\n    );\n    this.params = [];\n    this.isNestedCondition = isNestedCondition;\n  }\n\n  /**\n   * @description Accepts a value and executes a callback only of the value is not null or undefined.\n   */\n  when(\n    value: any,\n    cb: (value: any, query: WhereQueryBuilder<T>) => void,\n  ): this {\n    if (value === undefined || value === null) {\n      return this;\n    }\n\n    cb(value, this);\n    return this;\n  }\n\n  /**\n   * @description Adds a WHERE condition to the query.\n   */\n  where(\n    column: SelectableType<T>,\n    operator: BinaryOperatorType,\n    value: BaseValues,\n  ): this;\n  where(column: string, operator: BinaryOperatorType, value: BaseValues): this;\n  where(column: SelectableType<T> | string, value: BaseValues): this;\n  where(\n    column: SelectableType<T> | string,\n    operatorOrValue: BinaryOperatorType | BaseValues,\n    value?: BaseValues,\n  ): this {\n    let operator: BinaryOperatorType = \"=\";\n    let actualValue: BaseValues;\n\n    if (typeof operatorOrValue === \"string\" && value) {\n      operator = operatorOrValue as BinaryOperatorType;\n      actualValue = value;\n    } else {\n      actualValue = operatorOrValue as BaseValues;\n      operator = \"=\";\n    }\n\n    if (this.whereQuery || this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.andWhere(\n        column as string,\n        actualValue,\n        operator,\n      );\n      this.whereQuery += query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.where(\n      column as string,\n      actualValue,\n      operator,\n    );\n    this.whereQuery = query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an AND WHERE condition to the query.\n   */\n  andWhere(\n    column: SelectableType<T>,\n    operator: BinaryOperatorType,\n    value: BaseValues,\n  ): this;\n  andWhere(\n    column: string,\n    operator: BinaryOperatorType,\n    value: BaseValues,\n  ): this;\n  andWhere(column: SelectableType<T> | string, value: BaseValues): this;\n  andWhere(\n    column: SelectableType<T> | string,\n    operatorOrValue: BinaryOperatorType | BaseValues,\n    value?: BaseValues,\n  ): this {\n    let operator: BinaryOperatorType = \"=\";\n    let actualValue: BaseValues;\n\n    if (typeof operatorOrValue === \"string\" && value) {\n      operator = operatorOrValue as BinaryOperatorType;\n      actualValue = value;\n    } else {\n      actualValue = operatorOrValue as BaseValues;\n      operator = \"=\";\n    }\n\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.where(\n        column as string,\n        actualValue,\n        operator,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhere(\n      column as string,\n      actualValue,\n      operator,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an OR WHERE condition to the query.\n   */\n  orWhere(\n    column: SelectableType<T>,\n    operator: BinaryOperatorType,\n    value: BaseValues,\n  ): this;\n  orWhere(\n    column: string,\n    operator: BinaryOperatorType,\n    value: BaseValues,\n  ): this;\n  orWhere(column: SelectableType<T> | string, value: BaseValues): this;\n  orWhere(\n    column: SelectableType<T> | string,\n    operatorOrValue: BinaryOperatorType | BaseValues,\n    value?: BaseValues,\n  ): this {\n    let operator: BinaryOperatorType = \"=\";\n    let actualValue: BaseValues;\n\n    if (typeof operatorOrValue === \"string\" && value) {\n      operator = operatorOrValue as BinaryOperatorType;\n      actualValue = value;\n    } else {\n      actualValue = operatorOrValue as BaseValues;\n      operator = \"=\";\n    }\n\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.where(\n        column as string,\n        actualValue,\n        operator,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.orWhere(\n      column as string,\n      actualValue,\n      operator,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a WHERE BETWEEN condition to the query.\n   */\n  whereBetween(\n    column: SelectableType<T>,\n    min: BaseValues,\n    max: BaseValues,\n  ): this;\n  whereBetween(column: string, min: BaseValues, max: BaseValues): this;\n  whereBetween(\n    column: SelectableType<T> | string,\n    min: BaseValues,\n    max: BaseValues,\n  ): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereBetween(\n        column as string,\n        min,\n        max,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereBetween(\n      column as string,\n      min,\n      max,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an AND WHERE BETWEEN condition to the query.\n   */\n  andWhereBetween(\n    column: SelectableType<T>,\n    min: BaseValues,\n    max: BaseValues,\n  ): this;\n  andWhereBetween(column: string, min: BaseValues, max: BaseValues): this;\n  andWhereBetween(\n    column: SelectableType<T> | string,\n    min: BaseValues,\n    max: BaseValues,\n  ): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereBetween(\n        column as string,\n        min,\n        max,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereBetween(\n      column as string,\n      min,\n      max,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an OR WHERE BETWEEN condition to the query.\n   */\n  orWhereBetween(\n    column: SelectableType<T>,\n    min: BaseValues,\n    max: BaseValues,\n  ): this;\n  orWhereBetween(column: string, min: BaseValues, max: BaseValues): this;\n  orWhereBetween(\n    column: SelectableType<T> | string,\n    min: BaseValues,\n    max: BaseValues,\n  ): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereBetween(\n        column as string,\n        min,\n        max,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.orWhereBetween(\n      column as string,\n      min,\n      max,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a WHERE NOT BETWEEN condition to the query.\n   */\n  whereNotBetween(\n    column: SelectableType<T>,\n    min: BaseValues,\n    max: BaseValues,\n  ): this;\n  whereNotBetween(column: string, min: BaseValues, max: BaseValues): this;\n  whereNotBetween(\n    column: SelectableType<T> | string,\n    min: BaseValues,\n    max: BaseValues,\n  ): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNotBetween(\n        column as string,\n        min,\n        max,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereNotBetween(\n      column as string,\n      min,\n      max,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an OR WHERE NOT BETWEEN condition to the query.\n   */\n  orWhereNotBetween(\n    column: SelectableType<T>,\n    min: BaseValues,\n    max: BaseValues,\n  ): this;\n  orWhereNotBetween(column: string, min: BaseValues, max: BaseValues): this;\n  orWhereNotBetween(\n    column: SelectableType<T> | string,\n    min: BaseValues,\n    max: BaseValues,\n  ): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNotBetween(\n        column as string,\n        min,\n        max,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.orWhereNotBetween(\n      column as string,\n      min,\n      max,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a WHERE IN condition to the query.\n   */\n  whereIn(column: SelectableType<T>, values: BaseValues[]): this;\n  whereIn(column: string, values: BaseValues[]): this;\n  whereIn(column: SelectableType<T> | string, values: BaseValues[]): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereIn(\n        column as string,\n        values,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereIn(\n      column as string,\n      values,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an AND WHERE IN condition to the query.\n   */\n  andWhereIn(column: SelectableType<T>, values: BaseValues[]): this;\n  andWhereIn(column: string, values: BaseValues[]): this;\n  andWhereIn(column: SelectableType<T> | string, values: BaseValues[]): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereIn(\n        column as string,\n        values,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereIn(\n      column as string,\n      values,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an OR WHERE IN condition to the query.\n   */\n  orWhereIn(column: SelectableType<T>, values: BaseValues[]): this;\n  orWhereIn(column: string, values: BaseValues[]): this;\n  orWhereIn(column: SelectableType<T> | string, values: BaseValues[]): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereIn(\n        column as string,\n        values,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.orWhereIn(\n      column as string,\n      values,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a WHERE NOT IN condition to the query.\n   */\n  whereNotIn(column: SelectableType<T>, values: BaseValues[]): this;\n  whereNotIn(column: string, values: BaseValues[]): this;\n  whereNotIn(column: SelectableType<T> | string, values: BaseValues[]): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNotIn(\n        column as string,\n        values,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereNotIn(\n      column as string,\n      values,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an OR WHERE NOT IN condition to the query.\n   */\n  orWhereNotIn(column: SelectableType<T>, values: BaseValues[]): this;\n  orWhereNotIn(column: string, values: BaseValues[]): this;\n  orWhereNotIn(column: SelectableType<T> | string, values: BaseValues[]): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNotIn(\n        column as string,\n        values,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.orWhereNotIn(\n      column as string,\n      values,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a WHERE NULL condition to the query.\n   */\n  whereNull(column: SelectableType<T>): this;\n  whereNull(column: string): this;\n  whereNull(column: SelectableType<T> | string): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNull(column as string);\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereNull(column as string);\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an AND WHERE NULL condition to the query.\n   */\n  andWhereNull(column: SelectableType<T>): this;\n  andWhereNull(column: string): this;\n  andWhereNull(column: SelectableType<T> | string): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNull(column as string);\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereNull(column as string);\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an OR WHERE NULL condition to the query.\n   */\n  orWhereNull(column: SelectableType<T>): this;\n  orWhereNull(column: string): this;\n  orWhereNull(column: SelectableType<T> | string): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNull(column as string);\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.orWhereNull(column as string);\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a WHERE NOT NULL condition to the query.\n   */\n  whereNotNull(column: SelectableType<T>): this;\n  whereNotNull(column: string): this;\n  whereNotNull(column: SelectableType<T> | string): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNotNull(\n        column as string,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereNotNull(\n      column as string,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an AND WHERE NOT NULL condition to the query.\n   */\n  andWhereNotNull(column: SelectableType<T>): this;\n  andWhereNotNull(column: string): this;\n  andWhereNotNull(column: SelectableType<T> | string): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNotNull(\n        column as string,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereNotNull(\n      column as string,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an OR WHERE NOT NULL condition to the query.\n   */\n  orWhereNotNull(column: SelectableType<T>): this;\n  orWhereNotNull(column: string): this;\n  orWhereNotNull(column: SelectableType<T> | string): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereNotNull(\n        column as string,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.orWhereNotNull(\n      column as string,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a WHERE REGEXP condition to the query.\n   */\n  whereRegexp(column: SelectableType<T>, regexp: RegExp): this;\n  whereRegexp(column: string, regexp: RegExp): this;\n  whereRegexp(column: SelectableType<T> | string, regexp: RegExp): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereRegex(\n        column as string,\n        regexp,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereRegex(\n      column as string,\n      regexp,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an AND WHERE REGEXP condition to the query.\n   */\n  andWhereRegexp(column: SelectableType<T>, regexp: RegExp): this;\n  andWhereRegexp(column: string, regexp: RegExp): this;\n  andWhereRegexp(column: SelectableType<T> | string, regexp: RegExp): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereRegex(\n        column as string,\n        regexp,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.andWhereRegex(\n      column as string,\n      regexp,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds an OR WHERE REGEXP condition to the query.\n   */\n  orWhereRegexp(column: SelectableType<T>, regexp: RegExp): this;\n  orWhereRegexp(column: string, regexp: RegExp): this;\n  orWhereRegexp(column: SelectableType<T> | string, regexp: RegExp): this {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query, params } = this.whereTemplate.whereRegex(\n        column as string,\n        regexp,\n      );\n      this.whereQuery = query;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query, params } = this.whereTemplate.orWhereRegex(\n      column as string,\n      regexp,\n    );\n    this.whereQuery += query;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a raw WHERE condition to the query.\n   */\n  rawWhere(query: string, queryParams: any[] = []) {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query: rawQuery, params } = this.whereTemplate.rawWhere(\n        query,\n        queryParams,\n      );\n      this.whereQuery = rawQuery;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query: rawQuery, params } = this.whereTemplate.rawAndWhere(\n      query,\n      queryParams,\n    );\n    this.whereQuery += rawQuery;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a raw AND WHERE condition to the query.\n   */\n  rawAndWhere(query: string, queryParams: any[] = []) {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query: rawQuery, params } = this.whereTemplate.rawWhere(\n        query,\n        queryParams,\n      );\n      this.whereQuery = rawQuery;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query: rawQuery, params } = this.whereTemplate.rawAndWhere(\n      query,\n      queryParams,\n    );\n    this.whereQuery += rawQuery;\n    this.params.push(...params);\n    return this;\n  }\n\n  /**\n   * @description Adds a raw OR WHERE condition to the query.\n   */\n  rawOrWhere(query: string, queryParams: any[] = []) {\n    if (!this.whereQuery && !this.isNestedCondition) {\n      const { query: rawQuery, params } = this.whereTemplate.rawWhere(\n        query,\n        queryParams,\n      );\n      this.whereQuery = rawQuery;\n      this.params.push(...params);\n      return this;\n    }\n\n    const { query: rawQuery, params } = this.whereTemplate.rawOrWhere(\n      query,\n      queryParams,\n    );\n    this.whereQuery += rawQuery;\n    this.params.push(...params);\n    return this;\n  }\n}\n","import { convertCase } from \"../../utils/case_utils\";\nimport { Model } from \"../models/model\";\nimport { getModelColumns } from \"../models/model_decorators\";\nimport {\n  SelectableType,\n  RelationType,\n  DynamicColumnType,\n} from \"../models/model_manager/model_manager_types\";\nimport { MysqlQueryBuilder } from \"../mysql/mysql_query_builder\";\nimport { PaginatedData } from \"../pagination\";\nimport { PostgresQueryBuilder } from \"../postgres/postgres_query_builder\";\nimport selectTemplate from \"../resources/query/SELECT\";\nimport { addDynamicColumnsToModel } from \"../serializer\";\nimport { SqlDataSource } from \"../sql_data_source\";\nimport { SqlLiteQueryBuilder } from \"../sqlite/sql_lite_query_builder\";\nimport { DeleteOptions, SoftDeleteOptions } from \"./delete_query_builder_type\";\nimport { UpdateOptions } from \"./update_query_builder_types\";\nimport { WhereQueryBuilder } from \"./where_query_builder\";\n\n/**\n * @description The abstract class for query builders for selecting data.\n */\nexport type ModelQueryBuilder<T extends Model> =\n  | MysqlQueryBuilder<T>\n  | PostgresQueryBuilder<T>\n  | SqlLiteQueryBuilder<T>;\n\nexport type ModelInstanceType<O> = O extends typeof Model\n  ? InstanceType<O>\n  : never;\n\nexport type FetchHooks = \"beforeFetch\" | \"afterFetch\";\n\nexport type OneOptions = {\n  ignoreHooks?: FetchHooks[];\n};\n\nexport type ManyOptions = {\n  ignoreHooks?: FetchHooks[];\n};\n\nexport type RelationQueryBuilder = {\n  relation: string;\n  selectedColumns?: string[];\n  whereQuery?: string;\n  params?: any[];\n  joinQuery?: string;\n  groupByQuery?: string;\n  orderByQuery?: string;\n  limitQuery?: string;\n  offsetQuery?: string;\n  havingQuery?: string;\n  dynamicColumns?: string[];\n  ignoreAfterFetchHook?: boolean;\n};\n\nexport abstract class QueryBuilder<\n  T extends Model,\n> extends WhereQueryBuilder<T> {\n  protected selectQuery: string;\n  protected modelSelectedColumns: string[];\n  protected joinQuery: string;\n  protected relations: RelationQueryBuilder[];\n  protected dynamicColumns: string[];\n  protected groupByQuery: string;\n  protected orderByQuery: string;\n  protected limitQuery: string;\n  protected offsetQuery: string;\n  protected havingQuery: string;\n  protected selectTemplate: ReturnType<typeof selectTemplate>;\n\n  /**\n   * @description Constructs a Mysql_query_builder instance.\n   */\n  protected constructor(\n    model: typeof Model,\n    table: string,\n    logs: boolean,\n    sqlDataSource: SqlDataSource,\n  ) {\n    super(model, table, logs, false, sqlDataSource);\n    this.sqlDataSource = sqlDataSource;\n    this.selectQuery = selectTemplate(\n      this.sqlDataSource.getDbType(),\n      this.model,\n    ).selectAll;\n    this.selectTemplate = selectTemplate(\n      this.sqlDataSource.getDbType(),\n      this.model,\n    );\n    this.joinQuery = \"\";\n    this.whereQuery = \"\";\n    this.modelSelectedColumns = [];\n    this.relations = [];\n    this.dynamicColumns = [];\n    this.groupByQuery = \"\";\n    this.orderByQuery = \"\";\n    this.limitQuery = \"\";\n    this.offsetQuery = \"\";\n    this.havingQuery = \"\";\n  }\n\n  /**\n   * @description Executes the query and retrieves the first result.\n   */\n  abstract one(options?: OneOptions): Promise<T | null>;\n\n  /**\n   * @description Executes the query and retrieves the first result.\n   * @alias one\n   */\n  async first(options?: OneOptions): Promise<T | null> {\n    return this.one(options);\n  }\n\n  /**\n   * @description Executes the query and retrieves the first result. Fail if no result is found.\n   */\n  abstract oneOrFail(options?: {\n    ignoreHooks?: OneOptions[\"ignoreHooks\"] & { customError?: Error };\n  }): Promise<T>;\n\n  /**\n   * @description Executes the query and retrieves the first result. Fail if no result is found.\n   * @alias oneOrFail\n   */\n  async firstOrFail(options?: {\n    ignoreHooks?: OneOptions[\"ignoreHooks\"] & { customError?: Error };\n  }): Promise<T> {\n    return this.oneOrFail(options);\n  }\n\n  /**\n   * @description Executes the query and retrieves multiple results.\n   */\n  abstract many(options: ManyOptions): Promise<T[]>;\n\n  /**\n   * @description Updates records in the database.\n   */\n  abstract update(data: Partial<T>, options?: UpdateOptions): Promise<number>;\n\n  /**\n   * @description soft Deletes Records from the database.\n   * @default column - 'deletedAt'\n   * @default value - The current date and time.\n   * @default ignoreBeforeDeleteHook - false\n   * @default trx - undefined\n   */\n  abstract softDelete(options?: SoftDeleteOptions<T>): Promise<number>;\n\n  /**\n   * @description Deletes Records from the database for the current query.\n   */\n  abstract delete(options?: DeleteOptions): Promise<number>;\n\n  /**\n   * @description Executes the query and retrieves the count of results, it ignores all select, group by, order by, limit and offset clauses if they are present.\n   */\n  abstract getCount(options: { ignoreHooks: boolean }): Promise<number>;\n\n  /**\n   * @description Executes the query and retrieves the sum of a column, it ignores all select, group by, order by, limit and offset clauses if they are present.\n   */\n  abstract getSum(\n    column: string,\n    options: { ignoreHooks: boolean },\n  ): Promise<number>;\n\n  /**\n   * @description Executes the query and retrieves multiple results.\n   */\n  abstract paginate(\n    page: number,\n    limit: number,\n    options?: ManyOptions,\n  ): Promise<PaginatedData<T>>;\n\n  /**\n   * @description Adds a SELECT condition to the query.\n   */\n  abstract select(...columns: string[]): ModelQueryBuilder<T>;\n  abstract select(\n    ...columns: (SelectableType<T> | \"*\")[]\n  ): ModelQueryBuilder<T>;\n  abstract select(\n    ...columns: (SelectableType<T> | \"*\" | string)[]\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a DISTINCT condition to the query.\n   */\n  abstract distinct(): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a DISTINCT ON condition to the query.\n   */\n  abstract distinctOn(...columns: string[]): ModelQueryBuilder<T>;\n  abstract distinctOn(...columns: SelectableType<T>[]): ModelQueryBuilder<T>;\n  abstract distinctOn(\n    ...columns: (SelectableType<T> | string)[]\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a JOIN condition to the query.\n   */\n  abstract join(\n    table: string,\n    primaryColumn: string,\n    foreignColumn: string,\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a raw JOIN condition to the query.\n   */\n  abstract joinRaw(query: string): QueryBuilder<T>;\n\n  /**\n   * @description Adds a LEFT JOIN condition to the query.\n   */\n  abstract leftJoin(\n    table: string,\n    primaryColumn: string,\n    foreignColumn: string,\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a relation to the final model.\n   */\n  abstract with<O extends typeof Model>(\n    relation: RelationType<T>,\n    relatedModel?: O,\n    relatedModelQueryBuilder?: (\n      queryBuilder: ModelQueryBuilder<ModelInstanceType<O>>,\n    ) => void,\n    ignoreHooks?: { beforeFetch?: boolean; afterFetch?: boolean },\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a the selected dynamic columns from the model into the final model\n   */\n  abstract addDynamicColumns(\n    dynamicColumns: DynamicColumnType<T>[],\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Build more complex where conditions.\n   */\n  abstract whereBuilder(\n    cb: (queryBuilder: ModelQueryBuilder<T>) => void,\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Build more complex where conditions.\n   */\n  abstract andWhereBuilder(\n    cb: (queryBuilder: ModelQueryBuilder<T>) => void,\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Build more complex where conditions.\n   */\n  abstract orWhereBuilder(\n    cb: (queryBuilder: ModelQueryBuilder<T>) => void,\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds GROUP BY conditions to the query.\n   */\n  abstract groupBy(...columns: SelectableType<T>[]): ModelQueryBuilder<T>;\n  abstract groupBy(...columns: string[]): ModelQueryBuilder<T>;\n  abstract groupBy(\n    ...columns: (SelectableType<T> | string)[]\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a raw GROUP BY condition to the query, only one raw GROUP BY condition is stackable, the last one will be used.\n   */\n  abstract groupByRaw(query: string): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds ORDER BY conditions to the query.\n   */\n  abstract orderBy(\n    column: SelectableType<T>,\n    order: \"ASC\" | \"DESC\",\n  ): ModelQueryBuilder<T>;\n  abstract orderBy(column: string, order: \"ASC\" | \"DESC\"): ModelQueryBuilder<T>;\n  abstract orderBy(\n    column: SelectableType<T> | string,\n    order: \"ASC\" | \"DESC\",\n  ): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a raw ORDER BY condition to the query, only one raw ORDER BY condition is stackable, the last one will be used.\n   * @description ORDER BY is implicitly added to the query.\n   */\n  abstract orderByRaw(query: string): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a LIMIT condition to the query.\n   */\n  abstract limit(limit: number): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds an OFFSET condition to the query.\n   */\n  abstract offset(offset: number): ModelQueryBuilder<T>;\n\n  /**\n   * @description Adds a raw HAVING condition to the query, only one raw HAVING condition is stackable, the last one will be used.\n   */\n  abstract havingRaw(query: string): ModelQueryBuilder<T>;\n\n  /**\n   * @description Returns a copy of the query builder instance.\n   */\n  abstract copy(): ModelQueryBuilder<T>;\n\n  /**\n   * @description Returns the query and the parameters in an object.\n   */\n  toSql(): {\n    query: string;\n    params: any[];\n  } {\n    const query =\n      this.selectQuery +\n      this.joinQuery +\n      this.whereQuery +\n      this.groupByQuery +\n      this.havingQuery +\n      this.orderByQuery +\n      this.limitQuery +\n      this.offsetQuery;\n\n    function parsePlaceHolders(\n      dbType: string,\n      query: string,\n      startIndex: number = 1,\n    ): string {\n      switch (dbType) {\n        case \"mysql\":\n        case \"sqlite\":\n        case \"mariadb\":\n          return query.replace(/PLACEHOLDER/g, () => \"?\");\n        case \"postgres\":\n          let index = startIndex;\n          return query.replace(/PLACEHOLDER/g, () => `$${index++}`);\n        default:\n          throw new Error(\n            \"Unsupported database type, did you forget to set the dbType in the function params?\",\n          );\n      }\n    }\n\n    const parsedQuery = parsePlaceHolders(\n      this.sqlDataSource.getDbType(),\n      query,\n    );\n\n    return { query: parsedQuery, params: this.params };\n  }\n\n  protected groupFooterQuery(): string {\n    return (\n      this.groupByQuery +\n      this.havingQuery +\n      this.orderByQuery +\n      this.limitQuery +\n      this.offsetQuery\n    );\n  }\n\n  protected async mergeRawPacketIntoModel(\n    model: T,\n    row: any,\n    typeofModel: typeof Model,\n  ) {\n    const columns = getModelColumns(this.model);\n    Object.entries(row).forEach(([key, value]) => {\n      const casedKey = convertCase(\n        key,\n        typeofModel.modelCaseConvention,\n      ) as string;\n      if (columns.map((column) => column.columnName).includes(casedKey)) {\n        Object.assign(model, { [casedKey]: value });\n        return;\n      }\n\n      model.$additionalColumns[key] = value as string | number | boolean;\n    });\n\n    if (!this.dynamicColumns.length) {\n      return;\n    }\n\n    await addDynamicColumnsToModel(this.model, model, this.dynamicColumns);\n  }\n}\n","import { convertCase } from \"../../../utils/case_utils\";\nimport { Model } from \"../../models/model\";\n\nconst joinTemplate = (\n  typeofModel: typeof Model,\n  relatedTable: string,\n  primaryColumn: string,\n  foreignColumn: string,\n) => {\n  const table = typeofModel.table;\n  const foreignColumnName = foreignColumn.includes(\".\")\n    ? foreignColumn.split(\".\").pop()\n    : foreignColumn;\n  const primaryColumnName = primaryColumn.includes(\".\")\n    ? primaryColumn.split(\".\").pop()\n    : primaryColumn;\n\n  return {\n    innerJoin: () => {\n      const foreignColumnConverted = convertCase(\n        foreignColumnName,\n        typeofModel.databaseCaseConvention,\n      );\n      const primaryColumnConverted = convertCase(\n        primaryColumnName,\n        typeofModel.databaseCaseConvention,\n      );\n\n      return `\\nINNER JOIN ${relatedTable} ON ${relatedTable}.${foreignColumnConverted} = ${table}.${primaryColumnConverted} `;\n    },\n    leftJoin: () => {\n      const foreignColumnConverted = convertCase(\n        foreignColumnName,\n        typeofModel.databaseCaseConvention,\n      );\n      const primaryColumnConverted = convertCase(\n        primaryColumnName,\n        typeofModel.databaseCaseConvention,\n      );\n\n      return `\\nLEFT JOIN ${relatedTable} ON ${relatedTable}.${foreignColumnConverted} = ${table}.${primaryColumnConverted} `;\n    },\n  };\n};\n\nexport default joinTemplate;\n","import { convertCase } from \"../../utils/case_utils\";\nimport { log } from \"../../utils/logger\";\nimport { Model, getBaseModelInstance } from \"../models/model\";\nimport {\n  SelectableType,\n  RelationType,\n  DynamicColumnType,\n} from \"../models/model_manager/model_manager_types\";\nimport SqlModelManagerUtils from \"../models/model_manager/model_manager_utils\";\nimport { PaginatedData, getPaginationMetadata } from \"../pagination\";\nimport {\n  QueryBuilder,\n  OneOptions,\n  ManyOptions,\n  ModelQueryBuilder,\n  ModelInstanceType,\n} from \"../query_builder/query_builder\";\nimport joinTemplate from \"../resources/query/JOIN\";\nimport { parseDatabaseDataIntoModelResponse } from \"../serializer\";\nimport { SqlDataSource } from \"../sql_data_source\";\nimport {\n  DeleteOptions,\n  SoftDeleteOptions,\n} from \"../query_builder/delete_query_builder_type\";\nimport deleteTemplate from \"../resources/query/DELETE\";\nimport updateTemplate from \"../resources/query/UPDATE\";\nimport { UpdateOptions } from \"../query_builder/update_query_builder_types\";\nimport { MysqlConnectionInstance } from \"../sql_data_source_types\";\n\nexport class MysqlQueryBuilder<T extends Model> extends QueryBuilder<T> {\n  protected type: \"mysql\" | \"mariadb\";\n  protected mysqlConnection: MysqlConnectionInstance;\n  protected updateTemplate: ReturnType<typeof updateTemplate>;\n  protected deleteTemplate: ReturnType<typeof deleteTemplate>;\n  protected mysqlModelManagerUtils: SqlModelManagerUtils<T>;\n\n  constructor(\n    type: \"mysql\" | \"mariadb\",\n    model: typeof Model,\n    table: string,\n    mysqlConnection: MysqlConnectionInstance,\n    logs: boolean,\n    isNestedCondition = false,\n    sqlDataSource: SqlDataSource,\n  ) {\n    super(model, table, logs, sqlDataSource);\n    this.type = type;\n    this.mysqlConnection = mysqlConnection;\n    this.updateTemplate = updateTemplate(sqlDataSource.getDbType(), this.model);\n    this.deleteTemplate = deleteTemplate(table, sqlDataSource.getDbType());\n    this.isNestedCondition = isNestedCondition;\n    this.mysqlModelManagerUtils = new SqlModelManagerUtils<T>(\n      this.type,\n      this.mysqlConnection,\n    );\n  }\n\n  async one(options: OneOptions = {}): Promise<T | null> {\n    // hook query builder\n    if (!options.ignoreHooks?.includes(\"beforeFetch\")) {\n      this.model.beforeFetch(this);\n    }\n\n    let query: string = \"\";\n    if (this.joinQuery && !this.selectQuery) {\n      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);\n    }\n    query = this.selectQuery + this.joinQuery;\n\n    if (this.whereQuery) {\n      query += this.whereQuery;\n    }\n\n    query = this.whereTemplate.convertPlaceHolderToValue(query);\n\n    // limit to 1\n    this.limit(1);\n    query += this.groupFooterQuery();\n\n    query = query.trim();\n    log(query, this.logs, this.params);\n    const [rows] = await this.mysqlConnection.query<any[]>(query, this.params);\n\n    if (!rows.length) {\n      return null;\n    }\n\n    const modelInstance = getBaseModelInstance<T>();\n    await this.mergeRawPacketIntoModel(modelInstance, rows[0], this.model);\n    const relationModels =\n      await this.mysqlModelManagerUtils.parseQueryBuilderRelations(\n        [modelInstance],\n        this.model,\n        this.relations,\n        this.type,\n        this.logs,\n      );\n\n    const model = (await parseDatabaseDataIntoModelResponse(\n      [modelInstance],\n      this.model,\n      relationModels,\n      this.modelSelectedColumns,\n    )) as T;\n\n    return !options.ignoreHooks?.includes(\"afterFetch\")\n      ? ((await this.model.afterFetch([model]))[0] as T)\n      : model;\n  }\n\n  async oneOrFail(options?: OneOptions & { customError: Error }): Promise<T> {\n    const model = await this.one({\n      ignoreHooks: options?.ignoreHooks,\n    });\n\n    if (!model) {\n      if (options?.customError) {\n        throw options.customError;\n      }\n\n      throw new Error(\"ROW_NOT_FOUND\");\n    }\n\n    return model as T;\n  }\n\n  async many(options: ManyOptions = {}): Promise<T[]> {\n    // hook query builder\n    if (!options.ignoreHooks?.includes(\"beforeFetch\")) {\n      this.model.beforeFetch(this);\n    }\n\n    let query: string = \"\";\n    if (this.joinQuery && !this.selectQuery) {\n      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);\n    }\n    query = this.selectQuery + this.joinQuery;\n\n    if (this.whereQuery) {\n      query += this.whereQuery;\n    }\n\n    query += this.groupFooterQuery();\n    query = this.whereTemplate.convertPlaceHolderToValue(query);\n    query = query.trim();\n\n    log(query, this.logs, this.params);\n    const [rows] = await this.mysqlConnection.query<any[]>(query, this.params);\n\n    const modelPromises = rows.map(async (row) => {\n      const modelInstance = getBaseModelInstance<T>();\n      await this.mergeRawPacketIntoModel(modelInstance, row, this.model);\n      return modelInstance as T;\n    });\n\n    const models = await Promise.all(modelPromises);\n    const relationModels =\n      await this.mysqlModelManagerUtils.parseQueryBuilderRelations(\n        models,\n        this.model,\n        this.relations,\n        this.type,\n        this.logs,\n      );\n\n    const serializedModels = await parseDatabaseDataIntoModelResponse(\n      models,\n      this.model,\n      relationModels,\n      this.modelSelectedColumns,\n    );\n    if (!serializedModels) {\n      return [];\n    }\n\n    if (!options.ignoreHooks?.includes(\"afterFetch\")) {\n      await this.model.afterFetch(\n        Array.isArray(serializedModels) ? serializedModels : [serializedModels],\n      );\n    }\n\n    return (\n      Array.isArray(serializedModels) ? serializedModels : [serializedModels]\n    ) as T[];\n  }\n\n  async softDelete(options?: SoftDeleteOptions<T>): Promise<number> {\n    const {\n      column = \"deletedAt\",\n      value = new Date().toISOString().slice(0, 19).replace(\"T\", \" \"),\n      ignoreBeforeDeleteHook = false,\n    } = options || {};\n    if (!ignoreBeforeDeleteHook) {\n      this.model.beforeDelete(this);\n    }\n\n    let { query, params } = this.updateTemplate.massiveUpdate(\n      [column as string],\n      [value],\n      this.whereQuery,\n      this.joinQuery,\n    );\n\n    params = [...params, ...this.params];\n\n    log(query, this.logs, params);\n    const rows: any = await this.mysqlConnection.query(query, params);\n    if (!rows[0].affectedRows) {\n      return 0;\n    }\n\n    return rows[0].affectedRows;\n  }\n\n  async delete(options: DeleteOptions = {}): Promise<number> {\n    const { ignoreBeforeDeleteHook } = options || {};\n    if (!ignoreBeforeDeleteHook) {\n      this.model.beforeDelete(this);\n    }\n\n    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(\n      this.whereQuery,\n    );\n\n    const query = this.deleteTemplate.massiveDelete(\n      this.whereQuery,\n      this.joinQuery,\n    );\n\n    log(query, this.logs, this.params);\n    const rows: any = await this.mysqlConnection.query(query, this.params);\n\n    if (!rows[0].affectedRows) {\n      return 0;\n    }\n\n    return rows[0].affectedRows;\n  }\n\n  async update(data: Partial<T>, options?: UpdateOptions): Promise<number> {\n    const { ignoreBeforeUpdateHook } = options || {};\n    if (!ignoreBeforeUpdateHook) {\n      this.model.beforeUpdate(this);\n    }\n\n    const columns = Object.keys(data);\n    const values = Object.values(data);\n    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(\n      this.whereQuery,\n    );\n\n    const { query, params } = this.updateTemplate.massiveUpdate(\n      columns,\n      values,\n      this.whereQuery,\n      this.joinQuery,\n    );\n    console.log(query, params, this.params);\n\n    params.push(...this.params);\n\n    log(query, this.logs, params);\n    const rows: any = await this.mysqlConnection.query(query, params);\n    if (!rows[0].affectedRows) {\n      return 0;\n    }\n\n    return rows[0].affectedRows;\n  }\n\n  whereBuilder(cb: (queryBuilder: MysqlQueryBuilder<T>) => void): this {\n    const queryBuilder = new MysqlQueryBuilder(\n      this.type,\n      this.model as typeof Model,\n      this.table,\n      this.mysqlConnection,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(queryBuilder as unknown as MysqlQueryBuilder<T>);\n\n    let whereCondition = queryBuilder.whereQuery.trim();\n    if (whereCondition.startsWith(\"AND\")) {\n      whereCondition = whereCondition.substring(4); // 'AND '.length === 4 has to be removed from the beginning of the where condition\n    } else if (whereCondition.startsWith(\"OR\")) {\n      whereCondition = whereCondition.substring(3); // 'OR '.length === 3 has to be removed from the beginning of the where condition\n    }\n\n    whereCondition = \"(\" + whereCondition + \")\";\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? whereCondition\n        : `WHERE ${whereCondition}`;\n    } else {\n      this.whereQuery += ` AND ${whereCondition}`;\n    }\n\n    this.params.push(...queryBuilder.params);\n    return this;\n  }\n\n  orWhereBuilder(cb: (queryBuilder: MysqlQueryBuilder<T>) => void): this {\n    const nestedBuilder = new MysqlQueryBuilder(\n      this.type,\n      this.model as typeof Model,\n      this.table,\n      this.mysqlConnection,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(nestedBuilder as unknown as MysqlQueryBuilder<T>);\n\n    let nestedCondition = nestedBuilder.whereQuery.trim();\n    if (nestedCondition.startsWith(\"AND\")) {\n      nestedCondition = nestedCondition.substring(4);\n    } else if (nestedCondition.startsWith(\"OR\")) {\n      nestedCondition = nestedCondition.substring(3);\n    }\n\n    nestedCondition = `(${nestedCondition})`;\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? nestedCondition\n        : `WHERE ${nestedCondition}`;\n\n      this.params.push(...nestedBuilder.params);\n      return this;\n    }\n\n    this.whereQuery += ` OR ${nestedCondition}`;\n    this.params.push(...nestedBuilder.params);\n\n    return this;\n  }\n\n  andWhereBuilder(cb: (queryBuilder: MysqlQueryBuilder<T>) => void): this {\n    const nestedBuilder = new MysqlQueryBuilder(\n      this.type,\n      this.model as typeof Model,\n      this.table,\n      this.mysqlConnection,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(nestedBuilder as unknown as MysqlQueryBuilder<T>);\n\n    let nestedCondition = nestedBuilder.whereQuery.trim();\n    if (nestedCondition.startsWith(\"AND\")) {\n      nestedCondition = nestedCondition.substring(4);\n    } else if (nestedCondition.startsWith(\"OR\")) {\n      nestedCondition = nestedCondition.substring(3);\n    }\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? nestedCondition\n        : `WHERE ${nestedCondition}`;\n\n      this.params.push(...nestedBuilder.params);\n      return this;\n    }\n\n    this.whereQuery += ` AND ${nestedCondition}`;\n    this.params.push(...nestedBuilder.params);\n\n    return this;\n  }\n\n  async getCount(\n    options: { ignoreHooks: boolean } = { ignoreHooks: false },\n  ): Promise<number> {\n    if (options.ignoreHooks) {\n      const [result]: any = await this.mysqlConnection.query(\n        `SELECT COUNT(*) as total from ${this.table}`,\n      );\n      return result[0].total;\n    }\n\n    this.select(\"COUNT(*) as total\");\n    const result = await this.one();\n    return result ? +result.$additionalColumns.total : 0;\n  }\n\n  async getSum(column: SelectableType<T>): Promise<number>;\n  async getSum(column: string): Promise<number>;\n  async getSum(\n    column: SelectableType<T> | string,\n    options: { ignoreHooks: boolean } = { ignoreHooks: false },\n  ): Promise<number> {\n    if (options.ignoreHooks) {\n      const [result]: any = await this.mysqlConnection.query(\n        `SELECT SUM(${column as string}) as total from ${this.table}`,\n      );\n      return result[0].total;\n    }\n\n    column = convertCase(column as string, this.model.databaseCaseConvention);\n    this.select(`SUM(${column as string}) as total`);\n    const result = await this.one();\n    return result ? +result.$additionalColumns.total : 0;\n  }\n\n  async paginate(\n    page: number,\n    limit: number,\n    options?: ManyOptions,\n  ): Promise<PaginatedData<T>> {\n    this.limitQuery = this.selectTemplate.limit(limit);\n    this.offsetQuery = this.selectTemplate.offset((page - 1) * limit);\n\n    const originalSelectQuery = this.selectQuery;\n    this.select(\"COUNT(*) as total\");\n    const total = await this.many(options);\n\n    this.selectQuery = originalSelectQuery;\n    const models = await this.many(options);\n\n    const paginationMetadata = getPaginationMetadata(\n      page,\n      limit,\n      +total[0].$additionalColumns[\"total\"] as number,\n    );\n    let data =\n      (await parseDatabaseDataIntoModelResponse(models, this.model)) || [];\n    if (Array.isArray(data)) {\n      data = data.filter((model) => model !== null);\n    }\n\n    return {\n      paginationMetadata,\n      data: Array.isArray(data) ? data : [data],\n    } as PaginatedData<T>;\n  }\n\n  // SELECT\n  select(...columns: string[]): MysqlQueryBuilder<T>;\n  select(...columns: (SelectableType<T> | \"*\")[]): MysqlQueryBuilder<T>;\n  select(\n    ...columns: (SelectableType<T> | \"*\" | string)[]\n  ): MysqlQueryBuilder<T> {\n    this.modelSelectedColumns = columns.map((column) =>\n      convertCase(column as string, this.model.databaseCaseConvention),\n    ) as string[];\n    this.selectQuery = this.selectTemplate.selectColumns(\n      ...(columns as string[]),\n    );\n\n    return this;\n  }\n\n  distinct(): MysqlQueryBuilder<T> {\n    const distinct = this.selectTemplate.distinct;\n    this.selectQuery = this.selectQuery.replace(\n      /select/i,\n      `SELECT ${distinct}`,\n    );\n    return this;\n  }\n\n  distinctOn(...columns: string[]): MysqlQueryBuilder<T>;\n  distinctOn(...columns: SelectableType<T>[]): MysqlQueryBuilder<T>;\n  distinctOn(...columns: (string | SelectableType<T>)[]): MysqlQueryBuilder<T>;\n  distinctOn(...columns: (string | SelectableType<T>)[]): MysqlQueryBuilder<T> {\n    throw new Error(\"DISTINCT ON is only supported in postgres\");\n  }\n\n  joinRaw(query: string): this {\n    this.joinQuery += ` ${query} `;\n    return this;\n  }\n\n  join(\n    relationTable: string,\n    primaryColumn: string,\n    foreignColumn: string,\n  ): MysqlQueryBuilder<T> {\n    const join = joinTemplate(\n      this.model,\n      relationTable,\n      primaryColumn,\n      foreignColumn,\n    );\n    this.joinQuery += join.innerJoin();\n    return this;\n  }\n\n  leftJoin(\n    relationTable: string,\n    primaryColumn: string,\n    foreignColumn: string,\n  ): MysqlQueryBuilder<T> {\n    const join = joinTemplate(\n      this.model,\n      relationTable,\n      primaryColumn,\n      foreignColumn,\n    );\n    this.joinQuery += join.leftJoin();\n    return this;\n  }\n\n  with<O extends typeof Model>(\n    relation: RelationType<T>,\n    relatedModel?: O,\n    relatedModelQueryBuilder?: (\n      queryBuilder: ModelQueryBuilder<ModelInstanceType<O>>,\n    ) => void,\n    ignoreHooks?: { beforeFetch?: boolean; afterFetch?: boolean },\n  ): ModelQueryBuilder<T> {\n    if (!relatedModelQueryBuilder) {\n      this.relations.push({\n        relation: relation as string,\n      });\n\n      return this;\n    }\n\n    const queryBuilder = new MysqlQueryBuilder(\n      this.type,\n      relatedModel as typeof Model,\n      relatedModel?.table || \"\",\n      this.mysqlConnection,\n      this.logs,\n      false,\n      this.sqlDataSource,\n    );\n\n    relatedModelQueryBuilder(queryBuilder as ModelQueryBuilder<any>);\n    if (!ignoreHooks?.beforeFetch) {\n      relatedModel?.beforeFetch(queryBuilder);\n    }\n\n    this.relations.push({\n      relation: relation as string,\n      selectedColumns: queryBuilder.modelSelectedColumns,\n      whereQuery: this.whereTemplate.convertPlaceHolderToValue(\n        queryBuilder.whereQuery,\n      ),\n      params: queryBuilder.params,\n      joinQuery: queryBuilder.joinQuery,\n      groupByQuery: queryBuilder.groupByQuery,\n      orderByQuery: queryBuilder.orderByQuery,\n      limitQuery: queryBuilder.limitQuery,\n      offsetQuery: queryBuilder.offsetQuery,\n      havingQuery: queryBuilder.havingQuery,\n      dynamicColumns: queryBuilder.dynamicColumns,\n      ignoreAfterFetchHook: ignoreHooks?.afterFetch || false,\n    });\n\n    return this;\n  }\n\n  addDynamicColumns(\n    dynamicColumns: DynamicColumnType<T>[],\n  ): ModelQueryBuilder<T> {\n    this.dynamicColumns = dynamicColumns as string[];\n    return this;\n  }\n\n  groupBy(...columns: SelectableType<T>[]): this;\n  groupBy(...columns: string[]): this;\n  groupBy(...columns: (SelectableType<T> | string)[]): this {\n    this.groupByQuery = this.selectTemplate.groupBy(...(columns as string[]));\n    return this;\n  }\n\n  groupByRaw(query: string): this {\n    query.replace(\"GROUP BY\", \"\");\n    this.groupByQuery = ` GROUP BY ${query}`;\n    return this;\n  }\n\n  orderBy(column: SelectableType<T>, order: \"ASC\" | \"DESC\"): this;\n  orderBy(column: string, order: \"ASC\" | \"DESC\"): this;\n  orderBy(column: SelectableType<T> | string, order: \"ASC\" | \"DESC\"): this {\n    const casedColumn = convertCase(\n      column as string,\n      this.model.databaseCaseConvention,\n    );\n\n    if (this.orderByQuery) {\n      this.orderByQuery += `, ${casedColumn as string} ${order}`;\n      return this;\n    }\n\n    this.orderByQuery = ` ORDER BY ${casedColumn as string} ${order}`;\n    return this;\n  }\n\n  orderByRaw(query: string): this {\n    if (this.orderByQuery) {\n      this.orderByQuery += `, ${query}`;\n      return this;\n    }\n\n    this.orderByQuery = ` ORDER BY ${query}`;\n    return this;\n  }\n\n  limit(limit: number) {\n    this.limitQuery = this.selectTemplate.limit(limit);\n    return this;\n  }\n\n  offset(offset: number) {\n    this.offsetQuery = this.selectTemplate.offset(offset);\n    return this;\n  }\n\n  havingRaw(query: string): ModelQueryBuilder<T> {\n    query = query.replace(\"HAVING\", \"\");\n    if (this.havingQuery) {\n      this.havingQuery += ` AND ${query}`;\n      return this;\n    }\n\n    this.havingQuery = ` HAVING ${query}`;\n    return this;\n  }\n\n  copy(): ModelQueryBuilder<T> {\n    const queryBuilder = new MysqlQueryBuilder<T>(\n      this.type,\n      this.model as typeof Model,\n      this.table,\n      this.mysqlConnection,\n      this.logs,\n      this.isNestedCondition,\n      this.sqlDataSource,\n    );\n\n    queryBuilder.selectQuery = this.selectQuery;\n    queryBuilder.whereQuery = this.whereQuery;\n    queryBuilder.joinQuery = this.joinQuery;\n    queryBuilder.groupByQuery = this.groupByQuery;\n    queryBuilder.orderByQuery = this.orderByQuery;\n    queryBuilder.limitQuery = this.limitQuery;\n    queryBuilder.offsetQuery = this.offsetQuery;\n    queryBuilder.params = [...this.params];\n    queryBuilder.relations = [...this.relations];\n    return queryBuilder;\n  }\n}\n","import { log } from \"../../utils/logger\";\nimport { Model } from \"../models/model\";\nimport { ModelManager } from \"../models/model_manager/model_manager\";\nimport {\n  FindType,\n  UnrestrictedFindType,\n  FindOneType,\n  UnrestrictedFindOneType,\n} from \"../models/model_manager/model_manager_types\";\nimport SqlModelManagerUtils from \"../models/model_manager/model_manager_utils\";\nimport { parseDatabaseDataIntoModelResponse } from \"../serializer\";\nimport { SqlDataSource } from \"../sql_data_source\";\nimport { MysqlConnectionInstance } from \"../sql_data_source_types\";\nimport { MysqlQueryBuilder } from \"./mysql_query_builder\";\n\nexport class MysqlModelManager<T extends Model> extends ModelManager<T> {\n  protected type: \"mysql\" | \"mariadb\";\n  protected mysqlConnection: MysqlConnectionInstance;\n  protected sqlModelManagerUtils: SqlModelManagerUtils<T>;\n\n  /**\n   * Constructor for MysqlModelManager class.\n   *\n   * @param {typeof Model} model - Model constructor.\n   * @param {Connection} mysqlConnection - MySQL connection pool.\n   * @param {boolean} logs - Flag to enable or disable logging.\n   */\n  constructor(\n    type: \"mysql\" | \"mariadb\",\n    model: typeof Model,\n    mysqlConnection: MysqlConnectionInstance,\n    logs: boolean,\n    sqlDataSource: SqlDataSource,\n  ) {\n    super(model, logs, sqlDataSource);\n    this.type = type;\n    this.mysqlConnection = mysqlConnection;\n    this.sqlModelManagerUtils = new SqlModelManagerUtils<T>(\n      this.type,\n      mysqlConnection,\n    );\n  }\n\n  /**\n   * Find method to retrieve multiple records from the database based on the input conditions.\n   *\n   * @param {FindType} input - Optional query parameters for filtering, ordering, and pagination.\n   * @returns Promise resolving to an array of models.\n   */\n  async find(input?: FindType<T> | UnrestrictedFindType<T>): Promise<T[]> {\n    if (!input) {\n      return await this.query().many();\n    }\n\n    const query = this.query();\n    if (input.select) {\n      query.select(...(input.select as string[]));\n    }\n\n    if (input.relations) {\n      input.relations.forEach((relation) => {\n        query.with(relation);\n      });\n    }\n\n    if (input.where) {\n      Object.entries(input.where).forEach(([key, value]) => {\n        query.where(key, value);\n      });\n    }\n\n    if (input.orderBy) {\n      Object.entries(input.orderBy).forEach(([key, value]) => {\n        query.orderBy(key, value);\n      });\n    }\n\n    if (input.limit) {\n      query.limit(input.limit);\n    }\n\n    if (input.offset) {\n      query.offset(input.offset);\n    }\n\n    if (input.groupBy) {\n      query.groupBy(...(input.groupBy as string[]));\n    }\n\n    return await query.many({ ignoreHooks: input.ignoreHooks || [] });\n  }\n\n  /**\n   * Find a single record from the database based on the input conditions.\n   *\n   * @param {FindOneType} input - query parameters for filtering and selecting a single record.\n   * @returns Promise resolving to a single model or null if not found.\n   */\n  async findOne(\n    input: FindOneType<T> | UnrestrictedFindOneType<T>,\n  ): Promise<T | null> {\n    const results = await this.find({\n      ...input,\n      limit: 1,\n    });\n\n    if (!results.length) {\n      return null;\n    }\n\n    return results[0];\n  }\n\n  /**\n   * Find a single record by its PK from the database.\n   *\n   * @param {string | number | boolean} value - PK of the record to retrieve, hooks will not have any effect, since it's a direct query for the PK.\n   * @returns Promise resolving to a single model or null if not found.\n   */\n  async findOneByPrimaryKey(\n    value: string | number | boolean,\n  ): Promise<T | null> {\n    if (!this.model.primaryKey) {\n      throw new Error(\n        \"Model \" + this.model.table + \" has no primary key to be retrieved by\",\n      );\n    }\n\n    return await this.query()\n      .where(this.model.primaryKey as string, value)\n      .one();\n  }\n\n  /**\n   * Save a new model instance to the database.\n   *\n   * @param {Model} model - Model instance to be saved.\n   * @param {TransactionType} trx - TransactionType to be used on the save operation.\n   * @returns Promise resolving to the saved model or null if saving fails.\n   */\n  async insert(model: Partial<T>): Promise<T | null> {\n    this.model.beforeInsert(model as T);\n    const { query, params } = this.sqlModelManagerUtils.parseInsert(\n      model as T,\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n\n    log(query, this.logs, params);\n    const [result]: any = await this.mysqlConnection.query<any>(query, params);\n\n    // If pk it's not autogenerated but it's passed in creation process, the model it's retrieved by it's primary key\n    if (this.model.primaryKey && model[this.model.primaryKey as keyof T]) {\n      const pkValue = model[this.model.primaryKey as keyof T] as\n        | string\n        | number;\n      return await this.findOneByPrimaryKey(pkValue);\n    }\n\n    return await this.findOneByPrimaryKey(result[\"insertId\"]);\n  }\n\n  /**\n   * Create multiple model instances in the database.\n   *\n   * @param {Model} model - Model instance to be saved.\n   * @param {TransactionType} trx - TransactionType to be used on the save operation.\n   * @returns Promise resolving to an array of saved models or null if saving fails.\n   */\n  async insertMany(models: Partial<T>[]): Promise<T[]> {\n    models.forEach((model) => {\n      this.model.beforeInsert(model as T);\n    });\n\n    const { query, params } = this.sqlModelManagerUtils.parseMassiveInsert(\n      models as T[],\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n\n    log(query, this.logs, params);\n    const [rows]: any = await this.mysqlConnection.query(query, params);\n\n    if (!rows.affectedRows) {\n      return [];\n    }\n\n    // If pk it's not autogenerated but it's passed in creation process, the model it's retrieved by it's primary key\n    if (this.model.primaryKey && models[0][this.model.primaryKey as keyof T]) {\n      const idsToFetchList = models.map(\n        (model) => model[this.model.primaryKey as keyof T],\n      ) as string[];\n\n      const primaryKeyList = idsToFetchList.map((key) => `'${key}'`).join(\",\");\n\n      return await this.query()\n        .whereIn(this.model.primaryKey as string, idsToFetchList)\n        .orderByRaw(`FIELD(${this.model.primaryKey}, ${primaryKeyList})`)\n        .many();\n    }\n\n    const idsToFetchList = Array.from(\n      { length: rows.affectedRows },\n      (_, i) => i + rows.insertId,\n    );\n\n    return await this.query()\n      .whereIn(this.model.primaryKey as string, idsToFetchList)\n      .many();\n  }\n\n  /**\n   * Update an existing model instance in the database.\n   * @param {Model} model - Model instance to be updated.\n   * @param {TransactionType} trx - TransactionType to be used on the update operation.\n   * @returns Promise resolving to the updated model or null if updating fails.\n   */\n  async updateRecord(model: T): Promise<T | null> {\n    if (!this.model.primaryKey) {\n      throw new Error(\n        \"Model \" +\n          this.model.table +\n          \" has no primary key to be updated, try save\",\n      );\n    }\n\n    const updateQuery = this.sqlModelManagerUtils.parseUpdate(\n      model,\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n    log(updateQuery.query, this.logs, updateQuery.params);\n    await this.mysqlConnection.query(updateQuery.query, updateQuery.params);\n    if (!this.model.primaryKey) {\n      log(\"Model has no primary key so no record can be retrieved\", this.logs);\n      return null;\n    }\n\n    return await this.findOneByPrimaryKey(\n      model[this.model.primaryKey as keyof T] as string | number,\n    );\n  }\n\n  /**\n   * @description Delete a record from the database from the given model.\n   *\n   * @param {Model} model - Model to delete.\n   * @param {TransactionType} trx - TransactionType to be used on the delete operation.\n   * @returns Promise resolving to the deleted model or null if deleting fails.\n   */\n  async deleteRecord(model: T): Promise<T | null> {\n    if (!this.model.primaryKey) {\n      throw new Error(\n        \"Model \" + this.model.table + \" has no primary key to be deleted from\",\n      );\n    }\n    const { query, params } = this.sqlModelManagerUtils.parseDelete(\n      this.model.table,\n      this.model.primaryKey,\n      model[this.model.primaryKey as keyof T] as string,\n    );\n\n    log(query, this.logs, params);\n    const [rows]: any = await this.mysqlConnection.query<any>(query, params);\n    if (this.sqlDataSource.getDbType() === \"mariadb\") {\n      return (await parseDatabaseDataIntoModelResponse(\n        [rows[0] as T],\n        this.model,\n      )) as T;\n    }\n\n    return model;\n  }\n\n  /**\n   * Create and return a new instance of the Mysql_query_builder for building more complex SQL queries.\n   *\n   * @returns {Mysql_query_builder<Model>} - Instance of Mysql_query_builder.\n   */\n  query(): MysqlQueryBuilder<T> {\n    return new MysqlQueryBuilder<T>(\n      this.type,\n      this.model,\n      this.model.table,\n      this.mysqlConnection,\n      this.logs,\n      false,\n      this.sqlDataSource,\n    );\n  }\n}\n","import { getBaseModelInstance, Model } from \"../models/model\";\nimport {\n  OneOptions,\n  QueryBuilder,\n  ModelQueryBuilder,\n  ManyOptions,\n  ModelInstanceType,\n} from \"../query_builder/query_builder\";\nimport { log } from \"../../utils/logger\";\nimport joinTemplate from \"../resources/query/JOIN\";\nimport { PaginatedData, getPaginationMetadata } from \"../pagination\";\nimport { parseDatabaseDataIntoModelResponse } from \"../serializer\";\nimport {\n  DynamicColumnType,\n  RelationType,\n  SelectableType,\n} from \"../models/model_manager/model_manager_types\";\nimport \"reflect-metadata\";\nimport { SqlDataSource } from \"../../../src/sql/sql_data_source\";\nimport { convertCase } from \"../../utils/case_utils\";\nimport SqlModelManagerUtils from \"../models/model_manager/model_manager_utils\";\nimport {\n  DeleteOptions,\n  SoftDeleteOptions,\n} from \"../query_builder/delete_query_builder_type\";\nimport deleteTemplate from \"../resources/query/DELETE\";\nimport updateTemplate from \"../resources/query/UPDATE\";\nimport { UpdateOptions } from \"../query_builder/update_query_builder_types\";\nimport { PgClientInstance } from \"../sql_data_source_types\";\n\nexport class PostgresQueryBuilder<T extends Model> extends QueryBuilder<T> {\n  protected pgClient: PgClientInstance;\n  protected postgresModelManagerUtils: SqlModelManagerUtils<T>;\n  protected updateTemplate: ReturnType<typeof updateTemplate>;\n  protected deleteTemplate: ReturnType<typeof deleteTemplate>;\n\n  constructor(\n    model: typeof Model,\n    table: string,\n    pgClient: PgClientInstance,\n    logs: boolean,\n    isNestedCondition = false,\n    sqlDataSource: SqlDataSource,\n  ) {\n    super(model, table, logs, sqlDataSource);\n    this.pgClient = pgClient;\n    this.isNestedCondition = isNestedCondition;\n    this.updateTemplate = updateTemplate(sqlDataSource.getDbType(), this.model);\n    this.deleteTemplate = deleteTemplate(table, sqlDataSource.getDbType());\n    this.postgresModelManagerUtils = new SqlModelManagerUtils<T>(\n      \"postgres\",\n      this.pgClient,\n    );\n  }\n\n  // SELECT\n  select(...columns: string[]): PostgresQueryBuilder<T>;\n  select(...columns: (SelectableType<T> | \"*\")[]): PostgresQueryBuilder<T>;\n  select(\n    ...columns: (SelectableType<T> | \"*\" | string)[]\n  ): PostgresQueryBuilder<T> {\n    this.selectQuery = this.selectTemplate.selectColumns(\n      ...(columns as string[]),\n    );\n    this.modelSelectedColumns = columns.map((column) =>\n      convertCase(column as string, this.model.databaseCaseConvention),\n    ) as string[];\n    return this;\n  }\n\n  distinct(): PostgresQueryBuilder<T> {\n    const distinct = this.selectTemplate.distinct;\n    this.selectQuery = this.selectQuery.replace(\n      /select/i,\n      `SELECT ${distinct}`,\n    );\n    return this;\n  }\n\n  distinctOn(...columns: string[]): PostgresQueryBuilder<T>;\n  distinctOn(...columns: SelectableType<T>[]): PostgresQueryBuilder<T>;\n  distinctOn(\n    ...columns: (string | SelectableType<T>)[]\n  ): PostgresQueryBuilder<T> {\n    const distinctOn = this.selectTemplate.distinctOn(...(columns as string[]));\n\n    this.selectQuery = this.selectQuery.replace(\n      /select/i,\n      `SELECT ${distinctOn}`,\n    );\n    return this;\n  }\n\n  async one(options: OneOptions = {}): Promise<T | null> {\n    // hook query builder\n    if (!options.ignoreHooks?.includes(\"beforeFetch\")) {\n      this.model.beforeFetch(this);\n    }\n\n    this.limitQuery = this.selectTemplate.limit(1);\n    let query: string = \"\";\n    if (this.joinQuery && !this.selectQuery) {\n      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);\n    }\n    query = this.selectQuery + this.joinQuery;\n\n    if (this.whereQuery) {\n      query += this.whereQuery;\n    }\n\n    query = this.whereTemplate.convertPlaceHolderToValue(query);\n\n    // limit to 1\n    this.limit(1);\n    query += this.groupFooterQuery();\n\n    query = query.trim();\n    log(query, this.logs, this.params);\n    const result = await this.pgClient.query(query, this.params);\n    if (!result.rows[0]) {\n      return null;\n    }\n\n    const modelInstance = getBaseModelInstance<T>();\n    await this.mergeRawPacketIntoModel(\n      modelInstance,\n      result.rows[0],\n      this.model,\n    );\n\n    const relationModels =\n      await this.postgresModelManagerUtils.parseQueryBuilderRelations(\n        [modelInstance],\n        this.model,\n        this.relations,\n        \"postgres\",\n        this.logs,\n      );\n\n    const model = (await parseDatabaseDataIntoModelResponse(\n      [modelInstance],\n      this.model,\n      relationModels,\n      this.modelSelectedColumns,\n    )) as T;\n\n    return !options.ignoreHooks?.includes(\"afterFetch\")\n      ? ((await this.model.afterFetch([model]))[0] as T)\n      : model;\n  }\n\n  async oneOrFail(options?: OneOptions & { customError: Error }): Promise<T> {\n    const model = await this.one({\n      ignoreHooks: options?.ignoreHooks,\n    });\n\n    if (!model) {\n      if (options?.customError) {\n        throw options.customError;\n      }\n\n      throw new Error(\"ROW_NOT_FOUND\");\n    }\n\n    return model as T;\n  }\n\n  async many(options: ManyOptions = {}): Promise<T[]> {\n    // hook query builder\n    if (!options.ignoreHooks?.includes(\"beforeFetch\")) {\n      this.model.beforeFetch(this);\n    }\n\n    let query: string = \"\";\n    if (this.joinQuery && !this.selectQuery) {\n      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);\n    }\n    query = this.selectQuery + this.joinQuery;\n\n    if (this.whereQuery) {\n      query += this.whereQuery;\n    }\n\n    query += this.groupFooterQuery();\n    query = this.whereTemplate.convertPlaceHolderToValue(query);\n    query = query.trim();\n\n    log(query, this.logs, this.params);\n    const result = await this.pgClient.query(query, this.params);\n    const rows = result.rows;\n\n    const modelPromises = rows.map(async (row) => {\n      const modelInstance = getBaseModelInstance<T>();\n      await this.mergeRawPacketIntoModel(modelInstance, row, this.model);\n\n      return modelInstance as T;\n    });\n\n    const models = await Promise.all(modelPromises);\n    const relationModels =\n      await this.postgresModelManagerUtils.parseQueryBuilderRelations(\n        models,\n        this.model,\n        this.relations,\n        \"postgres\",\n        this.logs,\n      );\n\n    const serializedModels = await parseDatabaseDataIntoModelResponse(\n      models,\n      this.model,\n      relationModels,\n      this.modelSelectedColumns,\n    );\n    if (!serializedModels) {\n      return [];\n    }\n\n    if (!options.ignoreHooks?.includes(\"afterFetch\")) {\n      await this.model.afterFetch(\n        Array.isArray(serializedModels) ? serializedModels : [serializedModels],\n      );\n    }\n\n    return (\n      Array.isArray(serializedModels) ? serializedModels : [serializedModels]\n    ) as T[];\n  }\n\n  async update(data: Partial<T>, options?: UpdateOptions): Promise<number> {\n    const { ignoreBeforeUpdateHook } = options || {};\n    if (!ignoreBeforeUpdateHook) {\n      this.model.beforeUpdate(this);\n    }\n\n    const columns = Object.keys(data);\n    const values = Object.values(data);\n    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(\n      this.whereQuery,\n      values.length + 1,\n    );\n    const { query, params } = this.updateTemplate.massiveUpdate(\n      columns,\n      values,\n      this.whereQuery,\n      this.joinQuery,\n    );\n\n    params.push(...this.params);\n\n    log(query, this.logs, params);\n    const result = await this.pgClient.query<T>(query, params);\n    if (!result.rows) {\n      return 0;\n    }\n\n    return result.rowCount || 0;\n  }\n\n  async delete(options: DeleteOptions = {}): Promise<number> {\n    const { ignoreBeforeDeleteHook } = options || {};\n    if (!ignoreBeforeDeleteHook) {\n      this.model.beforeDelete(this);\n    }\n\n    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(\n      this.whereQuery,\n    );\n    const query = this.deleteTemplate.massiveDelete(\n      this.whereQuery,\n      this.joinQuery,\n    );\n\n    log(query, this.logs, this.params);\n    const result = await this.pgClient.query<T>(query, this.params);\n    if (!result.rows) {\n      return 0;\n    }\n\n    return result.rowCount || 0;\n  }\n\n  async softDelete(options?: SoftDeleteOptions<T>): Promise<number> {\n    const {\n      column = \"deletedAt\",\n      value = new Date().toISOString().slice(0, 19).replace(\"T\", \" \"),\n      ignoreBeforeDeleteHook = false,\n    } = options || {};\n    if (!ignoreBeforeDeleteHook) {\n      this.model.beforeDelete(this);\n    }\n\n    let { query, params } = this.updateTemplate.massiveUpdate(\n      [column as string],\n      [value],\n      this.whereQuery,\n      this.joinQuery,\n    );\n\n    params = [...params, ...this.params];\n\n    log(query, this.logs, params);\n    const result = await this.pgClient.query<T>(query, params);\n    if (!result.rows) {\n      return 0;\n    }\n\n    return result.rowCount || 0;\n  }\n\n  whereBuilder(cb: (queryBuilder: PostgresQueryBuilder<T>) => void): this {\n    const queryBuilder = new PostgresQueryBuilder(\n      this.model as typeof Model,\n      this.table,\n      this.pgClient,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(queryBuilder as unknown as PostgresQueryBuilder<T>);\n\n    let whereCondition = queryBuilder.whereQuery.trim();\n    if (whereCondition.startsWith(\"AND\")) {\n      whereCondition = whereCondition.substring(4); // 'AND '.length === 4 has to be removed from the beginning of the where condition\n    } else if (whereCondition.startsWith(\"OR\")) {\n      whereCondition = whereCondition.substring(3); // 'OR '.length === 3 has to be removed from the beginning of the where condition\n    }\n\n    whereCondition = \"(\" + whereCondition + \")\";\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? whereCondition\n        : `WHERE ${whereCondition}`;\n    } else {\n      this.whereQuery += ` AND ${whereCondition}`;\n    }\n\n    this.params.push(...queryBuilder.params);\n    return this;\n  }\n\n  orWhereBuilder(cb: (queryBuilder: PostgresQueryBuilder<T>) => void): this {\n    const nestedBuilder = new PostgresQueryBuilder(\n      this.model as typeof Model,\n      this.table,\n      this.pgClient,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(nestedBuilder as unknown as PostgresQueryBuilder<T>);\n\n    let nestedCondition = nestedBuilder.whereQuery.trim();\n    if (nestedCondition.startsWith(\"AND\")) {\n      nestedCondition = nestedCondition.substring(4);\n    } else if (nestedCondition.startsWith(\"OR\")) {\n      nestedCondition = nestedCondition.substring(3);\n    }\n\n    nestedCondition = `(${nestedCondition})`;\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? nestedCondition\n        : `WHERE ${nestedCondition}`;\n\n      this.params.push(...nestedBuilder.params);\n      return this;\n    }\n\n    this.whereQuery += ` OR ${nestedCondition}`;\n    this.params.push(...nestedBuilder.params);\n\n    return this;\n  }\n\n  andWhereBuilder(cb: (queryBuilder: PostgresQueryBuilder<T>) => void): this {\n    const nestedBuilder = new PostgresQueryBuilder(\n      this.model as typeof Model,\n      this.table,\n      this.pgClient,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(nestedBuilder as unknown as PostgresQueryBuilder<T>);\n\n    let nestedCondition = nestedBuilder.whereQuery.trim();\n    if (nestedCondition.startsWith(\"AND\")) {\n      nestedCondition = nestedCondition.substring(4);\n    } else if (nestedCondition.startsWith(\"OR\")) {\n      nestedCondition = nestedCondition.substring(3);\n    }\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? nestedCondition\n        : `WHERE ${nestedCondition}`;\n\n      this.params.push(...nestedBuilder.params);\n      return this;\n    }\n\n    this.whereQuery += ` AND ${nestedCondition}`;\n    this.params.push(...nestedBuilder.params);\n\n    return this;\n  }\n\n  async getCount(\n    options: { ignoreHooks: boolean } = { ignoreHooks: false },\n  ): Promise<number> {\n    if (options.ignoreHooks) {\n      const { rows } = await this.pgClient.query(\n        `SELECT COUNT(*) as total from ${this.table}`,\n      );\n      return +rows[0].total;\n    }\n    this.select(\"COUNT(*) as total\");\n    const result = await this.one();\n    return result ? +result.$additionalColumns[\"total\"] : 0;\n  }\n\n  async getSum(column: SelectableType<T>): Promise<number>;\n  async getSum(column: string): Promise<number>;\n  async getSum(\n    column: SelectableType<T> | string,\n    options: { ignoreHooks: boolean } = { ignoreHooks: false },\n  ): Promise<number> {\n    if (options.ignoreHooks) {\n      const { rows } = await this.pgClient.query(\n        `SELECT SUM(${column as string}) as total from ${this.table}`,\n      );\n      return +rows[0].total || 0;\n    }\n\n    column = convertCase(column as string, this.model.databaseCaseConvention);\n    this.select(`SUM(${column as string}) as total`);\n    const result = await this.one();\n    return result ? +result.$additionalColumns[\"total\"] : 0;\n  }\n\n  async paginate(\n    page: number,\n    limit: number,\n    options?: ManyOptions,\n  ): Promise<PaginatedData<T>> {\n    this.limitQuery = this.selectTemplate.limit(limit);\n    this.offsetQuery = this.selectTemplate.offset((page - 1) * limit);\n\n    const originalSelectQuery = this.selectQuery;\n    this.select(\"COUNT(*) as total\");\n    const total = await this.many(options);\n    this.selectQuery = originalSelectQuery;\n\n    const models = await this.many(options);\n    const paginationMetadata = getPaginationMetadata(\n      page,\n      limit,\n      +total[0].$additionalColumns[\"total\"] as number,\n    );\n    let data =\n      (await parseDatabaseDataIntoModelResponse(models, this.model)) || [];\n    if (Array.isArray(data)) {\n      data = data.filter((model) => model !== null);\n    }\n    return {\n      paginationMetadata,\n      data: Array.isArray(data) ? data : [data],\n    } as PaginatedData<T>;\n  }\n\n  joinRaw(query: string): this {\n    this.joinQuery += ` ${query} `;\n    return this;\n  }\n\n  join(\n    relationTable: string,\n    primaryColumn: string,\n    foreignColumn: string,\n  ): PostgresQueryBuilder<T> {\n    const join = joinTemplate(\n      this.model,\n      relationTable,\n      primaryColumn as string,\n      foreignColumn as string,\n    );\n    this.joinQuery += join.innerJoin();\n    return this;\n  }\n\n  leftJoin(\n    relationTable: string,\n    primaryColumn: string,\n    foreignColumn: string,\n  ): PostgresQueryBuilder<T> {\n    const join = joinTemplate(\n      this.model,\n      relationTable,\n      primaryColumn as string,\n      foreignColumn as string,\n    );\n    this.joinQuery += join.leftJoin();\n    return this;\n  }\n  with<O extends typeof Model>(\n    relation: RelationType<T>,\n    relatedModel?: O,\n    relatedModelQueryBuilder?: (\n      queryBuilder: ModelQueryBuilder<ModelInstanceType<O>>,\n    ) => void,\n    ignoreHooks?: { beforeFetch?: boolean; afterFetch?: boolean },\n  ): ModelQueryBuilder<T> {\n    if (!relatedModelQueryBuilder) {\n      this.relations.push({\n        relation: relation as string,\n      });\n\n      return this;\n    }\n\n    const queryBuilder = new PostgresQueryBuilder(\n      relatedModel as typeof Model,\n      relatedModel?.table || \"\",\n      this.pgClient,\n      this.logs,\n      false,\n      this.sqlDataSource,\n    );\n\n    relatedModelQueryBuilder(queryBuilder as ModelQueryBuilder<any>);\n    if (!ignoreHooks?.beforeFetch) {\n      relatedModel?.beforeFetch(queryBuilder);\n    }\n\n    this.relations.push({\n      relation: relation as string,\n      selectedColumns: queryBuilder.modelSelectedColumns,\n      whereQuery: this.whereTemplate.convertPlaceHolderToValue(\n        queryBuilder.whereQuery,\n      ),\n      params: queryBuilder.params,\n      joinQuery: queryBuilder.joinQuery,\n      groupByQuery: queryBuilder.groupByQuery,\n      orderByQuery: queryBuilder.orderByQuery,\n      limitQuery: queryBuilder.limitQuery,\n      offsetQuery: queryBuilder.offsetQuery,\n      havingQuery: queryBuilder.havingQuery,\n      dynamicColumns: queryBuilder.dynamicColumns,\n      ignoreAfterFetchHook: ignoreHooks?.afterFetch || false,\n    });\n\n    return this;\n  }\n\n  addDynamicColumns(\n    dynamicColumns: DynamicColumnType<T>[],\n  ): ModelQueryBuilder<T> {\n    this.dynamicColumns = dynamicColumns as string[];\n    return this;\n  }\n\n  groupBy(...columns: SelectableType<T>[]): this;\n  groupBy(...columns: string[]): this;\n  groupBy(...columns: (SelectableType<T> | string)[]): this {\n    this.groupByQuery = this.selectTemplate.groupBy(...(columns as string[]));\n    return this;\n  }\n\n  groupByRaw(query: string): this {\n    query.replace(\"GROUP BY\", \"\");\n    this.groupByQuery = ` GROUP BY ${query}`;\n    return this;\n  }\n\n  orderBy(column: SelectableType<T>, order: \"ASC\" | \"DESC\"): this;\n  orderBy(column: string, order: \"ASC\" | \"DESC\"): this;\n  orderBy(column: SelectableType<T> | string, order: \"ASC\" | \"DESC\"): this {\n    const casedColumn = convertCase(\n      column as string,\n      this.model.databaseCaseConvention,\n    );\n\n    if (this.orderByQuery) {\n      this.orderByQuery += `, ${casedColumn as string} ${order}`;\n      return this;\n    }\n\n    this.orderByQuery = ` ORDER BY ${casedColumn as string} ${order}`;\n    return this;\n  }\n\n  orderByRaw(query: string): this {\n    if (this.orderByQuery) {\n      this.orderByQuery += `, ${query}`;\n      return this;\n    }\n\n    this.orderByQuery = ` ORDER BY ${query}`;\n    return this;\n  }\n\n  limit(limit: number) {\n    this.limitQuery = this.selectTemplate.limit(limit);\n    return this;\n  }\n\n  offset(offset: number) {\n    this.offsetQuery = this.selectTemplate.offset(offset);\n    return this;\n  }\n\n  havingRaw(query: string): ModelQueryBuilder<T> {\n    query = query.replace(\"HAVING\", \"\");\n    if (this.havingQuery) {\n      this.havingQuery += ` AND ${query}`;\n      return this;\n    }\n\n    this.havingQuery = ` HAVING ${query}`;\n    return this;\n  }\n\n  copy(): ModelQueryBuilder<T> {\n    const queryBuilder = new PostgresQueryBuilder<T>(\n      this.model as typeof Model,\n      this.table,\n      this.pgClient,\n      this.logs,\n      this.isNestedCondition,\n      this.sqlDataSource,\n    );\n    queryBuilder.selectQuery = this.selectQuery;\n    queryBuilder.whereQuery = this.whereQuery;\n    queryBuilder.groupByQuery = this.groupByQuery;\n    queryBuilder.orderByQuery = this.orderByQuery;\n    queryBuilder.limitQuery = this.limitQuery;\n    queryBuilder.offsetQuery = this.offsetQuery;\n    queryBuilder.params = [...this.params];\n    return queryBuilder;\n  }\n}\n","import { Model } from \"../models/model\";\nimport {\n  FindOneType,\n  FindType,\n  UnrestrictedFindOneType,\n  UnrestrictedFindType,\n} from \"../models/model_manager/model_manager_types\";\nimport { log } from \"../../utils/logger\";\nimport { ModelManager } from \"../models/model_manager/model_manager\";\nimport { PostgresQueryBuilder } from \"./postgres_query_builder\";\nimport { parseDatabaseDataIntoModelResponse } from \"../serializer\";\nimport { SqlDataSource } from \"../../../src/sql/sql_data_source\";\nimport SqlModelManagerUtils from \"../models/model_manager/model_manager_utils\";\nimport { PgClientInstance } from \"../sql_data_source_types\";\n\nexport class PostgresModelManager<T extends Model> extends ModelManager<T> {\n  protected pgConnection: PgClientInstance;\n  protected sqlModelManagerUtils: SqlModelManagerUtils<T>;\n\n  /**\n   * Constructor for Postgres_model_manager class.\n   *\n   * @param {typeof Model} model - Model constructor.\n   * @param {Pool} pgConnection - PostgreSQL connection pool.\n   * @param {boolean} logs - Flag to enable or disable logging.\n   */\n  constructor(\n    model: typeof Model,\n    pgConnection: PgClientInstance,\n    logs: boolean,\n    sqlDataSource: SqlDataSource,\n  ) {\n    super(model, logs, sqlDataSource);\n    this.pgConnection = pgConnection;\n    this.sqlModelManagerUtils = new SqlModelManagerUtils(\n      \"postgres\",\n      pgConnection,\n    );\n  }\n\n  /**\n   * Find method to retrieve multiple records from the database based on the input conditions.\n   *\n   * @param {FindType} input - Optional query parameters for filtering, ordering, and pagination.\n   * @returns Promise resolving to an array of models.\n   */\n  async find(input?: FindType<T> | UnrestrictedFindType<T>): Promise<T[]> {\n    if (!input) {\n      return await this.query().many();\n    }\n\n    const query = this.query();\n    if (input.select) {\n      query.select(...(input.select as string[]));\n    }\n\n    if (input.relations) {\n      input.relations.forEach((relation) => {\n        query.with(relation);\n      });\n    }\n    if (input.where) {\n      Object.entries(input.where).forEach(([key, value]) => {\n        query.where(key, value);\n      });\n    }\n\n    if (input.orderBy) {\n      Object.entries(input.orderBy).forEach(([key, value]) => {\n        query.orderBy(key, value);\n      });\n    }\n\n    if (input.limit) {\n      query.limit(input.limit);\n    }\n\n    if (input.offset) {\n      query.offset(input.offset);\n    }\n\n    if (input.groupBy) {\n      query.groupBy(...(input.groupBy as string[]));\n    }\n\n    return await query.many({ ignoreHooks: input.ignoreHooks || [] });\n  }\n\n  /**\n   * Find a single record from the database based on the input conditions.\n   *\n   * @param {FindOneType} input - query parameters for filtering and selecting a single record.\n   * @returns Promise resolving to a single model or null if not found.\n   */\n  async findOne(\n    input: FindOneType<T> | UnrestrictedFindOneType<T>,\n  ): Promise<T | null> {\n    const results = await this.find({\n      ...input,\n      limit: 1,\n    });\n\n    if (!results.length) {\n      return null;\n    }\n\n    return results[0];\n  }\n\n  /**\n   * Find a single record by its PK from the database.\n   *\n   * @param {string | number | boolean} value - PK value of the record to retrieve.\n   * @returns Promise resolving to a single model or null if not found.\n   */\n  async findOneByPrimaryKey(\n    value: string | number | boolean,\n  ): Promise<T | null> {\n    if (!this.model.primaryKey) {\n      throw new Error(\n        \"Model \" + this.model.table + \" has no primary key to be retrieved by\",\n      );\n    }\n\n    return await this.query()\n      .where(this.model.primaryKey as string, \"=\", value)\n      .one();\n  }\n\n  /**\n   * Save a new model instance to the database.\n   *\n   * @param {Model} model - Model instance to be saved.\n   * @param {MysqlTransaction} trx - MysqlTransaction to be used on the save operation.\n   * @returns Promise resolving to the saved model or null if saving fails.\n   */\n  async insert(model: Partial<T>): Promise<T | null> {\n    this.model.beforeInsert(model as T);\n    const { query, params } = this.sqlModelManagerUtils.parseInsert(\n      model as T,\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n    log(query, this.logs, params);\n    const { rows } = await this.pgConnection.query(query, params);\n    const insertedModel = rows[0] as T;\n    if (!insertedModel) {\n      throw new Error(rows[0]);\n    }\n\n    const result = (await parseDatabaseDataIntoModelResponse(\n      [insertedModel],\n      this.model,\n    )) as T;\n\n    this.model.afterFetch([result]);\n    return result;\n  }\n\n  /**\n   * Create multiple model instances in the database.\n   *\n   * @param {Model} models - Model instance to be saved.\n   * @param {Transaction} trx - MysqlTransaction to be used on the save operation.\n   * @returns Promise resolving to an array of saved models or null if saving fails.\n   */\n  async insertMany(models: Partial<T>[]): Promise<T[]> {\n    models.forEach((model) => this.model.beforeInsert(model as T));\n\n    const { query, params } = this.sqlModelManagerUtils.parseMassiveInsert(\n      models as T[],\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n\n    log(query, this.logs, params);\n    const { rows } = await this.pgConnection.query(query, params);\n    const insertedModel = rows as T[];\n    if (!insertedModel.length) {\n      return [];\n    }\n\n    const insertModelPromise = insertedModel.map(\n      async (model) =>\n        (await parseDatabaseDataIntoModelResponse([model], this.model)) as T,\n    );\n\n    const results = await Promise.all(insertModelPromise);\n    this.model.afterFetch(results);\n    return results;\n  }\n\n  /**\n   * Update an existing model instance in the database.\n   * @param {Model} model - Model instance to be updated.\n   * @param {Transaction} trx - Transaction to be used on the update operation.\n   * @returns Promise resolving to the updated model or null if updating fails.\n   */\n  async updateRecord(model: T): Promise<T | null> {\n    const { table, primaryKey } = this.model;\n    if (!primaryKey) {\n      throw new Error(\n        \"Model \" + table + \" has no primary key to be updated, try save\",\n      );\n    }\n\n    const { query, params } = this.sqlModelManagerUtils.parseUpdate(\n      model,\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n    log(query, this.logs, params);\n    await this.pgConnection.query(query, params);\n    if (!primaryKey) {\n      return null;\n    }\n\n    return await this.findOneByPrimaryKey(\n      model[primaryKey as keyof T] as string | number | boolean,\n    );\n  }\n\n  /**\n   * @description Delete a record from the database from the given model.\n   *\n   * @param {Model} model - Model to delete.\n   * @param {Transaction} trx - Transaction to be used on the delete operation.\n   * @returns Promise resolving to the deleted model or null if deleting fails.\n   */\n  async deleteRecord(model: T): Promise<T | null> {\n    if (!this.model.primaryKey) {\n      throw new Error(\n        \"Model \" + this.model.table + \" has no primary key to be deleted from\",\n      );\n    }\n\n    const { query, params } = this.sqlModelManagerUtils.parseDelete(\n      this.model.table,\n      this.model.primaryKey,\n      model[this.model.primaryKey as keyof T] as string,\n    );\n\n    log(query, this.logs, params);\n    await this.pgConnection.query(query, params);\n    return model;\n  }\n\n  /**\n   * Create and return a new instance of the Mysql_query_builder for building more complex SQL queries.\n   *\n   * @returns {MysqlQueryBuilder<Model>} - Instance of Mysql_query_builder.\n   */\n  query(): PostgresQueryBuilder<T> {\n    return new PostgresQueryBuilder<T>(\n      this.model,\n      this.model.table,\n      this.pgConnection,\n      this.logs,\n      false,\n      this.sqlDataSource,\n    );\n  }\n}\n","import { getBaseModelInstance, Model } from \"../models/model\";\nimport { log } from \"../../utils/logger\";\nimport {\n  OneOptions,\n  QueryBuilder,\n  ModelQueryBuilder,\n  ManyOptions,\n  ModelInstanceType,\n} from \"../query_builder/query_builder\";\nimport joinTemplate from \"../resources/query/JOIN\";\nimport { getPaginationMetadata, PaginatedData } from \"../pagination\";\nimport { parseDatabaseDataIntoModelResponse } from \"../serializer\";\nimport {\n  DynamicColumnType,\n  RelationType,\n  SelectableType,\n} from \"../models/model_manager/model_manager_types\";\nimport { SqlDataSource } from \"../../../src/sql/sql_data_source\";\nimport { convertCase } from \"../../utils/case_utils\";\nimport SqlModelManagerUtils from \"../models/model_manager/model_manager_utils\";\nimport {\n  DeleteOptions,\n  SoftDeleteOptions,\n} from \"../query_builder/delete_query_builder_type\";\nimport deleteTemplate from \"../resources/query/DELETE\";\nimport updateTemplate from \"../resources/query/UPDATE\";\nimport { UpdateOptions } from \"../query_builder/update_query_builder_types\";\nimport { SqliteConnectionInstance } from \"../sql_data_source_types\";\n\nexport class SqlLiteQueryBuilder<T extends Model> extends QueryBuilder<T> {\n  protected sqLiteConnection: SqliteConnectionInstance;\n  protected sqliteModelManagerUtils: SqlModelManagerUtils<T>;\n  protected updateTemplate: ReturnType<typeof updateTemplate>;\n  protected deleteTemplate: ReturnType<typeof deleteTemplate>;\n\n  constructor(\n    model: typeof Model,\n    table: string,\n    sqLiteConnection: SqliteConnectionInstance,\n    logs: boolean,\n    isNestedCondition = false,\n    sqlDataSource: SqlDataSource,\n  ) {\n    super(model, table, logs, sqlDataSource);\n    this.sqLiteConnection = sqLiteConnection;\n    this.isNestedCondition = isNestedCondition;\n    this.updateTemplate = updateTemplate(sqlDataSource.getDbType(), this.model);\n    this.deleteTemplate = deleteTemplate(table, sqlDataSource.getDbType());\n    this.sqliteModelManagerUtils = new SqlModelManagerUtils<T>(\n      \"sqlite\",\n      this.sqLiteConnection,\n    );\n  }\n\n  async one(options: OneOptions = {}): Promise<T | null> {\n    // hook query builder\n    if (!options.ignoreHooks?.includes(\"beforeFetch\")) {\n      this.model.beforeFetch(this);\n    }\n\n    let query: string = \"\";\n    if (this.joinQuery && !this.selectQuery) {\n      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);\n    }\n    query = this.selectQuery + this.joinQuery;\n\n    if (this.whereQuery) {\n      query += this.whereQuery;\n    }\n\n    query = this.whereTemplate.convertPlaceHolderToValue(query);\n\n    // limit to 1\n    this.limit(1);\n    query += this.groupFooterQuery();\n\n    query = query.trim();\n    log(query, this.logs, this.params);\n    const results = await this.promisifyQuery<T>(query, this.params);\n    if (!results.length) {\n      return null;\n    }\n\n    const result = results[0];\n\n    const modelInstance = getBaseModelInstance<T>();\n    await this.mergeRawPacketIntoModel(modelInstance, result, this.model);\n    const relationModels =\n      await this.sqliteModelManagerUtils.parseQueryBuilderRelations(\n        [modelInstance],\n        this.model,\n        this.relations,\n        \"sqlite\",\n        this.logs,\n      );\n\n    const model = (await parseDatabaseDataIntoModelResponse(\n      [modelInstance],\n      this.model,\n      relationModels,\n      this.modelSelectedColumns,\n    )) as T;\n\n    return !options.ignoreHooks?.includes(\"afterFetch\")\n      ? ((await this.model.afterFetch([model]))[0] as T)\n      : model;\n  }\n\n  async oneOrFail(options?: OneOptions & { customError: Error }): Promise<T> {\n    const model = await this.one({\n      ignoreHooks: options?.ignoreHooks,\n    });\n\n    if (!model) {\n      if (options?.customError) {\n        throw options.customError;\n      }\n\n      throw new Error(\"ROW_NOT_FOUND\");\n    }\n\n    return model as T;\n  }\n\n  async many(options: ManyOptions = {}): Promise<T[]> {\n    // hook query builder\n    if (!options.ignoreHooks?.includes(\"beforeFetch\")) {\n      this.model.beforeFetch(this);\n    }\n\n    let query: string = \"\";\n    if (this.joinQuery && !this.selectQuery) {\n      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);\n    }\n    query = this.selectQuery + this.joinQuery;\n\n    if (this.whereQuery) {\n      query += this.whereQuery;\n    }\n\n    query += this.groupFooterQuery();\n    query = this.whereTemplate.convertPlaceHolderToValue(query);\n    query = query.trim();\n\n    log(query, this.logs, this.params);\n    const results = await this.promisifyQuery<T[]>(query, this.params);\n    const modelPromises = results.map(async (result) => {\n      const modelInstance = getBaseModelInstance<T>();\n      await this.mergeRawPacketIntoModel(modelInstance, result, this.model);\n\n      return modelInstance as T;\n    });\n\n    const models = await Promise.all(modelPromises);\n    const relationModels =\n      await this.sqliteModelManagerUtils.parseQueryBuilderRelations(\n        models,\n        this.model,\n        this.relations,\n        \"sqlite\",\n        this.logs,\n      );\n\n    const serializedModels = await parseDatabaseDataIntoModelResponse(\n      models,\n      this.model,\n      relationModels,\n      this.modelSelectedColumns,\n    );\n    if (!serializedModels) {\n      return [];\n    }\n\n    if (!options.ignoreHooks?.includes(\"afterFetch\")) {\n      await this.model.afterFetch(\n        Array.isArray(serializedModels) ? serializedModels : [serializedModels],\n      );\n    }\n\n    return (\n      Array.isArray(serializedModels) ? serializedModels : [serializedModels]\n    ) as T[];\n  }\n\n  async update(data: Partial<T>, options?: UpdateOptions): Promise<number> {\n    const { ignoreBeforeUpdateHook } = options || {};\n    if (!ignoreBeforeUpdateHook) {\n      this.model.beforeUpdate(this);\n    }\n\n    const columns = Object.keys(data);\n    const values = Object.values(data);\n    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(\n      this.whereQuery,\n      values.length + 1,\n    );\n    const { query, params } = this.updateTemplate.massiveUpdate(\n      columns,\n      values,\n      this.whereQuery,\n      this.joinQuery,\n    );\n\n    params.push(...this.params);\n\n    log(query, this.logs, params);\n    return await new Promise((resolve, reject) => {\n      this.sqLiteConnection.run(query, params, function (this: any, err) {\n        if (err) {\n          reject(new Error(err.message));\n        } else {\n          resolve(this.changes);\n        }\n      });\n    });\n  }\n\n  async delete(options: DeleteOptions = {}): Promise<number> {\n    const { ignoreBeforeDeleteHook } = options || {};\n    if (!ignoreBeforeDeleteHook) {\n      this.model.beforeDelete(this);\n    }\n\n    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(\n      this.whereQuery,\n    );\n    const query = this.deleteTemplate.massiveDelete(\n      this.whereQuery,\n      this.joinQuery,\n    );\n\n    log(query, this.logs, this.params);\n    return new Promise((resolve, reject) => {\n      this.sqLiteConnection.run(query, this.params, function (this: any, err) {\n        if (err) {\n          reject(new Error(err.message));\n        } else {\n          resolve(this.changes);\n        }\n      });\n    });\n  }\n\n  async softDelete(options?: SoftDeleteOptions<T>): Promise<number> {\n    const {\n      column = \"deletedAt\",\n      value = new Date().toISOString().slice(0, 19).replace(\"T\", \" \"), // TODO: check if this is the correct format\n      ignoreBeforeDeleteHook = false,\n    } = options || {};\n    if (!ignoreBeforeDeleteHook) {\n      this.model.beforeDelete(this);\n    }\n\n    let { query, params } = this.updateTemplate.massiveUpdate(\n      [column as string],\n      [value],\n      this.whereQuery,\n      this.joinQuery,\n    );\n\n    params = [...params, ...this.params];\n\n    log(query, this.logs, params);\n    return new Promise((resolve, reject) => {\n      this.sqLiteConnection.run(query, params, function (this: any, err) {\n        if (err) {\n          reject(new Error(err.message));\n        } else {\n          resolve(this.changes);\n        }\n      });\n    });\n  }\n\n  whereBuilder(cb: (queryBuilder: SqlLiteQueryBuilder<T>) => void): this {\n    const queryBuilder = new SqlLiteQueryBuilder(\n      this.model as typeof Model,\n      this.table,\n      this.sqLiteConnection,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(queryBuilder as unknown as SqlLiteQueryBuilder<T>);\n\n    let whereCondition = queryBuilder.whereQuery.trim();\n    if (whereCondition.startsWith(\"AND\")) {\n      whereCondition = whereCondition.substring(4); // 'AND '.length === 4 has to be removed from the beginning of the where condition\n    } else if (whereCondition.startsWith(\"OR\")) {\n      whereCondition = whereCondition.substring(3); // 'OR '.length === 3 has to be removed from the beginning of the where condition\n    }\n\n    whereCondition = \"(\" + whereCondition + \")\";\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? whereCondition\n        : `WHERE ${whereCondition}`;\n    } else {\n      this.whereQuery += ` AND ${whereCondition}`;\n    }\n\n    this.params.push(...queryBuilder.params);\n    return this;\n  }\n\n  orWhereBuilder(cb: (queryBuilder: SqlLiteQueryBuilder<T>) => void): this {\n    const nestedBuilder = new SqlLiteQueryBuilder(\n      this.model as typeof Model,\n      this.table,\n      this.sqLiteConnection,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(nestedBuilder as unknown as SqlLiteQueryBuilder<T>);\n\n    let nestedCondition = nestedBuilder.whereQuery.trim();\n    if (nestedCondition.startsWith(\"AND\")) {\n      nestedCondition = nestedCondition.substring(4);\n    } else if (nestedCondition.startsWith(\"OR\")) {\n      nestedCondition = nestedCondition.substring(3);\n    }\n\n    nestedCondition = `(${nestedCondition})`;\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? nestedCondition\n        : `WHERE ${nestedCondition}`;\n\n      this.params.push(...nestedBuilder.params);\n      return this;\n    }\n\n    this.whereQuery += ` OR ${nestedCondition}`;\n    this.params.push(...nestedBuilder.params);\n\n    return this;\n  }\n\n  andWhereBuilder(cb: (queryBuilder: SqlLiteQueryBuilder<T>) => void): this {\n    const nestedBuilder = new SqlLiteQueryBuilder(\n      this.model as typeof Model,\n      this.table,\n      this.sqLiteConnection,\n      this.logs,\n      true,\n      this.sqlDataSource,\n    );\n    cb(nestedBuilder as unknown as SqlLiteQueryBuilder<T>);\n\n    let nestedCondition = nestedBuilder.whereQuery.trim();\n    if (nestedCondition.startsWith(\"AND\")) {\n      nestedCondition = nestedCondition.substring(4);\n    } else if (nestedCondition.startsWith(\"OR\")) {\n      nestedCondition = nestedCondition.substring(3);\n    }\n\n    if (!this.whereQuery) {\n      this.whereQuery = this.isNestedCondition\n        ? nestedCondition\n        : `WHERE ${nestedCondition}`;\n\n      this.params.push(...nestedBuilder.params);\n      return this;\n    }\n\n    this.whereQuery += ` AND ${nestedCondition}`;\n    this.params.push(...nestedBuilder.params);\n\n    return this;\n  }\n\n  async raw<T>(query: string, params: any[] = []) {\n    return await this.promisifyQuery<T>(query, params);\n  }\n\n  async getCount(\n    options: { ignoreHooks: boolean } = { ignoreHooks: false },\n  ): Promise<number> {\n    if (options.ignoreHooks) {\n      const result = (await this.promisifyQuery<T>(\n        \"SELECT COUNT(*) as total FROM \" + this.table,\n        [],\n      )) as any;\n      return +result[0].total;\n    }\n\n    this.select(\"COUNT(*) as total\");\n    const result = await this.one();\n    return result ? +result.$additionalColumns.total : 0;\n  }\n\n  async getSum(column: SelectableType<T>): Promise<number>;\n  async getSum(column: string): Promise<number>;\n  async getSum(\n    column: SelectableType<T> | string,\n    options: { ignoreHooks: boolean } = { ignoreHooks: false },\n  ): Promise<number> {\n    if (!options.ignoreHooks) {\n      const result = (await this.promisifyQuery(\n        `SELECT SUM(\"${column as string}) as total FROM ` + this.table,\n        [],\n      )) as any;\n      return +result[0].total || 0;\n    }\n\n    column = convertCase(column as string, this.model.databaseCaseConvention);\n    this.select(`SUM(${column as string}) as total`);\n    const result = await this.one();\n    return result ? +result.$additionalColumns.total : 0;\n  }\n\n  async paginate(\n    page: number,\n    limit: number,\n    options?: ManyOptions,\n  ): Promise<PaginatedData<T>> {\n    this.limitQuery = this.selectTemplate.limit(limit);\n    this.offsetQuery = this.selectTemplate.offset((page - 1) * limit);\n\n    const originalSelectQuery = this.selectQuery;\n    this.select(\"COUNT(*) as total\");\n    const total = await this.many(options);\n\n    this.selectQuery = originalSelectQuery;\n    const models = await this.many(options);\n\n    const paginationMetadata = getPaginationMetadata(\n      page,\n      limit,\n      +total[0].$additionalColumns[\"total\"] as number,\n    );\n    let data =\n      (await parseDatabaseDataIntoModelResponse(models, this.model)) || [];\n    if (Array.isArray(data)) {\n      data = data.filter((model) => model !== null);\n    }\n\n    return {\n      paginationMetadata,\n      data: Array.isArray(data) ? data : [data],\n    } as PaginatedData<T>;\n  }\n\n  // SELECT\n  select(...columns: string[]): SqlLiteQueryBuilder<T>;\n  select(...columns: (SelectableType<T> | \"*\")[]): SqlLiteQueryBuilder<T>;\n  select(\n    ...columns: (SelectableType<T> | \"*\" | string)[]\n  ): SqlLiteQueryBuilder<T> {\n    this.selectQuery = this.selectTemplate.selectColumns(\n      ...(columns as string[]),\n    );\n    this.modelSelectedColumns = columns.map((column) =>\n      convertCase(column as string, this.model.databaseCaseConvention),\n    ) as string[];\n    return this;\n  }\n\n  distinct(): SqlLiteQueryBuilder<T> {\n    const distinct = this.selectTemplate.distinct;\n    this.selectQuery = this.selectQuery.replace(\n      /select/i,\n      `SELECT ${distinct}`,\n    );\n    return this;\n  }\n\n  distinctOn(...columns: string[]): SqlLiteQueryBuilder<T>;\n  distinctOn(...columns: SelectableType<T>[]): SqlLiteQueryBuilder<T>;\n  distinctOn(\n    ...columns: (string | SelectableType<T>)[]\n  ): SqlLiteQueryBuilder<T>;\n  distinctOn(\n    ...columns: (string | SelectableType<T>)[]\n  ): SqlLiteQueryBuilder<T> {\n    throw new Error(\"DISTINCT ON is only supported in postgres\");\n  }\n\n  joinRaw(query: string): this {\n    this.joinQuery += ` ${query} `;\n    return this;\n  }\n\n  join(\n    relationTable: string,\n    primaryColumn: string,\n    foreignColumn: string,\n  ): SqlLiteQueryBuilder<T> {\n    const join = joinTemplate(\n      this.model,\n      relationTable,\n      primaryColumn,\n      foreignColumn,\n    );\n    this.joinQuery += join.innerJoin();\n    return this;\n  }\n\n  leftJoin(\n    relationTable: string,\n    primaryColumn: string,\n    foreignColumn: string,\n  ): SqlLiteQueryBuilder<T> {\n    const join = joinTemplate(\n      this.model,\n      relationTable,\n      primaryColumn,\n      foreignColumn,\n    );\n    this.joinQuery += join.leftJoin();\n    return this;\n  }\n\n  with<O extends typeof Model>(\n    relation: RelationType<T>,\n    relatedModel?: O,\n    relatedModelQueryBuilder?: (\n      queryBuilder: ModelQueryBuilder<ModelInstanceType<O>>,\n    ) => void,\n    ignoreHooks?: { beforeFetch?: boolean; afterFetch?: boolean },\n  ): ModelQueryBuilder<T> {\n    if (!relatedModelQueryBuilder) {\n      this.relations.push({\n        relation: relation as string,\n      });\n\n      return this;\n    }\n\n    const queryBuilder = new SqlLiteQueryBuilder(\n      relatedModel as typeof Model,\n      relatedModel?.table || \"\",\n      this.sqLiteConnection,\n      this.logs,\n      false,\n      this.sqlDataSource,\n    );\n\n    relatedModelQueryBuilder(queryBuilder as ModelQueryBuilder<any>);\n    if (!ignoreHooks?.beforeFetch) {\n      relatedModel?.beforeFetch(queryBuilder);\n    }\n\n    this.relations.push({\n      relation: relation as string,\n      selectedColumns: queryBuilder.modelSelectedColumns,\n      whereQuery: this.whereTemplate.convertPlaceHolderToValue(\n        queryBuilder.whereQuery,\n      ),\n      params: queryBuilder.params,\n      joinQuery: queryBuilder.joinQuery,\n      groupByQuery: queryBuilder.groupByQuery,\n      orderByQuery: queryBuilder.orderByQuery,\n      limitQuery: queryBuilder.limitQuery,\n      offsetQuery: queryBuilder.offsetQuery,\n      havingQuery: queryBuilder.havingQuery,\n      dynamicColumns: queryBuilder.dynamicColumns,\n      ignoreAfterFetchHook: ignoreHooks?.afterFetch || false,\n    });\n\n    return this;\n  }\n\n  addDynamicColumns(\n    dynamicColumns: DynamicColumnType<T>[],\n  ): ModelQueryBuilder<T> {\n    this.dynamicColumns = dynamicColumns as string[];\n    return this;\n  }\n\n  groupBy(...columns: SelectableType<T>[]): this;\n  groupBy(...columns: string[]): this;\n  groupBy(...columns: (SelectableType<T> | string)[]): this {\n    this.groupByQuery = this.selectTemplate.groupBy(...(columns as string[]));\n    return this;\n  }\n\n  groupByRaw(query: string): this {\n    query.replace(\"GROUP BY\", \"\");\n    this.groupByQuery = ` GROUP BY ${query}`;\n    return this;\n  }\n\n  orderBy(column: SelectableType<T>, order: \"ASC\" | \"DESC\"): this;\n  orderBy(column: string, order: \"ASC\" | \"DESC\"): this;\n  orderBy(column: SelectableType<T> | string, order: \"ASC\" | \"DESC\"): this {\n    const casedColumn = convertCase(\n      column as string,\n      this.model.databaseCaseConvention,\n    );\n\n    if (this.orderByQuery) {\n      this.orderByQuery += `, ${casedColumn as string} ${order}`;\n      return this;\n    }\n\n    this.orderByQuery = ` ORDER BY ${casedColumn as string} ${order}`;\n    return this;\n  }\n\n  orderByRaw(query: string): this {\n    if (this.orderByQuery) {\n      this.orderByQuery += `, ${query}`;\n      return this;\n    }\n\n    this.orderByQuery = ` ORDER BY ${query}`;\n    return this;\n  }\n\n  limit(limit: number) {\n    this.limitQuery = this.selectTemplate.limit(limit);\n    return this;\n  }\n\n  offset(offset: number) {\n    this.offsetQuery = this.selectTemplate.offset(offset);\n    return this;\n  }\n\n  havingRaw(query: string): ModelQueryBuilder<T> {\n    query = query.replace(\"HAVING\", \"\");\n    if (this.havingQuery) {\n      this.havingQuery += ` AND ${query}`;\n      return this;\n    }\n\n    this.havingQuery = ` HAVING ${query}`;\n    return this;\n  }\n\n  copy(): ModelQueryBuilder<T> {\n    const queryBuilder = new SqlLiteQueryBuilder<T>(\n      this.model as typeof Model,\n      this.table,\n      this.sqLiteConnection,\n      this.logs,\n      this.isNestedCondition,\n      this.sqlDataSource,\n    );\n\n    queryBuilder.selectQuery = this.selectQuery;\n    queryBuilder.whereQuery = this.whereQuery;\n    queryBuilder.joinQuery = this.joinQuery;\n    queryBuilder.groupByQuery = this.groupByQuery;\n    queryBuilder.orderByQuery = this.orderByQuery;\n    queryBuilder.limitQuery = this.limitQuery;\n    queryBuilder.offsetQuery = this.offsetQuery;\n    queryBuilder.params = [...this.params];\n    queryBuilder.relations = [...this.relations];\n    return queryBuilder;\n  }\n\n  private promisifyQuery<T>(query: string, params: any): Promise<T[]> {\n    return new Promise<T[]>((resolve, reject) => {\n      this.sqLiteConnection.all(query, params, (err, result) => {\n        if (err) {\n          reject(err);\n        }\n\n        if (!result) {\n          resolve([] as T[]);\n        }\n\n        if (!Array.isArray(result)) {\n          resolve([result as T]);\n        }\n\n        resolve(result as T[]);\n      });\n    });\n  }\n}\n","import { Model } from \"../models/model\";\nimport {\n  FindOneType,\n  FindType,\n  UnrestrictedFindOneType,\n  UnrestrictedFindType,\n} from \"../models/model_manager/model_manager_types\";\nimport { log } from \"../../utils/logger\";\nimport { ModelManager } from \"../models/model_manager/model_manager\";\nimport { SqlDataSource } from \"../../../src/sql/sql_data_source\";\nimport SqlModelManagerUtils from \"../models/model_manager/model_manager_utils\";\nimport { SqlLiteQueryBuilder } from \"./sql_lite_query_builder\";\nimport { SqliteConnectionInstance } from \"../sql_data_source_types\";\n\nexport class SqliteModelManager<T extends Model> extends ModelManager<T> {\n  protected sqLiteConnection: SqliteConnectionInstance;\n  protected sqlModelManagerUtils: SqlModelManagerUtils<T>;\n\n  /**\n   * Constructor for SqLiteModelManager class.\n   *\n   * @param {typeof Model} model - Model constructor.\n   * @param {Pool} sqLiteConnection - sqlite connection.\n   * @param {boolean} logs - Flag to enable or disable logging.\n   */\n  constructor(\n    model: typeof Model,\n    sqLiteConnection: SqliteConnectionInstance,\n    logs: boolean,\n    sqlDataSource: SqlDataSource,\n  ) {\n    super(model, logs, sqlDataSource);\n    this.sqLiteConnection = sqLiteConnection;\n    this.sqlModelManagerUtils = new SqlModelManagerUtils<T>(\n      \"sqlite\",\n      sqLiteConnection,\n    );\n  }\n\n  /**\n   * Find method to retrieve multiple records from the database based on the input conditions.\n   *\n   * @param {FindType} input - Optional query parameters for filtering, ordering, and pagination.\n   * @returns Promise resolving to an array of models.\n   */\n  async find(input?: FindType<T> | UnrestrictedFindType<T>): Promise<T[]> {\n    if (!input) {\n      return await this.query().many();\n    }\n\n    const query = this.query();\n    if (input.select) {\n      query.select(...(input.select as string[]));\n    }\n\n    if (input.relations) {\n      input.relations.forEach((relation) => {\n        query.with(relation);\n      });\n    }\n\n    if (input.where) {\n      Object.entries(input.where).forEach(([key, value]) => {\n        query.where(key, value);\n      });\n    }\n\n    if (input.orderBy) {\n      Object.entries(input.orderBy).forEach(([key, value]) => {\n        query.orderBy(key, value);\n      });\n    }\n\n    if (input.limit) {\n      query.limit(input.limit);\n    }\n\n    if (input.offset) {\n      query.offset(input.offset);\n    }\n\n    if (input.groupBy) {\n      query.groupBy(...(input.groupBy as string[]));\n    }\n\n    return await query.many({ ignoreHooks: input.ignoreHooks || [] });\n  }\n\n  /**\n   * Find a single record from the database based on the input conditions.\n   *\n   * @param {FindOneType} input - query parameters for filtering and selecting a single record.\n   * @returns Promise resolving to a single model or null if not found.\n   */\n  async findOne(\n    input: FindOneType<T> | UnrestrictedFindOneType<T>,\n  ): Promise<T | null> {\n    const results = await this.find({\n      ...input,\n      limit: 1,\n    });\n\n    if (!results.length) {\n      return null;\n    }\n\n    return results[0];\n  }\n\n  /**\n   * Find a single record by its PK from the database.\n   *\n   * @param {string | number | boolean} value - PK of the record to retrieve, hooks will not have any effect, since it's a direct query for the PK.\n   * @returns Promise resolving to a single model or null if not found.\n   */\n  async findOneByPrimaryKey(\n    value: string | number | boolean,\n  ): Promise<T | null> {\n    if (!this.model.primaryKey) {\n      throw new Error(\n        \"Model \" + this.model.table + \" has no primary key to be retrieved by\",\n      );\n    }\n\n    return await this.query()\n      .where(this.model.primaryKey as string, value)\n      .one();\n  }\n\n  /**\n   * Save a new model instance to the database.\n   *\n   * @param {Model} model - Model instance to be saved.\n   * @param {SqliteTransaction} trx - SqliteTransaction to be used on the save operation.\n   * @returns Promise resolving to the saved model or null if saving fails.\n   */\n  async insert(model: Partial<T>): Promise<T | null> {\n    this.model.beforeInsert(model as T);\n\n    const { query, params } = this.sqlModelManagerUtils.parseInsert(\n      model as T,\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n\n    log(query, this.logs, params);\n    return (await this.promisifyQuery<T>(query, params, {\n      isCreate: true,\n      models: model as T,\n    })) as T;\n  }\n\n  /**\n   * Create multiple model instances in the database.\n   *\n   * @param {Model} model - Model instance to be saved.\n   * @param {SqliteTransaction} trx - SqliteTransaction to be used on the save operation.\n   * @returns Promise resolving to an array of saved models or null if saving fails.\n   */\n  async insertMany(models: Partial<T>[]): Promise<T[]> {\n    models.forEach((model) => {\n      this.model.beforeInsert(model as T);\n    });\n\n    const { query, params } = this.sqlModelManagerUtils.parseMassiveInsert(\n      models as T[],\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n    log(query, this.logs, params);\n    return (await this.promisifyQuery<T[]>(query, params, {\n      isInsertMany: true,\n      models: models as T[],\n    })) as T[];\n  }\n\n  /**\n   * Update an existing model instance in the database.\n   * @param {Model} model - Model instance to be updated.\n   * @param {SqliteTransaction} trx - SqliteTransaction to be used on the update operation.\n   * @returns Promise resolving to the updated model or null if updating fails.\n   */\n  async updateRecord(model: T): Promise<T | null> {\n    if (!this.model.primaryKey) {\n      throw new Error(\n        \"Model \" +\n          this.model.table +\n          \" has no primary key to be updated, try save\",\n      );\n    }\n\n    const updateQuery = this.sqlModelManagerUtils.parseUpdate(\n      model,\n      this.model,\n      this.sqlDataSource.getDbType(),\n    );\n\n    log(updateQuery.query, this.logs, updateQuery.params);\n    await this.promisifyQuery<T>(updateQuery.query, updateQuery.params);\n\n    return await this.findOneByPrimaryKey(\n      model[this.model.primaryKey as keyof T] as string | number,\n    );\n  }\n\n  /**\n   * @description Delete a record from the database from the given model.\n   *\n   * @param {Model} model - Model to delete.\n   * @param trx - SqliteTransaction to be used on the delete operation.\n   * @returns Promise resolving to the deleted model or null if deleting fails.\n   */\n  async deleteRecord(model: T): Promise<T | null> {\n    if (!this.model.primaryKey) {\n      throw new Error(\n        \"Model \" + this.model.table + \" has no primary key to be deleted from\",\n      );\n    }\n    const { query, params } = this.sqlModelManagerUtils.parseDelete(\n      this.model.table,\n      this.model.primaryKey,\n      model[this.model.primaryKey as keyof T] as string,\n    );\n\n    log(query, this.logs, params);\n    await this.promisifyQuery<T>(query, params);\n    return model;\n  }\n\n  /**\n   * Create and return a new instance of the Mysql_query_builder for building more complex SQL queries.\n   *\n   * @returns {MysqlQueryBuilder<Model>} - Instance of Mysql_query_builder.\n   */\n  query(): SqlLiteQueryBuilder<T> {\n    return new SqlLiteQueryBuilder<T>(\n      this.model,\n      this.model.table,\n      this.sqLiteConnection,\n      this.logs,\n      false,\n      this.sqlDataSource,\n    );\n  }\n\n  private promisifyQuery<T>(\n    query: string,\n    params: any,\n    options: {\n      isCreate?: boolean;\n      isInsertMany?: boolean;\n      models?: T | T[];\n    } = {\n      isCreate: false,\n      isInsertMany: false,\n      models: [],\n    },\n  ): Promise<T | T[]> {\n    const primaryKeyName = this.model.primaryKey as string;\n    if (options.isCreate || options.isInsertMany) {\n      if (options.isCreate) {\n        const table = this.model.table;\n        const sqLiteConnection = this.sqLiteConnection;\n        return new Promise<T>((resolve, reject) => {\n          this.sqLiteConnection.run(\n            query,\n            params,\n            function (this: any, err: any) {\n              if (err) {\n                return reject(err);\n              }\n\n              const currentModel = options.models as T;\n              const lastID =\n                currentModel[primaryKeyName as keyof T] || this.lastID;\n              const selectQuery = `SELECT * FROM ${table} WHERE ${primaryKeyName} = ?`;\n              sqLiteConnection.get(\n                selectQuery,\n                [lastID],\n                (err: any, row: T) => {\n                  if (err) {\n                    return reject(err);\n                  }\n\n                  resolve(row as T);\n                },\n              );\n            },\n          );\n        });\n      }\n\n      if (!Array.isArray(options.models)) {\n        throw new Error(\n          \"Models should be an array when massive creating on sqlite\",\n        );\n      }\n\n      const models = options.models as T[];\n      const table = this.model.table;\n      const finalResult: T[] = [];\n      const sqLiteConnection = this.sqLiteConnection;\n      return new Promise<T[]>(async (resolve, reject) => {\n        for (const model of models) {\n          try {\n            const { query, params } = this.sqlModelManagerUtils.parseInsert(\n              model as any,\n              this.model,\n              this.sqlDataSource.getDbType(),\n            );\n\n            await new Promise<void>((resolve, reject) => {\n              this.sqLiteConnection.run(query, params, function (err: any) {\n                if (err) {\n                  return reject(err);\n                }\n\n                const lastID = model[primaryKeyName as keyof T] || this.lastID;\n                const selectQuery = `SELECT * FROM ${table} WHERE ${primaryKeyName} = ?`;\n                sqLiteConnection.get(\n                  selectQuery,\n                  [lastID],\n                  (err: any, row: T) => {\n                    if (err) {\n                      return reject(err);\n                    }\n\n                    finalResult.push(row as T);\n                    resolve();\n                  },\n                );\n              });\n            });\n          } catch (err) {\n            return reject(err);\n          }\n        }\n        resolve(finalResult);\n      });\n    }\n\n    return new Promise<T>((resolve, reject) => {\n      this.sqLiteConnection.all(query, params, (err, rows) => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(rows as T);\n      });\n    });\n  }\n}\n","import { SqlDataSource } from \"../sql_data_source\";\nimport {\n  BEGIN_TRANSACTION,\n  COMMIT_TRANSACTION,\n  ROLLBACK_TRANSACTION,\n} from \"../resources/query/TRANSACTION\";\nimport { log } from \"../../utils/logger\";\nimport {\n  MysqlConnectionInstance,\n  PgClientInstance,\n  SqlConnectionType,\n  SqliteConnectionInstance,\n} from \"../sql_data_source_types\";\n\nexport class Transaction {\n  sqlDataSource: SqlDataSource;\n  sqlConnection: SqlConnectionType;\n  isActive: boolean;\n  private readonly logs: boolean;\n\n  constructor(sqlDataSource: SqlDataSource, logs?: boolean) {\n    this.sqlDataSource = sqlDataSource;\n    this.sqlConnection = this.sqlDataSource.getCurrentConnection();\n    this.isActive = false;\n    this.logs = logs || this.sqlDataSource.logs || false;\n  }\n\n  async startTransaction(): Promise<void> {\n    try {\n      switch (this.sqlDataSource.getDbType()) {\n        case \"mysql\":\n        case \"mariadb\":\n          log(BEGIN_TRANSACTION, this.logs);\n          await (\n            this.sqlConnection as MysqlConnectionInstance\n          ).beginTransaction();\n          break;\n\n        case \"postgres\":\n          log(BEGIN_TRANSACTION, this.logs);\n          await (this.sqlConnection as PgClientInstance).query(\n            BEGIN_TRANSACTION,\n          );\n          break;\n\n        case \"sqlite\":\n          log(BEGIN_TRANSACTION, this.logs);\n          (this.sqlConnection as SqliteConnectionInstance).run(\n            BEGIN_TRANSACTION,\n            (err) => {\n              if (err) {\n                throw new Error(err.message);\n              }\n            },\n          );\n          break;\n\n        default:\n          throw new Error(\"Invalid database type while beginning transaction\");\n      }\n\n      this.isActive = true;\n    } catch (error) {\n      await this.releaseConnection();\n    }\n  }\n\n  async commit(): Promise<void> {\n    try {\n      switch (this.sqlDataSource.getDbType()) {\n        case \"mysql\":\n        case \"mariadb\":\n          log(COMMIT_TRANSACTION, this.logs);\n          await (this.sqlConnection as MysqlConnectionInstance).commit();\n          break;\n\n        case \"postgres\":\n          log(COMMIT_TRANSACTION, this.logs);\n          await (this.sqlConnection as PgClientInstance).query(\n            COMMIT_TRANSACTION,\n          );\n          break;\n\n        case \"sqlite\":\n          log(COMMIT_TRANSACTION, this.logs);\n          (this.sqlConnection as SqliteConnectionInstance).run(\n            COMMIT_TRANSACTION,\n            (err) => {\n              if (err) {\n                throw new Error(err.message);\n              }\n            },\n          );\n          break;\n        default:\n          throw new Error(\"Invalid database type while committing transaction\");\n      }\n\n      this.isActive = false;\n    } catch (error) {\n      throw error;\n    } finally {\n      await this.releaseConnection();\n    }\n  }\n\n  async rollback(): Promise<void> {\n    try {\n      switch (this.sqlDataSource.getDbType()) {\n        case \"mysql\":\n        case \"mariadb\":\n          log(ROLLBACK_TRANSACTION, this.logs);\n          await (this.sqlConnection as MysqlConnectionInstance).rollback();\n          break;\n\n        case \"postgres\":\n          log(ROLLBACK_TRANSACTION, this.logs);\n          await (this.sqlConnection as PgClientInstance).query(\n            ROLLBACK_TRANSACTION,\n          );\n          break;\n\n        case \"sqlite\":\n          log(ROLLBACK_TRANSACTION, this.logs);\n          (this.sqlConnection as SqliteConnectionInstance).run(\n            ROLLBACK_TRANSACTION,\n            (err) => {\n              if (err) {\n                throw new Error(err.message);\n              }\n            },\n          );\n          break;\n\n        default:\n          throw new Error(\n            \"Invalid database type while rolling back transaction\",\n          );\n      }\n\n      this.isActive = false;\n    } finally {\n      await this.releaseConnection();\n    }\n  }\n\n  private async releaseConnection(): Promise<void> {\n    switch (this.sqlDataSource.getDbType()) {\n      case \"mysql\":\n      case \"mariadb\":\n        await (this.sqlConnection as MysqlConnectionInstance).end();\n        break;\n\n      case \"postgres\":\n        await (this.sqlConnection as PgClientInstance).end();\n        break;\n\n      case \"sqlite\":\n        (this.sqlConnection as SqliteConnectionInstance).close();\n        break;\n\n      default:\n        throw new Error(\"Invalid database type while releasing connection\");\n    }\n  }\n}\n","import { DataSource } from \"../data_source\";\nimport {\n  Mysql2Import,\n  PgImport,\n  Sqlite3Import,\n} from \"../drivers/driver_constants\";\nimport { DriverFactory } from \"../drivers/drivers_factory\";\nimport logger, { log } from \"../utils/logger\";\nimport { Model } from \"./models/model\";\nimport { MysqlModelManager } from \"./mysql/mysql_model_manager\";\nimport { PostgresModelManager } from \"./postgres/postgres_model_manager\";\nimport {\n  SqlConnectionType,\n  SqlDataSourceInput,\n  SqlDataSourceType,\n  SqlDriverSpecificOptions,\n  ModelManager,\n  MysqlConnectionInstance,\n  PgClientInstance,\n  SqliteConnectionInstance,\n} from \"./sql_data_source_types\";\nimport { SqliteModelManager } from \"./sqlite/sql_lite_model_manager\";\nimport { Transaction } from \"./transactions/transaction\";\n\nexport class SqlDataSource extends DataSource {\n  isConnected: boolean;\n  protected sqlConnection!: SqlConnectionType;\n  private static instance: SqlDataSource | null = null;\n\n  private constructor(input?: SqlDataSourceInput) {\n    super(input);\n    this.isConnected = false;\n  }\n\n  getDbType(): SqlDataSourceType {\n    return this.type as SqlDataSourceType;\n  }\n\n  /**\n   * @description Connects to the database establishing a connection. If no connection details are provided, the default values from the env will be taken instead\n   * @description The User input connection details will always come first\n   */\n  static async connect(\n    input?: SqlDataSourceInput,\n    cb?: () => Promise<void> | void,\n  ): Promise<SqlDataSource> {\n    const sqlDataSource = new this(input);\n    const driver = await DriverFactory.getDriver(sqlDataSource.type);\n    switch (sqlDataSource.type) {\n      case \"mysql\":\n      case \"mariadb\":\n        const mysqlDriver = driver.client as Mysql2Import;\n        sqlDataSource.sqlConnection = await mysqlDriver.createConnection({\n          host: sqlDataSource.host,\n          port: sqlDataSource.port,\n          user: sqlDataSource.username,\n          password: sqlDataSource.password,\n          database: sqlDataSource.database,\n          ...input?.mysqlOptions,\n        });\n        break;\n\n      case \"postgres\":\n        const pgDriver = driver.client as PgImport;\n        sqlDataSource.sqlConnection = new pgDriver.Client({\n          host: sqlDataSource.host,\n          port: sqlDataSource.port,\n          user: sqlDataSource.username,\n          password: sqlDataSource.password,\n          database: sqlDataSource.database,\n          ...input?.pgOptions,\n        });\n        await (sqlDataSource.sqlConnection as PgClientInstance).connect();\n        break;\n\n      case \"sqlite\":\n        const sqlite3 = driver.client as Sqlite3Import;\n        sqlDataSource.sqlConnection = new sqlite3.Database(\n          sqlDataSource.database,\n          sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,\n          (err) => {\n            if (err) {\n              throw new Error(`Error while connecting to sqlite: ${err}`);\n            }\n          },\n        );\n        break;\n\n      default:\n        throw new Error(`Unsupported data source type: ${sqlDataSource.type}`);\n    }\n\n    sqlDataSource.isConnected = true;\n    SqlDataSource.instance = sqlDataSource;\n    cb?.();\n    return sqlDataSource;\n  }\n\n  static getInstance(): SqlDataSource {\n    if (!SqlDataSource.instance) {\n      throw new Error(\"sql database connection not established\");\n    }\n\n    return SqlDataSource.instance;\n  }\n\n  /**\n   * @description Executes a callback function with the provided connection details using the main connection established with SqlDataSource.connect() method\n   * @description The callback automatically commits or rollbacks the transaction based on the result of the callback\n   * @description NOTE: trx must always be passed to single methods that are part of the transaction\n   */\n  static async useTransaction(\n    cb: (trx: Transaction) => Promise<void>,\n    driverSpecificOptions?: SqlDriverSpecificOptions,\n  ): Promise<void> {\n    const trx = await this.getInstance().startTransaction(\n      driverSpecificOptions,\n    );\n    try {\n      await cb(trx).then(async () => {\n        if (!trx.isActive) {\n          return;\n        }\n\n        await trx.commit();\n      });\n    } catch (error) {\n      if (!trx.isActive) {\n        return;\n      }\n\n      await trx.rollback();\n      throw error;\n    }\n  }\n\n  /**\n   * @description Executes a callback function with the provided connection details\n   * @description The callback automatically commits or rollbacks the transaction based on the result of the callback\n   * @description NOTE: trx must always be passed to single methods that are part of the transaction\n   */\n  async useTransaction(\n    cb: (trx: Transaction) => Promise<void>,\n    driverSpecificOptions?: SqlDriverSpecificOptions,\n  ): Promise<void> {\n    const trx = await this.startTransaction(driverSpecificOptions);\n    try {\n      await cb(trx).then(async () => {\n        if (!trx.isActive) {\n          return;\n        }\n\n        await trx.commit();\n      });\n    } catch (error) {\n      if (!trx.isActive) {\n        return;\n      }\n\n      await trx.rollback();\n      throw error;\n    }\n  }\n\n  /**\n   * @description Starts a transaction on the database and returns the transaction object\n   * @description This creates a new connection to the database, you can customize the connection details using the driverSpecificOptions\n   */\n  async startTransaction(\n    driverSpecificOptions?: SqlDriverSpecificOptions,\n  ): Promise<Transaction> {\n    const sqlDataSource = new SqlDataSource({\n      type: this.type as SqlDataSourceType,\n      host: this.host,\n      port: this.port,\n      username: this.username,\n      password: this.password,\n      database: this.database,\n      logs: this.logs,\n      ...driverSpecificOptions,\n    });\n\n    await sqlDataSource.connectDriver();\n    sqlDataSource.isConnected = true;\n    const mysqlTrx = new Transaction(sqlDataSource, this.logs);\n    await mysqlTrx.startTransaction();\n    return mysqlTrx;\n  }\n\n  /**\n   * @description Alias for startTransaction {Promise<Transaction>} trx\n   */\n  async beginTransaction(\n    driverSpecificOptions?: SqlDriverSpecificOptions,\n  ): Promise<Transaction> {\n    return this.startTransaction(driverSpecificOptions);\n  }\n\n  /**\n   * @description Alias for startTransaction {Promise<Transaction>} trx\n   */\n  async transaction(\n    driverSpecificOptions?: SqlDriverSpecificOptions,\n  ): Promise<Transaction> {\n    return this.startTransaction(driverSpecificOptions);\n  }\n\n  /**\n   * @description Returns model manager for the provided model\n   */\n  getModelManager<T extends Model>(\n    model: { new (): T } | typeof Model,\n  ): ModelManager<T> {\n    if (!this.isConnected) {\n      throw new Error(\"sql database connection not established\");\n    }\n\n    switch (this.type) {\n      case \"mysql\":\n      case \"mariadb\":\n        return new MysqlModelManager<T>(\n          this.type,\n          model as typeof Model,\n          this.sqlConnection as MysqlConnectionInstance,\n          this.logs,\n          this,\n        );\n      case \"postgres\":\n        return new PostgresModelManager<T>(\n          model as typeof Model,\n          this.sqlConnection as PgClientInstance,\n          this.logs,\n          this,\n        );\n      case \"sqlite\":\n        return new SqliteModelManager<T>(\n          model as typeof Model,\n          this.sqlConnection as SqliteConnectionInstance,\n          this.logs,\n          this,\n        );\n      default:\n        throw new Error(`Unsupported data source type: ${this.type}`);\n    }\n  }\n\n  /**\n   * @description Executes a callback function with the provided connection details\n   */\n  static async useConnection(\n    connectionDetails: SqlDataSourceInput,\n    cb: (sqlDataSource: SqlDataSource) => Promise<void>,\n  ) {\n    const customSqlInstance = new SqlDataSource(connectionDetails);\n    await customSqlInstance.connectDriver({\n      mysqlOptions: connectionDetails.mysqlOptions,\n      pgOptions: connectionDetails.pgOptions,\n    });\n    customSqlInstance.isConnected = true;\n    try {\n      await cb(customSqlInstance).then(async () => {\n        if (!customSqlInstance.isConnected) {\n          return;\n        }\n\n        await customSqlInstance.closeConnection();\n      });\n    } catch (error) {\n      if (customSqlInstance.isConnected) {\n        await customSqlInstance.closeConnection();\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * @description Returns the current connection {Promise<SqlConnectionType>} sqlConnection\n   */\n  getCurrentConnection(): SqlConnectionType {\n    return this.sqlConnection;\n  }\n\n  /**\n   * @description Returns separate raw sql connection\n   */\n  async getRawConnection(\n    driverSpecificOptions?: SqlDriverSpecificOptions,\n  ): Promise<SqlConnectionType> {\n    switch (this.type) {\n      case \"mysql\":\n      case \"mariadb\":\n        const mysqlDriver = (await DriverFactory.getDriver(\"mysql\"))\n          .client as Mysql2Import;\n        return await mysqlDriver.createConnection({\n          host: this.host,\n          port: this.port,\n          user: this.username,\n          password: this.password,\n          database: this.database,\n          ...driverSpecificOptions?.mysqlOptions,\n        });\n      case \"postgres\":\n        const pg = (await DriverFactory.getDriver(\"postgres\"))\n          .client as PgImport;\n        const client = new pg.Client({\n          host: this.host,\n          port: this.port,\n          user: this.username,\n          password: this.password,\n          database: this.database,\n          ...driverSpecificOptions?.pgOptions,\n        });\n        await client.connect();\n        return client;\n\n      case \"sqlite\":\n        const sqlite3 = (await DriverFactory.getDriver(\"sqlite\"))\n          .client as Sqlite3Import;\n        return new sqlite3.Database(\n          this.database,\n          sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,\n          (err) => {\n            if (err) {\n              throw new Error(`Error while connecting to sqlite: ${err}`);\n            }\n          },\n        );\n      default:\n        throw new Error(`Unsupported data source type: ${this.type}`);\n    }\n  }\n\n  /**\n   * @description Closes the connection to the database\n   */\n  async closeConnection(): Promise<void> {\n    if (!this.isConnected) {\n      logger.warn(\"Connection already closed\", this);\n      return;\n    }\n\n    logger.warn(\"Closing connection\", this);\n    switch (this.type) {\n      case \"mysql\":\n      case \"mariadb\":\n        await (this.sqlConnection as MysqlConnectionInstance).end();\n        this.isConnected = false;\n        SqlDataSource.instance = null;\n        break;\n      case \"postgres\":\n        await (this.sqlConnection as PgClientInstance).end();\n        this.isConnected = false;\n        SqlDataSource.instance = null;\n        break;\n      case \"sqlite\":\n        await new Promise<void>((resolve, reject) => {\n          (this.sqlConnection as SqliteConnectionInstance).close((err) => {\n            if (err) {\n              reject(err);\n            }\n            resolve();\n          });\n        });\n        this.isConnected = false;\n        SqlDataSource.instance = null;\n        break;\n      default:\n        throw new Error(`Unsupported data source type: ${this.type}`);\n    }\n  }\n\n  /**\n   * @description Closes the main connection to the database established with SqlDataSource.connect() method\n   */\n  static async closeConnection(): Promise<void> {\n    const sqlDataSource = SqlDataSource.getInstance();\n    if (!sqlDataSource.isConnected) {\n      logger.warn(\"Connection already closed\", sqlDataSource);\n      return;\n    }\n\n    logger.warn(\"Closing connection\", sqlDataSource);\n    switch (sqlDataSource.type) {\n      case \"mysql\":\n      case \"mariadb\":\n        await (sqlDataSource.sqlConnection as MysqlConnectionInstance).end();\n        sqlDataSource.isConnected = false;\n        SqlDataSource.instance = null;\n        break;\n      case \"postgres\":\n        await (sqlDataSource.sqlConnection as PgClientInstance).end();\n        sqlDataSource.isConnected = false;\n        SqlDataSource.instance = null;\n        break;\n      case \"sqlite\":\n        await new Promise<void>((resolve, reject) => {\n          (sqlDataSource.sqlConnection as SqliteConnectionInstance).close(\n            (err) => {\n              if (err) {\n                reject(err);\n              }\n              resolve();\n            },\n          );\n        });\n        sqlDataSource.isConnected = false;\n        SqlDataSource.instance = null;\n        break;\n      default:\n        throw new Error(`Unsupported data source type: ${sqlDataSource.type}`);\n    }\n  }\n\n  /**\n   * @description Disconnects the connection to the database\n   * @alias closeConnection\n   */\n  async disconnect(): Promise<void> {\n    return this.closeConnection();\n  }\n\n  /**\n   * @description Disconnects the main connection to the database established with SqlDataSource.connect() method\n   * @alias closeMainConnection\n   */\n  static async disconnect(): Promise<void> {\n    return SqlDataSource.closeConnection();\n  }\n\n  /**\n   * @description Executes a raw query on the database\n   */\n  async rawQuery<T = any>(query: string, params: any[] = []): Promise<T> {\n    if (!this.isConnected) {\n      throw new Error(\"sql database connection not established\");\n    }\n\n    log(query, this.logs, params);\n    switch (this.type) {\n      case \"mysql\":\n      case \"mariadb\":\n        const [mysqlRows] = await (\n          this.sqlConnection as MysqlConnectionInstance\n        ).execute(query, params);\n\n        return mysqlRows as T;\n      case \"postgres\":\n        const { rows } = await (this.sqlConnection as PgClientInstance).query(\n          query,\n          params as any[],\n        );\n\n        return rows as T;\n      case \"sqlite\":\n        return new Promise((resolve, reject) => {\n          (this.sqlConnection as SqliteConnectionInstance).all(\n            query,\n            params,\n            (err, rows) => {\n              if (err) {\n                reject(err);\n              }\n\n              resolve(rows as T);\n            },\n          );\n        });\n      default:\n        throw new Error(`Unsupported data source type: ${this.type}`);\n    }\n  }\n\n  /**\n   * @description Executes a raw query on the database with the base connection created with SqlDataSource.connect() method\n   */\n  static async rawQuery<T = any>(\n    query: string,\n    params: any[] = [],\n  ): Promise<T> {\n    const sqlDataSource = SqlDataSource.getInstance();\n    if (!sqlDataSource || !sqlDataSource.isConnected) {\n      throw new Error(\"sql database connection not established\");\n    }\n\n    log(query, SqlDataSource.getInstance()?.logs ?? false, params);\n    switch (sqlDataSource.type) {\n      case \"mysql\":\n      case \"mariadb\":\n        const [mysqlRows] = await (\n          sqlDataSource.sqlConnection as MysqlConnectionInstance\n        ).execute(query, params);\n\n        return mysqlRows as T;\n      case \"postgres\":\n        const { rows } = await (\n          sqlDataSource.sqlConnection as PgClientInstance\n        ).query(query, params);\n\n        return rows as T;\n      case \"sqlite\":\n        return new Promise((resolve, reject) => {\n          (sqlDataSource.sqlConnection as SqliteConnectionInstance).all(\n            query,\n            params,\n            (err, rows) => {\n              if (err) {\n                reject(err);\n              }\n\n              resolve(rows as T);\n            },\n          );\n        });\n      default:\n        throw new Error(`Unsupported data source type: ${sqlDataSource.type}`);\n    }\n  }\n\n  private async connectDriver(\n    driverSpecificOptions?: SqlDriverSpecificOptions,\n  ): Promise<void> {\n    switch (this.type) {\n      case \"mysql\":\n      case \"mariadb\":\n        const mysql = (await DriverFactory.getDriver(\"mysql\"))\n          .client as Mysql2Import;\n        this.sqlConnection = await mysql.createConnection({\n          host: this.host,\n          port: this.port,\n          user: this.username,\n          password: this.password,\n          database: this.database,\n          ...driverSpecificOptions?.mysqlOptions,\n        });\n        break;\n      case \"postgres\":\n        const pg = (await DriverFactory.getDriver(\"postgres\"))\n          .client as PgImport;\n        this.sqlConnection = new pg.Client({\n          host: this.host,\n          port: this.port,\n          user: this.username,\n          password: this.password,\n          database: this.database,\n          ...driverSpecificOptions?.pgOptions,\n        });\n        await (this.sqlConnection as PgClientInstance).connect();\n        break;\n      case \"sqlite\":\n        const sqlite3 = (await DriverFactory.getDriver(\"sqlite\"))\n          .client as Sqlite3Import;\n        this.sqlConnection = new sqlite3.Database(\n          this.database,\n          sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,\n          (err) => {\n            if (err) {\n              throw new Error(`Error while connecting to sqlite: ${err}`);\n            }\n          },\n        );\n        break;\n      default:\n        throw new Error(`Unsupported data source type: ${this.type}`);\n    }\n  }\n}\n","import fs from \"node:fs\";\nimport path, { join } from \"node:path\";\nimport { Migration } from \"../sql/migrations/migration\";\nimport dotenv from \"dotenv\";\nimport { MigrationTableType } from \"./resources/migration_table_type\";\nimport MigrationTemplates from \"./resources/migration_templates\";\nimport {\n  MysqlConnectionInstance,\n  PgClientInstance,\n  SqlConnectionType,\n  SqliteConnectionInstance,\n} from \"../sql/sql_data_source_types\";\nimport { register } from \"ts-node\";\n\ndotenv.config();\n\nexport async function getMigrationTable(\n  sqlConnection: SqlConnectionType,\n): Promise<MigrationTableType[]> {\n  switch (process.env.DB_TYPE) {\n    case \"mariadb\":\n    case \"mysql\":\n      const mysqlConnection = sqlConnection as MysqlConnectionInstance;\n      await mysqlConnection.query(\n        MigrationTemplates.migrationTableTemplateMysql(),\n      );\n      const result = await mysqlConnection.query(\n        MigrationTemplates.selectAllFromMigrationsTemplate(),\n      );\n      return result[0] as MigrationTableType[];\n\n    case \"postgres\":\n      const pgConnection = sqlConnection as PgClientInstance;\n      await pgConnection.query(MigrationTemplates.migrationTableTemplatePg());\n      const pgResult = await pgConnection.query(\n        MigrationTemplates.selectAllFromMigrationsTemplate(),\n      );\n      return pgResult.rows as MigrationTableType[];\n\n    case \"sqlite\":\n      await promisifySqliteQuery(\n        MigrationTemplates.migrationTableTemplateSQLite(),\n        [],\n        sqlConnection as SqliteConnectionInstance,\n      );\n      const resultSqlite =\n        (await promisifySqliteQuery<MigrationTableType[]>(\n          MigrationTemplates.selectAllFromMigrationsTemplate(),\n          [],\n          sqlConnection as SqliteConnectionInstance,\n        )) || [];\n      return Array.isArray(resultSqlite) ? resultSqlite : [resultSqlite];\n\n    default:\n      throw new Error(\"Unsupported database type\");\n  }\n}\n\nexport async function getMigrations(): Promise<Migration[]> {\n  const migrationNames = findMigrationNames();\n  const migrations: Migration[] = [];\n\n  for (const migrationName of migrationNames) {\n    const migrationModule = await findMigrationModule(migrationName);\n    const migration: Migration = new migrationModule();\n    migration.migrationName = migrationName;\n    migrations.push(migration);\n  }\n\n  return migrations;\n}\n\nexport function getPendingMigrations(\n  migrations: Migration[],\n  migrationTable: MigrationTableType[],\n): Migration[] {\n  return migrations.filter((migration) => {\n    const migrationName = migration.migrationName;\n    const migrationEntry = migrationTable.find(\n      (migration) => migration.name === migrationName,\n    );\n\n    return !migrationEntry;\n  });\n}\n\nasync function loadMigrationModule(\n  absolutePath: string,\n): Promise<new () => Migration> {\n  const isTs = absolutePath.endsWith(\".ts\");\n  if (isTs) {\n    register({\n      transpileOnly: true,\n      compilerOptions: {\n        module: \"esnext\",\n        target: \"es2020\",\n      },\n    });\n\n    const migrationModule = await import(absolutePath);\n    return migrationModule.default;\n  }\n\n  const migrationModule = await import(absolutePath);\n  return migrationModule.default;\n}\n\nasync function findMigrationModule(\n  migrationName: string,\n  migrationModulePath: string = process.env.MIGRATION_PATH\n    ? process.env.MIGRATION_PATH + \"/\" + migrationName\n    : \"database/migrations/\" + migrationName,\n): Promise<new () => Migration> {\n  const migrationPath = process.cwd() + \"/\" + migrationModulePath;\n  const migrationModule = await loadMigrationModule(migrationPath);\n\n  if (!migrationModule) {\n    throw new Error(\n      \"migrations module not found for migration: \" + migrationName,\n    );\n  }\n\n  return migrationModule;\n}\n\nfunction findMigrationNames(): string[] {\n  const currentUserDirectory = process.cwd();\n  const migrationPath = path.resolve(\n    process.env.MIGRATION_PATH || \"database/migrations\",\n  );\n\n  const fullPathToMigrationPath = path.resolve(\n    currentUserDirectory,\n    migrationPath,\n  );\n\n  try {\n    const migrationFiles = fs.readdirSync(fullPathToMigrationPath);\n    if (migrationFiles.length > 0) {\n      return migrationFiles;\n    }\n\n    throw new Error(\n      \"No database migration files found on path: \" + fullPathToMigrationPath,\n    );\n  } catch (error) {\n    throw new Error(\n      \"No database migration files found on path: \" + fullPathToMigrationPath,\n    );\n  }\n}\n\nexport async function promisifySqliteQuery<T>(\n  query: string,\n  params: any,\n  sqLiteConnection: SqliteConnectionInstance,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    sqLiteConnection.get<T>(query, params, (err, result) => {\n      if (err) {\n        reject(err);\n      }\n      resolve(result);\n    });\n  });\n}\n","#!/usr/bin/env node\n\nimport dotenv from \"dotenv\";\nimport { MigrationTableType } from \"../resources/migration_table_type\";\nimport { Migration } from \"../../sql/migrations/migration\";\nimport { MigrationController } from \"../../sql/migrations/migration_controller\";\nimport {\n  BEGIN_TRANSACTION,\n  COMMIT_TRANSACTION,\n  ROLLBACK_TRANSACTION,\n} from \"../../sql/resources/query/TRANSACTION\";\nimport logger, { log } from \"../../utils/logger\";\nimport { SqlDataSource } from \"../../sql/sql_data_source\";\nimport { getMigrations, getMigrationTable } from \"../migration_utils\";\nimport { MysqlConnectionInstance } from \"../../sql/sql_data_source_types\";\n\ndotenv.config();\n\nexport async function runMigrationsSql(runUntil?: string): Promise<void> {\n  const sql = await SqlDataSource.connect();\n  const sqlConnection = sql.getCurrentConnection() as MysqlConnectionInstance;\n  try {\n    log(BEGIN_TRANSACTION, true);\n    await sqlConnection.beginTransaction();\n    const migrationTable: MigrationTableType[] = await getMigrationTable(\n      sqlConnection as MysqlConnectionInstance,\n    );\n    const migrations: Migration[] = await getMigrations();\n    const pendingMigrations = migrations.filter(\n      (migration) =>\n        !migrationTable\n          .map((table) => table.name)\n          .includes(migration.migrationName),\n    );\n\n    if (pendingMigrations.length === 0) {\n      logger.info(\"No pending migrations.\");\n      await sql.closeConnection();\n      process.exit(0);\n    }\n\n    if (runUntil) {\n      const runUntilIndex = pendingMigrations.findIndex(\n        (migration) => migration.migrationName === runUntil,\n      );\n\n      if (runUntilIndex === -1) {\n        throw new Error(`Migration ${runUntil} not found.`);\n      }\n\n      const filteredMigrations = pendingMigrations.slice(0, runUntilIndex + 1);\n      const migrationController = new MigrationController(\n        sql,\n        sqlConnection as MysqlConnectionInstance,\n        \"mysql\",\n      );\n      await migrationController.upMigrations(filteredMigrations);\n      log(COMMIT_TRANSACTION, true);\n      await sqlConnection.commit();\n      return;\n    }\n\n    const migrationController = new MigrationController(\n      sql,\n      sqlConnection as MysqlConnectionInstance,\n      \"mysql\",\n    );\n\n    await migrationController.upMigrations(pendingMigrations);\n\n    log(COMMIT_TRANSACTION, true);\n    await sqlConnection.commit();\n  } catch (error: any) {\n    log(ROLLBACK_TRANSACTION, true);\n    await sqlConnection.rollback();\n    throw error;\n  } finally {\n    await sql.closeConnection();\n  }\n}\n","#!/usr/bin/env node\n\nimport dotenv from \"dotenv\";\nimport { MigrationTableType } from \"../resources/migration_table_type\";\nimport { Migration } from \"../../sql/migrations/migration\";\nimport { MigrationController } from \"../../sql/migrations/migration_controller\";\nimport logger from \"../../utils/logger\";\nimport { SqlDataSource } from \"../../sql/sql_data_source\";\nimport { getMigrations, getMigrationTable } from \"../migration_utils\";\nimport { SqliteConnectionInstance } from \"../../sql/sql_data_source_types\";\n\ndotenv.config();\n\nexport async function runMigrationsSQLite(runUntil?: string): Promise<void> {\n  const sql = await SqlDataSource.connect();\n  const sqlConnection = sql.getCurrentConnection() as SqliteConnectionInstance;\n\n  try {\n    const migrationTable: MigrationTableType[] =\n      (await getMigrationTable(sqlConnection)) || [];\n    const migrations: Migration[] = await getMigrations();\n    const pendingMigrations = migrations.filter(\n      (migration) =>\n        !migrationTable\n          .map((table) => table.name)\n          .includes(migration.migrationName),\n    );\n\n    if (pendingMigrations.length === 0) {\n      logger.info(\"No pending migrations.\");\n      await sql.closeConnection();\n      process.exit(0);\n    }\n\n    if (runUntil) {\n      const runUntilIndex = pendingMigrations.findIndex(\n        (migration) => migration.migrationName === runUntil,\n      );\n\n      if (runUntilIndex === -1) {\n        throw new Error(`Migration ${runUntil} not found.`);\n      }\n\n      const filteredMigrations = pendingMigrations.slice(0, runUntilIndex + 1);\n      const migrationController = new MigrationController(\n        sql,\n        sqlConnection,\n        \"sqlite\",\n      );\n\n      await migrationController.upMigrations(filteredMigrations);\n    }\n\n    const migrationController = new MigrationController(\n      sql,\n      sqlConnection,\n      \"sqlite\",\n    );\n\n    await migrationController.upMigrations(pendingMigrations);\n  } finally {\n    await sql.closeConnection();\n  }\n}\n","import dotenv from \"dotenv\";\nimport { migrationRollBackSql } from \"./mysql/rollback_migration\";\nimport { migrationRollBackPg } from \"./postgres/rollback_migration\";\nimport logger from \"../utils/logger\";\nimport { migrationRollBackSqlite } from \"./sqlite/rollback_migration\";\n\ndotenv.config();\n\nexport default async function rollbackMigrationConnector(\n  rollBackUntil?: string,\n) {\n  const databaseType = process.env.DB_TYPE;\n  logger.info(\"Rolling back migrations for database type: \" + databaseType);\n\n  switch (databaseType) {\n    case \"mariadb\":\n    case \"mysql\":\n      await migrationRollBackSql(rollBackUntil);\n      break;\n    case \"postgres\":\n      await migrationRollBackPg(rollBackUntil);\n      break;\n    case \"sqlite\":\n      await migrationRollBackSqlite(rollBackUntil);\n      break;\n    default:\n      throw new Error(\n        \"Invalid database type, must be mysql or mysql, postgres, mariadb, sqlite, got: \" +\n          databaseType,\n      );\n  }\n}\n","#!/usr/bin/env node\n\nimport dotenv from \"dotenv\";\nimport { MigrationTableType } from \"../resources/migration_table_type\";\nimport { Migration } from \"../../sql/migrations/migration\";\nimport { MigrationController } from \"../../sql/migrations/migration_controller\";\nimport {\n  BEGIN_TRANSACTION,\n  COMMIT_TRANSACTION,\n  ROLLBACK_TRANSACTION,\n} from \"../../sql/resources/query/TRANSACTION\";\nimport logger, { log } from \"../../utils/logger\";\nimport { SqlDataSource } from \"../../sql/sql_data_source\";\nimport { getMigrations, getMigrationTable } from \"../migration_utils\";\nimport { MysqlConnectionInstance } from \"../../sql/sql_data_source_types\";\n\ndotenv.config();\n\nexport async function migrationRollBackSql(\n  rollBackUntil?: string,\n): Promise<void> {\n  const sql = await SqlDataSource.connect();\n  const sqlConnection = sql.getCurrentConnection() as MysqlConnectionInstance;\n\n  try {\n    log(BEGIN_TRANSACTION, true);\n    await sqlConnection.beginTransaction();\n    const migrationTable: MigrationTableType[] =\n      await getMigrationTable(sqlConnection);\n    const migrations: Migration[] = await getMigrations();\n    const tableMigrations = migrationTable.map((migration) => migration.name);\n    const pendingMigrations = migrations.filter((migration) =>\n      tableMigrations.includes(migration.migrationName),\n    );\n\n    if (pendingMigrations.length === 0) {\n      logger.info(\"No pending migrations.\");\n      await sql.closeConnection();\n      process.exit(0);\n    }\n\n    if (rollBackUntil) {\n      const rollBackUntilIndex = pendingMigrations.findIndex(\n        (migration) => migration.migrationName === rollBackUntil,\n      );\n\n      if (rollBackUntilIndex === -1) {\n        throw new Error(`Migration ${rollBackUntil} not found.`);\n      }\n\n      const filteredMigrations = pendingMigrations.slice(rollBackUntilIndex);\n      const migrationController: MigrationController = new MigrationController(\n        sql,\n        sqlConnection,\n        \"mysql\",\n      );\n\n      await migrationController.downMigrations(filteredMigrations);\n      log(COMMIT_TRANSACTION, true);\n      await sqlConnection.commit();\n      return;\n    }\n\n    const migrationController: MigrationController = new MigrationController(\n      sql,\n      sqlConnection,\n      \"mysql\",\n    );\n\n    await migrationController.downMigrations(pendingMigrations);\n\n    log(COMMIT_TRANSACTION, true);\n    await sqlConnection.commit();\n  } catch (error: any) {\n    log(ROLLBACK_TRANSACTION, true);\n    await sqlConnection.rollback();\n    throw error;\n  } finally {\n    await sql.closeConnection();\n  }\n}\n","#!/usr/bin/env node\n\nimport dotenv from \"dotenv\";\nimport { MigrationTableType } from \"../resources/migration_table_type\";\nimport { Migration } from \"../../sql/migrations/migration\";\nimport { MigrationController } from \"../../sql/migrations/migration_controller\";\nimport {\n  BEGIN_TRANSACTION,\n  COMMIT_TRANSACTION,\n  ROLLBACK_TRANSACTION,\n} from \"../../sql/resources/query/TRANSACTION\";\nimport logger, { log } from \"../../utils/logger\";\nimport { SqlDataSource } from \"../../sql/sql_data_source\";\nimport { getMigrationTable, getMigrations } from \"../migration_utils\";\nimport { PgClientInstance } from \"../../sql/sql_data_source_types\";\n\ndotenv.config();\n\nexport async function migrationRollBackPg(\n  rollBackUntil?: string,\n): Promise<void> {\n  const sql = await SqlDataSource.connect();\n  const sqlConnection = sql.getCurrentConnection() as PgClientInstance;\n  try {\n    const migrationTable: MigrationTableType[] =\n      await getMigrationTable(sqlConnection);\n    const migrations: Migration[] = await getMigrations();\n\n    const tableMigrations = migrationTable.map((migration) => migration.name);\n    const pendingMigrations = migrations.filter((migration) =>\n      tableMigrations.includes(migration.migrationName),\n    );\n\n    if (pendingMigrations.length === 0) {\n      logger.info(\"No pending migrations.\");\n      await sql.closeConnection();\n      process.exit(0);\n    }\n\n    if (rollBackUntil) {\n      const rollBackUntilIndex = pendingMigrations.findIndex(\n        (migration) => migration.migrationName === rollBackUntil,\n      );\n\n      if (rollBackUntilIndex === -1) {\n        throw new Error(`Migration ${rollBackUntil} not found.`);\n      }\n\n      const filteredMigrations = pendingMigrations.slice(rollBackUntilIndex);\n      const migrationController = new MigrationController(\n        sql,\n        sqlConnection,\n        \"postgres\",\n      );\n\n      log(BEGIN_TRANSACTION, true);\n      await sqlConnection.query(BEGIN_TRANSACTION);\n      await migrationController.downMigrations(filteredMigrations);\n      await sqlConnection.query(COMMIT_TRANSACTION);\n      return;\n    }\n\n    const migrationController = new MigrationController(\n      sql,\n      sqlConnection,\n      \"postgres\",\n    );\n    log(BEGIN_TRANSACTION, true);\n    await sqlConnection.query(BEGIN_TRANSACTION);\n    await migrationController.downMigrations(pendingMigrations);\n\n    log(COMMIT_TRANSACTION, true);\n    await sqlConnection.query(COMMIT_TRANSACTION);\n  } catch (error: any) {\n    log(ROLLBACK_TRANSACTION, true);\n    await sqlConnection.query(ROLLBACK_TRANSACTION);\n    throw error;\n  } finally {\n    await sql.closeConnection();\n  }\n}\n","#!/usr/bin/env node\n\nimport dotenv from \"dotenv\";\nimport { MigrationTableType } from \"../resources/migration_table_type\";\nimport { Migration } from \"../../sql/migrations/migration\";\nimport { MigrationController } from \"../../sql/migrations/migration_controller\";\nimport logger from \"../../utils/logger\";\nimport { SqlDataSource } from \"../../sql/sql_data_source\";\nimport { getMigrations, getMigrationTable } from \"../migration_utils\";\nimport { SqliteConnectionInstance } from \"../../sql/sql_data_source_types\";\n\ndotenv.config();\n\nexport async function migrationRollBackSqlite(\n  rollBackUntil?: string,\n): Promise<void> {\n  const sql = await SqlDataSource.connect();\n  const sqlConnection = sql.getCurrentConnection() as SqliteConnectionInstance;\n\n  try {\n    const migrationTable: MigrationTableType[] =\n      (await getMigrationTable(sqlConnection)) || [];\n    const migrations: Migration[] = await getMigrations();\n\n    const tableMigrations = migrationTable.map((migration) => migration.name);\n    const pendingMigrations = migrations.filter((migration) =>\n      tableMigrations.includes(migration.migrationName),\n    );\n\n    if (pendingMigrations.length === 0) {\n      logger.info(\"No pending migrations.\");\n      await sql.closeConnection();\n      process.exit(0);\n    }\n\n    if (rollBackUntil) {\n      const rollBackUntilIndex = pendingMigrations.findIndex(\n        (migration) => migration.migrationName === rollBackUntil,\n      );\n\n      if (rollBackUntilIndex === -1) {\n        throw new Error(`Migration ${rollBackUntil} not found.`);\n      }\n\n      const filteredMigrations = pendingMigrations.slice(rollBackUntilIndex);\n      const migrationController = new MigrationController(\n        sql,\n        sqlConnection,\n        \"sqlite\",\n      );\n\n      await migrationController.downMigrations(filteredMigrations);\n      return;\n    }\n\n    const migrationController = new MigrationController(\n      sql,\n      sqlConnection,\n      \"sqlite\",\n    );\n    await migrationController.downMigrations(pendingMigrations);\n  } finally {\n    await sql.closeConnection();\n  }\n}\n"],"mappings":"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","names":["winston","dotenv","path","fs","import_dotenv","import_dotenv","import_dotenv","dotenv","column","dynamicColumn","column","relationModel","dynamicColumn","column","column","column","modelColumn","column","alias","relation","column","column","modelColumn","column","relation","column","column","column","query","params","rawQuery","query","column","column","result","join","idsToFetchList","import_reflect_metadata","column","join","column","result","join","table","sqLiteConnection","err","query","params","resolve","reject","rows","import_dotenv","dotenv","migrationModule","path","fs","dotenv","migrationController","import_dotenv","dotenv","migrationController","import_dotenv","dotenv","migrationController","dotenv","import_dotenv","import_dotenv","dotenv","migrationController","import_dotenv","dotenv","migrationController","import_dotenv","dotenv","migrationController","dotenv"]}
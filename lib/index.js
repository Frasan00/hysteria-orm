"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse2(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name3) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name3 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/mssql/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/mssql/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable2;
      createDebug.enable = enable2;
      createDebug.enabled = enabled2;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy2;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable2(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable2() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled2(name3) {
        if (name3[name3.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name3)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name3)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy2() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/mssql/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/mssql/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/supports-color/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/supports-color/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os3 = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os3.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/mssql/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/mssql/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init2;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name3, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name3} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name3 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log3(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/mssql/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/mssql/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@tediousjs/connection-string/lib/parser/connection-string.js
var require_connection_string = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/parser/connection-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CollectionMode;
    (function(CollectionMode2) {
      CollectionMode2[CollectionMode2["key"] = 0] = "key";
      CollectionMode2[CollectionMode2["value"] = 1] = "value";
    })(CollectionMode || (CollectionMode = {}));
    var CONFIG = Object.freeze({
      key: {
        terminator: "=",
        quotes: {}
      },
      value: {
        terminator: ";",
        quotes: {
          '"': '"',
          "'": "'",
          "{": "}"
        }
      }
    });
    function connectionStringParser(connectionString, parserConfig = CONFIG) {
      const parsed = {};
      let collectionMode = CollectionMode.key;
      let started = false;
      let finished = false;
      let quoted = false;
      let quote = "";
      let buffer = "";
      let currentKey = "";
      let pointer = 0;
      function start() {
        started = true;
      }
      function finish() {
        finished = true;
      }
      function reset() {
        started = false;
        finished = false;
        quoted = false;
        quote = "";
        buffer = "";
      }
      function config() {
        return collectionMode === CollectionMode.key ? parserConfig.key : parserConfig.value;
      }
      function isTerminator(char) {
        return config().terminator === char;
      }
      function isStartQuote(char) {
        return Object.keys(config().quotes).some((val) => char === val);
      }
      function isEndQuote(char) {
        return quoted && char === config().quotes[quote];
      }
      function push(char) {
        buffer += char;
      }
      function collect() {
        if (!quoted) {
          buffer = buffer.trim();
        }
        switch (collectionMode) {
          case CollectionMode.key:
            currentKey = buffer.toLowerCase();
            collectionMode = CollectionMode.value;
            break;
          case CollectionMode.value:
            collectionMode = CollectionMode.key;
            parsed[currentKey] = buffer;
            currentKey = "";
            break;
        }
        reset();
      }
      while (pointer < connectionString.length) {
        const current = connectionString.charAt(pointer);
        if (!finished) {
          if (!started) {
            if (current.trim()) {
              start();
              if (isStartQuote(current)) {
                quoted = true;
                quote = current;
              } else {
                push(current);
              }
            }
          } else {
            if (quoted && isEndQuote(current)) {
              const next = connectionString.charAt(pointer + 1);
              if (current === next) {
                push(current);
                pointer++;
              } else {
                finish();
              }
            } else if (!quoted && isTerminator(current)) {
              const next = connectionString.charAt(pointer + 1);
              if (current === next) {
                push(current);
                pointer++;
              } else {
                collect();
              }
            } else {
              push(current);
            }
          }
        } else if (isTerminator(current)) {
          collect();
        } else if (current.trim()) {
          throw new Error("Malformed connection string");
        }
        pointer++;
      }
      if (quoted && !finished) {
        throw new Error("Connection string terminated unexpectedly");
      } else {
        collect();
      }
      return parsed;
    }
    exports2.default = connectionStringParser;
  }
});

// node_modules/@tediousjs/connection-string/lib/parser/sql-connection-string.js
var require_sql_connection_string = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/parser/sql-connection-string.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SCHEMA = exports2.SchemaTypes = void 0;
    var connection_string_1 = __importDefault(require_connection_string());
    var SchemaTypes;
    (function(SchemaTypes2) {
      SchemaTypes2[SchemaTypes2["BOOL"] = 0] = "BOOL";
      SchemaTypes2[SchemaTypes2["STRING"] = 1] = "STRING";
      SchemaTypes2[SchemaTypes2["NUMBER"] = 2] = "NUMBER";
    })(SchemaTypes = exports2.SchemaTypes || (exports2.SchemaTypes = {}));
    exports2.SCHEMA = {
      "Application Name": {
        type: SchemaTypes.STRING,
        aliases: ["App"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "ApplicationIntent": {
        type: SchemaTypes.STRING,
        allowedValues: ["ReadOnly", "ReadWrite"],
        default: "ReadWrite"
      },
      "Asynchronous Processing": {
        type: SchemaTypes.BOOL,
        default: false,
        aliases: ["Async"]
      },
      "AttachDBFilename": {
        type: SchemaTypes.STRING,
        aliases: ["Extended Properties", "Initial File Name"]
      },
      "Authentication": {
        type: SchemaTypes.STRING,
        allowedValues: ["Active Directory Integrated", "Active Directory Password", "Sql Password"]
      },
      "Column Encryption Setting": {
        type: SchemaTypes.STRING
      },
      "Connection Timeout": {
        type: SchemaTypes.NUMBER,
        aliases: ["Connect Timeout", "Timeout"],
        default: 15
      },
      "Connection Lifetime": {
        type: SchemaTypes.NUMBER,
        aliases: ["Load Balance Timeout"],
        default: 0
      },
      "ConnectRetryCount": {
        type: SchemaTypes.NUMBER,
        default: 1,
        validator(val) {
          return val > 0 && val <= 255;
        }
      },
      "ConnectRetryInterval": {
        type: SchemaTypes.NUMBER,
        default: 10
      },
      "Context Connection": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Current Language": {
        aliases: ["Language"],
        type: SchemaTypes.STRING,
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Data Source": {
        aliases: ["Addr", "Address", "Server", "Network Address"],
        type: SchemaTypes.STRING
      },
      "Encrypt": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Enlist": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "Failover Partner": {
        type: SchemaTypes.STRING
      },
      "Initial Catalog": {
        type: SchemaTypes.STRING,
        aliases: ["Database"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Integrated Security": {
        type: SchemaTypes.BOOL,
        aliases: ["Trusted_Connection"],
        coerce(val) {
          return val === "sspi" || null;
        }
      },
      "Max Pool Size": {
        type: SchemaTypes.NUMBER,
        default: 100,
        validator(val) {
          return val >= 1;
        }
      },
      "Min Pool Size": {
        type: SchemaTypes.NUMBER,
        default: 0,
        validator(val) {
          return val >= 0;
        }
      },
      "MultipleActiveResultSets": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "MultiSubnetFailover": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Network Library": {
        type: SchemaTypes.STRING,
        aliases: ["Network", "Net"],
        allowedValues: ["dbnmpntw", "dbmsrpcn", "dbmsadsn", "dbmsgnet", "dbmslpcn", "dbmsspxn", "dbmssocn", "Dbmsvinn"]
      },
      "Packet Size": {
        type: SchemaTypes.NUMBER,
        default: 8e3,
        validator(val) {
          return val >= 512 && val <= 32768;
        }
      },
      "Password": {
        type: SchemaTypes.STRING,
        aliases: ["PWD"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Persist Security Info": {
        type: SchemaTypes.BOOL,
        aliases: ["PersistSecurityInfo"],
        default: false
      },
      "PoolBlockingPeriod": {
        type: SchemaTypes.NUMBER,
        default: 0,
        coerce(val) {
          if (typeof val !== "string") {
            return null;
          }
          switch (val.toLowerCase()) {
            case "alwaysblock":
              return 1;
            case "auto":
              return 0;
            case "neverblock":
              return 2;
          }
          return null;
        }
      },
      "Pooling": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "Replication": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Transaction Binding": {
        type: SchemaTypes.STRING,
        allowedValues: ["Implicit Unbind", "Explicit Unbind"],
        default: "Implicit Unbind"
      },
      "TransparentNetworkIPResolution": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "TrustServerCertificate": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Type System Version": {
        type: SchemaTypes.STRING,
        allowedValues: ["SQL Server 2012", "SQL Server 2008", "SQL Server 2005", "Latest"]
      },
      "User ID": {
        type: SchemaTypes.STRING,
        aliases: ["UID"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "User Instance": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Workstation ID": {
        type: SchemaTypes.STRING,
        aliases: ["WSID"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      }
    };
    function guessType(value) {
      if (value.trim() === "") {
        return SchemaTypes.STRING;
      }
      const asNum = parseInt(value, 10);
      if (!Number.isNaN(asNum) && asNum.toString() === value) {
        return SchemaTypes.NUMBER;
      }
      if (["true", "false", "yes", "no"].includes(value.toLowerCase())) {
        return SchemaTypes.BOOL;
      }
      return SchemaTypes.STRING;
    }
    function coerce(value, type2, coercer) {
      if (coercer) {
        const coerced = coercer(value);
        if (coerced !== null) {
          return coerced;
        }
      }
      switch (type2) {
        case SchemaTypes.BOOL:
          if (["true", "yes", "1"].includes(value.toLowerCase())) {
            return true;
          }
          if (["false", "no", "0"].includes(value.toLowerCase())) {
            return false;
          }
          return value;
        case SchemaTypes.NUMBER:
          return parseInt(value, 10);
      }
      return value;
    }
    function validate2(value, allowedValues, validator) {
      let valid = true;
      if (validator) {
        valid = validator(value);
      }
      if (valid) {
        valid = (allowedValues === null || allowedValues === void 0 ? void 0 : allowedValues.includes(value)) || false;
      }
      return valid;
    }
    function parseSqlConnectionString(connectionString, canonicalProps = false, allowUnknown = false, strict = false, schema = exports2.SCHEMA) {
      const flattenedSchema = Object.entries(schema).reduce((flattened, [key, item]) => {
        var _a3;
        Object.assign(flattened, {
          [key.toLowerCase()]: item
        });
        return ((_a3 = item.aliases) === null || _a3 === void 0 ? void 0 : _a3.reduce((accum, alias) => {
          return Object.assign(accum, {
            [alias.toLowerCase()]: {
              ...item,
              canonical: key.toLowerCase()
            }
          });
        }, flattened)) || flattened;
      }, {});
      return Object.entries((0, connection_string_1.default)(connectionString)).reduce((config, [prop, value]) => {
        if (!Object.prototype.hasOwnProperty.call(flattenedSchema, prop)) {
          return Object.assign(config, {
            [prop]: coerce(value, guessType(value))
          });
        }
        let coercedValue = coerce(value, flattenedSchema[prop].type, flattenedSchema[prop].coerce);
        if (strict && !validate2(coercedValue, flattenedSchema[prop].allowedValues, flattenedSchema[prop].validator)) {
          coercedValue = flattenedSchema[prop].default;
        }
        const propName = canonicalProps ? flattenedSchema[prop].canonical || prop : prop;
        return Object.assign(config, {
          [propName]: coercedValue
        });
      }, {});
    }
    exports2.default = parseSqlConnectionString;
  }
});

// node_modules/@tediousjs/connection-string/lib/builder/index.js
var require_builder = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildConnectionString = void 0;
    function isQuoted(val) {
      if (val[0] !== "{") {
        return false;
      }
      for (let i = 1; i < val.length; i++) {
        if (val[i] === "}") {
          if (i + 1 === val.length) {
            return true;
          } else if (val[i + 1] !== "}") {
            return false;
          } else {
            i++;
          }
        }
      }
      return false;
    }
    function needsQuotes(val) {
      var _a3;
      return !isQuoted(val) && !!((_a3 = val.match(/\[|]|{|}|\|\(|\)|,|;|\?|\*|=|!|@/)) === null || _a3 === void 0 ? void 0 : _a3.length);
    }
    function encodeTuple(key, value) {
      if (value === null || value === void 0) {
        return [key, ""];
      }
      switch (typeof value) {
        case "boolean":
          return [key, value ? "Yes" : "No"];
        default: {
          const strVal = value.toString();
          if (needsQuotes(strVal)) {
            return [key, `{${strVal.replace(/}/g, "}}")}}`];
          }
          return [key, strVal];
        }
      }
    }
    function buildConnectionString(data) {
      return Object.entries(data).map(([key, value]) => {
        return encodeTuple(key.trim(), value).join("=");
      }).join(";");
    }
    exports2.buildConnectionString = buildConnectionString;
  }
});

// node_modules/@tediousjs/connection-string/lib/index.js
var require_lib = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSqlConnectionString = exports2.parseConnectionString = void 0;
    var connection_string_1 = __importDefault(require_connection_string());
    exports2.parseConnectionString = connection_string_1.default;
    var sql_connection_string_1 = __importDefault(require_sql_connection_string());
    exports2.parseSqlConnectionString = sql_connection_string_1.default;
    __exportStar(require_builder(), exports2);
  }
});

// node_modules/tarn/dist/TimeoutError.js
var require_TimeoutError = __commonJS({
  "node_modules/tarn/dist/TimeoutError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TimeoutError = class extends Error {
    };
    exports2.TimeoutError = TimeoutError;
  }
});

// node_modules/tarn/dist/PromiseInspection.js
var require_PromiseInspection = __commonJS({
  "node_modules/tarn/dist/PromiseInspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PromiseInspection = class {
      constructor(args) {
        this._value = args.value;
        this._error = args.error;
      }
      value() {
        return this._value;
      }
      reason() {
        return this._error;
      }
      isRejected() {
        return !!this._error;
      }
      isFulfilled() {
        return !!this._value;
      }
    };
    exports2.PromiseInspection = PromiseInspection;
  }
});

// node_modules/tarn/dist/utils.js
var require_utils = __commonJS({
  "node_modules/tarn/dist/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PromiseInspection_1 = require_PromiseInspection();
    function defer() {
      let resolve = null;
      let reject = null;
      const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
      });
      return {
        promise,
        resolve,
        reject
      };
    }
    exports2.defer = defer;
    function now() {
      return Date.now();
    }
    exports2.now = now;
    function duration(t1, t2) {
      return Math.abs(t2 - t1);
    }
    exports2.duration = duration;
    function checkOptionalTime(time) {
      if (typeof time === "undefined") {
        return true;
      }
      return checkRequiredTime(time);
    }
    exports2.checkOptionalTime = checkOptionalTime;
    function checkRequiredTime(time) {
      return typeof time === "number" && time === Math.round(time) && time > 0;
    }
    exports2.checkRequiredTime = checkRequiredTime;
    function delay4(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    exports2.delay = delay4;
    function reflect(promise) {
      return promise.then((value) => {
        return new PromiseInspection_1.PromiseInspection({ value });
      }).catch((error) => {
        return new PromiseInspection_1.PromiseInspection({ error });
      });
    }
    exports2.reflect = reflect;
    function tryPromise(cb) {
      try {
        const result = cb();
        return Promise.resolve(result);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    exports2.tryPromise = tryPromise;
  }
});

// node_modules/tarn/dist/PendingOperation.js
var require_PendingOperation = __commonJS({
  "node_modules/tarn/dist/PendingOperation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TimeoutError_1 = require_TimeoutError();
    var utils_1 = require_utils();
    var PendingOperation = class {
      constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout(this.deferred.promise, timeoutMillis).catch((err) => {
          if (err instanceof TimeoutError_1.TimeoutError) {
            if (this.possibleTimeoutCause) {
              err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
            } else {
              err = new TimeoutError_1.TimeoutError("operation timed out for an unknown reason");
            }
          }
          this.isRejected = true;
          return Promise.reject(err);
        });
      }
      abort() {
        this.reject(new Error("aborted"));
      }
      reject(err) {
        this.deferred.reject(err);
      }
      resolve(value) {
        this.deferred.resolve(value);
      }
    };
    exports2.PendingOperation = PendingOperation;
    function timeout(promise, time) {
      return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
        promise.then((result) => {
          clearTimeout(timeoutHandle);
          resolve(result);
        }).catch((err) => {
          clearTimeout(timeoutHandle);
          reject(err);
        });
      });
    }
  }
});

// node_modules/tarn/dist/Resource.js
var require_Resource = __commonJS({
  "node_modules/tarn/dist/Resource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils();
    var Resource = class _Resource {
      constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1.now();
        this.deferred = utils_1.defer();
      }
      get promise() {
        return this.deferred.promise;
      }
      resolve() {
        this.deferred.resolve(void 0);
        return new _Resource(this.resource);
      }
    };
    exports2.Resource = Resource;
  }
});

// node_modules/tarn/dist/Pool.js
var require_Pool = __commonJS({
  "node_modules/tarn/dist/Pool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PendingOperation_1 = require_PendingOperation();
    var Resource_1 = require_Resource();
    var utils_1 = require_utils();
    var events_1 = require("events");
    var timers_1 = require("timers");
    var Pool = class {
      constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
          throw new Error("Tarn: opt.create function most be provided");
        }
        if (!opt.destroy) {
          throw new Error("Tarn: opt.destroy function most be provided");
        }
        if (typeof opt.min !== "number" || opt.min < 0 || opt.min !== Math.round(opt.min)) {
          throw new Error("Tarn: opt.min must be an integer >= 0");
        }
        if (typeof opt.max !== "number" || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
          throw new Error("Tarn: opt.max must be an integer > 0");
        }
        if (opt.min > opt.max) {
          throw new Error("Tarn: opt.max is smaller than opt.min");
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
          throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
          throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
          create: true,
          validate: true,
          destroy: true,
          log: true,
          min: true,
          max: true,
          acquireTimeoutMillis: true,
          createTimeoutMillis: true,
          destroyTimeoutMillis: true,
          idleTimeoutMillis: true,
          reapIntervalMillis: true,
          createRetryIntervalMillis: true,
          propagateCreateError: true
        };
        for (const key of Object.keys(opt)) {
          if (!allowedKeys[key]) {
            throw new Error(`Tarn: unsupported option opt.${key}`);
          }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === "function" ? opt.validate : () => true;
        this.log = opt.log || (() => {
        });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 3e4;
        this.createTimeoutMillis = opt.createTimeoutMillis || 3e4;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5e3;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 3e4;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1e3;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        this.used = [];
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
      }
      numUsed() {
        return this.used.length;
      }
      numFree() {
        return this.free.length;
      }
      numPendingAcquires() {
        return this.pendingAcquires.length;
      }
      numPendingValidations() {
        return this.pendingValidations.length;
      }
      numPendingCreates() {
        return this.pendingCreates.length;
      }
      acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers("acquireRequest", eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        pendingAcquire.promise = pendingAcquire.promise.then((resource) => {
          this._executeEventHandlers("acquireSuccess", eventId, resource);
          return resource;
        }).catch((err) => {
          this._executeEventHandlers("acquireFail", eventId, err);
          remove(this.pendingAcquires, pendingAcquire);
          return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
      }
      release(resource) {
        this._executeEventHandlers("release", resource);
        for (let i = 0, l = this.used.length; i < l; ++i) {
          const used = this.used[i];
          if (used.resource === resource) {
            this.used.splice(i, 1);
            this.free.push(used.resolve());
            this._tryAcquireOrCreate();
            return true;
          }
        }
        return false;
      }
      isEmpty() {
        return [
          this.numFree(),
          this.numUsed(),
          this.numPendingAcquires(),
          this.numPendingValidations(),
          this.numPendingCreates()
        ].reduce((total, value) => total + value) === 0;
      }
      /**
       * Reaping cycle.
       */
      check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach((free) => {
          if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {
            numDestroyed++;
            this._destroy(free.resource);
          } else {
            newFree.push(free);
          }
        });
        this.free = newFree;
        if (this.isEmpty()) {
          this._stopReaping();
        }
      }
      destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers("poolDestroyRequest", eventId);
        this._stopReaping();
        this.destroyed = true;
        return utils_1.reflect(Promise.all(this.pendingCreates.map((create) => utils_1.reflect(create.promise))).then(() => {
          return new Promise((resolve, reject) => {
            if (this.numPendingValidations() === 0) {
              resolve();
              return;
            }
            const interval = setInterval(() => {
              if (this.numPendingValidations() === 0) {
                timers_1.clearInterval(interval);
                resolve();
              }
            }, 100);
          });
        }).then(() => {
          return Promise.all(this.used.map((used) => utils_1.reflect(used.promise)));
        }).then(() => {
          return Promise.all(this.pendingAcquires.map((acquire) => {
            acquire.abort();
            return utils_1.reflect(acquire.promise);
          }));
        }).then(() => {
          return Promise.all(this.free.map((free) => utils_1.reflect(this._destroy(free.resource))));
        }).then(() => {
          return Promise.all(this.pendingDestroys.map((pd) => pd.promise));
        }).then(() => {
          this.free = [];
          this.pendingAcquires = [];
        })).then((res) => {
          this._executeEventHandlers("poolDestroySuccess", eventId);
          this.emitter.removeAllListeners();
          return res;
        });
      }
      on(event, listener) {
        this.emitter.on(event, listener);
      }
      removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
      }
      removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
      }
      /**
       * The most important method that is called always when resources
       * are created / destroyed / acquired / released. In other words
       * every time when resources are moved from used to free or vice
       * versa.
       *
       * Either assigns free resources to pendingAcquires or creates new
       * resources if there is room for it in the pool.
       */
      _tryAcquireOrCreate() {
        if (this.destroyed) {
          return;
        }
        if (this._hasFreeResources()) {
          this._doAcquire();
        } else if (this._shouldCreateMoreResources()) {
          this._doCreate();
        }
      }
      _hasFreeResources() {
        return this.free.length > 0;
      }
      _doAcquire() {
        while (this._canAcquire()) {
          const pendingAcquire = this.pendingAcquires.shift();
          const free = this.free.pop();
          if (free === void 0 || pendingAcquire === void 0) {
            const errMessage = "this.free was empty while trying to acquire resource";
            this.log(`Tarn: ${errMessage}`, "warn");
            throw new Error(`Internal error, should never happen. ${errMessage}`);
          }
          this.pendingValidations.push(pendingAcquire);
          this.used.push(free);
          const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
          pendingAcquire.promise.catch((err) => {
            abortAbleValidation.abort();
          });
          abortAbleValidation.promise.catch((err) => {
            this.log("Tarn: resource validator threw an exception " + err.stack, "warn");
            return false;
          }).then((validationSuccess) => {
            try {
              if (validationSuccess && !pendingAcquire.isRejected) {
                this._startReaping();
                pendingAcquire.resolve(free.resource);
              } else {
                remove(this.used, free);
                if (!validationSuccess) {
                  this._destroy(free.resource);
                  setTimeout(() => {
                    this._tryAcquireOrCreate();
                  }, 0);
                } else {
                  this.free.push(free);
                }
                if (!pendingAcquire.isRejected) {
                  this.pendingAcquires.unshift(pendingAcquire);
                }
              }
            } finally {
              remove(this.pendingValidations, pendingAcquire);
            }
          });
          this._validateResource(free.resource).then((validationSuccess) => {
            abortAbleValidation.resolve(validationSuccess);
          }).catch((err) => {
            abortAbleValidation.reject(err);
          });
        }
      }
      _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
      }
      _validateResource(resource) {
        try {
          return Promise.resolve(this.validate(resource));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _shouldCreateMoreResources() {
        return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
      }
      _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise.then(() => {
          this._tryAcquireOrCreate();
          return null;
        }).catch((err) => {
          if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
            this.pendingAcquires[0].reject(err);
          }
          pendingAcquiresBeforeCreate.forEach((pendingAcquire) => {
            pendingAcquire.possibleTimeoutCause = err;
          });
          utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
      }
      _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers("createRequest", eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        pendingCreate.promise = pendingCreate.promise.catch((err) => {
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator).then((resource) => {
          if (pendingCreate.isRejected) {
            this.destroyer(resource);
            return null;
          }
          remove(this.pendingCreates, pendingCreate);
          this.free.push(new Resource_1.Resource(resource));
          pendingCreate.resolve(resource);
          this._executeEventHandlers("createSuccess", eventId, resource);
          return null;
        }).catch((err) => {
          if (pendingCreate.isRejected) {
            return null;
          }
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          pendingCreate.reject(err);
          return null;
        });
        return pendingCreate;
      }
      _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers("destroyRequest", eventId, resource);
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal.then(() => {
          pendingDestroy.resolve(resource);
        }).catch((err) => {
          pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        return pendingDestroy.promise.then((res) => {
          this._executeEventHandlers("destroySuccess", eventId, resource);
          return res;
        }).catch((err) => this._logDestroyerError(eventId, resource, err)).then((res) => {
          const index = this.pendingDestroys.findIndex((pd) => pd === pendingDestroy);
          this.pendingDestroys.splice(index, 1);
          return res;
        });
      }
      _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers("destroyFail", eventId, resource, err);
        this.log("Tarn: resource destroyer threw an exception " + err.stack, "warn");
      }
      _startReaping() {
        if (!this.interval) {
          this._executeEventHandlers("startReaping");
          this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
      }
      _stopReaping() {
        if (this.interval !== null) {
          this._executeEventHandlers("stopReaping");
          timers_1.clearInterval(this.interval);
        }
        this.interval = null;
      }
      _executeEventHandlers(eventName, ...args) {
        const listeners = this.emitter.listeners(eventName);
        listeners.forEach((listener) => {
          try {
            listener(...args);
          } catch (err) {
            this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, "warn");
          }
        });
      }
    };
    exports2.Pool = Pool;
    function remove(arr, item) {
      const idx = arr.indexOf(item);
      if (idx === -1) {
        return false;
      } else {
        arr.splice(idx, 1);
        return true;
      }
    }
    function callbackOrPromise(func) {
      return new Promise((resolve, reject) => {
        const callback = (err, resource) => {
          if (err) {
            reject(err);
          } else {
            resolve(resource);
          }
        };
        utils_1.tryPromise(() => func(callback)).then((res) => {
          if (res) {
            resolve(res);
          }
        }).catch((err) => {
          reject(err);
        });
      });
    }
  }
});

// node_modules/tarn/dist/tarn.js
var require_tarn = __commonJS({
  "node_modules/tarn/dist/tarn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Pool_1 = require_Pool();
    exports2.Pool = Pool_1.Pool;
    var TimeoutError_1 = require_TimeoutError();
    exports2.TimeoutError = TimeoutError_1.TimeoutError;
    module2.exports = {
      Pool: Pool_1.Pool,
      TimeoutError: TimeoutError_1.TimeoutError
    };
  }
});

// node_modules/mssql/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/mssql/lib/utils.js"(exports2, module2) {
    "use strict";
    var IDS = /* @__PURE__ */ new WeakMap();
    var INCREMENT = {
      Connection: 1,
      ConnectionPool: 1,
      Request: 1,
      Transaction: 1,
      PreparedStatement: 1
    };
    module2.exports = {
      objectHasProperty: (object, property) => Object.prototype.hasOwnProperty.call(object, property),
      INCREMENT,
      IDS: {
        get: IDS.get.bind(IDS),
        add: (object, type2, id) => {
          if (id)
            return IDS.set(object, id);
          IDS.set(object, INCREMENT[type2]++);
        }
      }
    };
  }
});

// node_modules/mssql/lib/error/mssql-error.js
var require_mssql_error = __commonJS({
  "node_modules/mssql/lib/error/mssql-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = class extends Error {
      /**
       * Creates a new ConnectionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        if (message instanceof Error) {
          super(message.message);
          this.code = message.code || code;
          Error.captureStackTrace(this, this.constructor);
          Object.defineProperty(this, "originalError", { enumerable: true, value: message });
        } else {
          super(message);
          this.code = code;
        }
        this.name = "MSSQLError";
      }
    };
    module2.exports = MSSQLError;
  }
});

// node_modules/mssql/lib/error/connection-error.js
var require_connection_error = __commonJS({
  "node_modules/mssql/lib/error/connection-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var ConnectionError = class extends MSSQLError {
      /**
       * Creates a new ConnectionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "ConnectionError";
      }
    };
    module2.exports = ConnectionError;
  }
});

// node_modules/mssql/lib/datatypes.js
var require_datatypes = __commonJS({
  "node_modules/mssql/lib/datatypes.js"(exports2, module2) {
    "use strict";
    var objectHasProperty2 = require_utils2().objectHasProperty;
    var inspect2 = Symbol.for("nodejs.util.inspect.custom");
    var TYPES = {
      VarChar(length) {
        return { type: TYPES.VarChar, length };
      },
      NVarChar(length) {
        return { type: TYPES.NVarChar, length };
      },
      Text() {
        return { type: TYPES.Text };
      },
      Int() {
        return { type: TYPES.Int };
      },
      BigInt() {
        return { type: TYPES.BigInt };
      },
      TinyInt() {
        return { type: TYPES.TinyInt };
      },
      SmallInt() {
        return { type: TYPES.SmallInt };
      },
      Bit() {
        return { type: TYPES.Bit };
      },
      Float() {
        return { type: TYPES.Float };
      },
      Numeric(precision, scale) {
        return { type: TYPES.Numeric, precision, scale };
      },
      Decimal(precision, scale) {
        return { type: TYPES.Decimal, precision, scale };
      },
      Real() {
        return { type: TYPES.Real };
      },
      Date() {
        return { type: TYPES.Date };
      },
      DateTime() {
        return { type: TYPES.DateTime };
      },
      DateTime2(scale) {
        return { type: TYPES.DateTime2, scale };
      },
      DateTimeOffset(scale) {
        return { type: TYPES.DateTimeOffset, scale };
      },
      SmallDateTime() {
        return { type: TYPES.SmallDateTime };
      },
      Time(scale) {
        return { type: TYPES.Time, scale };
      },
      UniqueIdentifier() {
        return { type: TYPES.UniqueIdentifier };
      },
      SmallMoney() {
        return { type: TYPES.SmallMoney };
      },
      Money() {
        return { type: TYPES.Money };
      },
      Binary(length) {
        return { type: TYPES.Binary, length };
      },
      VarBinary(length) {
        return { type: TYPES.VarBinary, length };
      },
      Image() {
        return { type: TYPES.Image };
      },
      Xml() {
        return { type: TYPES.Xml };
      },
      Char(length) {
        return { type: TYPES.Char, length };
      },
      NChar(length) {
        return { type: TYPES.NChar, length };
      },
      NText() {
        return { type: TYPES.NText };
      },
      TVP(tvpType) {
        return { type: TYPES.TVP, tvpType };
      },
      UDT() {
        return { type: TYPES.UDT };
      },
      Geography() {
        return { type: TYPES.Geography };
      },
      Geometry() {
        return { type: TYPES.Geometry };
      },
      Variant() {
        return { type: TYPES.Variant };
      }
    };
    module2.exports.TYPES = TYPES;
    module2.exports.DECLARATIONS = {};
    var zero = function(value, length) {
      if (length == null)
        length = 2;
      value = String(value);
      if (value.length < length) {
        for (let i = 1; i <= length - value.length; i++) {
          value = `0${value}`;
        }
      }
      return value;
    };
    for (const key in TYPES) {
      if (objectHasProperty2(TYPES, key)) {
        const value = TYPES[key];
        value.declaration = key.toLowerCase();
        module2.exports.DECLARATIONS[value.declaration] = value;
        ((key2, value2) => {
          value2[inspect2] = () => `[sql.${key2}]`;
        })(key, value);
      }
    }
    module2.exports.declare = (type2, options) => {
      switch (type2) {
        case TYPES.VarChar:
        case TYPES.VarBinary:
          return `${type2.declaration} (${options.length > 8e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
        case TYPES.NVarChar:
          return `${type2.declaration} (${options.length > 4e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
        case TYPES.Char:
        case TYPES.NChar:
        case TYPES.Binary:
          return `${type2.declaration} (${options.length == null ? 1 : options.length})`;
        case TYPES.Decimal:
        case TYPES.Numeric:
          return `${type2.declaration} (${options.precision == null ? 18 : options.precision}, ${options.scale == null ? 0 : options.scale})`;
        case TYPES.Time:
        case TYPES.DateTime2:
        case TYPES.DateTimeOffset:
          return `${type2.declaration} (${options.scale == null ? 7 : options.scale})`;
        case TYPES.TVP:
          return `${options.tvpType} readonly`;
        default:
          return type2.declaration;
      }
    };
    module2.exports.cast = (value, type2, options) => {
      if (value == null) {
        return null;
      }
      switch (typeof value) {
        case "string":
          return `N'${value.replace(/'/g, "''")}'`;
        case "number":
        case "bigint":
          return value;
        case "boolean":
          return value ? 1 : 0;
        case "object":
          if (value instanceof Date) {
            let ns = value.getUTCMilliseconds() / 1e3;
            if (value.nanosecondDelta != null) {
              ns += value.nanosecondDelta;
            }
            const scale = options.scale == null ? 7 : options.scale;
            if (scale > 0) {
              ns = String(ns).substr(1, scale + 1);
            } else {
              ns = "";
            }
            return `N'${value.getUTCFullYear()}-${zero(value.getUTCMonth() + 1)}-${zero(value.getUTCDate())} ${zero(value.getUTCHours())}:${zero(value.getUTCMinutes())}:${zero(value.getUTCSeconds())}${ns}'`;
          } else if (Buffer.isBuffer(value)) {
            return `0x${value.toString("hex")}`;
          }
          return null;
        default:
          return null;
      }
    };
  }
});

// node_modules/mssql/lib/table.js
var require_table = __commonJS({
  "node_modules/mssql/lib/table.js"(exports2, module2) {
    "use strict";
    var TYPES = require_datatypes().TYPES;
    var declareType = require_datatypes().declare;
    var objectHasProperty2 = require_utils2().objectHasProperty;
    var MAX = 65535;
    var JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
    function Table(name3) {
      if (name3) {
        const parsed = Table.parseName(name3);
        this.name = parsed.name;
        this.schema = parsed.schema;
        this.database = parsed.database;
        this.path = (this.database ? `[${this.database}].` : "") + (this.schema ? `[${this.schema}].` : "") + `[${this.name}]`;
        this.temporary = this.name.charAt(0) === "#";
      }
      this.columns = [];
      this.rows = [];
      Object.defineProperty(this.columns, "add", {
        value(name4, column2, options) {
          if (column2 == null) {
            throw new Error("Column data type is not defined.");
          }
          if (column2 instanceof Function) {
            column2 = column2();
          }
          options = options || {};
          column2.name = name4;
          ["nullable", "primary", "identity", "readOnly", "length"].forEach((prop) => {
            if (objectHasProperty2(options, prop)) {
              column2[prop] = options[prop];
            }
          });
          return this.push(column2);
        }
      });
      Object.defineProperty(
        this.rows,
        "add",
        {
          value() {
            return this.push(Array.prototype.slice.call(arguments));
          }
        }
      );
      Object.defineProperty(
        this.rows,
        "clear",
        {
          value() {
            return this.splice(0, this.length);
          }
        }
      );
    }
    Table.prototype._makeBulk = function _makeBulk() {
      for (let i = 0; i < this.columns.length; i++) {
        const col = this.columns[i];
        switch (col.type) {
          case TYPES.Date:
          case TYPES.DateTime:
          case TYPES.DateTime2:
            for (let j = 0; j < this.rows.length; j++) {
              const dateValue = this.rows[j][i];
              if (typeof dateValue === "string" || typeof dateValue === "number") {
                const date = new Date(dateValue);
                if (isNaN(date.getDate())) {
                  throw new TypeError("Invalid date value passed to bulk rows");
                }
                this.rows[j][i] = date;
              }
            }
            break;
          case TYPES.Xml:
            col.type = TYPES.NVarChar(MAX).type;
            break;
          case TYPES.UDT:
          case TYPES.Geography:
          case TYPES.Geometry:
            col.type = TYPES.VarBinary(MAX).type;
            break;
          default:
            break;
        }
      }
      return this;
    };
    Table.prototype.declare = function declare() {
      const pkey = this.columns.filter((col) => col.primary === true).map((col) => `[${col.name}]`);
      const cols = this.columns.map((col) => {
        const def = [`[${col.name}] ${declareType(col.type, col)}`];
        if (col.nullable === true) {
          def.push("null");
        } else if (col.nullable === false) {
          def.push("not null");
        }
        if (col.primary === true && pkey.length === 1) {
          def.push("primary key");
        }
        return def.join(" ");
      });
      const constraint = pkey.length > 1 ? `, constraint [PK_${this.temporary ? this.name.substr(1) : this.name}] primary key (${pkey.join(", ")})` : "";
      return `create table ${this.path} (${cols.join(", ")}${constraint})`;
    };
    Table.fromRecordset = function fromRecordset(recordset, name3) {
      const t = new this(name3);
      for (const colName in recordset.columns) {
        if (objectHasProperty2(recordset.columns, colName)) {
          const col = recordset.columns[colName];
          t.columns.add(colName, {
            type: col.type,
            length: col.length,
            scale: col.scale,
            precision: col.precision
          }, {
            nullable: col.nullable,
            identity: col.identity,
            readOnly: col.readOnly
          });
        }
      }
      if (t.columns.length === 1 && t.columns[0].name === JSON_COLUMN_ID) {
        for (let i = 0; i < recordset.length; i++) {
          t.rows.add(JSON.stringify(recordset[i]));
        }
      } else {
        for (let i = 0; i < recordset.length; i++) {
          t.rows.add.apply(t.rows, t.columns.map((col) => recordset[i][col.name]));
        }
      }
      return t;
    };
    Table.parseName = function parseName(name3) {
      const length = name3.length;
      let cursor = -1;
      let buffer = "";
      let escaped = false;
      const path4 = [];
      while (++cursor < length) {
        const char = name3.charAt(cursor);
        if (char === "[") {
          if (escaped) {
            buffer += char;
          } else {
            escaped = true;
          }
        } else if (char === "]") {
          if (escaped) {
            escaped = false;
          } else {
            throw new Error("Invalid table name.");
          }
        } else if (char === ".") {
          if (escaped) {
            buffer += char;
          } else {
            path4.push(buffer);
            buffer = "";
          }
        } else {
          buffer += char;
        }
      }
      if (buffer) {
        path4.push(buffer);
      }
      switch (path4.length) {
        case 1:
          return {
            name: path4[0],
            schema: null,
            database: null
          };
        case 2:
          return {
            name: path4[1],
            schema: path4[0],
            database: null
          };
        case 3:
          return {
            name: path4[2],
            schema: path4[1],
            database: path4[0]
          };
        default:
          throw new Error("Invalid table name.");
      }
    };
    module2.exports = Table;
  }
});

// node_modules/mssql/lib/shared.js
var require_shared = __commonJS({
  "node_modules/mssql/lib/shared.js"(exports2, module2) {
    "use strict";
    var TYPES = require_datatypes().TYPES;
    var Table = require_table();
    var PromiseLibrary = Promise;
    var driver = {};
    var map = [];
    map.register = function(jstype, sqltype) {
      for (let index = 0; index < this.length; index++) {
        const item = this[index];
        if (item.js === jstype) {
          this.splice(index, 1);
          break;
        }
      }
      this.push({
        js: jstype,
        sql: sqltype
      });
      return null;
    };
    map.register(String, TYPES.NVarChar);
    map.register(Number, TYPES.Int);
    map.register(Boolean, TYPES.Bit);
    map.register(Date, TYPES.DateTime);
    map.register(Buffer, TYPES.VarBinary);
    map.register(Table, TYPES.TVP);
    var getTypeByValue = function(value) {
      if (value === null || value === void 0) {
        return TYPES.NVarChar;
      }
      switch (typeof value) {
        case "string":
          for (const item of Array.from(map)) {
            if (item.js === String) {
              return item.sql;
            }
          }
          return TYPES.NVarChar;
        case "number":
          if (value % 1 === 0) {
            if (value < -2147483648 || value > 2147483647) {
              return TYPES.BigInt;
            } else {
              return TYPES.Int;
            }
          } else {
            return TYPES.Float;
          }
        case "bigint":
          if (value < -2147483648n || value > 2147483647n) {
            return TYPES.BigInt;
          } else {
            return TYPES.Int;
          }
        case "boolean":
          for (const item of Array.from(map)) {
            if (item.js === Boolean) {
              return item.sql;
            }
          }
          return TYPES.Bit;
        case "object":
          for (const item of Array.from(map)) {
            if (value instanceof item.js) {
              return item.sql;
            }
          }
          return TYPES.NVarChar;
        default:
          return TYPES.NVarChar;
      }
    };
    module2.exports = {
      driver,
      getTypeByValue,
      map
    };
    Object.defineProperty(module2.exports, "Promise", {
      get: () => {
        return PromiseLibrary;
      },
      set: (value) => {
        PromiseLibrary = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: /* @__PURE__ */ new Map(),
      writable: false,
      configurable: false
    });
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/rfdc/default.js
var require_default = __commonJS({
  "node_modules/rfdc/default.js"(exports2, module2) {
    "use strict";
    module2.exports = require_rfdc()();
  }
});

// node_modules/mssql/lib/error/prepared-statement-error.js
var require_prepared_statement_error = __commonJS({
  "node_modules/mssql/lib/error/prepared-statement-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var PreparedStatementError = class extends MSSQLError {
      /**
       * Creates a new PreparedStatementError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "PreparedStatementError";
      }
    };
    module2.exports = PreparedStatementError;
  }
});

// node_modules/mssql/lib/error/request-error.js
var require_request_error = __commonJS({
  "node_modules/mssql/lib/error/request-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var RequestError = class extends MSSQLError {
      /**
       * Creates a new RequestError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        if (message instanceof Error) {
          if (message.info) {
            this.number = message.info.number || message.code;
            this.lineNumber = message.info.lineNumber;
            this.state = message.info.state || message.sqlstate;
            this.class = message.info.class;
            this.serverName = message.info.serverName;
            this.procName = message.info.procName;
          } else {
            this.number = message.code;
            this.lineNumber = message.lineNumber;
            this.state = message.sqlstate;
            this.class = message.severity;
            this.serverName = message.serverName;
            this.procName = message.procName;
          }
        }
        this.name = "RequestError";
        const parsedMessage = /^\[Microsoft\]\[SQL Server Native Client 11\.0\](?:\[SQL Server\])?([\s\S]*)$/.exec(this.message);
        if (parsedMessage) {
          this.message = parsedMessage[1];
        }
      }
    };
    module2.exports = RequestError;
  }
});

// node_modules/mssql/lib/error/transaction-error.js
var require_transaction_error = __commonJS({
  "node_modules/mssql/lib/error/transaction-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var TransactionError = class extends MSSQLError {
      /**
       * Creates a new TransactionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "TransactionError";
      }
    };
    module2.exports = TransactionError;
  }
});

// node_modules/mssql/lib/error/index.js
var require_error = __commonJS({
  "node_modules/mssql/lib/error/index.js"(exports2, module2) {
    "use strict";
    var ConnectionError = require_connection_error();
    var MSSQLError = require_mssql_error();
    var PreparedStatementError = require_prepared_statement_error();
    var RequestError = require_request_error();
    var TransactionError = require_transaction_error();
    module2.exports = {
      ConnectionError,
      MSSQLError,
      PreparedStatementError,
      RequestError,
      TransactionError
    };
  }
});

// node_modules/mssql/lib/base/connection-pool.js
var require_connection_pool = __commonJS({
  "node_modules/mssql/lib/base/connection-pool.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var debug = require_src()("mssql:base");
    var { parseSqlConnectionString } = require_lib();
    var tarn = require_tarn();
    var { IDS } = require_utils2();
    var ConnectionError = require_connection_error();
    var shared = require_shared();
    var clone = require_default();
    var { MSSQLError } = require_error();
    var ConnectionPool = class extends EventEmitter {
      /**
       * Create new Connection.
       *
       * @param {Object|String} config Connection configuration object or connection string.
       * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.
       */
      constructor(config, callback) {
        super();
        IDS.add(this, "ConnectionPool");
        debug("pool(%d): created", IDS.get(this));
        this._connectStack = [];
        this._closeStack = [];
        this._connected = false;
        this._connecting = false;
        this._healthy = false;
        if (typeof config === "string") {
          try {
            this.config = this.constructor.parseConnectionString(config);
          } catch (ex) {
            if (typeof callback === "function") {
              return setImmediate(callback, ex);
            }
            throw ex;
          }
        } else {
          this.config = clone(config);
        }
        this.config.port = this.config.port || 1433;
        this.config.options = this.config.options || {};
        this.config.stream = this.config.stream || false;
        this.config.parseJSON = this.config.parseJSON || false;
        this.config.arrayRowMode = this.config.arrayRowMode || false;
        this.config.validateConnection = "validateConnection" in this.config ? this.config.validateConnection : true;
        const namedServer = /^(.*)\\(.*)$/.exec(this.config.server);
        if (namedServer) {
          this.config.server = namedServer[1];
          this.config.options.instanceName = namedServer[2];
        }
        if (typeof this.config.options.useColumnNames !== "undefined" && this.config.options.useColumnNames !== true) {
          const ex = new MSSQLError("Invalid options `useColumnNames`, use `arrayRowMode` instead");
          if (typeof callback === "function") {
            return setImmediate(callback, ex);
          }
          throw ex;
        }
        if (typeof callback === "function") {
          this.connect(callback);
        }
      }
      get connected() {
        return this._connected;
      }
      get connecting() {
        return this._connecting;
      }
      get healthy() {
        return this._healthy;
      }
      static parseConnectionString(connectionString) {
        return this._parseConnectionString(connectionString);
      }
      static _parseAuthenticationType(type2, entries) {
        switch (type2.toLowerCase()) {
          case "active directory integrated":
            if (entries.includes("token")) {
              return "azure-active-directory-access-token";
            } else if (["client id", "client secret", "tenant id"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-service-principal-secret";
            } else if (["client id", "msi endpoint", "msi secret"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-msi-app-service";
            } else if (["client id", "msi endpoint"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-msi-vm";
            }
            return "azure-active-directory-default";
          case "active directory password":
            return "azure-active-directory-password";
          case "ntlm":
            return "ntlm";
          default:
            return "default";
        }
      }
      static _parseConnectionString(connectionString) {
        const parsed = parseSqlConnectionString(connectionString, true, true);
        return Object.entries(parsed).reduce((config, [key, value]) => {
          switch (key) {
            case "application name":
              break;
            case "applicationintent":
              Object.assign(config.options, {
                readOnlyIntent: value === "readonly"
              });
              break;
            case "asynchronous processing":
              break;
            case "attachdbfilename":
              break;
            case "authentication":
              Object.assign(config, {
                authentication_type: this._parseAuthenticationType(value, Object.keys(parsed))
              });
              break;
            case "column encryption setting":
              break;
            case "connection timeout":
              Object.assign(config, {
                connectionTimeout: value * 1e3
              });
              break;
            case "connection lifetime":
              break;
            case "connectretrycount":
              break;
            case "connectretryinterval":
              Object.assign(config.options, {
                connectionRetryInterval: value * 1e3
              });
              break;
            case "context connection":
              break;
            case "client id":
              Object.assign(config, {
                clientId: value
              });
              break;
            case "client secret":
              Object.assign(config, {
                clientSecret: value
              });
              break;
            case "current language":
              Object.assign(config.options, {
                language: value
              });
              break;
            case "data source": {
              let server = value;
              let instanceName;
              let port = 1433;
              if (/^np:/i.test(server)) {
                throw new Error("Connection via Named Pipes is not supported.");
              }
              if (/^tcp:/i.test(server)) {
                server = server.substr(4);
              }
              const namedServerParts = /^(.*)\\(.*)$/.exec(server);
              if (namedServerParts) {
                server = namedServerParts[1].trim();
                instanceName = namedServerParts[2].trim();
              }
              const serverParts = /^(.*),(.*)$/.exec(server);
              if (serverParts) {
                server = serverParts[1].trim();
                port = parseInt(serverParts[2].trim(), 10);
              } else {
                const instanceParts = /^(.*),(.*)$/.exec(instanceName);
                if (instanceParts) {
                  instanceName = instanceParts[1].trim();
                  port = parseInt(instanceParts[2].trim(), 10);
                }
              }
              if (server === "." || server === "(.)" || server.toLowerCase() === "(localdb)" || server.toLowerCase() === "(local)") {
                server = "localhost";
              }
              Object.assign(config, {
                port,
                server
              });
              if (instanceName) {
                Object.assign(config.options, {
                  instanceName
                });
              }
              break;
            }
            case "encrypt":
              Object.assign(config.options, {
                encrypt: !!value
              });
              break;
            case "enlist":
              break;
            case "failover partner":
              break;
            case "initial catalog":
              Object.assign(config, {
                database: value
              });
              break;
            case "integrated security":
              break;
            case "max pool size":
              Object.assign(config.pool, {
                max: value
              });
              break;
            case "min pool size":
              Object.assign(config.pool, {
                min: value
              });
              break;
            case "msi endpoint":
              Object.assign(config, {
                msiEndpoint: value
              });
              break;
            case "msi secret":
              Object.assign(config, {
                msiSecret: value
              });
              break;
            case "multipleactiveresultsets":
              break;
            case "multisubnetfailover":
              Object.assign(config.options, {
                multiSubnetFailover: value
              });
              break;
            case "network library":
              break;
            case "packet size":
              Object.assign(config.options, {
                packetSize: value
              });
              break;
            case "password":
              Object.assign(config, {
                password: value
              });
              break;
            case "persist security info":
              break;
            case "poolblockingperiod":
              break;
            case "pooling":
              break;
            case "replication":
              break;
            case "tenant id":
              Object.assign(config, {
                tenantId: value
              });
              break;
            case "token":
              Object.assign(config, {
                token: value
              });
              break;
            case "transaction binding":
              Object.assign(config.options, {
                enableImplicitTransactions: value.toLowerCase() === "implicit unbind"
              });
              break;
            case "transparentnetworkipresolution":
              break;
            case "trustservercertificate":
              Object.assign(config.options, {
                trustServerCertificate: value
              });
              break;
            case "type system version":
              break;
            case "user id": {
              let user = value;
              let domain;
              const domainUser = /^(.*)\\(.*)$/.exec(user);
              if (domainUser) {
                domain = domainUser[1];
                user = domainUser[2];
              }
              if (domain) {
                Object.assign(config, {
                  domain
                });
              }
              if (user) {
                Object.assign(config, {
                  user
                });
              }
              break;
            }
            case "user instance":
              break;
            case "workstation id":
              Object.assign(config.options, {
                workstationId: value
              });
              break;
            case "request timeout":
              Object.assign(config, {
                requestTimeout: parseInt(value, 10)
              });
              break;
            case "stream":
              Object.assign(config, {
                stream: !!value
              });
              break;
            case "useutc":
              Object.assign(config.options, {
                useUTC: !!value
              });
              break;
            case "parsejson":
              Object.assign(config, {
                parseJSON: !!value
              });
              break;
          }
          return config;
        }, { options: {}, pool: {} });
      }
      /**
       * Acquire connection from this connection pool.
       *
       * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.
       * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      acquire(requester, callback) {
        const acquirePromise = shared.Promise.resolve(this._acquire()).catch((err) => {
          this.emit("error", err);
          throw err;
        });
        if (typeof callback === "function") {
          acquirePromise.then((connection) => callback(null, connection, this.config)).catch(callback);
          return this;
        }
        return acquirePromise;
      }
      _acquire() {
        if (!this.pool) {
          return shared.Promise.reject(new ConnectionError("Connection not yet open.", "ENOTOPEN"));
        } else if (this.pool.destroyed) {
          return shared.Promise.reject(new ConnectionError("Connection is closing", "ENOTOPEN"));
        }
        return this.pool.acquire().promise;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {ConnectionPool}
       */
      release(connection) {
        debug("connection(%d): released", IDS.get(connection));
        if (this.pool) {
          this.pool.release(connection);
        }
        return this;
      }
      /**
       * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.
       *
       * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      connect(callback) {
        if (typeof callback === "function") {
          this._connect(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          return this._connect((err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _connect(callback) {
        if (this._connected) {
          debug("pool(%d): already connected, executing connect callback immediately", IDS.get(this));
          return setImmediate(callback, null, this);
        }
        this._connectStack.push(callback);
        if (this._connecting) {
          return;
        }
        this._connecting = true;
        debug("pool(%d): connecting", IDS.get(this));
        this._poolCreate().then((connection) => {
          debug("pool(%d): connected", IDS.get(this));
          this._healthy = true;
          return this._poolDestroy(connection).then(() => {
            this.pool = new tarn.Pool(
              Object.assign({
                create: () => this._poolCreate().then((connection2) => {
                  this._healthy = true;
                  return connection2;
                }).catch((err) => {
                  if (this.pool.numUsed() + this.pool.numFree() <= 0) {
                    this._healthy = false;
                  }
                  throw err;
                }),
                validate: this._poolValidate.bind(this),
                destroy: this._poolDestroy.bind(this),
                max: 10,
                min: 0,
                idleTimeoutMillis: 3e4,
                propagateCreateError: true
              }, this.config.pool)
            );
            this._connecting = false;
            this._connected = true;
          });
        }).then(() => {
          this._connectStack.forEach((cb) => {
            setImmediate(cb, null, this);
          });
        }).catch((err) => {
          this._connecting = false;
          this._connectStack.forEach((cb) => {
            setImmediate(cb, err);
          });
        }).then(() => {
          this._connectStack = [];
        });
      }
      get size() {
        return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates();
      }
      get available() {
        return this.pool.numFree();
      }
      get pending() {
        return this.pool.numPendingAcquires();
      }
      get borrowed() {
        return this.pool.numUsed();
      }
      /**
       * Close all active connections in the pool.
       *
       * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      close(callback) {
        if (typeof callback === "function") {
          this._close(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._close((err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _close(callback) {
        if (this._connecting) {
          debug("pool(%d): close called while connecting", IDS.get(this));
          setImmediate(callback, new ConnectionError("Cannot close a pool while it is connecting"));
        }
        if (!this.pool) {
          debug("pool(%d): already closed, executing close callback immediately", IDS.get(this));
          return setImmediate(callback, null);
        }
        this._closeStack.push(callback);
        if (this.pool.destroyed)
          return;
        this._connecting = this._connected = this._healthy = false;
        this.pool.destroy().then(() => {
          debug("pool(%d): pool closed, removing pool reference and executing close callbacks", IDS.get(this));
          this.pool = null;
          this._closeStack.forEach((cb) => {
            setImmediate(cb, null);
          });
        }).catch((err) => {
          this.pool = null;
          this._closeStack.forEach((cb) => {
            setImmediate(cb, err);
          });
        }).then(() => {
          this._closeStack = [];
        });
      }
      /**
       * Returns new request using this connection.
       *
       * @return {Request}
       */
      request() {
        return new shared.driver.Request(this);
      }
      /**
       * Returns new transaction using this connection.
       *
       * @return {Transaction}
       */
      transaction() {
        return new shared.driver.Transaction(this);
      }
      /**
       * Creates a new query using this connection from a tagged template string.
       *
       * @variation 1
       * @param {Array} strings Array of string literals.
       * @param {...*} keys Values.
       * @return {Request}
       */
      /**
       * Execute the SQL command.
       *
       * @variation 2
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      query() {
        if (typeof arguments[0] === "string") {
          return new shared.driver.Request(this).query(arguments[0], arguments[1]);
        }
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return new shared.driver.Request(this)._template(strings, values, "query");
      }
      /**
       * Creates a new batch using this connection from a tagged template string.
       *
       * @variation 1
       * @param {Array} strings Array of string literals.
       * @param {...*} keys Values.
       * @return {Request}
       */
      /**
       * Execute the SQL command.
       *
       * @variation 2
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      batch() {
        if (typeof arguments[0] === "string") {
          return new shared.driver.Request(this).batch(arguments[0], arguments[1]);
        }
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return new shared.driver.Request(this)._template(strings, values, "batch");
      }
    };
    module2.exports = ConnectionPool;
  }
});

// node_modules/mssql/lib/global-connection.js
var require_global_connection = __commonJS({
  "node_modules/mssql/lib/global-connection.js"(exports2, module2) {
    "use strict";
    var shared = require_shared();
    var globalConnection = null;
    var globalConnectionHandlers = {};
    function connect(config, callback) {
      if (!globalConnection) {
        globalConnection = new shared.driver.ConnectionPool(config);
        for (const event in globalConnectionHandlers) {
          for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
            globalConnection.on(event, globalConnectionHandlers[event][i]);
          }
        }
        const ogClose = globalConnection.close;
        const globalClose = function(callback2) {
          for (const event in globalConnectionHandlers) {
            for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
              this.removeListener(event, globalConnectionHandlers[event][i]);
            }
          }
          this.on("error", (err) => {
            if (globalConnectionHandlers.error) {
              for (let i = 0, l = globalConnectionHandlers.error.length; i < l; i++) {
                globalConnectionHandlers.error[i].call(this, err);
              }
            }
          });
          globalConnection = null;
          return ogClose.call(this, callback2);
        };
        globalConnection.close = globalClose.bind(globalConnection);
      }
      if (typeof callback === "function") {
        return globalConnection.connect((err, connection) => {
          if (err) {
            globalConnection = null;
          }
          callback(err, connection);
        });
      }
      return globalConnection.connect().catch((err) => {
        globalConnection = null;
        return shared.Promise.reject(err);
      });
    }
    function close(callback) {
      if (globalConnection) {
        const gc = globalConnection;
        globalConnection = null;
        return gc.close(callback);
      }
      if (typeof callback === "function") {
        setImmediate(callback);
        return null;
      }
      return new shared.Promise((resolve) => {
        resolve(globalConnection);
      });
    }
    function on(event, handler) {
      if (!globalConnectionHandlers[event])
        globalConnectionHandlers[event] = [];
      globalConnectionHandlers[event].push(handler);
      if (globalConnection)
        globalConnection.on(event, handler);
      return globalConnection;
    }
    function removeListener(event, handler) {
      if (!globalConnectionHandlers[event])
        return globalConnection;
      const index = globalConnectionHandlers[event].indexOf(handler);
      if (index === -1)
        return globalConnection;
      globalConnectionHandlers[event].splice(index, 1);
      if (globalConnectionHandlers[event].length === 0)
        globalConnectionHandlers[event] = void 0;
      if (globalConnection)
        globalConnection.removeListener(event, handler);
      return globalConnection;
    }
    function query() {
      if (typeof arguments[0] === "string") {
        return new shared.driver.Request().query(arguments[0], arguments[1]);
      }
      const values = Array.prototype.slice.call(arguments);
      const strings = values.shift();
      return new shared.driver.Request()._template(strings, values, "query");
    }
    function batch() {
      if (typeof arguments[0] === "string") {
        return new shared.driver.Request().batch(arguments[0], arguments[1]);
      }
      const values = Array.prototype.slice.call(arguments);
      const strings = values.shift();
      return new shared.driver.Request()._template(strings, values, "batch");
    }
    module2.exports = {
      batch,
      close,
      connect,
      off: removeListener,
      on,
      query,
      removeListener
    };
    Object.defineProperty(module2.exports, "pool", {
      get: () => {
        return globalConnection;
      },
      set: () => {
      }
    });
  }
});

// node_modules/mssql/lib/base/prepared-statement.js
var require_prepared_statement = __commonJS({
  "node_modules/mssql/lib/base/prepared-statement.js"(exports2, module2) {
    "use strict";
    var debug = require_src()("mssql:base");
    var { EventEmitter } = require("events");
    var { IDS, objectHasProperty: objectHasProperty2 } = require_utils2();
    var globalConnection = require_global_connection();
    var { TransactionError, PreparedStatementError } = require_error();
    var shared = require_shared();
    var { TYPES, declare } = require_datatypes();
    var PreparedStatement = class extends EventEmitter {
      /**
       * Creates a new Prepared Statement.
       *
       * @param {ConnectionPool|Transaction} [holder]
       */
      constructor(parent) {
        super();
        IDS.add(this, "PreparedStatement");
        debug("ps(%d): created", IDS.get(this));
        this.parent = parent || globalConnection.pool;
        this._handle = 0;
        this.prepared = false;
        this.parameters = {};
      }
      get config() {
        return this.parent.config;
      }
      get connected() {
        return this.parent.connected;
      }
      /**
       * Acquire connection from connection pool.
       *
       * @param {Request} request Request.
       * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      acquire(request3, callback) {
        if (!this._acquiredConnection) {
          setImmediate(callback, new PreparedStatementError("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
          return this;
        }
        if (this._activeRequest) {
          setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
          return this;
        }
        this._activeRequest = request3;
        setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
        return this;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {PreparedStatement}
       */
      release(connection) {
        if (connection === this._acquiredConnection) {
          this._activeRequest = null;
        }
        return this;
      }
      /**
       * Add an input parameter to the prepared statement.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} type SQL data type of input parameter.
       * @return {PreparedStatement}
       */
      input(name3, type2) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new PreparedStatementError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", "EARGS");
        }
        if (type2 instanceof Function) {
          type2 = type2();
        }
        if (objectHasProperty2(this.parameters, name3)) {
          throw new PreparedStatementError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type2.type,
          io: 1,
          length: type2.length,
          scale: type2.scale,
          precision: type2.precision,
          tvpType: type2.tvpType
        };
        return this;
      }
      /**
       * Replace an input parameter on the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      replaceInput(name3, type2, value) {
        delete this.parameters[name3];
        return this.input(name3, type2, value);
      }
      /**
       * Add an output parameter to the prepared statement.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @return {PreparedStatement}
       */
      output(name3, type2) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new PreparedStatementError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", "EARGS");
        }
        if (type2 instanceof Function)
          type2 = type2();
        if (objectHasProperty2(this.parameters, name3)) {
          throw new PreparedStatementError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type2.type,
          io: 2,
          length: type2.length,
          scale: type2.scale,
          precision: type2.precision
        };
        return this;
      }
      /**
       * Replace an output parameter on the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @return {PreparedStatement}
       */
      replaceOutput(name3, type2) {
        delete this.parameters[name3];
        return this.output(name3, type2);
      }
      /**
       * Prepare a statement.
       *
       * @param {String} statement SQL statement to prepare.
       * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      prepare(statement, callback) {
        if (typeof callback === "function") {
          this._prepare(statement, callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._prepare(statement, (err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {String} statement
       * @param {basicCallback} callback
       */
      _prepare(statement, callback) {
        debug("ps(%d): prepare", IDS.get(this));
        if (typeof statement === "function") {
          callback = statement;
          statement = void 0;
        }
        if (this.prepared) {
          return setImmediate(callback, new PreparedStatementError("Statement is already prepared.", "EALREADYPREPARED"));
        }
        this.statement = statement || this.statement;
        this.parent.acquire(this, (err, connection, config) => {
          if (err)
            return callback(err);
          this._acquiredConnection = connection;
          this._acquiredConfig = config;
          const req = new shared.driver.Request(this);
          req.stream = false;
          req.output("handle", TYPES.Int);
          req.input("params", TYPES.NVarChar, (() => {
            const result = [];
            for (const name3 in this.parameters) {
              if (!objectHasProperty2(this.parameters, name3)) {
                continue;
              }
              const param = this.parameters[name3];
              result.push(`@${name3} ${declare(param.type, param)}${param.io === 2 ? " output" : ""}`);
            }
            return result;
          })().join(","));
          req.input("stmt", TYPES.NVarChar, this.statement);
          req.execute("sp_prepare", (err2, result) => {
            if (err2) {
              this.parent.release(this._acquiredConnection);
              this._acquiredConnection = null;
              this._acquiredConfig = null;
              return callback(err2);
            }
            debug("ps(%d): prepared", IDS.get(this));
            this._handle = result.output.handle;
            this.prepared = true;
            callback(null);
          });
        });
      }
      /**
       * Execute a prepared statement.
       *
       * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.
       * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      execute(values, callback) {
        if (this.stream || typeof callback === "function") {
          return this._execute(values, callback);
        }
        return new shared.Promise((resolve, reject) => {
          this._execute(values, (err, recordset) => {
            if (err)
              return reject(err);
            resolve(recordset);
          });
        });
      }
      /**
       * @private
       * @param {Object} values
       * @param {basicCallback} callback
       */
      _execute(values, callback) {
        const req = new shared.driver.Request(this);
        req.stream = this.stream;
        req.arrayRowMode = this.arrayRowMode;
        req.input("handle", TYPES.Int, this._handle);
        for (const name3 in this.parameters) {
          if (!objectHasProperty2(this.parameters, name3)) {
            continue;
          }
          const param = this.parameters[name3];
          req.parameters[name3] = {
            name: name3,
            type: param.type,
            io: param.io,
            value: values[name3],
            length: param.length,
            scale: param.scale,
            precision: param.precision
          };
        }
        req.execute("sp_execute", (err, result) => {
          if (err)
            return callback(err);
          callback(null, result);
        });
        return req;
      }
      /**
       * Unprepare a prepared statement.
       *
       * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      unprepare(callback) {
        if (typeof callback === "function") {
          this._unprepare(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._unprepare((err) => {
            if (err)
              return reject(err);
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _unprepare(callback) {
        debug("ps(%d): unprepare", IDS.get(this));
        if (!this.prepared) {
          return setImmediate(callback, new PreparedStatementError("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't unprepare the statement. There is a request in progress.", "EREQINPROG"));
        }
        const req = new shared.driver.Request(this);
        req.stream = false;
        req.input("handle", TYPES.Int, this._handle);
        req.execute("sp_unprepare", (err) => {
          if (err)
            return callback(err);
          this.parent.release(this._acquiredConnection);
          this._acquiredConnection = null;
          this._acquiredConfig = null;
          this._handle = 0;
          this.prepared = false;
          debug("ps(%d): unprepared", IDS.get(this));
          return callback(null);
        });
      }
    };
    module2.exports = PreparedStatement;
  }
});

// node_modules/mssql/lib/base/request.js
var require_request = __commonJS({
  "node_modules/mssql/lib/base/request.js"(exports2, module2) {
    "use strict";
    var debug = require_src()("mssql:base");
    var { EventEmitter } = require("events");
    var { Readable: Readable2 } = require("stream");
    var { IDS, objectHasProperty: objectHasProperty2 } = require_utils2();
    var globalConnection = require_global_connection();
    var { RequestError, ConnectionError } = require_error();
    var { TYPES } = require_datatypes();
    var shared = require_shared();
    var Request = class extends EventEmitter {
      /**
       * Create new Request.
       *
       * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If omitted, global connection is used instead.
       */
      constructor(parent) {
        super();
        IDS.add(this, "Request");
        debug("request(%d): created", IDS.get(this));
        this.canceled = false;
        this._paused = false;
        this.parent = parent || globalConnection.pool;
        this.parameters = {};
        this.stream = null;
        this.arrayRowMode = null;
      }
      get paused() {
        return this._paused;
      }
      /**
       * Generate sql string and set input parameters from tagged template string.
       *
       * @param {Template literal} template
       * @return {String}
       */
      template() {
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return this._template(strings, values);
      }
      /**
       * Fetch request from tagged template string.
       *
       * @private
       * @param {Array} strings
       * @param {Array} values
       * @param {String} [method] If provided, method is automatically called with serialized command on this object.
       * @return {Request}
       */
      _template(strings, values, method) {
        const command = [strings[0]];
        for (let index = 0; index < values.length; index++) {
          const value = values[index];
          if (Array.isArray(value)) {
            for (let parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {
              this.input(`param${index + 1}_${parameterIndex}`, value[parameterIndex]);
              command.push(`@param${index + 1}_${parameterIndex}`);
              if (parameterIndex < value.length - 1) {
                command.push(", ");
              }
            }
            command.push(strings[index + 1]);
          } else {
            this.input(`param${index + 1}`, value);
            command.push(`@param${index + 1}`, strings[index + 1]);
          }
        }
        if (method) {
          return this[method](command.join(""));
        } else {
          return command.join("");
        }
      }
      /**
       * Add an input parameter to the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      input(name3, type2, value) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new RequestError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new RequestError("Invalid number of arguments. At least 2 arguments expected.", "EARGS");
        } else if (arguments.length === 2) {
          value = type2;
          type2 = shared.getTypeByValue(value);
        }
        if (value && typeof value.valueOf === "function" && !(value instanceof Date))
          value = value.valueOf();
        if (value === void 0)
          value = null;
        if (typeof value === "number" && isNaN(value))
          value = null;
        if (type2 instanceof Function)
          type2 = type2();
        if (objectHasProperty2(this.parameters, name3)) {
          throw new RequestError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type2.type,
          io: 1,
          value,
          length: type2.length,
          scale: type2.scale,
          precision: type2.precision,
          tvpType: type2.tvpType
        };
        return this;
      }
      /**
       * Replace an input parameter on the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      replaceInput(name3, type2, value) {
        delete this.parameters[name3];
        return this.input(name3, type2, value);
      }
      /**
       * Add an output parameter to the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
       * @return {Request}
       */
      output(name3, type2, value) {
        if (!type2) {
          type2 = TYPES.NVarChar;
        }
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new RequestError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (type2 === TYPES.Text || type2 === TYPES.NText || type2 === TYPES.Image) {
          throw new RequestError("Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.", "EDEPRECATED");
        }
        if (value && typeof value.valueOf === "function" && !(value instanceof Date))
          value = value.valueOf();
        if (value === void 0)
          value = null;
        if (typeof value === "number" && isNaN(value))
          value = null;
        if (type2 instanceof Function)
          type2 = type2();
        if (objectHasProperty2(this.parameters, name3)) {
          throw new RequestError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type2.type,
          io: 2,
          value,
          length: type2.length,
          scale: type2.scale,
          precision: type2.precision
        };
        return this;
      }
      /**
       * Replace an output parameter on the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
       * @return {Request}
       */
      replaceOutput(name3, type2, value) {
        delete this.parameters[name3];
        return this.output(name3, type2, value);
      }
      /**
       * Execute the SQL batch.
       *
       * @param {String} batch T-SQL batch to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      batch(batch, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._batch(batch, (err, recordsets, output, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            callback(null, {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            });
          });
          return this;
        }
        if (typeof batch === "object") {
          const values = Array.prototype.slice.call(arguments);
          const strings = values.shift();
          batch = this._template(strings, values);
        }
        return new shared.Promise((resolve, reject) => {
          this._batch(batch, (err, recordsets, output, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return reject(err);
            resolve({
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            });
          });
        });
      }
      /**
       * @private
       * @param {String} batch
       * @param {Request~requestCallback} callback
       */
      _batch(batch, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Bulk load.
       *
       * @param {Table} table SQL table.
       * @param {object} [options] Options to be passed to the underlying driver (tedious only).
       * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      bulk(table, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "undefined") {
          options = {};
        }
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        if (this.stream || typeof callback === "function") {
          this._bulk(table, options, (err, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              return this.emit("done", {
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            callback(null, {
              rowsAffected
            });
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._bulk(table, options, (err, rowsAffected) => {
            if (err)
              return reject(err);
            resolve({
              rowsAffected
            });
          });
        });
      }
      /**
       * @private
       * @param {Table} table
       * @param {object} options
       * @param {Request~bulkCallback} callback
       */
      _bulk(table, options, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Wrap original request in a Readable stream that supports back pressure and return.
       * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
       *
       * @param {Object} streamOptions - optional options to configure the readable stream with like highWaterMark
       * @return {Stream}
       */
      toReadableStream(streamOptions = {}) {
        this.stream = true;
        this.pause();
        const readableStream = new Readable2({
          ...streamOptions,
          objectMode: true,
          read: () => {
            this.resume();
          }
        });
        this.on("row", (row) => {
          if (!readableStream.push(row)) {
            this.pause();
          }
        });
        this.on("error", (error) => {
          readableStream.emit("error", error);
        });
        this.on("done", () => {
          readableStream.push(null);
        });
        return readableStream;
      }
      /**
       * Wrap original request in a Readable stream that supports back pressure and pipe to the Writable stream.
       * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
       *
       * @param {Stream} stream Stream to pipe data into.
       * @return {Stream}
       */
      pipe(writableStream) {
        const readableStream = this.toReadableStream();
        return readableStream.pipe(writableStream);
      }
      /**
       * Execute the SQL command.
       *
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      query(command, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._query(command, (err, recordsets, output, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            };
            if (this.arrayRowMode)
              result.columns = columns;
            callback(null, result);
          });
          return this;
        }
        if (typeof command === "object") {
          const values = Array.prototype.slice.call(arguments);
          const strings = values.shift();
          command = this._template(strings, values);
        }
        return new shared.Promise((resolve, reject) => {
          this._query(command, (err, recordsets, output, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return reject(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            };
            if (this.arrayRowMode)
              result.columns = columns;
            resolve(result);
          });
        });
      }
      /**
       * @private
       * @param {String} command
       * @param {Request~bulkCallback} callback
       */
      _query(command, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Call a stored procedure.
       *
       * @param {String} procedure Name of the stored procedure to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      execute(command, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected,
                returnValue
              });
            }
            if (err)
              return callback(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected,
              returnValue
            };
            if (this.arrayRowMode)
              result.columns = columns;
            callback(null, result);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected,
                returnValue
              });
            }
            if (err)
              return reject(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected,
              returnValue
            };
            if (this.arrayRowMode)
              result.columns = columns;
            resolve(result);
          });
        });
      }
      /**
       * @private
       * @param {String} procedure
       * @param {Request~bulkCallback} callback
       */
      _execute(procedure, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Cancel currently executed request.
       *
       * @return {Boolean}
       */
      cancel() {
        this._cancel();
        return true;
      }
      /**
       * @private
       */
      _cancel() {
        this.canceled = true;
      }
      pause() {
        if (this.stream) {
          this._pause();
          return true;
        }
        return false;
      }
      _pause() {
        this._paused = true;
      }
      resume() {
        if (this.stream) {
          this._resume();
          return true;
        }
        return false;
      }
      _resume() {
        this._paused = false;
      }
      _setCurrentRequest(request3) {
        this._currentRequest = request3;
        if (this._paused) {
          this.pause();
        }
        return this;
      }
    };
    module2.exports = Request;
  }
});

// node_modules/mssql/lib/isolationlevel.js
var require_isolationlevel = __commonJS({
  "node_modules/mssql/lib/isolationlevel.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
  }
});

// node_modules/mssql/lib/base/transaction.js
var require_transaction = __commonJS({
  "node_modules/mssql/lib/base/transaction.js"(exports2, module2) {
    "use strict";
    var debug = require_src()("mssql:base");
    var { EventEmitter } = require("events");
    var { IDS } = require_utils2();
    var globalConnection = require_global_connection();
    var { TransactionError } = require_error();
    var shared = require_shared();
    var ISOLATION_LEVEL = require_isolationlevel();
    var Transaction2 = class _Transaction extends EventEmitter {
      /**
       * Create new Transaction.
       *
       * @param {Connection} [parent] If ommited, global connection is used instead.
       */
      constructor(parent) {
        super();
        IDS.add(this, "Transaction");
        debug("transaction(%d): created", IDS.get(this));
        this.parent = parent || globalConnection.pool;
        this.isolationLevel = _Transaction.defaultIsolationLevel;
        this.name = "";
      }
      get config() {
        return this.parent.config;
      }
      get connected() {
        return this.parent.connected;
      }
      /**
       * Acquire connection from connection pool.
       *
       * @param {Request} request Request.
       * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      acquire(request3, callback) {
        if (!this._acquiredConnection) {
          setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
          return this;
        }
        if (this._activeRequest) {
          setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
          return this;
        }
        this._activeRequest = request3;
        setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
        return this;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {Transaction}
       */
      release(connection) {
        if (connection === this._acquiredConnection) {
          this._activeRequest = null;
        }
        return this;
      }
      /**
       * Begin a transaction.
       *
       * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.
       * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      begin(isolationLevel, callback) {
        if (isolationLevel instanceof Function) {
          callback = isolationLevel;
          isolationLevel = void 0;
        }
        if (typeof callback === "function") {
          this._begin(isolationLevel, (err) => {
            if (!err) {
              this.emit("begin");
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._begin(isolationLevel, (err) => {
            if (err)
              return reject(err);
            this.emit("begin");
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {Number} [isolationLevel]
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _begin(isolationLevel, callback) {
        if (this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has already begun.", "EALREADYBEGUN"));
        }
        this._aborted = false;
        this._rollbackRequested = false;
        if (isolationLevel) {
          if (Object.keys(ISOLATION_LEVEL).some((key) => {
            return ISOLATION_LEVEL[key] === isolationLevel;
          })) {
            this.isolationLevel = isolationLevel;
          } else {
            throw new TransactionError("Invalid isolation level.");
          }
        }
        setImmediate(callback);
      }
      /**
       * Commit a transaction.
       *
       * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      commit(callback) {
        if (typeof callback === "function") {
          this._commit((err) => {
            if (!err) {
              this.emit("commit");
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._commit((err) => {
            if (err)
              return reject(err);
            this.emit("commit");
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _commit(callback) {
        if (this._aborted) {
          return setImmediate(callback, new TransactionError("Transaction has been aborted.", "EABORT"));
        }
        if (!this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't commit transaction. There is a request in progress.", "EREQINPROG"));
        }
        setImmediate(callback);
      }
      /**
       * Returns new request using this transaction.
       *
       * @return {Request}
       */
      request() {
        return new shared.driver.Request(this);
      }
      /**
       * Rollback a transaction.
       *
       * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      rollback(callback) {
        if (typeof callback === "function") {
          this._rollback((err) => {
            if (!err) {
              this.emit("rollback", this._aborted);
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          return this._rollback((err) => {
            if (err)
              return reject(err);
            this.emit("rollback", this._aborted);
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _rollback(callback) {
        if (this._aborted) {
          return setImmediate(callback, new TransactionError("Transaction has been aborted.", "EABORT"));
        }
        if (!this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't rollback transaction. There is a request in progress.", "EREQINPROG"));
        }
        this._rollbackRequested = true;
        setImmediate(callback);
      }
    };
    Transaction2.defaultIsolationLevel = ISOLATION_LEVEL.READ_COMMITTED;
    module2.exports = Transaction2;
  }
});

// node_modules/mssql/lib/base/index.js
var require_base = __commonJS({
  "node_modules/mssql/lib/base/index.js"(exports2, module2) {
    "use strict";
    var ConnectionPool = require_connection_pool();
    var PreparedStatement = require_prepared_statement();
    var Request = require_request();
    var Transaction2 = require_transaction();
    var { ConnectionError, TransactionError, RequestError, PreparedStatementError, MSSQLError } = require_error();
    var shared = require_shared();
    var Table = require_table();
    var ISOLATION_LEVEL = require_isolationlevel();
    var { TYPES } = require_datatypes();
    var { connect, close, on, off, removeListener, query, batch } = require_global_connection();
    module2.exports = {
      ConnectionPool,
      Transaction: Transaction2,
      Request,
      PreparedStatement,
      ConnectionError,
      TransactionError,
      RequestError,
      PreparedStatementError,
      MSSQLError,
      driver: shared.driver,
      exports: {
        ConnectionError,
        TransactionError,
        RequestError,
        PreparedStatementError,
        MSSQLError,
        Table,
        ISOLATION_LEVEL,
        TYPES,
        MAX: 65535,
        // (1 << 16) - 1
        map: shared.map,
        getTypeByValue: shared.getTypeByValue,
        connect,
        close,
        on,
        removeListener,
        off,
        query,
        batch
      }
    };
    Object.defineProperty(module2.exports, "Promise", {
      enumerable: true,
      get: () => {
        return shared.Promise;
      },
      set: (value) => {
        shared.Promise = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: shared.valueHandler,
      writable: false,
      configurable: false
    });
    for (const key in TYPES) {
      const value = TYPES[key];
      module2.exports.exports[key] = value;
      module2.exports.exports[key.toUpperCase()] = value;
    }
  }
});

// node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js
var require_writable_tracking_buffer = __commonJS({
  "node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var ZERO_LENGTH_BUFFER = Buffer.alloc(0);
    var WritableTrackingBuffer = class {
      constructor(initialSize, encoding, doubleSizeGrowth) {
        this.initialSize = initialSize;
        this.encoding = encoding || "ucs2";
        this.doubleSizeGrowth = doubleSizeGrowth || false;
        this.buffer = Buffer.alloc(this.initialSize, 0);
        this.compositeBuffer = ZERO_LENGTH_BUFFER;
        this.position = 0;
      }
      get data() {
        this.newBuffer(0);
        return this.compositeBuffer;
      }
      copyFrom(buffer) {
        const length = buffer.length;
        this.makeRoomFor(length);
        buffer.copy(this.buffer, this.position);
        this.position += length;
      }
      makeRoomFor(requiredLength) {
        if (this.buffer.length - this.position < requiredLength) {
          if (this.doubleSizeGrowth) {
            let size = Math.max(128, this.buffer.length * 2);
            while (size < requiredLength) {
              size *= 2;
            }
            this.newBuffer(size);
          } else {
            this.newBuffer(requiredLength);
          }
        }
      }
      newBuffer(size) {
        const buffer = this.buffer.slice(0, this.position);
        this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);
        this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);
        this.position = 0;
      }
      writeUInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeUInt8(value, this.position);
        this.position += length;
      }
      writeUInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16LE(value, this.position);
        this.position += length;
      }
      writeUShort(value) {
        this.writeUInt16LE(value);
      }
      writeUInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16BE(value, this.position);
        this.position += length;
      }
      writeUInt24LE(value) {
        const length = 3;
        this.makeRoomFor(length);
        this.buffer[this.position + 2] = value >>> 16 & 255;
        this.buffer[this.position + 1] = value >>> 8 & 255;
        this.buffer[this.position] = value & 255;
        this.position += length;
      }
      writeUInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32LE(value, this.position);
        this.position += length;
      }
      writeBigInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigInt64LE(value, this.position);
        this.position += length;
      }
      writeInt64LE(value) {
        this.writeBigInt64LE(BigInt(value));
      }
      writeUInt64LE(value) {
        this.writeBigUInt64LE(BigInt(value));
      }
      writeBigUInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigUInt64LE(value, this.position);
        this.position += length;
      }
      writeUInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32BE(value, this.position);
        this.position += length;
      }
      writeUInt40LE(value) {
        this.writeInt32LE(value & -1);
        this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));
      }
      writeInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeInt8(value, this.position);
        this.position += length;
      }
      writeInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16LE(value, this.position);
        this.position += length;
      }
      writeInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16BE(value, this.position);
        this.position += length;
      }
      writeInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32LE(value, this.position);
        this.position += length;
      }
      writeInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32BE(value, this.position);
        this.position += length;
      }
      writeFloatLE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeFloatLE(value, this.position);
        this.position += length;
      }
      writeDoubleLE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeDoubleLE(value, this.position);
        this.position += length;
      }
      writeString(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        const length = Buffer.byteLength(value, encoding);
        this.makeRoomFor(length);
        this.buffer.write(value, this.position, encoding);
        this.position += length;
      }
      writeBVarchar(value, encoding) {
        this.writeUInt8(value.length);
        this.writeString(value, encoding);
      }
      writeUsVarchar(value, encoding) {
        this.writeUInt16LE(value.length);
        this.writeString(value, encoding);
      }
      // TODO: Figure out what types are passed in other than `Buffer`
      writeUsVarbyte(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeUInt16LE(length);
        if (value instanceof Buffer) {
          this.writeBuffer(value);
        } else {
          this.makeRoomFor(length);
          this.buffer.write(value, this.position, encoding);
          this.position += length;
        }
      }
      writePLPBody(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeBuffer(UNKNOWN_PLP_LEN);
        if (length > 0) {
          this.writeUInt32LE(length);
          if (value instanceof Buffer) {
            this.writeBuffer(value);
          } else {
            this.makeRoomFor(length);
            this.buffer.write(value, this.position, encoding);
            this.position += length;
          }
        }
        this.writeUInt32LE(0);
      }
      writeBuffer(value) {
        const length = value.length;
        this.makeRoomFor(length);
        value.copy(this.buffer, this.position);
        this.position += length;
      }
      writeMoney(value) {
        this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));
        this.writeInt32LE(value & -1);
      }
    };
    var _default = exports2.default = WritableTrackingBuffer;
    module2.exports = WritableTrackingBuffer;
  }
});

// node_modules/tedious/lib/token/token.js
var require_token = __commonJS({
  "node_modules/tedious/lib/token/token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Token = exports2.TYPE = exports2.SSPIToken = exports2.RowToken = exports2.RoutingEnvChangeToken = exports2.RollbackTransactionEnvChangeToken = exports2.ReturnValueToken = exports2.ReturnStatusToken = exports2.ResetConnectionEnvChangeToken = exports2.PacketSizeEnvChangeToken = exports2.OrderToken = exports2.NBCRowToken = exports2.LoginAckToken = exports2.LanguageEnvChangeToken = exports2.InfoMessageToken = exports2.FedAuthInfoToken = exports2.FeatureExtAckToken = exports2.ErrorMessageToken = exports2.DoneToken = exports2.DoneProcToken = exports2.DoneInProcToken = exports2.DatabaseMirroringPartnerEnvChangeToken = exports2.DatabaseEnvChangeToken = exports2.CommitTransactionEnvChangeToken = exports2.CollationChangeToken = exports2.ColMetadataToken = exports2.CharsetEnvChangeToken = exports2.BeginTransactionEnvChangeToken = void 0;
    var TYPE = exports2.TYPE = {
      ALTMETADATA: 136,
      ALTROW: 211,
      COLMETADATA: 129,
      COLINFO: 165,
      DONE: 253,
      DONEPROC: 254,
      DONEINPROC: 255,
      ENVCHANGE: 227,
      ERROR: 170,
      FEATUREEXTACK: 174,
      FEDAUTHINFO: 238,
      INFO: 171,
      LOGINACK: 173,
      NBCROW: 210,
      OFFSET: 120,
      ORDER: 169,
      RETURNSTATUS: 121,
      RETURNVALUE: 172,
      ROW: 209,
      SSPI: 237,
      TABNAME: 164
    };
    var Token = class {
      constructor(name3, handlerName) {
        this.name = name3;
        this.handlerName = handlerName;
      }
    };
    exports2.Token = Token;
    var ColMetadataToken = class extends Token {
      constructor(columns) {
        super("COLMETADATA", "onColMetadata");
        this.columns = columns;
      }
    };
    exports2.ColMetadataToken = ColMetadataToken;
    var DoneToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONE", "onDone");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports2.DoneToken = DoneToken;
    var DoneInProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEINPROC", "onDoneInProc");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports2.DoneInProcToken = DoneInProcToken;
    var DoneProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEPROC", "onDoneProc");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports2.DoneProcToken = DoneProcToken;
    var DatabaseEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseChange");
        this.type = "DATABASE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.DatabaseEnvChangeToken = DatabaseEnvChangeToken;
    var LanguageEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onLanguageChange");
        this.type = "LANGUAGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.LanguageEnvChangeToken = LanguageEnvChangeToken;
    var CharsetEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCharsetChange");
        this.type = "CHARSET";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.CharsetEnvChangeToken = CharsetEnvChangeToken;
    var PacketSizeEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onPacketSizeChange");
        this.type = "PACKET_SIZE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.PacketSizeEnvChangeToken = PacketSizeEnvChangeToken;
    var BeginTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onBeginTransaction");
        this.type = "BEGIN_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.BeginTransactionEnvChangeToken = BeginTransactionEnvChangeToken;
    var CommitTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCommitTransaction");
        this.type = "COMMIT_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.CommitTransactionEnvChangeToken = CommitTransactionEnvChangeToken;
    var RollbackTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRollbackTransaction");
        this.type = "ROLLBACK_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.RollbackTransactionEnvChangeToken = RollbackTransactionEnvChangeToken;
    var DatabaseMirroringPartnerEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseMirroringPartner");
        this.type = "DATABASE_MIRRORING_PARTNER";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.DatabaseMirroringPartnerEnvChangeToken = DatabaseMirroringPartnerEnvChangeToken;
    var ResetConnectionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onResetConnection");
        this.type = "RESET_CONNECTION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.ResetConnectionEnvChangeToken = ResetConnectionEnvChangeToken;
    var CollationChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onSqlCollationChange");
        this.type = "SQL_COLLATION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.CollationChangeToken = CollationChangeToken;
    var RoutingEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRoutingChange");
        this.type = "ROUTING_CHANGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.RoutingEnvChangeToken = RoutingEnvChangeToken;
    var FeatureExtAckToken = class extends Token {
      /** Value of UTF8_SUPPORT acknowledgement.
       *
       * undefined when UTF8_SUPPORT not included in token. */
      constructor(fedAuth, utf8Support) {
        super("FEATUREEXTACK", "onFeatureExtAck");
        this.fedAuth = fedAuth;
        this.utf8Support = utf8Support;
      }
    };
    exports2.FeatureExtAckToken = FeatureExtAckToken;
    var FedAuthInfoToken = class extends Token {
      constructor(spn, stsurl) {
        super("FEDAUTHINFO", "onFedAuthInfo");
        this.spn = spn;
        this.stsurl = stsurl;
      }
    };
    exports2.FedAuthInfoToken = FedAuthInfoToken;
    var InfoMessageToken = class extends Token {
      constructor({
        number,
        state: state3,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("INFO", "onInfoMessage");
        this.number = number;
        this.state = state3;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports2.InfoMessageToken = InfoMessageToken;
    var ErrorMessageToken = class extends Token {
      constructor({
        number,
        state: state3,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("ERROR", "onErrorMessage");
        this.number = number;
        this.state = state3;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports2.ErrorMessageToken = ErrorMessageToken;
    var LoginAckToken = class extends Token {
      constructor({
        interface: interfaze,
        tdsVersion,
        progName,
        progVersion
      }) {
        super("LOGINACK", "onLoginAck");
        this.interface = interfaze;
        this.tdsVersion = tdsVersion;
        this.progName = progName;
        this.progVersion = progVersion;
      }
    };
    exports2.LoginAckToken = LoginAckToken;
    var NBCRowToken = class extends Token {
      constructor(columns) {
        super("NBCROW", "onRow");
        this.columns = columns;
      }
    };
    exports2.NBCRowToken = NBCRowToken;
    var OrderToken = class extends Token {
      constructor(orderColumns) {
        super("ORDER", "onOrder");
        this.orderColumns = orderColumns;
      }
    };
    exports2.OrderToken = OrderToken;
    var ReturnStatusToken = class extends Token {
      constructor(value) {
        super("RETURNSTATUS", "onReturnStatus");
        this.value = value;
      }
    };
    exports2.ReturnStatusToken = ReturnStatusToken;
    var ReturnValueToken = class extends Token {
      constructor({
        paramOrdinal,
        paramName,
        metadata,
        value
      }) {
        super("RETURNVALUE", "onReturnValue");
        this.paramOrdinal = paramOrdinal;
        this.paramName = paramName;
        this.metadata = metadata;
        this.value = value;
      }
    };
    exports2.ReturnValueToken = ReturnValueToken;
    var RowToken = class extends Token {
      constructor(columns) {
        super("ROW", "onRow");
        this.columns = columns;
      }
    };
    exports2.RowToken = RowToken;
    var SSPIToken = class extends Token {
      constructor(ntlmpacket, ntlmpacketBuffer) {
        super("SSPICHALLENGE", "onSSPI");
        this.ntlmpacket = ntlmpacket;
        this.ntlmpacketBuffer = ntlmpacketBuffer;
      }
    };
    exports2.SSPIToken = SSPIToken;
  }
});

// node_modules/tedious/lib/bulk-load.js
var require_bulk_load = __commonJS({
  "node_modules/tedious/lib/bulk-load.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _events = require("events");
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _stream = require("stream");
    var _token = require_token();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var FLAGS = {
      nullable: 1 << 0,
      caseSen: 1 << 1,
      updateableReadWrite: 1 << 2,
      updateableUnknown: 1 << 3,
      identity: 1 << 4,
      computed: 1 << 5,
      // introduced in TDS 7.2
      fixedLenCLRType: 1 << 8,
      // introduced in TDS 7.2
      sparseColumnSet: 1 << 10,
      // introduced in TDS 7.3.B
      hidden: 1 << 13,
      // introduced in TDS 7.2
      key: 1 << 14,
      // introduced in TDS 7.2
      nullableUnknown: 1 << 15
      // introduced in TDS 7.2
    };
    var DONE_STATUS = {
      FINAL: 0,
      MORE: 1,
      ERROR: 2,
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    var rowTokenBuffer = Buffer.from([_token.TYPE.ROW]);
    var textPointerAndTimestampBuffer = Buffer.from([
      // TextPointer length
      16,
      // TextPointer
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // Timestamp
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var textPointerNullBuffer = Buffer.from([0]);
    var RowTransform = class extends _stream.Transform {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      constructor(bulkLoad) {
        super({
          writableObjectMode: true
        });
        this.bulkLoad = bulkLoad;
        this.mainOptions = bulkLoad.options;
        this.columns = bulkLoad.columns;
        this.columnMetadataWritten = false;
      }
      /**
       * @private
       */
      _transform(row, _encoding, callback) {
        if (!this.columnMetadataWritten) {
          this.push(this.bulkLoad.getColMetaData());
          this.columnMetadataWritten = true;
        }
        this.push(rowTokenBuffer);
        for (let i = 0; i < this.columns.length; i++) {
          const c = this.columns[i];
          let value = Array.isArray(row) ? row[i] : row[c.objName];
          if (!this.bulkLoad.firstRowWritten) {
            try {
              value = c.type.validate(value, c.collation);
            } catch (error) {
              return callback(error);
            }
          }
          const parameter = {
            length: c.length,
            scale: c.scale,
            precision: c.precision,
            value
          };
          if (c.type.name === "Text" || c.type.name === "Image" || c.type.name === "NText") {
            if (value == null) {
              this.push(textPointerNullBuffer);
              continue;
            }
            this.push(textPointerAndTimestampBuffer);
          }
          try {
            this.push(c.type.generateParameterLength(parameter, this.mainOptions));
            for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
              this.push(chunk);
            }
          } catch (error) {
            return callback(error);
          }
        }
        process.nextTick(callback);
      }
      /**
       * @private
       */
      _flush(callback) {
        this.push(this.bulkLoad.createDoneToken());
        process.nextTick(callback);
      }
    };
    var BulkLoad = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      constructor(table, collation, connectionOptions, {
        checkConstraints = false,
        fireTriggers = false,
        keepNulls = false,
        lockTable = false,
        order = {}
      }, callback) {
        if (typeof checkConstraints !== "boolean") {
          throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
        }
        if (typeof fireTriggers !== "boolean") {
          throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
        }
        if (typeof keepNulls !== "boolean") {
          throw new TypeError('The "options.keepNulls" property must be of type boolean.');
        }
        if (typeof lockTable !== "boolean") {
          throw new TypeError('The "options.lockTable" property must be of type boolean.');
        }
        if (typeof order !== "object" || order === null) {
          throw new TypeError('The "options.order" property must be of type object.');
        }
        for (const [column2, direction] of Object.entries(order)) {
          if (direction !== "ASC" && direction !== "DESC") {
            throw new TypeError('The value of the "' + column2 + '" key in the "options.order" object must be either "ASC" or "DESC".');
          }
        }
        super();
        this.error = void 0;
        this.canceled = false;
        this.executionStarted = false;
        this.collation = collation;
        this.table = table;
        this.options = connectionOptions;
        this.callback = callback;
        this.columns = [];
        this.columnsByName = {};
        this.firstRowWritten = false;
        this.streamingMode = false;
        this.rowToPacketTransform = new RowTransform(this);
        this.bulkOptions = {
          checkConstraints,
          fireTriggers,
          keepNulls,
          lockTable,
          order
        };
      }
      /**
       * Adds a column to the bulk load.
       *
       * The column definitions should match the table you are trying to insert into.
       * Attempting to call addColumn after the first row has been added will throw an exception.
       *
       * ```js
       * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
       * ```
       *
       * @param name The name of the column.
       * @param type One of the supported `data types`.
       * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
       * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
       * @param nullable Indicates whether the column accepts NULL values.
       * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
       * @param precision For Numeric, Decimal.
       * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
      */
      addColumn(name3, type2, {
        output = false,
        length,
        precision,
        scale,
        objName = name3,
        nullable = true
      }) {
        if (this.firstRowWritten) {
          throw new Error("Columns cannot be added to bulk insert after the first row has been written.");
        }
        if (this.executionStarted) {
          throw new Error("Columns cannot be added to bulk insert after execution has started.");
        }
        const column2 = {
          type: type2,
          name: name3,
          value: null,
          output,
          length,
          precision,
          scale,
          objName,
          nullable,
          collation: this.collation
        };
        if ((type2.id & 48) === 32) {
          if (column2.length == null && type2.resolveLength) {
            column2.length = type2.resolveLength(column2);
          }
        }
        if (type2.resolvePrecision && column2.precision == null) {
          column2.precision = type2.resolvePrecision(column2);
        }
        if (type2.resolveScale && column2.scale == null) {
          column2.scale = type2.resolveScale(column2);
        }
        this.columns.push(column2);
        this.columnsByName[name3] = column2;
      }
      /**
       * @private
       */
      getOptionsSql() {
        const addOptions = [];
        if (this.bulkOptions.checkConstraints) {
          addOptions.push("CHECK_CONSTRAINTS");
        }
        if (this.bulkOptions.fireTriggers) {
          addOptions.push("FIRE_TRIGGERS");
        }
        if (this.bulkOptions.keepNulls) {
          addOptions.push("KEEP_NULLS");
        }
        if (this.bulkOptions.lockTable) {
          addOptions.push("TABLOCK");
        }
        if (this.bulkOptions.order) {
          const orderColumns = [];
          for (const [column2, direction] of Object.entries(this.bulkOptions.order)) {
            orderColumns.push(`${column2} ${direction}`);
          }
          if (orderColumns.length) {
            addOptions.push(`ORDER (${orderColumns.join(", ")})`);
          }
        }
        if (addOptions.length > 0) {
          return ` WITH (${addOptions.join(",")})`;
        } else {
          return "";
        }
      }
      /**
       * @private
       */
      getBulkInsertSql() {
        let sql = "insert bulk " + this.table + "(";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql += ", ";
          }
          sql += "[" + c.name + "] " + c.type.declaration(c);
        }
        sql += ")";
        sql += this.getOptionsSql();
        return sql;
      }
      /**
       * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
       * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
       *
       * ```js
       * var sql = bulkLoad.getTableCreationSql();
       * ```
       *
       * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
       * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
       */
      getTableCreationSql() {
        let sql = "CREATE TABLE " + this.table + "(\n";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql += ",\n";
          }
          sql += "[" + c.name + "] " + c.type.declaration(c);
          if (c.nullable !== void 0) {
            sql += " " + (c.nullable ? "NULL" : "NOT NULL");
          }
        }
        sql += "\n)";
        return sql;
      }
      /**
       * @private
       */
      getColMetaData() {
        const tBuf = new _writableTrackingBuffer.default(100, null, true);
        tBuf.writeUInt8(_token.TYPE.COLMETADATA);
        tBuf.writeUInt16LE(this.columns.length);
        for (let j = 0, len = this.columns.length; j < len; j++) {
          const c = this.columns[j];
          if (this.options.tdsVersion < "7_2") {
            tBuf.writeUInt16LE(0);
          } else {
            tBuf.writeUInt32LE(0);
          }
          let flags = FLAGS.updateableReadWrite;
          if (c.nullable) {
            flags |= FLAGS.nullable;
          } else if (c.nullable === void 0 && this.options.tdsVersion >= "7_2") {
            flags |= FLAGS.nullableUnknown;
          }
          tBuf.writeUInt16LE(flags);
          tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options));
          if (c.type.hasTableName) {
            tBuf.writeUsVarchar(this.table, "ucs2");
          }
          tBuf.writeBVarchar(c.name, "ucs2");
        }
        return tBuf.data;
      }
      /**
       * Sets a timeout for this bulk load.
       *
       * ```js
       * bulkLoad.setTimeout(timeout);
       * ```
       *
       * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
       *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
      /**
       * @private
       */
      createDoneToken() {
        const tBuf = new _writableTrackingBuffer.default(this.options.tdsVersion < "7_2" ? 9 : 13);
        tBuf.writeUInt8(_token.TYPE.DONE);
        const status = DONE_STATUS.FINAL;
        tBuf.writeUInt16LE(status);
        tBuf.writeUInt16LE(0);
        tBuf.writeUInt32LE(0);
        if (this.options.tdsVersion >= "7_2") {
          tBuf.writeUInt32LE(0);
        }
        return tBuf.data;
      }
      /**
       * @private
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
    };
    var _default = exports2.default = BulkLoad;
    module2.exports = BulkLoad;
  }
});

// node_modules/@azure/identity/dist-esm/src/constants.js
var SDK_VERSION, DeveloperSignOnClientId, DefaultTenantId, AzureAuthorityHosts, DefaultAuthorityHost, ALL_TENANTS, CACHE_CAE_SUFFIX, CACHE_NON_CAE_SUFFIX, DEFAULT_TOKEN_CACHE_NAME;
var init_constants = __esm({
  "node_modules/@azure/identity/dist-esm/src/constants.js"() {
    "use strict";
    SDK_VERSION = `4.4.1`;
    DeveloperSignOnClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
    DefaultTenantId = "common";
    (function(AzureAuthorityHosts2) {
      AzureAuthorityHosts2["AzureChina"] = "https://login.chinacloudapi.cn";
      AzureAuthorityHosts2["AzureGermany"] = "https://login.microsoftonline.de";
      AzureAuthorityHosts2["AzureGovernment"] = "https://login.microsoftonline.us";
      AzureAuthorityHosts2["AzurePublicCloud"] = "https://login.microsoftonline.com";
    })(AzureAuthorityHosts || (AzureAuthorityHosts = {}));
    DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;
    ALL_TENANTS = ["*"];
    CACHE_CAE_SUFFIX = "cae";
    CACHE_NON_CAE_SUFFIX = "nocae";
    DEFAULT_TOKEN_CACHE_NAME = "msal.cache";
  }
});

// node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalPlugins.js
function generatePluginConfiguration(options) {
  var _a3, _b2, _c2, _d2, _e, _f, _g;
  const config = {
    cache: {},
    broker: {
      isEnabled: (_b2 = (_a3 = options.brokerOptions) === null || _a3 === void 0 ? void 0 : _a3.enabled) !== null && _b2 !== void 0 ? _b2 : false,
      enableMsaPassthrough: (_d2 = (_c2 = options.brokerOptions) === null || _c2 === void 0 ? void 0 : _c2.legacyEnableMsaPassthrough) !== null && _d2 !== void 0 ? _d2 : false,
      parentWindowHandle: (_e = options.brokerOptions) === null || _e === void 0 ? void 0 : _e.parentWindowHandle
    }
  };
  if ((_f = options.tokenCachePersistenceOptions) === null || _f === void 0 ? void 0 : _f.enabled) {
    if (persistenceProvider === void 0) {
      throw new Error([
        "Persistent token caching was requested, but no persistence provider was configured.",
        "You must install the identity-cache-persistence plugin package (`npm install --save @azure/identity-cache-persistence`)",
        "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
        "`useIdentityPlugin(cachePersistencePlugin)` before using `tokenCachePersistenceOptions`."
      ].join(" "));
    }
    const cacheBaseName = options.tokenCachePersistenceOptions.name || DEFAULT_TOKEN_CACHE_NAME;
    config.cache.cachePlugin = persistenceProvider(Object.assign({ name: `${cacheBaseName}.${CACHE_NON_CAE_SUFFIX}` }, options.tokenCachePersistenceOptions));
    config.cache.cachePluginCae = persistenceProvider(Object.assign({ name: `${cacheBaseName}.${CACHE_CAE_SUFFIX}` }, options.tokenCachePersistenceOptions));
  }
  if ((_g = options.brokerOptions) === null || _g === void 0 ? void 0 : _g.enabled) {
    if (nativeBrokerInfo === void 0) {
      throw new Error([
        "Broker for WAM was requested to be enabled, but no native broker was configured.",
        "You must install the identity-broker plugin package (`npm install --save @azure/identity-broker`)",
        "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
        "`useIdentityPlugin(createNativeBrokerPlugin())` before using `enableBroker`."
      ].join(" "));
    }
    config.broker.nativeBrokerPlugin = nativeBrokerInfo.broker;
  }
  return config;
}
var persistenceProvider, msalNodeFlowCacheControl, nativeBrokerInfo, msalNodeFlowNativeBrokerControl, msalPlugins;
var init_msalPlugins = __esm({
  "node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalPlugins.js"() {
    "use strict";
    init_constants();
    persistenceProvider = void 0;
    msalNodeFlowCacheControl = {
      setPersistence(pluginProvider) {
        persistenceProvider = pluginProvider;
      }
    };
    nativeBrokerInfo = void 0;
    msalNodeFlowNativeBrokerControl = {
      setNativeBroker(broker) {
        nativeBrokerInfo = {
          broker
        };
      }
    };
    msalPlugins = {
      generatePluginConfiguration
    };
  }
});

// node_modules/@azure/logger/dist/esm/log.js
function log2(message, ...args) {
  process2.stderr.write(`${import_node_util.default.format(message, ...args)}${import_node_os.EOL}`);
}
var import_node_os, import_node_util, process2;
var init_log = __esm({
  "node_modules/@azure/logger/dist/esm/log.js"() {
    "use strict";
    import_node_os = require("os");
    import_node_util = __toESM(require("util"), 1);
    process2 = __toESM(require("process"), 1);
  }
});

// node_modules/@azure/logger/dist/esm/debug.js
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const wildcard = /\*/g;
  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    } else {
      enabledNamespaces.push(new RegExp(`^${ns}$`));
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (skipped.test(namespace)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (enabledNamespace.test(namespace)) {
      return true;
    }
  }
  return false;
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
var debugEnvVariable, enabledString, enabledNamespaces, skippedNamespaces, debuggers, debugObj, debug_default;
var init_debug = __esm({
  "node_modules/@azure/logger/dist/esm/debug.js"() {
    "use strict";
    init_log();
    debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
    enabledNamespaces = [];
    skippedNamespaces = [];
    debuggers = [];
    if (debugEnvVariable) {
      enable(debugEnvVariable);
    }
    debugObj = Object.assign((namespace) => {
      return createDebugger(namespace);
    }, {
      enable,
      enabled,
      disable,
      log: log2
    });
    debug_default = debugObj;
  }
});

// node_modules/@azure/logger/dist/esm/index.js
function setLogLevel(level) {
  if (level && !isAzureLogLevel(level)) {
    throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
  }
  azureLogLevel = level;
  const enabledNamespaces2 = [];
  for (const logger26 of registeredLoggers) {
    if (shouldEnable(logger26)) {
      enabledNamespaces2.push(logger26.namespace);
    }
  }
  debug_default.enable(enabledNamespaces2.join(","));
}
function getLogLevel() {
  return azureLogLevel;
}
function createClientLogger(namespace) {
  const clientRootLogger = AzureLogger.extend(namespace);
  patchLogMethod(AzureLogger, clientRootLogger);
  return {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function createLogger(parent, level) {
  const logger26 = Object.assign(parent.extend(level), {
    level
  });
  patchLogMethod(parent, logger26);
  if (shouldEnable(logger26)) {
    const enabledNamespaces2 = debug_default.disable();
    debug_default.enable(enabledNamespaces2 + "," + logger26.namespace);
  }
  registeredLoggers.add(logger26);
  return logger26;
}
function shouldEnable(logger26) {
  return Boolean(azureLogLevel && levelMap[logger26.level] <= levelMap[azureLogLevel]);
}
function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}
var registeredLoggers, logLevelFromEnv, azureLogLevel, AzureLogger, AZURE_LOG_LEVELS, levelMap;
var init_esm = __esm({
  "node_modules/@azure/logger/dist/esm/index.js"() {
    "use strict";
    init_debug();
    registeredLoggers = /* @__PURE__ */ new Set();
    logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || void 0;
    AzureLogger = debug_default("azure");
    AzureLogger.log = (...args) => {
      debug_default.log(...args);
    };
    AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    if (logLevelFromEnv) {
      if (isAzureLogLevel(logLevelFromEnv)) {
        setLogLevel(logLevelFromEnv);
      } else {
        console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
      }
    }
    levelMap = {
      verbose: 400,
      info: 300,
      warning: 200,
      error: 100
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/util/logging.js
function processEnvVars(supportedEnvVars) {
  return supportedEnvVars.reduce((acc, envVariable) => {
    if (process.env[envVariable]) {
      acc.assigned.push(envVariable);
    } else {
      acc.missing.push(envVariable);
    }
    return acc;
  }, { missing: [], assigned: [] });
}
function formatSuccess(scope) {
  return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
}
function formatError(scope, error) {
  let message = "ERROR.";
  if (scope === null || scope === void 0 ? void 0 : scope.length) {
    message += ` Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
  }
  return `${message} Error message: ${typeof error === "string" ? error : error.message}.`;
}
function credentialLoggerInstance(title, parent, log3 = logger2) {
  const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
  function info(message) {
    log3.info(`${fullTitle} =>`, message);
  }
  function warning(message) {
    log3.warning(`${fullTitle} =>`, message);
  }
  function verbose(message) {
    log3.verbose(`${fullTitle} =>`, message);
  }
  function error(message) {
    log3.error(`${fullTitle} =>`, message);
  }
  return {
    title,
    fullTitle,
    info,
    warning,
    verbose,
    error
  };
}
function credentialLogger(title, log3 = logger2) {
  const credLogger = credentialLoggerInstance(title, void 0, log3);
  return Object.assign(Object.assign({}, credLogger), { parent: log3, getToken: credentialLoggerInstance("=> getToken()", credLogger, log3) });
}
var logger2;
var init_logging = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/logging.js"() {
    "use strict";
    init_esm();
    logger2 = createClientLogger("identity");
  }
});

// node_modules/@azure/identity/dist-esm/src/errors.js
function isErrorResponse(errorResponse) {
  return errorResponse && typeof errorResponse.error === "string" && typeof errorResponse.error_description === "string";
}
function convertOAuthErrorResponseToErrorResponse(errorBody) {
  return {
    error: errorBody.error,
    errorDescription: errorBody.error_description,
    correlationId: errorBody.correlation_id,
    errorCodes: errorBody.error_codes,
    timestamp: errorBody.timestamp,
    traceId: errorBody.trace_id
  };
}
var CredentialUnavailableErrorName, CredentialUnavailableError, AuthenticationErrorName, AuthenticationError, AggregateAuthenticationErrorName, AggregateAuthenticationError, AuthenticationRequiredError;
var init_errors = __esm({
  "node_modules/@azure/identity/dist-esm/src/errors.js"() {
    "use strict";
    CredentialUnavailableErrorName = "CredentialUnavailableError";
    CredentialUnavailableError = class extends Error {
      constructor(message) {
        super(message);
        this.name = CredentialUnavailableErrorName;
      }
    };
    AuthenticationErrorName = "AuthenticationError";
    AuthenticationError = class extends Error {
      // eslint-disable-next-line @typescript-eslint/ban-types
      constructor(statusCode, errorBody) {
        let errorResponse = {
          error: "unknown",
          errorDescription: "An unknown error occurred and no additional details are available."
        };
        if (isErrorResponse(errorBody)) {
          errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
        } else if (typeof errorBody === "string") {
          try {
            const oauthErrorResponse = JSON.parse(errorBody);
            errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
          } catch (e) {
            if (statusCode === 400) {
              errorResponse = {
                error: "authority_not_found",
                errorDescription: "The specified authority URL was not found."
              };
            } else {
              errorResponse = {
                error: "unknown_error",
                errorDescription: `An unknown error has occurred. Response body:

${errorBody}`
              };
            }
          }
        } else {
          errorResponse = {
            error: "unknown_error",
            errorDescription: "An unknown error occurred and no additional details are available."
          };
        }
        super(`${errorResponse.error} Status code: ${statusCode}
More details:
${errorResponse.errorDescription}`);
        this.statusCode = statusCode;
        this.errorResponse = errorResponse;
        this.name = AuthenticationErrorName;
      }
    };
    AggregateAuthenticationErrorName = "AggregateAuthenticationError";
    AggregateAuthenticationError = class extends Error {
      constructor(errors, errorMessage) {
        const errorDetail = errors.join("\n");
        super(`${errorMessage}
${errorDetail}`);
        this.errors = errors;
        this.name = AggregateAuthenticationErrorName;
      }
    };
    AuthenticationRequiredError = class extends Error {
      constructor(options) {
        super(options.message);
        this.scopes = options.scopes;
        this.getTokenOptions = options.getTokenOptions;
        this.name = "AuthenticationRequiredError";
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/util/processMultiTenantRequest.js
function createConfigurationErrorMessage(tenantId) {
  return `The current credential is not configured to acquire tokens for tenant ${tenantId}. To enable acquiring tokens for this tenant add it to the AdditionallyAllowedTenants on the credential options, or add "*" to AdditionallyAllowedTenants to allow acquiring tokens for any tenant.`;
}
function processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds = [], logger26) {
  var _a3;
  let resolvedTenantId;
  if (process.env.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH) {
    resolvedTenantId = tenantId;
  } else if (tenantId === "adfs") {
    resolvedTenantId = tenantId;
  } else {
    resolvedTenantId = (_a3 = getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId) !== null && _a3 !== void 0 ? _a3 : tenantId;
  }
  if (tenantId && resolvedTenantId !== tenantId && !additionallyAllowedTenantIds.includes("*") && !additionallyAllowedTenantIds.some((t) => t.localeCompare(resolvedTenantId) === 0)) {
    const message = createConfigurationErrorMessage(tenantId);
    logger26 === null || logger26 === void 0 ? void 0 : logger26.info(message);
    throw new CredentialUnavailableError(message);
  }
  return resolvedTenantId;
}
var init_processMultiTenantRequest = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/processMultiTenantRequest.js"() {
    "use strict";
    init_errors();
  }
});

// node_modules/@azure/identity/dist-esm/src/util/tenantIdUtils.js
function checkTenantId(logger26, tenantId) {
  if (!tenantId.match(/^[0-9a-zA-Z-.]+$/)) {
    const error = new Error("Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://learn.microsoft.com/partner-center/find-ids-and-domain-names.");
    logger26.info(formatError("", error));
    throw error;
  }
}
function resolveTenantId(logger26, tenantId, clientId) {
  if (tenantId) {
    checkTenantId(logger26, tenantId);
    return tenantId;
  }
  if (!clientId) {
    clientId = DeveloperSignOnClientId;
  }
  if (clientId !== DeveloperSignOnClientId) {
    return "common";
  }
  return "organizations";
}
function resolveAdditionallyAllowedTenantIds(additionallyAllowedTenants) {
  if (!additionallyAllowedTenants || additionallyAllowedTenants.length === 0) {
    return [];
  }
  if (additionallyAllowedTenants.includes("*")) {
    return ALL_TENANTS;
  }
  return additionallyAllowedTenants;
}
var init_tenantIdUtils = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/tenantIdUtils.js"() {
    "use strict";
    init_constants();
    init_logging();
    init_processMultiTenantRequest();
  }
});

// node_modules/@azure/core-client/dist/esm/base64.js
var init_base64 = __esm({
  "node_modules/@azure/core-client/dist/esm/base64.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-client/dist/esm/interfaces.js
var XML_ATTRKEY, XML_CHARKEY;
var init_interfaces = __esm({
  "node_modules/@azure/core-client/dist/esm/interfaces.js"() {
    "use strict";
    XML_ATTRKEY = "$";
    XML_CHARKEY = "_";
  }
});

// node_modules/@azure/core-client/dist/esm/utils.js
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === void 0 || value === null);
}
function handleNullableResponseAndWrappableBody(responseObject) {
  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? { body: null } : null;
  } else {
    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
  }
}
function flattenResponse(fullResponse, responseSpec) {
  var _a3, _b2;
  const parsedHeaders = fullResponse.parsedHeaders;
  if (fullResponse.request.method === "HEAD") {
    return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
  }
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
  if (expectedBodyTypeName === "Stream") {
    return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
  }
  const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    const arrayResponse = (_a3 = fullResponse.parsedBody) !== null && _a3 !== void 0 ? _a3 : [];
    for (const key of Object.keys(modelProperties)) {
      if (modelProperties[key].serializedName) {
        arrayResponse[key] = (_b2 = fullResponse.parsedBody) === null || _b2 === void 0 ? void 0 : _b2[key];
      }
    }
    if (parsedHeaders) {
      for (const key of Object.keys(parsedHeaders)) {
        arrayResponse[key] = parsedHeaders[key];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}
var init_utils = __esm({
  "node_modules/@azure/core-client/dist/esm/utils.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-client/dist/esm/serializer.js
var MapperTypeNames;
var init_serializer = __esm({
  "node_modules/@azure/core-client/dist/esm/serializer.js"() {
    "use strict";
    init_base64();
    init_interfaces();
    init_utils();
    MapperTypeNames = {
      Base64Url: "Base64Url",
      Boolean: "Boolean",
      ByteArray: "ByteArray",
      Composite: "Composite",
      Date: "Date",
      DateTime: "DateTime",
      DateTimeRfc1123: "DateTimeRfc1123",
      Dictionary: "Dictionary",
      Enum: "Enum",
      Number: "Number",
      Object: "Object",
      Sequence: "Sequence",
      String: "String",
      Stream: "Stream",
      TimeSpan: "TimeSpan",
      UnixTime: "UnixTime"
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/pipeline.js
function createEmptyPipeline() {
  return HttpPipeline.create();
}
var ValidPhaseNames, HttpPipeline;
var init_pipeline = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/pipeline.js"() {
    "use strict";
    ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    HttpPipeline = class _HttpPipeline {
      constructor(policies) {
        var _a3;
        this._policies = [];
        this._policies = (_a3 = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a3 !== void 0 ? _a3 : [];
        this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
          throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
          throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
          throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
          policy,
          options
        });
        this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
          if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
            removedPolicies.push(policyDescriptor.policy);
            return false;
          } else {
            return true;
          }
        });
        this._orderedPolicies = void 0;
        return removedPolicies;
      }
      sendRequest(httpClient, request3) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
          return (req) => {
            return policy.sendRequest(req, next);
          };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request3);
      }
      getOrderedPolicies() {
        if (!this._orderedPolicies) {
          this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        const result = [];
        const policyMap = /* @__PURE__ */ new Map();
        function createPhase(name3) {
          return {
            name: name3,
            policies: /* @__PURE__ */ new Set(),
            hasRun: false,
            hasAfterPolicies: false
          };
        }
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          if (phase === "Retry") {
            return retryPhase;
          } else if (phase === "Serialize") {
            return serializePhase;
          } else if (phase === "Deserialize") {
            return deserializePhase;
          } else if (phase === "Sign") {
            return signPhase;
          } else {
            return noPhase;
          }
        }
        for (const descriptor of this._policies) {
          const policy = descriptor.policy;
          const options = descriptor.options;
          const policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          const node = {
            policy,
            dependsOn: /* @__PURE__ */ new Set(),
            dependants: /* @__PURE__ */ new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          const phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        for (const descriptor of this._policies) {
          const { policy, options } = descriptor;
          const policyName = policy.name;
          const node = policyMap.get(policyName);
          if (!node) {
            throw new Error(`Missing node for policy ${policyName}`);
          }
          if (options.afterPolicies) {
            for (const afterPolicyName of options.afterPolicies) {
              const afterNode = policyMap.get(afterPolicyName);
              if (afterNode) {
                node.dependsOn.add(afterNode);
                afterNode.dependants.add(node);
              }
            }
          }
          if (options.beforePolicies) {
            for (const beforePolicyName of options.beforePolicies) {
              const beforeNode = policyMap.get(beforePolicyName);
              if (beforeNode) {
                beforeNode.dependsOn.add(node);
                node.dependants.add(beforeNode);
              }
            }
          }
        }
        function walkPhase(phase) {
          phase.hasRun = true;
          for (const node of phase.policies) {
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              continue;
            }
            if (node.dependsOn.size === 0) {
              result.push(node.policy);
              for (const dependant of node.dependants) {
                dependant.dependsOn.delete(node);
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        }
        function walkPhases() {
          for (const phase of orderedPhases) {
            walkPhase(phase);
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                walkPhase(noPhase);
              }
              return;
            }
            if (phase.hasAfterPolicies) {
              walkPhase(noPhase);
            }
          }
        }
        let iteration = 0;
        while (policyMap.size > 0) {
          iteration++;
          const initialResultLength = result.length;
          walkPhases();
          if (result.length <= initialResultLength && iteration > 1) {
            throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/log.js
var logger3;
var init_log2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/log.js"() {
    "use strict";
    init_esm();
    logger3 = createClientLogger("core-rest-pipeline");
  }
});

// node_modules/@azure/abort-controller/dist/esm/AbortError.js
var AbortError;
var init_AbortError = __esm({
  "node_modules/@azure/abort-controller/dist/esm/AbortError.js"() {
    "use strict";
    AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
  }
});

// node_modules/@azure/abort-controller/dist/esm/index.js
var init_esm2 = __esm({
  "node_modules/@azure/abort-controller/dist/esm/index.js"() {
    "use strict";
    init_AbortError();
  }
});

// node_modules/@azure/core-util/dist/esm/createAbortablePromise.js
function createAbortablePromise(buildPromise, options) {
  const { cleanupBeforeAbort, abortSignal: abortSignal2, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
  return new Promise((resolve, reject) => {
    function rejectOnAbort() {
      reject(new AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
    }
    function removeListeners() {
      abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.removeEventListener("abort", onAbort);
    }
    function onAbort() {
      cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();
      removeListeners();
      rejectOnAbort();
    }
    if (abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.aborted) {
      return rejectOnAbort();
    }
    try {
      buildPromise((x) => {
        removeListeners();
        resolve(x);
      }, (x) => {
        removeListeners();
        reject(x);
      });
    } catch (err) {
      reject(err);
    }
    abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.addEventListener("abort", onAbort);
  });
}
var init_createAbortablePromise = __esm({
  "node_modules/@azure/core-util/dist/esm/createAbortablePromise.js"() {
    "use strict";
    init_esm2();
  }
});

// node_modules/@azure/core-util/dist/esm/random.js
function getRandomIntegerInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  const offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}
var init_random = __esm({
  "node_modules/@azure/core-util/dist/esm/random.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-util/dist/esm/delay.js
function delay(timeInMs, options) {
  let token;
  const { abortSignal: abortSignal2, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
  return createAbortablePromise((resolve) => {
    token = setTimeout(resolve, timeInMs);
  }, {
    cleanupBeforeAbort: () => clearTimeout(token),
    abortSignal: abortSignal2,
    abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage
  });
}
var StandardAbortMessage;
var init_delay = __esm({
  "node_modules/@azure/core-util/dist/esm/delay.js"() {
    "use strict";
    init_createAbortablePromise();
    init_random();
    StandardAbortMessage = "The delay was aborted.";
  }
});

// node_modules/@azure/core-util/dist/esm/aborterUtils.js
var init_aborterUtils = __esm({
  "node_modules/@azure/core-util/dist/esm/aborterUtils.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-util/dist/esm/object.js
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
var init_object = __esm({
  "node_modules/@azure/core-util/dist/esm/object.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-util/dist/esm/error.js
function isError(e) {
  if (isObject(e)) {
    const hasName = typeof e.name === "string";
    const hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
function getErrorMessage(e) {
  if (isError(e)) {
    return e.message;
  } else {
    let stringified;
    try {
      if (typeof e === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}
var init_error = __esm({
  "node_modules/@azure/core-util/dist/esm/error.js"() {
    "use strict";
    init_object();
  }
});

// node_modules/@azure/core-util/dist/esm/sha256.js
var init_sha256 = __esm({
  "node_modules/@azure/core-util/dist/esm/sha256.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-util/dist/esm/typeGuards.js
var init_typeGuards = __esm({
  "node_modules/@azure/core-util/dist/esm/typeGuards.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-util/dist/esm/uuidUtils.js
function randomUUID() {
  return uuidFunction();
}
var import_crypto, _a, uuidFunction;
var init_uuidUtils = __esm({
  "node_modules/@azure/core-util/dist/esm/uuidUtils.js"() {
    "use strict";
    import_crypto = require("crypto");
    uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : import_crypto.randomUUID;
  }
});

// node_modules/@azure/core-util/dist/esm/checkEnvironment.js
var _a2, _b, _c, _d, isBrowser, isWebWorker, isDeno, isBun, isNodeLike, isNode, isReactNative;
var init_checkEnvironment = __esm({
  "node_modules/@azure/core-util/dist/esm/checkEnvironment.js"() {
    "use strict";
    isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a2 = self.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
    isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d = globalThis.process.versions) === null || _d === void 0 ? void 0 : _d.node);
    isNode = isNodeLike;
    isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
  }
});

// node_modules/@azure/core-util/dist/esm/bytesEncoding.js
function stringToUint8Array(value, format) {
  return Buffer.from(value, format);
}
var init_bytesEncoding = __esm({
  "node_modules/@azure/core-util/dist/esm/bytesEncoding.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-util/dist/esm/index.js
var init_esm3 = __esm({
  "node_modules/@azure/core-util/dist/esm/index.js"() {
    "use strict";
    init_delay();
    init_aborterUtils();
    init_createAbortablePromise();
    init_random();
    init_object();
    init_error();
    init_sha256();
    init_typeGuards();
    init_uuidUtils();
    init_checkEnvironment();
    init_bytesEncoding();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/sanitizer.js
var RedactedString, defaultAllowedHeaderNames, defaultAllowedQueryParameters, Sanitizer;
var init_sanitizer = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/sanitizer.js"() {
    "use strict";
    init_esm3();
    RedactedString = "REDACTED";
    defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    defaultAllowedQueryParameters = ["api-version"];
    Sanitizer = class {
      constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
          }
          if (key === "headers") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || isObject(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null || value === "") {
          return value;
        }
        const url = new URL(value);
        if (!url.search) {
          return value;
        }
        for (const [key] of url.searchParams) {
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString);
          }
        }
        return url.toString();
      }
      sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
          if (this.allowedHeaderNames.has(key.toLowerCase())) {
            sanitized[key] = obj[key];
          } else {
            sanitized[key] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (this.allowedQueryParameters.has(k.toLowerCase())) {
            sanitized[k] = value[k];
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/logPolicy.js
function logPolicy(options = {}) {
  var _a3;
  const logger26 = (_a3 = options.logger) !== null && _a3 !== void 0 ? _a3 : logger3.info;
  const sanitizer = new Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request3, next) {
      if (!logger26.enabled) {
        return next(request3);
      }
      logger26(`Request: ${sanitizer.sanitize(request3)}`);
      const response = await next(request3);
      logger26(`Response status code: ${response.status}`);
      logger26(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}
var logPolicyName;
var init_logPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/logPolicy.js"() {
    "use strict";
    init_log2();
    init_sanitizer();
    logPolicyName = "logPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/redirectPolicy.js
function redirectPolicy(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request3, next) {
      const response = await next(request3);
      return handleRedirect(next, response, maxRetries);
    }
  };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
  const { request: request3, status, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request3.method) || status === 302 && allowedRedirect.includes(request3.method) || status === 303 && request3.method === "POST" || status === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request3.url);
    request3.url = url.toString();
    if (status === 303) {
      request3.method = "GET";
      request3.headers.delete("Content-Length");
      delete request3.body;
    }
    request3.headers.delete("Authorization");
    const res = await next(request3);
    return handleRedirect(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}
var redirectPolicyName, allowedRedirect;
var init_redirectPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/redirectPolicy.js"() {
    "use strict";
    redirectPolicyName = "redirectPolicy";
    allowedRedirect = ["GET", "HEAD"];
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/userAgentPlatform.js
function getHeaderName() {
  return "User-Agent";
}
async function setPlatformSpecificData(map) {
  if (process3 && process3.versions) {
    const versions2 = process3.versions;
    if (versions2.bun) {
      map.set("Bun", versions2.bun);
    } else if (versions2.deno) {
      map.set("Deno", versions2.deno);
    } else if (versions2.node) {
      map.set("Node", versions2.node);
    }
  }
  map.set("OS", `(${os.arch()}-${os.type()}-${os.release()})`);
}
var os, process3;
var init_userAgentPlatform = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/userAgentPlatform.js"() {
    "use strict";
    os = __toESM(require("os"), 1);
    process3 = __toESM(require("process"), 1);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/constants.js
var SDK_VERSION2, DEFAULT_RETRY_POLICY_COUNT;
var init_constants2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/constants.js"() {
    "use strict";
    SDK_VERSION2 = "1.17.0";
    DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/userAgent.js
function getUserAgentString(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName() {
  return getHeaderName();
}
async function getUserAgentValue(prefix) {
  const runtimeInfo = /* @__PURE__ */ new Map();
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION2);
  await setPlatformSpecificData(runtimeInfo);
  const defaultAgent = getUserAgentString(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}
var init_userAgent = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/userAgent.js"() {
    "use strict";
    init_userAgentPlatform();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/userAgentPolicy.js
function userAgentPolicy(options = {}) {
  const userAgentValue = getUserAgentValue(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    async sendRequest(request3, next) {
      if (!request3.headers.has(UserAgentHeaderName)) {
        request3.headers.set(UserAgentHeaderName, await userAgentValue);
      }
      return next(request3);
    }
  };
}
var UserAgentHeaderName, userAgentPolicyName;
var init_userAgentPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/userAgentPolicy.js"() {
    "use strict";
    init_userAgent();
    UserAgentHeaderName = getUserAgentHeaderName();
    userAgentPolicyName = "userAgentPolicy";
  }
});

// node_modules/tslib/tslib.es6.mjs
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/typeGuards.js
function isBlob(x) {
  return typeof x.stream === "function";
}
var init_typeGuards2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/typeGuards.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/file.js
function hasRawContent(x) {
  return typeof x[rawContent] === "function";
}
function getRawContent(blob) {
  if (hasRawContent(blob)) {
    return blob[rawContent]();
  } else {
    return blob.stream();
  }
}
var rawContent;
var init_file = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/file.js"() {
    "use strict";
    init_esm3();
    init_typeGuards2();
    rawContent = Symbol("rawContent");
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/concat.js
function streamAsyncIterator() {
  return __asyncGenerator(this, arguments, function* streamAsyncIterator_1() {
    const reader = this.getReader();
    try {
      while (true) {
        const { done, value } = yield __await(reader.read());
        if (done) {
          return yield __await(void 0);
        }
        yield yield __await(value);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function makeAsyncIterable(webStream) {
  if (!webStream[Symbol.asyncIterator]) {
    webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
  }
  if (!webStream.values) {
    webStream.values = streamAsyncIterator.bind(webStream);
  }
}
function ensureNodeStream(stream) {
  if (stream instanceof ReadableStream) {
    makeAsyncIterable(stream);
    return import_node_stream.Readable.fromWeb(stream);
  } else {
    return stream;
  }
}
function toStream(source) {
  if (source instanceof Uint8Array) {
    return import_node_stream.Readable.from(Buffer.from(source));
  } else if (isBlob(source)) {
    return toStream(getRawContent(source));
  } else {
    return ensureNodeStream(source);
  }
}
async function concat(sources) {
  return function() {
    const streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
    return import_node_stream.Readable.from(function() {
      return __asyncGenerator(this, arguments, function* () {
        var _a3, e_1, _b2, _c2;
        for (const stream of streams) {
          try {
            for (var _d2 = true, stream_1 = (e_1 = void 0, __asyncValues(stream)), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a3 = stream_1_1.done, !_a3; _d2 = true) {
              _c2 = stream_1_1.value;
              _d2 = false;
              const chunk = _c2;
              yield yield __await(chunk);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d2 && !_a3 && (_b2 = stream_1.return))
                yield __await(_b2.call(stream_1));
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    }());
  };
}
var import_node_stream;
var init_concat = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/concat.js"() {
    "use strict";
    init_tslib_es6();
    import_node_stream = require("stream");
    init_typeGuards2();
    init_file();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/multipartPolicy.js
function generateBoundary() {
  return `----AzSDKFormBoundary${randomUUID()}`;
}
function encodeHeaders(headers) {
  let result = "";
  for (const [key, value] of headers) {
    result += `${key}: ${value}\r
`;
  }
  return result;
}
function getLength(source) {
  if (source instanceof Uint8Array) {
    return source.byteLength;
  } else if (isBlob(source)) {
    return source.size === -1 ? void 0 : source.size;
  } else {
    return void 0;
  }
}
function getTotalLength(sources) {
  let total = 0;
  for (const source of sources) {
    const partLength = getLength(source);
    if (partLength === void 0) {
      return void 0;
    } else {
      total += partLength;
    }
  }
  return total;
}
async function buildRequestBody(request3, parts, boundary) {
  const sources = [
    stringToUint8Array(`--${boundary}`, "utf-8"),
    ...parts.flatMap((part) => [
      stringToUint8Array("\r\n", "utf-8"),
      stringToUint8Array(encodeHeaders(part.headers), "utf-8"),
      stringToUint8Array("\r\n", "utf-8"),
      part.body,
      stringToUint8Array(`\r
--${boundary}`, "utf-8")
    ]),
    stringToUint8Array("--\r\n\r\n", "utf-8")
  ];
  const contentLength = getTotalLength(sources);
  if (contentLength) {
    request3.headers.set("Content-Length", contentLength);
  }
  request3.body = await concat(sources);
}
function assertValidBoundary(boundary) {
  if (boundary.length > maxBoundaryLength) {
    throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
  }
  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
    throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
  }
}
function multipartPolicy() {
  return {
    name: multipartPolicyName,
    async sendRequest(request3, next) {
      var _a3;
      if (!request3.multipartBody) {
        return next(request3);
      }
      if (request3.body) {
        throw new Error("multipartBody and regular body cannot be set at the same time");
      }
      let boundary = request3.multipartBody.boundary;
      const contentTypeHeader = (_a3 = request3.headers.get("Content-Type")) !== null && _a3 !== void 0 ? _a3 : "multipart/mixed";
      const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
      if (!parsedHeader) {
        throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
      }
      const [, contentType, parsedBoundary] = parsedHeader;
      if (parsedBoundary && boundary && parsedBoundary !== boundary) {
        throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
      }
      boundary !== null && boundary !== void 0 ? boundary : boundary = parsedBoundary;
      if (boundary) {
        assertValidBoundary(boundary);
      } else {
        boundary = generateBoundary();
      }
      request3.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
      await buildRequestBody(request3, request3.multipartBody.parts, boundary);
      request3.multipartBody = void 0;
      return next(request3);
    }
  };
}
var multipartPolicyName, maxBoundaryLength, validBoundaryCharacters;
var init_multipartPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/multipartPolicy.js"() {
    "use strict";
    init_esm3();
    init_concat();
    init_typeGuards2();
    multipartPolicyName = "multipartPolicy";
    maxBoundaryLength = 70;
    validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/decompressResponsePolicy.js
function decompressResponsePolicy() {
  return {
    name: decompressResponsePolicyName,
    async sendRequest(request3, next) {
      if (request3.method !== "HEAD") {
        request3.headers.set("Accept-Encoding", "gzip,deflate");
      }
      return next(request3);
    }
  };
}
var decompressResponsePolicyName;
var init_decompressResponsePolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/decompressResponsePolicy.js"() {
    "use strict";
    decompressResponsePolicyName = "decompressResponsePolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/helpers.js
function delay2(delayInMs, value, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage2));
    };
    const removeListeners = () => {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}
var StandardAbortMessage2;
var init_helpers = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/helpers.js"() {
    "use strict";
    init_esm2();
    StandardAbortMessage2 = "The operation was aborted.";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/retryStrategies/throttlingRetryStrategy.js
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return void 0;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date = Date.parse(retryAfterHeader);
    const diff = date - Date.now();
    return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
  } catch (_a3) {
    return void 0;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}
var RetryAfterHeader, AllRetryAfterHeaders;
var init_throttlingRetryStrategy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/retryStrategies/throttlingRetryStrategy.js"() {
    "use strict";
    init_helpers();
    RetryAfterHeader = "Retry-After";
    AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/retryStrategies/exponentialRetryStrategy.js
function exponentialRetryStrategy(options = {}) {
  var _a3, _b2;
  const retryInterval = (_a3 = options.retryDelayInMs) !== null && _a3 !== void 0 ? _a3 : DEFAULT_CLIENT_RETRY_INTERVAL;
  const maxRetryInterval = (_b2 = options.maxRetryDelayInMs) !== null && _b2 !== void 0 ? _b2 : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  let retryAfterInMs = retryInterval;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
      const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
      retryAfterInMs = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
      return { retryAfterInMs };
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
}
var DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
var init_exponentialRetryStrategy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/retryStrategies/exponentialRetryStrategy.js"() {
    "use strict";
    init_esm3();
    init_throttlingRetryStrategy();
    DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/retryPolicy.js
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger26 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request3, next) {
      var _a3, _b2;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest:
        while (true) {
          retryCount += 1;
          response = void 0;
          responseError = void 0;
          try {
            logger26.info(`Retry ${retryCount}: Attempting to send request`, request3.requestId);
            response = await next(request3);
            logger26.info(`Retry ${retryCount}: Received a response from request`, request3.requestId);
          } catch (e) {
            logger26.error(`Retry ${retryCount}: Received an error from request`, request3.requestId);
            responseError = e;
            if (!e || responseError.name !== "RestError") {
              throw e;
            }
            response = responseError.response;
          }
          if ((_a3 = request3.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.aborted) {
            logger26.error(`Retry ${retryCount}: Request aborted.`);
            const abortError = new AbortError();
            throw abortError;
          }
          if (retryCount >= ((_b2 = options.maxRetries) !== null && _b2 !== void 0 ? _b2 : DEFAULT_RETRY_POLICY_COUNT)) {
            logger26.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
            if (responseError) {
              throw responseError;
            } else if (response) {
              return response;
            } else {
              throw new Error("Maximum retries reached with no response or error to throw");
            }
          }
          logger26.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop:
            for (const strategy of strategies) {
              const strategyLogger = strategy.logger || retryPolicyLogger;
              strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
              const modifiers = strategy.retry({
                retryCount,
                response,
                responseError
              });
              if (modifiers.skipStrategy) {
                strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                continue strategiesLoop;
              }
              const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
              if (errorToThrow) {
                strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                throw errorToThrow;
              }
              if (retryAfterInMs || retryAfterInMs === 0) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                await delay2(retryAfterInMs, void 0, { abortSignal: request3.abortSignal });
                continue retryRequest;
              }
              if (redirectTo) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                request3.url = redirectTo;
                continue retryRequest;
              }
            }
          if (responseError) {
            logger26.info(`None of the retry strategies could work with the received error. Throwing it.`);
            throw responseError;
          }
          if (response) {
            logger26.info(`None of the retry strategies could work with the received response. Returning it.`);
            return response;
          }
        }
    }
  };
}
var retryPolicyLogger, retryPolicyName;
var init_retryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/retryPolicy.js"() {
    "use strict";
    init_helpers();
    init_esm();
    init_esm2();
    init_constants2();
    retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
    retryPolicyName = "retryPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/defaultRetryPolicy.js
function defaultRetryPolicy(options = {}) {
  var _a3;
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: (_a3 = options.maxRetries) !== null && _a3 !== void 0 ? _a3 : DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
var defaultRetryPolicyName;
var init_defaultRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/defaultRetryPolicy.js"() {
    "use strict";
    init_exponentialRetryStrategy();
    init_throttlingRetryStrategy();
    init_retryPolicy();
    init_constants2();
    defaultRetryPolicyName = "defaultRetryPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/httpHeaders.js
function normalizeName(name3) {
  return name3.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}
var HttpHeadersImpl;
var init_httpHeaders = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/httpHeaders.js"() {
    "use strict";
    HttpHeadersImpl = class {
      constructor(rawHeaders) {
        this._headersMap = /* @__PURE__ */ new Map();
        if (rawHeaders) {
          for (const headerName of Object.keys(rawHeaders)) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param name - The name of the header to set. This value is case-insensitive.
       * @param value - The value of the header to set.
       */
      set(name3, value) {
        this._headersMap.set(normalizeName(name3), { name: name3, value: String(value).trim() });
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param name - The name of the header. This value is case-insensitive.
       */
      get(name3) {
        var _a3;
        return (_a3 = this._headersMap.get(normalizeName(name3))) === null || _a3 === void 0 ? void 0 : _a3.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       * @param name - The name of the header to set. This value is case-insensitive.
       */
      has(name3) {
        return this._headersMap.has(normalizeName(name3));
      }
      /**
       * Remove the header with the provided headerName.
       * @param name - The name of the header to remove.
       */
      delete(name3) {
        this._headersMap.delete(normalizeName(name3));
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const entry of this._headersMap.values()) {
            result[entry.name] = entry.value;
          }
        } else {
          for (const [normalizedName, entry] of this._headersMap) {
            result[normalizedName] = entry.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
      }
      /**
       * Iterate over tuples of header [name, value] pairs.
       */
      [Symbol.iterator]() {
        return headerIterator(this._headersMap);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/formDataPolicy.js
function formDataToFormDataMap(formData) {
  var _a3;
  const formDataMap = {};
  for (const [key, value] of formData.entries()) {
    (_a3 = formDataMap[key]) !== null && _a3 !== void 0 ? _a3 : formDataMap[key] = [];
    formDataMap[key].push(value);
  }
  return formDataMap;
}
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    async sendRequest(request3, next) {
      if (isNodeLike && typeof FormData !== "undefined" && request3.body instanceof FormData) {
        request3.formData = formDataToFormDataMap(request3.body);
        request3.body = void 0;
      }
      if (request3.formData) {
        const contentType = request3.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request3.body = wwwFormUrlEncode(request3.formData);
        } else {
          await prepareFormData(request3.formData, request3);
        }
        request3.formData = void 0;
      }
      return next(request3);
    }
  };
}
function wwwFormUrlEncode(formData) {
  const urlSearchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(formData)) {
    if (Array.isArray(value)) {
      for (const subValue of value) {
        urlSearchParams.append(key, subValue.toString());
      }
    } else {
      urlSearchParams.append(key, value.toString());
    }
  }
  return urlSearchParams.toString();
}
async function prepareFormData(formData, request3) {
  const contentType = request3.headers.get("Content-Type");
  if (contentType && !contentType.startsWith("multipart/form-data")) {
    return;
  }
  request3.headers.set("Content-Type", contentType !== null && contentType !== void 0 ? contentType : "multipart/form-data");
  const parts = [];
  for (const [fieldName, values] of Object.entries(formData)) {
    for (const value of Array.isArray(values) ? values : [values]) {
      if (typeof value === "string") {
        parts.push({
          headers: createHttpHeaders({
            "Content-Disposition": `form-data; name="${fieldName}"`
          }),
          body: stringToUint8Array(value, "utf-8")
        });
      } else if (value === void 0 || value === null || typeof value !== "object") {
        throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
      } else {
        const fileName = value.name || "blob";
        const headers = createHttpHeaders();
        headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
        headers.set("Content-Type", value.type || "application/octet-stream");
        parts.push({
          headers,
          body: value
        });
      }
    }
  }
  request3.multipartBody = { parts };
}
var formDataPolicyName;
var init_formDataPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/formDataPolicy.js"() {
    "use strict";
    init_esm3();
    init_httpHeaders();
    formDataPolicyName = "formDataPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse2(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name3) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name3 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable2;
      createDebug.enable = enable2;
      createDebug.enabled = enabled2;
      createDebug.humanize = require_ms2();
      createDebug.destroy = destroy2;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable2(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable2() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled2(name3) {
        if (name3[name3.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name3)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name3)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy2() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init2;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name3, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name3} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name3 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log3(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/agent-base/dist/helpers.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.req = exports2.json = exports2.toBuffer = void 0;
    var http4 = __importStar(require("http"));
    var https3 = __importStar(require("https"));
    async function toBuffer(stream) {
      let length = 0;
      const chunks = [];
      for await (const chunk of stream) {
        length += chunk.length;
        chunks.push(chunk);
      }
      return Buffer.concat(chunks, length);
    }
    exports2.toBuffer = toBuffer;
    async function json(stream) {
      const buf = await toBuffer(stream);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    exports2.json = json;
    function req(url, opts = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https3 : http4).request(url, opts);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports2.req = req;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/agent-base/dist/index.js
var require_dist = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/agent-base/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Agent = void 0;
    var net = __importStar(require("net"));
    var http4 = __importStar(require("http"));
    var https_1 = require("https");
    __exportStar(require_helpers(), exports2);
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent3 = class extends http4.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name3) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name3]) {
          this.sockets[name3] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name3].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name3, socket) {
        if (!this.sockets[name3] || socket === null) {
          return;
        }
        const sockets = this.sockets[name3];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name3];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options) {
        const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options);
        }
        return super.getName(options);
      }
      createSocket(req, options, cb) {
        const connectOpts = {
          ...options,
          secureEndpoint: this.isSecureEndpoint(options)
        };
        const name3 = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name3);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name3, fakeSocket);
          if (socket instanceof http4.Agent) {
            return socket.addRequest(req, connectOpts);
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, (err) => {
          this.decrementSockets(name3, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    };
    exports2.Agent = Agent3;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseProxyResponse = void 0;
    var debug_1 = __importDefault(require_src2());
    var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports2.parseProxyResponse = parseProxyResponse;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/https-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpsProxyAgent = void 0;
    var net = __importStar(require("net"));
    var tls = __importStar(require("tls"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src2());
    var agent_base_1 = require_dist();
    var url_1 = require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug = (0, debug_1.default)("https-proxy-agent");
    var HttpsProxyAgent2 = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          const servername = this.connectOpts.servername || this.connectOpts.host;
          socket = tls.connect({
            ...this.connectOpts,
            servername
          });
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name3 of Object.keys(headers)) {
          payload += `${name3}: ${headers[name3]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls.connect({
              ...omit(opts, "host", "path", "port"),
              socket,
              servername
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent2.protocols = ["http", "https"];
    exports2.HttpsProxyAgent = HttpsProxyAgent2;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/ms/index.js
var require_ms3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse2(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name3) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name3 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable2;
      createDebug.enable = enable2;
      createDebug.enabled = enabled2;
      createDebug.humanize = require_ms3();
      createDebug.destroy = destroy2;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable2(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable2() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled2(name3) {
        if (name3[name3.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name3)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name3)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy2() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init2;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name3, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name3} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name3 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log3(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser3();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpProxyAgent = void 0;
    var net = __importStar(require("net"));
    var tls = __importStar(require("tls"));
    var debug_1 = __importDefault(require_src3());
    var events_1 = require("events");
    var agent_base_1 = require_dist();
    var url_1 = require("url");
    var debug = (0, debug_1.default)("http-proxy-agent");
    var HttpProxyAgent2 = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      addRequest(req, opts) {
        req._header = null;
        this.setRequestProps(req, opts);
        super.addRequest(req, opts);
      }
      setRequestProps(req, opts) {
        const { proxy } = this;
        const protocol = opts.secureEndpoint ? "https:" : "http:";
        const hostname = req.getHeader("host") || "localhost";
        const base = `${protocol}//${hostname}`;
        const url = new url_1.URL(req.path, base);
        if (opts.port !== 80) {
          url.port = String(opts.port);
        }
        req.path = String(url);
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name3 of Object.keys(headers)) {
          const value = headers[name3];
          if (value) {
            req.setHeader(name3, value);
          }
        }
      }
      async connect(req, opts) {
        req._header = null;
        if (!req.path.includes("://")) {
          this.setRequestProps(req, opts);
        }
        let first;
        let endOfHeaders;
        debug("Regenerating stored HTTP header string for request");
        req._implicitHeader();
        if (req.outputData && req.outputData.length > 0) {
          debug("Patching connection write() output buffer with updated header");
          first = req.outputData[0].data;
          endOfHeaders = first.indexOf("\r\n\r\n") + 4;
          req.outputData[0].data = req._header + first.substring(endOfHeaders);
          debug("Output buffer: %o", req.outputData[0].data);
        }
        let socket;
        if (this.proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(this.connectOpts);
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        await (0, events_1.once)(socket, "connect");
        return socket;
      }
    };
    HttpProxyAgent2.protocols = ["http", "https"];
    exports2.HttpProxyAgent = HttpProxyAgent2;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/proxyPolicy.js
function getEnvironmentValue(name3) {
  if (process.env[name3]) {
    return process.env[name3];
  } else if (process.env[name3.toLowerCase()]) {
    return process.env[name3.toLowerCase()];
  }
  return void 0;
}
function loadEnvironmentProxyValue() {
  if (!process) {
    return void 0;
  }
  const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
  const allProxy = getEnvironmentValue(ALL_PROXY);
  const httpProxy = getEnvironmentValue(HTTP_PROXY);
  return httpsProxy || allProxy || httpProxy;
}
function isBypassed(uri, noProxyList, bypassedMap) {
  if (noProxyList.length === 0) {
    return false;
  }
  const host = new URL(uri).hostname;
  if (bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.has(host)) {
    return bypassedMap.get(host);
  }
  let isBypassedFlag = false;
  for (const pattern of noProxyList) {
    if (pattern[0] === ".") {
      if (host.endsWith(pattern)) {
        isBypassedFlag = true;
      } else {
        if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
          isBypassedFlag = true;
        }
      }
    } else {
      if (host === pattern) {
        isBypassedFlag = true;
      }
    }
  }
  bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.set(host, isBypassedFlag);
  return isBypassedFlag;
}
function loadNoProxy() {
  const noProxy = getEnvironmentValue(NO_PROXY);
  noProxyListLoaded = true;
  if (noProxy) {
    return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
  }
  return [];
}
function getDefaultProxySettingsInternal() {
  const envProxy = loadEnvironmentProxyValue();
  return envProxy ? new URL(envProxy) : void 0;
}
function getUrlFromProxySettings(settings) {
  let parsedProxyUrl;
  try {
    parsedProxyUrl = new URL(settings.host);
  } catch (_a3) {
    throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
  }
  parsedProxyUrl.port = String(settings.port);
  if (settings.username) {
    parsedProxyUrl.username = settings.username;
  }
  if (settings.password) {
    parsedProxyUrl.password = settings.password;
  }
  return parsedProxyUrl;
}
function setProxyAgentOnRequest(request3, cachedAgents, proxyUrl) {
  if (request3.agent) {
    return;
  }
  const url = new URL(request3.url);
  const isInsecure = url.protocol !== "https:";
  if (request3.tlsSettings) {
    logger3.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
  }
  const headers = request3.headers.toJSON();
  if (isInsecure) {
    if (!cachedAgents.httpProxyAgent) {
      cachedAgents.httpProxyAgent = new import_http_proxy_agent.HttpProxyAgent(proxyUrl, { headers });
    }
    request3.agent = cachedAgents.httpProxyAgent;
  } else {
    if (!cachedAgents.httpsProxyAgent) {
      cachedAgents.httpsProxyAgent = new import_https_proxy_agent.HttpsProxyAgent(proxyUrl, { headers });
    }
    request3.agent = cachedAgents.httpsProxyAgent;
  }
}
function proxyPolicy(proxySettings, options) {
  if (!noProxyListLoaded) {
    globalNoProxyList.push(...loadNoProxy());
  }
  const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
  const cachedAgents = {};
  return {
    name: proxyPolicyName,
    async sendRequest(request3, next) {
      var _a3;
      if (!request3.proxySettings && defaultProxy && !isBypassed(request3.url, (_a3 = options === null || options === void 0 ? void 0 : options.customNoProxyList) !== null && _a3 !== void 0 ? _a3 : globalNoProxyList, (options === null || options === void 0 ? void 0 : options.customNoProxyList) ? void 0 : globalBypassedMap)) {
        setProxyAgentOnRequest(request3, cachedAgents, defaultProxy);
      } else if (request3.proxySettings) {
        setProxyAgentOnRequest(request3, cachedAgents, getUrlFromProxySettings(request3.proxySettings));
      }
      return next(request3);
    }
  };
}
var import_https_proxy_agent, import_http_proxy_agent, HTTPS_PROXY, HTTP_PROXY, ALL_PROXY, NO_PROXY, proxyPolicyName, globalNoProxyList, noProxyListLoaded, globalBypassedMap;
var init_proxyPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/proxyPolicy.js"() {
    "use strict";
    import_https_proxy_agent = __toESM(require_dist2(), 1);
    import_http_proxy_agent = __toESM(require_dist3(), 1);
    init_log2();
    HTTPS_PROXY = "HTTPS_PROXY";
    HTTP_PROXY = "HTTP_PROXY";
    ALL_PROXY = "ALL_PROXY";
    NO_PROXY = "NO_PROXY";
    proxyPolicyName = "proxyPolicy";
    globalNoProxyList = [];
    noProxyListLoaded = false;
    globalBypassedMap = /* @__PURE__ */ new Map();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/setClientRequestIdPolicy.js
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request3, next) {
      if (!request3.headers.has(requestIdHeaderName)) {
        request3.headers.set(requestIdHeaderName, request3.requestId);
      }
      return next(request3);
    }
  };
}
var setClientRequestIdPolicyName;
var init_setClientRequestIdPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/setClientRequestIdPolicy.js"() {
    "use strict";
    setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/tlsPolicy.js
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req, next) => {
      if (!req.tlsSettings) {
        req.tlsSettings = tlsSettings;
      }
      return next(req);
    }
  };
}
var tlsPolicyName;
var init_tlsPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/tlsPolicy.js"() {
    "use strict";
    tlsPolicyName = "tlsPolicy";
  }
});

// node_modules/@azure/core-tracing/dist/esm/tracingContext.js
function createTracingContext(options = {}) {
  let context = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context = context.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context = context.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context;
}
var knownContextKeys, TracingContextImpl;
var init_tracingContext = __esm({
  "node_modules/@azure/core-tracing/dist/esm/tracingContext.js"() {
    "use strict";
    knownContextKeys = {
      span: Symbol.for("@azure/core-tracing span"),
      namespace: Symbol.for("@azure/core-tracing namespace")
    };
    TracingContextImpl = class _TracingContextImpl {
      constructor(initialContext) {
        this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    };
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.state = void 0;
    exports2.state = {
      instrumenterImplementation: void 0
    };
  }
});

// node_modules/@azure/core-tracing/dist/esm/state.js
var import_state, state;
var init_state = __esm({
  "node_modules/@azure/core-tracing/dist/esm/state.js"() {
    "use strict";
    import_state = __toESM(require_state(), 1);
    state = import_state.state;
  }
});

// node_modules/@azure/core-tracing/dist/esm/instrumenter.js
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return void 0;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
function getInstrumenter() {
  if (!state.instrumenterImplementation) {
    state.instrumenterImplementation = createDefaultInstrumenter();
  }
  return state.instrumenterImplementation;
}
var init_instrumenter = __esm({
  "node_modules/@azure/core-tracing/dist/esm/instrumenter.js"() {
    "use strict";
    init_tracingContext();
    init_state();
  }
});

// node_modules/@azure/core-tracing/dist/esm/tracingClient.js
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name3, operationOptions, spanOptions) {
    var _a3;
    const startSpanResult = getInstrumenter().startSpan(name3, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a3 = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a3 === void 0 ? void 0 : _a3.tracingContext }));
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name3, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name3, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}
var init_tracingClient = __esm({
  "node_modules/@azure/core-tracing/dist/esm/tracingClient.js"() {
    "use strict";
    init_instrumenter();
    init_tracingContext();
  }
});

// node_modules/@azure/core-tracing/dist/esm/index.js
var init_esm4 = __esm({
  "node_modules/@azure/core-tracing/dist/esm/index.js"() {
    "use strict";
    init_instrumenter();
    init_tracingClient();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/inspect.js
var import_node_util2, custom;
var init_inspect = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/inspect.js"() {
    "use strict";
    import_node_util2 = require("util");
    custom = import_node_util2.inspect.custom;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/restError.js
function isRestError(e) {
  if (e instanceof RestError) {
    return true;
  }
  return isError(e) && e.name === "RestError";
}
var errorSanitizer, RestError;
var init_restError = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/restError.js"() {
    "use strict";
    init_esm3();
    init_inspect();
    init_sanitizer();
    errorSanitizer = new Sanitizer();
    RestError = class _RestError extends Error {
      constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        Object.defineProperty(this, "request", { value: options.request, enumerable: false });
        Object.defineProperty(this, "response", { value: options.response, enumerable: false });
        Object.setPrototypeOf(this, _RestError.prototype);
      }
      /**
       * Logging method for util.inspect in Node
       */
      [custom]() {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(Object.assign(Object.assign({}, this), { request: this.request, response: this.response }))}`;
      }
    };
    RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError.PARSE_ERROR = "PARSE_ERROR";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/tracingPolicy.js
function tracingPolicy(options = {}) {
  const userAgentPromise = getUserAgentValue(options.userAgentPrefix);
  const sanitizer = new Sanitizer({
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  const tracingClient2 = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request3, next) {
      var _a3;
      if (!tracingClient2) {
        return next(request3);
      }
      const userAgent = await userAgentPromise;
      const spanAttributes = {
        "http.url": sanitizer.sanitizeUrl(request3.url),
        "http.method": request3.method,
        "http.user_agent": userAgent,
        requestId: request3.requestId
      };
      if (userAgent) {
        spanAttributes["http.user_agent"] = userAgent;
      }
      const { span, tracingContext } = (_a3 = tryCreateSpan(tracingClient2, request3, spanAttributes)) !== null && _a3 !== void 0 ? _a3 : {};
      if (!span || !tracingContext) {
        return next(request3);
      }
      try {
        const response = await tracingClient2.withContext(tracingContext, next, request3);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION2
    });
  } catch (e) {
    logger3.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryCreateSpan(tracingClient2, request3, spanAttributes) {
  try {
    const { span, updatedOptions } = tracingClient2.startSpan(`HTTP ${request3.method}`, { tracingOptions: request3.tracingOptions }, {
      spanKind: "client",
      spanAttributes
    });
    if (!span.isRecording()) {
      span.end();
      return void 0;
    }
    const headers = tracingClient2.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key, value] of Object.entries(headers)) {
      request3.headers.set(key, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e) {
    logger3.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: isError(error) ? error : void 0
    });
    if (isRestError(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e) {
    logger3.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    span.setStatus({
      status: "success"
    });
    span.end();
  } catch (e) {
    logger3.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
var tracingPolicyName;
var init_tracingPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/tracingPolicy.js"() {
    "use strict";
    init_esm4();
    init_constants2();
    init_userAgent();
    init_log2();
    init_esm3();
    init_restError();
    init_sanitizer();
    tracingPolicyName = "tracingPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/createPipelineFromOptions.js
function createPipelineFromOptions(options) {
  var _a3;
  const pipeline = createEmptyPipeline();
  if (isNodeLike) {
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy());
  }
  pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });
  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy((_a3 = options.telemetryOptions) === null || _a3 === void 0 ? void 0 : _a3.clientRequestIdHeaderName));
  pipeline.addPolicy(multipartPolicy(), { afterPhase: "Deserialize" });
  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy(Object.assign(Object.assign({}, options.userAgentOptions), options.loggingOptions)), {
    afterPhase: "Retry"
  });
  if (isNodeLike) {
    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}
var init_createPipelineFromOptions = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/createPipelineFromOptions.js"() {
    "use strict";
    init_logPolicy();
    init_pipeline();
    init_redirectPolicy();
    init_userAgentPolicy();
    init_multipartPolicy();
    init_decompressResponsePolicy();
    init_defaultRetryPolicy();
    init_formDataPolicy();
    init_esm3();
    init_proxyPolicy();
    init_setClientRequestIdPolicy();
    init_tlsPolicy();
    init_tracingPolicy();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/nodeHttpClient.js
function isReadableStream(body) {
  return body && typeof body.pipe === "function";
}
function isStreamComplete(stream) {
  return new Promise((resolve) => {
    const handler = () => {
      resolve();
      stream.removeListener("close", handler);
      stream.removeListener("end", handler);
      stream.removeListener("error", handler);
    };
    stream.on("close", handler);
    stream.on("end", handler);
    stream.on("error", handler);
  });
}
function isArrayBuffer(body) {
  return body && typeof body.byteLength === "number";
}
function getResponseHeaders(res) {
  const headers = createHttpHeaders();
  for (const header of Object.keys(res.headers)) {
    const value = res.headers[header];
    if (Array.isArray(value)) {
      if (value.length > 0) {
        headers.set(header, value[0]);
      }
    } else if (value) {
      headers.set(header, value);
    }
  }
  return headers;
}
function getDecodedResponseStream(stream, headers) {
  const contentEncoding = headers.get("Content-Encoding");
  if (contentEncoding === "gzip") {
    const unzip = zlib.createGunzip();
    stream.pipe(unzip);
    return unzip;
  } else if (contentEncoding === "deflate") {
    const inflate = zlib.createInflate();
    stream.pipe(inflate);
    return inflate;
  }
  return stream;
}
function streamToText(stream) {
  return new Promise((resolve, reject) => {
    const buffer = [];
    stream.on("data", (chunk) => {
      if (Buffer.isBuffer(chunk)) {
        buffer.push(chunk);
      } else {
        buffer.push(Buffer.from(chunk));
      }
    });
    stream.on("end", () => {
      resolve(Buffer.concat(buffer).toString("utf8"));
    });
    stream.on("error", (e) => {
      if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
        reject(e);
      } else {
        reject(new RestError(`Error reading response as text: ${e.message}`, {
          code: RestError.PARSE_ERROR
        }));
      }
    });
  });
}
function getBodyLength(body) {
  if (!body) {
    return 0;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (isReadableStream(body)) {
    return null;
  } else if (isArrayBuffer(body)) {
    return body.byteLength;
  } else if (typeof body === "string") {
    return Buffer.from(body).length;
  } else {
    return null;
  }
}
function createNodeHttpClient() {
  return new NodeHttpClient();
}
var http, https, zlib, import_node_stream2, DEFAULT_TLS_SETTINGS, ReportTransform, NodeHttpClient;
var init_nodeHttpClient = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/nodeHttpClient.js"() {
    "use strict";
    http = __toESM(require("http"), 1);
    https = __toESM(require("https"), 1);
    zlib = __toESM(require("zlib"), 1);
    import_node_stream2 = require("stream");
    init_esm2();
    init_httpHeaders();
    init_restError();
    init_log2();
    DEFAULT_TLS_SETTINGS = {};
    ReportTransform = class extends import_node_stream2.Transform {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
      _transform(chunk, _encoding, callback) {
        this.push(chunk);
        this.loadedBytes += chunk.length;
        try {
          this.progressCallback({ loadedBytes: this.loadedBytes });
          callback();
        } catch (e) {
          callback(e);
        }
      }
      constructor(progressCallback) {
        super();
        this.loadedBytes = 0;
        this.progressCallback = progressCallback;
      }
    };
    NodeHttpClient = class {
      constructor() {
        this.cachedHttpsAgents = /* @__PURE__ */ new WeakMap();
      }
      /**
       * Makes a request over an underlying transport layer and returns the response.
       * @param request - The request to be made.
       */
      async sendRequest(request3) {
        var _a3, _b2, _c2;
        const abortController = new AbortController();
        let abortListener;
        if (request3.abortSignal) {
          if (request3.abortSignal.aborted) {
            throw new AbortError("The operation was aborted.");
          }
          abortListener = (event) => {
            if (event.type === "abort") {
              abortController.abort();
            }
          };
          request3.abortSignal.addEventListener("abort", abortListener);
        }
        if (request3.timeout > 0) {
          setTimeout(() => {
            abortController.abort();
          }, request3.timeout);
        }
        const acceptEncoding = request3.headers.get("Accept-Encoding");
        const shouldDecompress = (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("deflate"));
        let body = typeof request3.body === "function" ? request3.body() : request3.body;
        if (body && !request3.headers.has("Content-Length")) {
          const bodyLength = getBodyLength(body);
          if (bodyLength !== null) {
            request3.headers.set("Content-Length", bodyLength);
          }
        }
        let responseStream;
        try {
          if (body && request3.onUploadProgress) {
            const onUploadProgress = request3.onUploadProgress;
            const uploadReportStream = new ReportTransform(onUploadProgress);
            uploadReportStream.on("error", (e) => {
              logger3.error("Error in upload progress", e);
            });
            if (isReadableStream(body)) {
              body.pipe(uploadReportStream);
            } else {
              uploadReportStream.end(body);
            }
            body = uploadReportStream;
          }
          const res = await this.makeRequest(request3, abortController, body);
          const headers = getResponseHeaders(res);
          const status = (_a3 = res.statusCode) !== null && _a3 !== void 0 ? _a3 : 0;
          const response = {
            status,
            headers,
            request: request3
          };
          if (request3.method === "HEAD") {
            res.resume();
            return response;
          }
          responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
          const onDownloadProgress = request3.onDownloadProgress;
          if (onDownloadProgress) {
            const downloadReportStream = new ReportTransform(onDownloadProgress);
            downloadReportStream.on("error", (e) => {
              logger3.error("Error in download progress", e);
            });
            responseStream.pipe(downloadReportStream);
            responseStream = downloadReportStream;
          }
          if (
            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
            ((_b2 = request3.streamResponseStatusCodes) === null || _b2 === void 0 ? void 0 : _b2.has(Number.POSITIVE_INFINITY)) || ((_c2 = request3.streamResponseStatusCodes) === null || _c2 === void 0 ? void 0 : _c2.has(response.status))
          ) {
            response.readableStreamBody = responseStream;
          } else {
            response.bodyAsText = await streamToText(responseStream);
          }
          return response;
        } finally {
          if (request3.abortSignal && abortListener) {
            let uploadStreamDone = Promise.resolve();
            if (isReadableStream(body)) {
              uploadStreamDone = isStreamComplete(body);
            }
            let downloadStreamDone = Promise.resolve();
            if (isReadableStream(responseStream)) {
              downloadStreamDone = isStreamComplete(responseStream);
            }
            Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
              var _a4;
              if (abortListener) {
                (_a4 = request3.abortSignal) === null || _a4 === void 0 ? void 0 : _a4.removeEventListener("abort", abortListener);
              }
            }).catch((e) => {
              logger3.warning("Error when cleaning up abortListener on httpRequest", e);
            });
          }
        }
      }
      makeRequest(request3, abortController, body) {
        var _a3;
        const url = new URL(request3.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request3.allowInsecureConnection) {
          throw new Error(`Cannot connect to ${request3.url} while allowInsecureConnection is false.`);
        }
        const agent = (_a3 = request3.agent) !== null && _a3 !== void 0 ? _a3 : this.getOrCreateAgent(request3, isInsecure);
        const options = {
          agent,
          hostname: url.hostname,
          path: `${url.pathname}${url.search}`,
          port: url.port,
          method: request3.method,
          headers: request3.headers.toJSON({ preserveCase: true })
        };
        return new Promise((resolve, reject) => {
          const req = isInsecure ? http.request(options, resolve) : https.request(options, resolve);
          req.once("error", (err) => {
            var _a4;
            reject(new RestError(err.message, { code: (_a4 = err.code) !== null && _a4 !== void 0 ? _a4 : RestError.REQUEST_SEND_ERROR, request: request3 }));
          });
          abortController.signal.addEventListener("abort", () => {
            const abortError = new AbortError("The operation was aborted.");
            req.destroy(abortError);
            reject(abortError);
          });
          if (body && isReadableStream(body)) {
            body.pipe(req);
          } else if (body) {
            if (typeof body === "string" || Buffer.isBuffer(body)) {
              req.end(body);
            } else if (isArrayBuffer(body)) {
              req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
            } else {
              logger3.error("Unrecognized body type", body);
              reject(new RestError("Unrecognized body type"));
            }
          } else {
            req.end();
          }
        });
      }
      getOrCreateAgent(request3, isInsecure) {
        var _a3;
        const disableKeepAlive = request3.disableKeepAlive;
        if (isInsecure) {
          if (disableKeepAlive) {
            return http.globalAgent;
          }
          if (!this.cachedHttpAgent) {
            this.cachedHttpAgent = new http.Agent({ keepAlive: true });
          }
          return this.cachedHttpAgent;
        } else {
          if (disableKeepAlive && !request3.tlsSettings) {
            return https.globalAgent;
          }
          const tlsSettings = (_a3 = request3.tlsSettings) !== null && _a3 !== void 0 ? _a3 : DEFAULT_TLS_SETTINGS;
          let agent = this.cachedHttpsAgents.get(tlsSettings);
          if (agent && agent.options.keepAlive === !disableKeepAlive) {
            return agent;
          }
          logger3.info("No cached TLS Agent exist, creating a new Agent");
          agent = new https.Agent(Object.assign({
            // keepAlive is true if disableKeepAlive is false.
            keepAlive: !disableKeepAlive
          }, tlsSettings));
          this.cachedHttpsAgents.set(tlsSettings, agent);
          return agent;
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/defaultHttpClient.js
function createDefaultHttpClient() {
  return createNodeHttpClient();
}
var init_defaultHttpClient = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/defaultHttpClient.js"() {
    "use strict";
    init_nodeHttpClient();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/pipelineRequest.js
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}
var PipelineRequestImpl;
var init_pipelineRequest = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/pipelineRequest.js"() {
    "use strict";
    init_httpHeaders();
    init_esm3();
    PipelineRequestImpl = class {
      constructor(options) {
        var _a3, _b2, _c2, _d2, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a3 = options.headers) !== null && _a3 !== void 0 ? _a3 : createHttpHeaders();
        this.method = (_b2 = options.method) !== null && _b2 !== void 0 ? _b2 : "GET";
        this.timeout = (_c2 = options.timeout) !== null && _c2 !== void 0 ? _c2 : 0;
        this.multipartBody = options.multipartBody;
        this.formData = options.formData;
        this.disableKeepAlive = (_d2 = options.disableKeepAlive) !== null && _d2 !== void 0 ? _d2 : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.tracingOptions = options.tracingOptions;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || randomUUID();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/exponentialRetryPolicy.js
var init_exponentialRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/exponentialRetryPolicy.js"() {
    "use strict";
    init_exponentialRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/systemErrorRetryPolicy.js
var init_systemErrorRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/systemErrorRetryPolicy.js"() {
    "use strict";
    init_exponentialRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/throttlingRetryPolicy.js
var init_throttlingRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/throttlingRetryPolicy.js"() {
    "use strict";
    init_throttlingRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/util/tokenCycler.js
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch (_a3) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay2(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  let tenantId;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a3;
      if (cycler.isRefreshing) {
        return false;
      }
      if ((token === null || token === void 0 ? void 0 : token.refreshAfterTimestamp) && token.refreshAfterTimestamp < Date.now()) {
        return true;
      }
      return ((_a3 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a3 !== void 0 ? _a3 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    var _a3;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a3 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a3 !== void 0 ? _a3 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        tenantId = void 0;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const hasClaimChallenge = Boolean(tokenOptions.claims);
    const tenantIdChanged = tenantId !== tokenOptions.tenantId;
    if (hasClaimChallenge) {
      token = null;
    }
    const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
    if (mustRefresh) {
      return refresh(scopes, tokenOptions);
    }
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token;
  };
}
var DEFAULT_CYCLER_OPTIONS;
var init_tokenCycler = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/util/tokenCycler.js"() {
    "use strict";
    init_helpers();
    DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      // Force waiting for a refresh 1s before the token expires
      retryIntervalInMs: 3e3,
      // Allow refresh attempts every 3s
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/bearerTokenAuthenticationPolicy.js
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request: request3 } = options;
  const getTokenOptions = {
    abortSignal: request3.abortSignal,
    tracingOptions: request3.tracingOptions
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function getChallenge(response) {
  const challenge = response.headers.get("WWW-Authenticate");
  if (response.status === 401 && challenge) {
    return challenge;
  }
  return;
}
function bearerTokenAuthenticationPolicy(options) {
  var _a3;
  const { credential, scopes, challengeCallbacks } = options;
  const logger26 = options.logger || logger3;
  const callbacks = Object.assign({ authorizeRequest: (_a3 = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a3 !== void 0 ? _a3 : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
  const getAccessToken = credential ? createTokenCycler(
    credential
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(request3, next) {
      if (!request3.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request: request3,
        getAccessToken,
        logger: logger26
      });
      let response;
      let error;
      try {
        response = await next(request3);
      } catch (err) {
        error = err;
        response = err.response;
      }
      if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {
        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request: request3,
          response,
          getAccessToken,
          logger: logger26
        });
        if (shouldSendRequest) {
          return next(request3);
        }
      }
      if (error) {
        throw error;
      } else {
        return response;
      }
    }
  };
}
var bearerTokenAuthenticationPolicyName;
var init_bearerTokenAuthenticationPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/bearerTokenAuthenticationPolicy.js"() {
    "use strict";
    init_tokenCycler();
    init_log2();
    bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/ndJsonPolicy.js
var init_ndJsonPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/ndJsonPolicy.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/auxiliaryAuthenticationHeaderPolicy.js
var init_auxiliaryAuthenticationHeaderPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/policies/auxiliaryAuthenticationHeaderPolicy.js"() {
    "use strict";
    init_tokenCycler();
    init_log2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/esm/index.js
var init_esm5 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/esm/index.js"() {
    "use strict";
    init_pipeline();
    init_createPipelineFromOptions();
    init_defaultHttpClient();
    init_httpHeaders();
    init_pipelineRequest();
    init_restError();
    init_decompressResponsePolicy();
    init_exponentialRetryPolicy();
    init_setClientRequestIdPolicy();
    init_logPolicy();
    init_multipartPolicy();
    init_proxyPolicy();
    init_redirectPolicy();
    init_systemErrorRetryPolicy();
    init_throttlingRetryPolicy();
    init_retryPolicy();
    init_tracingPolicy();
    init_defaultRetryPolicy();
    init_userAgentPolicy();
    init_tlsPolicy();
    init_formDataPolicy();
    init_bearerTokenAuthenticationPolicy();
    init_ndJsonPolicy();
    init_auxiliaryAuthenticationHeaderPolicy();
    init_file();
  }
});

// node_modules/@azure/core-client/dist/commonjs/state.js
var require_state2 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.state = void 0;
    exports2.state = {
      operationRequestMap: /* @__PURE__ */ new WeakMap()
    };
  }
});

// node_modules/@azure/core-client/dist/esm/state.js
var import_state3, state2;
var init_state2 = __esm({
  "node_modules/@azure/core-client/dist/esm/state.js"() {
    "use strict";
    import_state3 = __toESM(require_state2(), 1);
    state2 = import_state3.state;
  }
});

// node_modules/@azure/core-client/dist/esm/operationHelpers.js
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
  let parameterPath = parameter.parameterPath;
  const parameterMapper = parameter.mapper;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== void 0) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
function hasOriginalRequest(request3) {
  return originalRequestSymbol in request3;
}
function getOperationRequestInfo(request3) {
  if (hasOriginalRequest(request3)) {
    return getOperationRequestInfo(request3[originalRequestSymbol]);
  }
  let info = state2.operationRequestMap.get(request3);
  if (!info) {
    info = {};
    state2.operationRequestMap.set(request3, info);
  }
  return info;
}
var originalRequestSymbol;
var init_operationHelpers = __esm({
  "node_modules/@azure/core-client/dist/esm/operationHelpers.js"() {
    "use strict";
    init_state2();
    originalRequestSymbol = Symbol.for("@azure/core-client original request");
  }
});

// node_modules/@azure/core-client/dist/esm/deserializationPolicy.js
function deserializationPolicy(options = {}) {
  var _a3, _b2, _c2, _d2, _e, _f, _g;
  const jsonContentTypes = (_b2 = (_a3 = options.expectedContentTypes) === null || _a3 === void 0 ? void 0 : _a3.json) !== null && _b2 !== void 0 ? _b2 : defaultJsonContentTypes;
  const xmlContentTypes = (_d2 = (_c2 = options.expectedContentTypes) === null || _c2 === void 0 ? void 0 : _c2.xml) !== null && _d2 !== void 0 ? _d2 : defaultXmlContentTypes;
  const parseXML = options.parseXML;
  const serializerOptions = options.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY
    }
  };
  return {
    name: deserializationPolicyName,
    async sendRequest(request3, next) {
      const response = await next(request3);
      return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  let result;
  const request3 = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request3);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  const request3 = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request3);
  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
  const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
  if (!shouldDeserializeResponse(parsedResponse)) {
    return parsedResponse;
  }
  const operationInfo = getOperationRequestInfo(parsedResponse.request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (!operationSpec || !operationSpec.responses) {
    return parsedResponse;
  }
  const responseSpec = getOperationResponseMap(parsedResponse);
  const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
  if (error) {
    throw error;
  } else if (shouldReturnResponse) {
    return parsedResponse;
  }
  if (responseSpec) {
    if (responseSpec.bodyMapper) {
      let valueToDeserialize = parsedResponse.parsedBody;
      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
      }
      try {
        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
      } catch (deserializeError) {
        const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
          statusCode: parsedResponse.status,
          request: parsedResponse.request,
          response: parsedResponse
        });
        throw restError;
      }
    } else if (operationSpec.httpMethod === "HEAD") {
      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
    }
    if (responseSpec.headersMapper) {
      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
    }
  }
  return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
  var _a3;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const initialErrorMessage = ((_a3 = parsedResponse.request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  if (!errorResponseSpec) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let deserializedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          const elementName = defaultBodyMapper.xmlElementName;
          if (typeof parsedBody === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
      }
      const internalError = parsedBody.error || deserializedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = deserializedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
  var _a3;
  if (!((_a3 = operationResponse.request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(operationResponse.status)) && operationResponse.bodyAsText) {
    const text = operationResponse.bodyAsText;
    const contentType = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
    try {
      if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
        operationResponse.parsedBody = JSON.parse(text);
        return operationResponse;
      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
        if (!parseXML) {
          throw new Error("Parsing XML not supported.");
        }
        const body = await parseXML(text, opts.xml);
        operationResponse.parsedBody = body;
        return operationResponse;
      }
    } catch (err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
      const errCode = err.code || RestError.PARSE_ERROR;
      const e = new RestError(msg, {
        code: errCode,
        statusCode: operationResponse.status,
        request: operationResponse.request,
        response: operationResponse
      });
      throw e;
    }
  }
  return operationResponse;
}
var defaultJsonContentTypes, defaultXmlContentTypes, deserializationPolicyName;
var init_deserializationPolicy = __esm({
  "node_modules/@azure/core-client/dist/esm/deserializationPolicy.js"() {
    "use strict";
    init_interfaces();
    init_esm5();
    init_serializer();
    init_operationHelpers();
    defaultJsonContentTypes = ["application/json", "text/json"];
    defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    deserializationPolicyName = "deserializationPolicy";
  }
});

// node_modules/@azure/core-client/dist/esm/interfaceHelpers.js
function getStreamingResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
function getPathStringFromParameter(parameter) {
  const { parameterPath, mapper } = parameter;
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
var init_interfaceHelpers = __esm({
  "node_modules/@azure/core-client/dist/esm/interfaceHelpers.js"() {
    "use strict";
    init_serializer();
  }
});

// node_modules/@azure/core-client/dist/esm/serializationPolicy.js
function serializationPolicy(options = {}) {
  const stringifyXML = options.stringifyXML;
  return {
    name: serializationPolicyName,
    async sendRequest(request3, next) {
      const operationInfo = getOperationRequestInfo(request3);
      const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
      const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
      if (operationSpec && operationArguments) {
        serializeHeaders(request3, operationArguments, operationSpec);
        serializeRequestBody(request3, operationArguments, operationSpec, stringifyXML);
      }
      return next(request3);
    }
  };
}
function serializeHeaders(request3, operationArguments, operationSpec) {
  var _a3, _b2;
  if (operationSpec.headerParameters) {
    for (const headerParameter of operationSpec.headerParameters) {
      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);
      if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          for (const key of Object.keys(headerValue)) {
            request3.headers.set(headerCollectionPrefix + key, headerValue[key]);
          }
        } else {
          request3.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
        }
      }
    }
  }
  const customHeaders = (_b2 = (_a3 = operationArguments.options) === null || _a3 === void 0 ? void 0 : _a3.requestOptions) === null || _b2 === void 0 ? void 0 : _b2.customHeaders;
  if (customHeaders) {
    for (const customHeaderName of Object.keys(customHeaders)) {
      request3.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
function serializeRequestBody(request3, operationArguments, operationSpec, stringifyXML = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var _a3, _b2, _c2, _d2, _e;
  const serializerOptions = (_a3 = operationArguments.options) === null || _a3 === void 0 ? void 0 : _a3.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_b2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b2 !== void 0 ? _b2 : "",
      includeRoot: (_c2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c2 !== void 0 ? _c2 : false,
      xmlCharKey: (_d2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d2 !== void 0 ? _d2 : XML_CHARKEY
    }
  };
  const xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request3.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (request3.body !== void 0 && request3.body !== null || nullable && request3.body === null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        request3.body = operationSpec.serializer.serialize(bodyMapper, request3.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request3.body, updatedOptions);
          if (typeName === MapperTypeNames.Sequence) {
            request3.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
          } else if (!isStream) {
            request3.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          request3.body = JSON.stringify(request3.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request3.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        request3.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}
var serializationPolicyName;
var init_serializationPolicy = __esm({
  "node_modules/@azure/core-client/dist/esm/serializationPolicy.js"() {
    "use strict";
    init_interfaces();
    init_operationHelpers();
    init_serializer();
    init_interfaceHelpers();
    serializationPolicyName = "serializationPolicy";
  }
});

// node_modules/@azure/core-client/dist/esm/pipeline.js
function createClientPipeline(options = {}) {
  const pipeline = createPipelineFromOptions(options !== null && options !== void 0 ? options : {});
  if (options.credentialOptions) {
    pipeline.addPolicy(bearerTokenAuthenticationPolicy({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
  pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}
var init_pipeline2 = __esm({
  "node_modules/@azure/core-client/dist/esm/pipeline.js"() {
    "use strict";
    init_deserializationPolicy();
    init_esm5();
    init_serializationPolicy();
  }
});

// node_modules/@azure/core-client/dist/esm/httpClientCache.js
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}
var cachedHttpClient;
var init_httpClientCache = __esm({
  "node_modules/@azure/core-client/dist/esm/httpClientCache.js"() {
    "use strict";
    init_esm5();
  }
});

// node_modules/@azure/core-client/dist/esm/urlHelpers.js
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  let isAbsolutePath = false;
  let requestUrl = replaceAll(baseUri, urlReplacements);
  if (operationSpec.path) {
    let path4 = replaceAll(operationSpec.path, urlReplacements);
    if (operationSpec.path === "/{nextLink}" && path4.startsWith("/")) {
      path4 = path4.substring(1);
    }
    if (isAbsoluteUrl(path4)) {
      requestUrl = path4;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path4);
    }
  }
  const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll(input, replacements) {
  let result = input;
  for (const [searchValue, replaceValue] of replacements) {
    result = result.split(searchValue).join(replaceValue);
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a3;
  const result = /* @__PURE__ */ new Map();
  if ((_a3 = operationSpec.urlParameters) === null || _a3 === void 0 ? void 0 : _a3.length) {
    for (const urlParameter of operationSpec.urlParameters) {
      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);
      const parameterPathString = getPathStringFromParameter(urlParameter);
      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
      if (!urlParameter.skipEncoding) {
        urlParameterValue = encodeURIComponent(urlParameterValue);
      }
      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
  }
  return result;
}
function isAbsoluteUrl(url) {
  return url.includes("://");
}
function appendPath(url, pathToAppend) {
  if (!pathToAppend) {
    return url;
  }
  const parsedUrl = new URL(url);
  let newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = `${newPath}/`;
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  const searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    const path4 = pathToAppend.substring(0, searchStart);
    const search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path4;
    if (search) {
      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a3;
  const result = /* @__PURE__ */ new Map();
  const sequenceParams = /* @__PURE__ */ new Set();
  if ((_a3 = operationSpec.queryParameters) === null || _a3 === void 0 ? void 0 : _a3.length) {
    for (const queryParameter of operationSpec.queryParameters) {
      if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
        sequenceParams.add(queryParameter.mapper.serializedName);
      }
      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);
      if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
        if (Array.isArray(queryParameterValue)) {
          queryParameterValue = queryParameterValue.map((item) => {
            if (item === null || item === void 0) {
              return "";
            }
            return item;
          });
        }
        if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
          continue;
        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        if (!queryParameter.skipEncoding) {
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              return encodeURIComponent(item);
            });
          } else {
            queryParameterValue = encodeURIComponent(queryParameterValue);
          }
        }
        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
      }
    }
  }
  return {
    queryParams: result,
    sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  const result = /* @__PURE__ */ new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  queryString = queryString.slice(1);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [name3, value] = pair.split("=", 2);
    const existingValue = result.get(name3);
    if (existingValue) {
      if (Array.isArray(existingValue)) {
        existingValue.push(value);
      } else {
        result.set(name3, [existingValue, value]);
      }
    } else {
      result.set(name3, value);
    }
  }
  return result;
}
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
  if (queryParams.size === 0) {
    return url;
  }
  const parsedUrl = new URL(url);
  const combinedParams = simpleParseQueryParams(parsedUrl.search);
  for (const [name3, value] of queryParams) {
    const existingValue = combinedParams.get(name3);
    if (Array.isArray(existingValue)) {
      if (Array.isArray(value)) {
        existingValue.push(...value);
        const valueSet = new Set(existingValue);
        combinedParams.set(name3, Array.from(valueSet));
      } else {
        existingValue.push(value);
      }
    } else if (existingValue) {
      if (Array.isArray(value)) {
        value.unshift(existingValue);
      } else if (sequenceParams.has(name3)) {
        combinedParams.set(name3, [existingValue, value]);
      }
      if (!noOverwrite) {
        combinedParams.set(name3, value);
      }
    } else {
      combinedParams.set(name3, value);
    }
  }
  const searchPieces = [];
  for (const [name3, value] of combinedParams) {
    if (typeof value === "string") {
      searchPieces.push(`${name3}=${value}`);
    } else if (Array.isArray(value)) {
      for (const subValue of value) {
        searchPieces.push(`${name3}=${subValue}`);
      }
    } else {
      searchPieces.push(`${name3}=${value}`);
    }
  }
  parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return parsedUrl.toString();
}
var CollectionFormatToDelimiterMap;
var init_urlHelpers = __esm({
  "node_modules/@azure/core-client/dist/esm/urlHelpers.js"() {
    "use strict";
    init_operationHelpers();
    init_interfaceHelpers();
    CollectionFormatToDelimiterMap = {
      CSV: ",",
      SSV: " ",
      Multi: "Multi",
      TSV: "	",
      Pipes: "|"
    };
  }
});

// node_modules/@azure/core-client/dist/esm/log.js
var logger4;
var init_log3 = __esm({
  "node_modules/@azure/core-client/dist/esm/log.js"() {
    "use strict";
    init_esm();
    logger4 = createClientLogger("core-client");
  }
});

// node_modules/@azure/core-client/dist/esm/serviceClient.js
function createDefaultPipeline(options) {
  const credentialScopes = getCredentialScopes(options);
  const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
  return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes(options) {
  if (options.credentialScopes) {
    return options.credentialScopes;
  }
  if (options.endpoint) {
    return `${options.endpoint}/.default`;
  }
  if (options.baseUri) {
    return `${options.baseUri}/.default`;
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
  }
  return void 0;
}
var ServiceClient;
var init_serviceClient = __esm({
  "node_modules/@azure/core-client/dist/esm/serviceClient.js"() {
    "use strict";
    init_esm5();
    init_pipeline2();
    init_utils();
    init_httpClientCache();
    init_operationHelpers();
    init_urlHelpers();
    init_interfaceHelpers();
    init_log3();
    ServiceClient = class {
      /**
       * The ServiceClient constructor
       * @param credential - The credentials used for authentication with the service.
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(options = {}) {
        var _a3, _b2;
        this._requestContentType = options.requestContentType;
        this._endpoint = (_a3 = options.endpoint) !== null && _a3 !== void 0 ? _a3 : options.baseUri;
        if (options.baseUri) {
          logger4.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || getCachedDefaultHttpClient();
        this.pipeline = options.pipeline || createDefaultPipeline(options);
        if ((_b2 = options.additionalPolicies) === null || _b2 === void 0 ? void 0 : _b2.length) {
          for (const { policy, position } of options.additionalPolicies) {
            const afterPhase = position === "perRetry" ? "Sign" : void 0;
            this.pipeline.addPolicy(policy, {
              afterPhase
            });
          }
        }
      }
      /**
       * Send the provided httpRequest.
       */
      async sendRequest(request3) {
        return this.pipeline.sendRequest(this._httpClient, request3);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @typeParam T - The typed result of the request, based on the OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       */
      async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) {
          throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);
        const request3 = createPipelineRequest({
          url
        });
        request3.method = operationSpec.httpMethod;
        const operationInfo = getOperationRequestInfo(request3);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) {
          request3.headers.set("Content-Type", contentType);
        }
        const options = operationArguments.options;
        if (options) {
          const requestOptions = options.requestOptions;
          if (requestOptions) {
            if (requestOptions.timeout) {
              request3.timeout = requestOptions.timeout;
            }
            if (requestOptions.onUploadProgress) {
              request3.onUploadProgress = requestOptions.onUploadProgress;
            }
            if (requestOptions.onDownloadProgress) {
              request3.onDownloadProgress = requestOptions.onDownloadProgress;
            }
            if (requestOptions.shouldDeserialize !== void 0) {
              operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
            }
            if (requestOptions.allowInsecureConnection) {
              request3.allowInsecureConnection = true;
            }
          }
          if (options.abortSignal) {
            request3.abortSignal = options.abortSignal;
          }
          if (options.tracingOptions) {
            request3.tracingOptions = options.tracingOptions;
          }
        }
        if (this._allowInsecureConnection) {
          request3.allowInsecureConnection = true;
        }
        if (request3.streamResponseStatusCodes === void 0) {
          request3.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
        }
        try {
          const rawResponse = await this.sendRequest(request3);
          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);
          if (options === null || options === void 0 ? void 0 : options.onResponse) {
            options.onResponse(rawResponse, flatResponse);
          }
          return flatResponse;
        } catch (error) {
          if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
            const rawResponse = error.response;
            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
            error.details = flatResponse;
            if (options === null || options === void 0 ? void 0 : options.onResponse) {
              options.onResponse(rawResponse, flatResponse, error);
            }
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/@azure/core-client/dist/esm/authorizeRequestOnClaimChallenge.js
var init_authorizeRequestOnClaimChallenge = __esm({
  "node_modules/@azure/core-client/dist/esm/authorizeRequestOnClaimChallenge.js"() {
    "use strict";
    init_log3();
    init_base64();
  }
});

// node_modules/@azure/core-client/dist/esm/authorizeRequestOnTenantChallenge.js
var init_authorizeRequestOnTenantChallenge = __esm({
  "node_modules/@azure/core-client/dist/esm/authorizeRequestOnTenantChallenge.js"() {
    "use strict";
  }
});

// node_modules/@azure/core-client/dist/esm/index.js
var init_esm6 = __esm({
  "node_modules/@azure/core-client/dist/esm/index.js"() {
    "use strict";
    init_serializer();
    init_serviceClient();
    init_pipeline2();
    init_interfaces();
    init_deserializationPolicy();
    init_serializationPolicy();
    init_authorizeRequestOnClaimChallenge();
    init_authorizeRequestOnTenantChallenge();
  }
});

// node_modules/@azure/identity/node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }
  if (signal.onabort) {
    signal.onabort.call(signal);
  }
  const listeners = listenersMap.get(signal);
  if (listeners) {
    listeners.slice().forEach((listener) => {
      listener.call(signal, { type: "abort" });
    });
  }
  abortedMap.set(signal, true);
}
var listenersMap, abortedMap, AbortSignal;
var init_AbortSignal = __esm({
  "node_modules/@azure/identity/node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js"() {
    "use strict";
    listenersMap = /* @__PURE__ */ new WeakMap();
    abortedMap = /* @__PURE__ */ new WeakMap();
    AbortSignal = class _AbortSignal {
      constructor() {
        this.onabort = null;
        listenersMap.set(this, []);
        abortedMap.set(this, false);
      }
      /**
       * Status of whether aborted or not.
       *
       * @readonly
       */
      get aborted() {
        if (!abortedMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        return abortedMap.get(this);
      }
      /**
       * Creates a new AbortSignal instance that will never be aborted.
       *
       * @readonly
       */
      static get none() {
        return new _AbortSignal();
      }
      /**
       * Added new "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be added
       */
      addEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        listeners.push(listener);
      }
      /**
       * Remove "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be removed
       */
      removeEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
      /**
       * Dispatches a synthetic event to the AbortSignal.
       */
      dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
      }
    };
  }
});

// node_modules/@azure/identity/node_modules/@azure/abort-controller/dist-esm/src/AbortController.js
var AbortError2, AbortController2;
var init_AbortController = __esm({
  "node_modules/@azure/identity/node_modules/@azure/abort-controller/dist-esm/src/AbortController.js"() {
    "use strict";
    init_AbortSignal();
    AbortError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    AbortController2 = class {
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      constructor(parentSignals) {
        this._signal = new AbortSignal();
        if (!parentSignals) {
          return;
        }
        if (!Array.isArray(parentSignals)) {
          parentSignals = arguments;
        }
        for (const parentSignal of parentSignals) {
          if (parentSignal.aborted) {
            this.abort();
          } else {
            parentSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
      }
      /**
       * The AbortSignal associated with this controller that will signal aborted
       * when the abort method is called on this controller.
       *
       * @readonly
       */
      get signal() {
        return this._signal;
      }
      /**
       * Signal that any operations passed this controller's associated abort signal
       * to cancel any remaining work and throw an `AbortError`.
       */
      abort() {
        abortSignal(this._signal);
      }
      /**
       * Creates a new AbortSignal instance that will abort after the provided ms.
       * @param ms - Elapsed time in milliseconds to trigger an abort.
       */
      static timeout(ms) {
        const signal = new AbortSignal();
        const timer = setTimeout(abortSignal, ms, signal);
        if (typeof timer.unref === "function") {
          timer.unref();
        }
        return signal;
      }
    };
  }
});

// node_modules/@azure/identity/node_modules/@azure/abort-controller/dist-esm/src/index.js
var init_src = __esm({
  "node_modules/@azure/identity/node_modules/@azure/abort-controller/dist-esm/src/index.js"() {
    "use strict";
    init_AbortController();
  }
});

// node_modules/@azure/identity/dist-esm/src/util/identityTokenEndpoint.js
function getIdentityTokenEndpointSuffix(tenantId) {
  if (tenantId === "adfs") {
    return "oauth2/token";
  } else {
    return "oauth2/v2.0/token";
  }
}
var init_identityTokenEndpoint = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/identityTokenEndpoint.js"() {
    "use strict";
  }
});

// node_modules/@azure/identity/dist-esm/src/util/tracing.js
var tracingClient;
var init_tracing = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/tracing.js"() {
    "use strict";
    init_constants();
    init_esm4();
    tracingClient = createTracingClient({
      namespace: "Microsoft.AAD",
      packageName: "@azure/identity",
      packageVersion: SDK_VERSION
    });
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/constants.js
var DefaultScopeSuffix, imdsHost, imdsEndpointPath, imdsApiVersion;
var init_constants3 = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/constants.js"() {
    "use strict";
    DefaultScopeSuffix = "/.default";
    imdsHost = "http://169.254.169.254";
    imdsEndpointPath = "/metadata/identity/oauth2/token";
    imdsApiVersion = "2018-02-01";
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/utils.js
function mapScopesToResource(scopes) {
  let scope = "";
  if (Array.isArray(scopes)) {
    if (scopes.length !== 1) {
      return;
    }
    scope = scopes[0];
  } else if (typeof scopes === "string") {
    scope = scopes;
  }
  if (!scope.endsWith(DefaultScopeSuffix)) {
    return scope;
  }
  return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));
}
function parseExpirationTimestamp(body) {
  if (typeof body.expires_on === "number") {
    return body.expires_on * 1e3;
  }
  if (typeof body.expires_on === "string") {
    const asNumber = +body.expires_on;
    if (!isNaN(asNumber)) {
      return asNumber * 1e3;
    }
    const asDate = Date.parse(body.expires_on);
    if (!isNaN(asDate)) {
      return asDate;
    }
  }
  if (typeof body.expires_in === "number") {
    return Date.now() + body.expires_in * 1e3;
  }
  throw new Error(`Failed to parse token expiration from body. expires_in="${body.expires_in}", expires_on="${body.expires_on}"`);
}
var init_utils2 = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/utils.js"() {
    "use strict";
    init_constants3();
  }
});

// node_modules/@azure/identity/dist-esm/src/client/identityClient.js
function getIdentityClientAuthorityHost(options) {
  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;
  if (isNode) {
    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;
  }
  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;
}
var noCorrelationId, IdentityClient;
var init_identityClient = __esm({
  "node_modules/@azure/identity/dist-esm/src/client/identityClient.js"() {
    "use strict";
    init_esm6();
    init_esm3();
    init_esm5();
    init_src();
    init_errors();
    init_identityTokenEndpoint();
    init_constants();
    init_tracing();
    init_logging();
    init_utils2();
    noCorrelationId = "noCorrelationId";
    IdentityClient = class extends ServiceClient {
      constructor(options) {
        var _a3, _b2;
        const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;
        const userAgentPrefix = ((_a3 = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a3 === void 0 ? void 0 : _a3.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        const baseUri = getIdentityClientAuthorityHost(options);
        if (!baseUri.startsWith("https:")) {
          throw new Error("The authorityHost address must use the 'https' protocol.");
        }
        super(Object.assign(Object.assign({ requestContentType: "application/json; charset=utf-8", retryOptions: {
          maxRetries: 3
        } }, options), { userAgentOptions: {
          userAgentPrefix
        }, baseUri }));
        this.allowInsecureConnection = false;
        this.authorityHost = baseUri;
        this.abortControllers = /* @__PURE__ */ new Map();
        this.allowLoggingAccountIdentifiers = (_b2 = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b2 === void 0 ? void 0 : _b2.allowLoggingAccountIdentifiers;
        this.tokenCredentialOptions = Object.assign({}, options);
        if (options === null || options === void 0 ? void 0 : options.allowInsecureConnection) {
          this.allowInsecureConnection = options.allowInsecureConnection;
        }
      }
      async sendTokenRequest(request3) {
        logger2.info(`IdentityClient: sending token request to [${request3.url}]`);
        const response = await this.sendRequest(request3);
        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {
          const parsedBody = JSON.parse(response.bodyAsText);
          if (!parsedBody.access_token) {
            return null;
          }
          this.logIdentifiers(response);
          const token = {
            accessToken: {
              token: parsedBody.access_token,
              expiresOnTimestamp: parseExpirationTimestamp(parsedBody)
            },
            refreshToken: parsedBody.refresh_token
          };
          logger2.info(`IdentityClient: [${request3.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
          return token;
        } else {
          const error = new AuthenticationError(response.status, response.bodyAsText);
          logger2.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
          throw error;
        }
      }
      async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {
        if (refreshToken === void 0) {
          return null;
        }
        logger2.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
        const refreshParams = {
          grant_type: "refresh_token",
          client_id: clientId,
          refresh_token: refreshToken,
          scope: scopes
        };
        if (clientSecret !== void 0) {
          refreshParams.client_secret = clientSecret;
        }
        const query = new URLSearchParams(refreshParams);
        return tracingClient.withSpan("IdentityClient.refreshAccessToken", options, async (updatedOptions) => {
          try {
            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);
            const request3 = createPipelineRequest({
              url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,
              method: "POST",
              body: query.toString(),
              abortSignal: options.abortSignal,
              headers: createHttpHeaders({
                Accept: "application/json",
                "Content-Type": "application/x-www-form-urlencoded"
              }),
              tracingOptions: updatedOptions.tracingOptions
            });
            const response = await this.sendTokenRequest(request3);
            logger2.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
            return response;
          } catch (err) {
            if (err.name === AuthenticationErrorName && err.errorResponse.error === "interaction_required") {
              logger2.info(`IdentityClient: interaction required for client ID: ${clientId}`);
              return null;
            } else {
              logger2.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
              throw err;
            }
          }
        });
      }
      // Here is a custom layer that allows us to abort requests that go through MSAL,
      // since MSAL doesn't allow us to pass options all the way through.
      generateAbortSignal(correlationId) {
        const controller = new AbortController2();
        const controllers = this.abortControllers.get(correlationId) || [];
        controllers.push(controller);
        this.abortControllers.set(correlationId, controllers);
        const existingOnAbort = controller.signal.onabort;
        controller.signal.onabort = (...params) => {
          this.abortControllers.set(correlationId, void 0);
          if (existingOnAbort) {
            existingOnAbort(...params);
          }
        };
        return controller.signal;
      }
      abortRequests(correlationId) {
        const key = correlationId || noCorrelationId;
        const controllers = [
          ...this.abortControllers.get(key) || [],
          // MSAL passes no correlation ID to the get requests...
          ...this.abortControllers.get(noCorrelationId) || []
        ];
        if (!controllers.length) {
          return;
        }
        for (const controller of controllers) {
          controller.abort();
        }
        this.abortControllers.set(key, void 0);
      }
      getCorrelationId(options) {
        var _a3;
        const parameter = (_a3 = options === null || options === void 0 ? void 0 : options.body) === null || _a3 === void 0 ? void 0 : _a3.split("&").map((part) => part.split("=")).find(([key]) => key === "client-request-id");
        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;
      }
      // The MSAL network module methods follow
      async sendGetRequestAsync(url, options) {
        const request3 = createPipelineRequest({
          url,
          method: "GET",
          body: options === null || options === void 0 ? void 0 : options.body,
          allowInsecureConnection: this.allowInsecureConnection,
          headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
          abortSignal: this.generateAbortSignal(noCorrelationId)
        });
        const response = await this.sendRequest(request3);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      async sendPostRequestAsync(url, options) {
        const request3 = createPipelineRequest({
          url,
          method: "POST",
          body: options === null || options === void 0 ? void 0 : options.body,
          headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
          allowInsecureConnection: this.allowInsecureConnection,
          // MSAL doesn't send the correlation ID on the get requests.
          abortSignal: this.generateAbortSignal(this.getCorrelationId(options))
        });
        const response = await this.sendRequest(request3);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      /**
       *
       * @internal
       */
      getTokenCredentialOptions() {
        return this.tokenCredentialOptions;
      }
      /**
       * If allowLoggingAccountIdentifiers was set on the constructor options
       * we try to log the account identifiers by parsing the received access token.
       *
       * The account identifiers we try to log are:
       * - `appid`: The application or Client Identifier.
       * - `upn`: User Principal Name.
       *   - It might not be available in some authentication scenarios.
       *   - If it's not available, we put a placeholder: "No User Principal Name available".
       * - `tid`: Tenant Identifier.
       * - `oid`: Object Identifier of the authenticated user.
       */
      logIdentifiers(response) {
        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {
          return;
        }
        const unavailableUpn = "No User Principal Name available";
        try {
          const parsed = response.parsedBody || JSON.parse(response.bodyAsText);
          const accessToken = parsed.access_token;
          if (!accessToken) {
            return;
          }
          const base64Metadata = accessToken.split(".")[1];
          const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, "base64").toString("utf8"));
          logger2.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);
        } catch (e) {
          logger2.warning("allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:", e.message);
        }
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/visualStudioCodeCredential.js
function checkUnsupportedTenant(tenantId) {
  const unsupportedTenantError = unsupportedTenantIds[tenantId];
  if (unsupportedTenantError) {
    throw new CredentialUnavailableError(unsupportedTenantError);
  }
}
function getPropertyFromVSCode(property) {
  const settingsPath = ["User", "settings.json"];
  const vsCodeFolder = "Code";
  const homedir = import_os.default.homedir();
  function loadProperty(...pathSegments) {
    const fullPath = import_path2.default.join(...pathSegments, vsCodeFolder, ...settingsPath);
    const settings = JSON.parse(import_fs.default.readFileSync(fullPath, { encoding: "utf8" }));
    return settings[property];
  }
  try {
    let appData;
    switch (process.platform) {
      case "win32":
        appData = process.env.APPDATA;
        return appData ? loadProperty(appData) : void 0;
      case "darwin":
        return loadProperty(homedir, "Library", "Application Support");
      case "linux":
        return loadProperty(homedir, ".config");
      default:
        return;
    }
  } catch (e) {
    logger5.info(`Failed to load the Visual Studio Code configuration file. Error: ${e.message}`);
    return;
  }
}
var import_fs, import_os, import_path2, CommonTenantId, AzureAccountClientId, logger5, findCredentials, vsCodeCredentialControl, unsupportedTenantIds, mapVSCodeAuthorityHosts, VisualStudioCodeCredential;
var init_visualStudioCodeCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/visualStudioCodeCredential.js"() {
    "use strict";
    init_logging();
    init_tenantIdUtils();
    init_constants();
    init_errors();
    init_identityClient();
    init_tenantIdUtils();
    import_fs = __toESM(require("fs"));
    import_os = __toESM(require("os"));
    import_path2 = __toESM(require("path"));
    CommonTenantId = "common";
    AzureAccountClientId = "aebc6443-996d-45c2-90f0-388ff96faa56";
    logger5 = credentialLogger("VisualStudioCodeCredential");
    findCredentials = void 0;
    vsCodeCredentialControl = {
      setVsCodeCredentialFinder(finder) {
        findCredentials = finder;
      }
    };
    unsupportedTenantIds = {
      adfs: "The VisualStudioCodeCredential does not support authentication with ADFS tenants."
    };
    mapVSCodeAuthorityHosts = {
      AzureCloud: AzureAuthorityHosts.AzurePublicCloud,
      AzureChina: AzureAuthorityHosts.AzureChina,
      AzureGermanCloud: AzureAuthorityHosts.AzureGermany,
      AzureUSGovernment: AzureAuthorityHosts.AzureGovernment
    };
    VisualStudioCodeCredential = class {
      /**
       * Creates an instance of VisualStudioCodeCredential to use for automatically authenticating via VSCode.
       *
       * **Note**: `VisualStudioCodeCredential` is provided by a plugin package:
       * `@azure/identity-vscode`. If this package is not installed and registered
       * using the plugin API (`useIdentityPlugin`), then authentication using
       * `VisualStudioCodeCredential` will not be available.
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(options) {
        this.cloudName = getPropertyFromVSCode("azure.cloud") || "AzureCloud";
        const authorityHost = mapVSCodeAuthorityHosts[this.cloudName];
        this.identityClient = new IdentityClient(Object.assign({ authorityHost }, options));
        if (options && options.tenantId) {
          checkTenantId(logger5, options.tenantId);
          this.tenantId = options.tenantId;
        } else {
          this.tenantId = CommonTenantId;
        }
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        checkUnsupportedTenant(this.tenantId);
      }
      /**
       * Runs preparations for any further getToken request.
       */
      async prepare() {
        const settingsTenant = getPropertyFromVSCode("azure.tenant");
        if (settingsTenant) {
          this.tenantId = settingsTenant;
        }
        checkUnsupportedTenant(this.tenantId);
      }
      /**
       * Runs preparations for any further getToken, but only once.
       */
      prepareOnce() {
        if (!this.preparePromise) {
          this.preparePromise = this.prepare();
        }
        return this.preparePromise;
      }
      /**
       * Returns the token found by searching VSCode's authentication cache or
       * returns null if no token could be found.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                `TokenCredential` implementation might make.
       */
      async getToken(scopes, options) {
        var _a3, _b2;
        await this.prepareOnce();
        const tenantId = processMultiTenantRequest(this.tenantId, options, this.additionallyAllowedTenantIds, logger5) || this.tenantId;
        if (findCredentials === void 0) {
          throw new CredentialUnavailableError([
            "No implementation of `VisualStudioCodeCredential` is available.",
            "You must install the identity-vscode plugin package (`npm install --save-dev @azure/identity-vscode`)",
            "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
            "`useIdentityPlugin(vsCodePlugin)` before creating a `VisualStudioCodeCredential`.",
            "To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot."
          ].join(" "));
        }
        let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
        if (!scopeString.match(/^[0-9a-zA-Z-.:/]+$/)) {
          const error = new Error("Invalid scope was specified by the user or calling client");
          logger5.getToken.info(formatError(scopes, error));
          throw error;
        }
        if (scopeString.indexOf("offline_access") < 0) {
          scopeString += " offline_access";
        }
        const credentials = await findCredentials();
        const { password: refreshToken } = (_b2 = (_a3 = credentials.find(({ account }) => account === this.cloudName)) !== null && _a3 !== void 0 ? _a3 : credentials[0]) !== null && _b2 !== void 0 ? _b2 : {};
        if (refreshToken) {
          const tokenResponse = await this.identityClient.refreshAccessToken(tenantId, AzureAccountClientId, scopeString, refreshToken, void 0);
          if (tokenResponse) {
            logger5.getToken.info(formatSuccess(scopes));
            return tokenResponse.accessToken;
          } else {
            const error = new CredentialUnavailableError("Could not retrieve the token associated with Visual Studio Code. Have you connected using the 'Azure Account' extension recently? To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot.");
            logger5.getToken.info(formatError(scopes, error));
            throw error;
          }
        } else {
          const error = new CredentialUnavailableError("Could not retrieve the token associated with Visual Studio Code. Did you connect using the 'Azure Account' extension? To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot.");
          logger5.getToken.info(formatError(scopes, error));
          throw error;
        }
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/plugins/consumer.js
function useIdentityPlugin(plugin) {
  plugin(pluginContext);
}
var pluginContext;
var init_consumer = __esm({
  "node_modules/@azure/identity/dist-esm/src/plugins/consumer.js"() {
    "use strict";
    init_msalPlugins();
    init_visualStudioCodeCredential();
    pluginContext = {
      cachePluginControl: msalNodeFlowCacheControl,
      nativeBrokerPluginControl: msalNodeFlowNativeBrokerControl,
      vsCodeCredentialControl
    };
  }
});

// node_modules/@azure/msal-node/dist/cache/serializer/Serializer.mjs
var Serializer;
var init_Serializer = __esm({
  "node_modules/@azure/msal-node/dist/cache/serializer/Serializer.mjs"() {
    "use strict";
    Serializer = class {
      /**
       * serialize the JSON blob
       * @param data
       */
      static serializeJSONBlob(data) {
        return JSON.stringify(data);
      }
      /**
       * Serialize Accounts
       * @param accCache
       */
      static serializeAccounts(accCache) {
        const accounts = {};
        Object.keys(accCache).map(function(key) {
          const accountEntity = accCache[key];
          accounts[key] = {
            home_account_id: accountEntity.homeAccountId,
            environment: accountEntity.environment,
            realm: accountEntity.realm,
            local_account_id: accountEntity.localAccountId,
            username: accountEntity.username,
            authority_type: accountEntity.authorityType,
            name: accountEntity.name,
            client_info: accountEntity.clientInfo,
            last_modification_time: accountEntity.lastModificationTime,
            last_modification_app: accountEntity.lastModificationApp,
            tenantProfiles: accountEntity.tenantProfiles?.map((tenantProfile) => {
              return JSON.stringify(tenantProfile);
            })
          };
        });
        return accounts;
      }
      /**
       * Serialize IdTokens
       * @param idTCache
       */
      static serializeIdTokens(idTCache) {
        const idTokens = {};
        Object.keys(idTCache).map(function(key) {
          const idTEntity = idTCache[key];
          idTokens[key] = {
            home_account_id: idTEntity.homeAccountId,
            environment: idTEntity.environment,
            credential_type: idTEntity.credentialType,
            client_id: idTEntity.clientId,
            secret: idTEntity.secret,
            realm: idTEntity.realm
          };
        });
        return idTokens;
      }
      /**
       * Serializes AccessTokens
       * @param atCache
       */
      static serializeAccessTokens(atCache) {
        const accessTokens = {};
        Object.keys(atCache).map(function(key) {
          const atEntity = atCache[key];
          accessTokens[key] = {
            home_account_id: atEntity.homeAccountId,
            environment: atEntity.environment,
            credential_type: atEntity.credentialType,
            client_id: atEntity.clientId,
            secret: atEntity.secret,
            realm: atEntity.realm,
            target: atEntity.target,
            cached_at: atEntity.cachedAt,
            expires_on: atEntity.expiresOn,
            extended_expires_on: atEntity.extendedExpiresOn,
            refresh_on: atEntity.refreshOn,
            key_id: atEntity.keyId,
            token_type: atEntity.tokenType,
            requestedClaims: atEntity.requestedClaims,
            requestedClaimsHash: atEntity.requestedClaimsHash,
            userAssertionHash: atEntity.userAssertionHash
          };
        });
        return accessTokens;
      }
      /**
       * Serialize refreshTokens
       * @param rtCache
       */
      static serializeRefreshTokens(rtCache) {
        const refreshTokens = {};
        Object.keys(rtCache).map(function(key) {
          const rtEntity = rtCache[key];
          refreshTokens[key] = {
            home_account_id: rtEntity.homeAccountId,
            environment: rtEntity.environment,
            credential_type: rtEntity.credentialType,
            client_id: rtEntity.clientId,
            secret: rtEntity.secret,
            family_id: rtEntity.familyId,
            target: rtEntity.target,
            realm: rtEntity.realm
          };
        });
        return refreshTokens;
      }
      /**
       * Serialize amdtCache
       * @param amdtCache
       */
      static serializeAppMetadata(amdtCache) {
        const appMetadata = {};
        Object.keys(amdtCache).map(function(key) {
          const amdtEntity = amdtCache[key];
          appMetadata[key] = {
            client_id: amdtEntity.clientId,
            environment: amdtEntity.environment,
            family_id: amdtEntity.familyId
          };
        });
        return appMetadata;
      }
      /**
       * Serialize the cache
       * @param jsonContent
       */
      static serializeAllCache(inMemCache) {
        return {
          Account: this.serializeAccounts(inMemCache.accounts),
          IdToken: this.serializeIdTokens(inMemCache.idTokens),
          AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
          RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
          AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
        };
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/Constants.mjs
var Constants, HttpStatus, OIDC_DEFAULT_SCOPES, OIDC_SCOPES, HeaderNames, AADAuthorityConstants, ClaimsRequestKeys, PromptValue, CodeChallengeMethodValues, ServerResponseType, ResponseMode, GrantType, CacheAccountType, Separators, CredentialType, APP_METADATA, CLIENT_INFO, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthorityMetadataSource, SERVER_TELEM_CONSTANTS, AuthenticationScheme, ThrottlingConstants, Errors, PasswordGrantConstants, ResponseCodes, RegionDiscoverySources, RegionDiscoveryOutcomes, CacheOutcome, DEFAULT_TOKEN_RENEWAL_OFFSET_SEC;
var init_Constants = __esm({
  "node_modules/@azure/msal-common/dist/utils/Constants.mjs"() {
    "use strict";
    Constants = {
      LIBRARY_NAME: "MSAL.JS",
      SKU: "msal.js.common",
      // Prefix for all library cache entries
      CACHE_PREFIX: "msal",
      // default authority
      DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
      DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
      DEFAULT_COMMON_TENANT: "common",
      // ADFS String
      ADFS: "adfs",
      DSTS: "dstsv2",
      // Default AAD Instance Discovery Endpoint
      AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
      // CIAM URL
      CIAM_AUTH_URL: ".ciamlogin.com",
      AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
      // Resource delimiter - used for certain cache entries
      RESOURCE_DELIM: "|",
      // Placeholder for non-existent account ids/objects
      NO_ACCOUNT: "NO_ACCOUNT",
      // Claims
      CLAIMS: "claims",
      // Consumer UTID
      CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
      // Default scopes
      OPENID_SCOPE: "openid",
      PROFILE_SCOPE: "profile",
      OFFLINE_ACCESS_SCOPE: "offline_access",
      EMAIL_SCOPE: "email",
      // Default response type for authorization code flow
      CODE_RESPONSE_TYPE: "code",
      CODE_GRANT_TYPE: "authorization_code",
      RT_GRANT_TYPE: "refresh_token",
      FRAGMENT_RESPONSE_MODE: "fragment",
      S256_CODE_CHALLENGE_METHOD: "S256",
      URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
      AUTHORIZATION_PENDING: "authorization_pending",
      NOT_DEFINED: "not_defined",
      EMPTY_STRING: "",
      NOT_APPLICABLE: "N/A",
      NOT_AVAILABLE: "Not Available",
      FORWARD_SLASH: "/",
      IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
      IMDS_VERSION: "2020-06-01",
      IMDS_TIMEOUT: 2e3,
      AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
      REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
      KNOWN_PUBLIC_CLOUDS: [
        "login.microsoftonline.com",
        "login.windows.net",
        "login.microsoft.com",
        "sts.windows.net"
      ],
      TOKEN_RESPONSE_TYPE: "token",
      ID_TOKEN_RESPONSE_TYPE: "id_token",
      SHR_NONCE_VALIDITY: 240,
      INVALID_INSTANCE: "invalid_instance"
    };
    HttpStatus = {
      SUCCESS: 200,
      SUCCESS_RANGE_START: 200,
      SUCCESS_RANGE_END: 299,
      REDIRECT: 302,
      CLIENT_ERROR: 400,
      CLIENT_ERROR_RANGE_START: 400,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      NOT_FOUND: 404,
      REQUEST_TIMEOUT: 408,
      TOO_MANY_REQUESTS: 429,
      CLIENT_ERROR_RANGE_END: 499,
      SERVER_ERROR: 500,
      SERVER_ERROR_RANGE_START: 500,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      SERVER_ERROR_RANGE_END: 599,
      MULTI_SIDED_ERROR: 600
    };
    OIDC_DEFAULT_SCOPES = [
      Constants.OPENID_SCOPE,
      Constants.PROFILE_SCOPE,
      Constants.OFFLINE_ACCESS_SCOPE
    ];
    OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants.EMAIL_SCOPE];
    HeaderNames = {
      CONTENT_TYPE: "Content-Type",
      RETRY_AFTER: "Retry-After",
      CCS_HEADER: "X-AnchorMailbox",
      WWWAuthenticate: "WWW-Authenticate",
      AuthenticationInfo: "Authentication-Info",
      X_MS_REQUEST_ID: "x-ms-request-id",
      X_MS_HTTP_VERSION: "x-ms-httpver"
    };
    AADAuthorityConstants = {
      COMMON: "common",
      ORGANIZATIONS: "organizations",
      CONSUMERS: "consumers"
    };
    ClaimsRequestKeys = {
      ACCESS_TOKEN: "access_token",
      XMS_CC: "xms_cc"
    };
    PromptValue = {
      LOGIN: "login",
      SELECT_ACCOUNT: "select_account",
      CONSENT: "consent",
      NONE: "none",
      CREATE: "create",
      NO_SESSION: "no_session"
    };
    CodeChallengeMethodValues = {
      PLAIN: "plain",
      S256: "S256"
    };
    ServerResponseType = {
      QUERY: "query",
      FRAGMENT: "fragment"
    };
    ResponseMode = {
      ...ServerResponseType,
      FORM_POST: "form_post"
    };
    GrantType = {
      IMPLICIT_GRANT: "implicit",
      AUTHORIZATION_CODE_GRANT: "authorization_code",
      CLIENT_CREDENTIALS_GRANT: "client_credentials",
      RESOURCE_OWNER_PASSWORD_GRANT: "password",
      REFRESH_TOKEN_GRANT: "refresh_token",
      DEVICE_CODE_GRANT: "device_code",
      JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer"
    };
    CacheAccountType = {
      MSSTS_ACCOUNT_TYPE: "MSSTS",
      ADFS_ACCOUNT_TYPE: "ADFS",
      MSAV1_ACCOUNT_TYPE: "MSA",
      GENERIC_ACCOUNT_TYPE: "Generic"
      // NTLM, Kerberos, FBA, Basic etc
    };
    Separators = {
      CACHE_KEY_SEPARATOR: "-",
      CLIENT_INFO_SEPARATOR: "."
    };
    CredentialType = {
      ID_TOKEN: "IdToken",
      ACCESS_TOKEN: "AccessToken",
      ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
      REFRESH_TOKEN: "RefreshToken"
    };
    APP_METADATA = "appmetadata";
    CLIENT_INFO = "client_info";
    THE_FAMILY_ID = "1";
    AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: "authority-metadata",
      REFRESH_TIME_SECONDS: 3600 * 24
      // 24 Hours
    };
    AuthorityMetadataSource = {
      CONFIG: "config",
      CACHE: "cache",
      NETWORK: "network",
      HARDCODED_VALUES: "hardcoded_values"
    };
    SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5,
      MAX_CUR_HEADER_BYTES: 80,
      MAX_LAST_HEADER_BYTES: 330,
      MAX_CACHED_ERRORS: 50,
      CACHE_KEY: "server-telemetry",
      CATEGORY_SEPARATOR: "|",
      VALUE_SEPARATOR: ",",
      OVERFLOW_TRUE: "1",
      OVERFLOW_FALSE: "0",
      UNKNOWN_ERROR: "unknown_error"
    };
    AuthenticationScheme = {
      BEARER: "Bearer",
      POP: "pop",
      SSH: "ssh-cert"
    };
    ThrottlingConstants = {
      // Default time to throttle RequestThumbprint in seconds
      DEFAULT_THROTTLE_TIME_SECONDS: 60,
      // Default maximum time to throttle in seconds, overrides what the server sends back
      DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
      // Prefix for storing throttling entries
      THROTTLING_PREFIX: "throttling",
      // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
      X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
    };
    Errors = {
      INVALID_GRANT_ERROR: "invalid_grant",
      CLIENT_MISMATCH_ERROR: "client_mismatch"
    };
    PasswordGrantConstants = {
      username: "username",
      password: "password"
    };
    ResponseCodes = {
      httpSuccess: 200,
      httpBadRequest: 400
    };
    RegionDiscoverySources = {
      FAILED_AUTO_DETECTION: "1",
      INTERNAL_CACHE: "2",
      ENVIRONMENT_VARIABLE: "3",
      IMDS: "4"
    };
    RegionDiscoveryOutcomes = {
      CONFIGURED_MATCHES_DETECTED: "1",
      CONFIGURED_NO_AUTO_DETECTION: "2",
      CONFIGURED_NOT_DETECTED: "3",
      AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
      AUTO_DETECTION_REQUESTED_FAILED: "5"
    };
    CacheOutcome = {
      // When a token is found in the cache or the cache is not supposed to be hit when making the request
      NOT_APPLICABLE: "0",
      // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
      FORCE_REFRESH_OR_CLAIMS: "1",
      // When the token request goes to the identity provider because no cached access token exists
      NO_CACHED_ACCESS_TOKEN: "2",
      // When the token request goes to the identity provider because cached access token expired
      CACHED_ACCESS_TOKEN_EXPIRED: "3",
      // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
      PROACTIVELY_REFRESHED: "4"
    };
    DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
  }
});

// node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs
var AuthErrorCodes_exports = {};
__export(AuthErrorCodes_exports, {
  postRequestFailed: () => postRequestFailed,
  unexpectedError: () => unexpectedError
});
var unexpectedError, postRequestFailed;
var init_AuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs"() {
    "use strict";
    unexpectedError = "unexpected_error";
    postRequestFailed = "post_request_failed";
  }
});

// node_modules/@azure/msal-common/dist/error/AuthError.mjs
function createAuthError(code, additionalMessage) {
  return new AuthError(code, additionalMessage ? `${AuthErrorMessages[code]} ${additionalMessage}` : AuthErrorMessages[code]);
}
var AuthErrorMessages, AuthErrorMessage, AuthError;
var init_AuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/AuthError.mjs"() {
    "use strict";
    init_Constants();
    init_AuthErrorCodes();
    AuthErrorMessages = {
      [unexpectedError]: "Unexpected error in authentication.",
      [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
    };
    AuthErrorMessage = {
      unexpectedError: {
        code: unexpectedError,
        desc: AuthErrorMessages[unexpectedError]
      },
      postRequestFailed: {
        code: postRequestFailed,
        desc: AuthErrorMessages[postRequestFailed]
      }
    };
    AuthError = class _AuthError extends Error {
      constructor(errorCode, errorMessage, suberror) {
        const errorString = errorMessage ? `${errorCode}: ${errorMessage}` : errorCode;
        super(errorString);
        Object.setPrototypeOf(this, _AuthError.prototype);
        this.errorCode = errorCode || Constants.EMPTY_STRING;
        this.errorMessage = errorMessage || Constants.EMPTY_STRING;
        this.subError = suberror || Constants.EMPTY_STRING;
        this.name = "AuthError";
      }
      setCorrelationId(correlationId) {
        this.correlationId = correlationId;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs
var ClientAuthErrorCodes_exports = {};
__export(ClientAuthErrorCodes_exports, {
  authTimeNotFound: () => authTimeNotFound,
  authorizationCodeMissingFromServerResponse: () => authorizationCodeMissingFromServerResponse,
  bindingKeyNotRemoved: () => bindingKeyNotRemoved,
  cannotAppendScopeSet: () => cannotAppendScopeSet,
  cannotRemoveEmptyScope: () => cannotRemoveEmptyScope,
  clientInfoDecodingError: () => clientInfoDecodingError,
  clientInfoEmptyError: () => clientInfoEmptyError,
  deviceCodeExpired: () => deviceCodeExpired,
  deviceCodePollingCancelled: () => deviceCodePollingCancelled,
  deviceCodeUnknownError: () => deviceCodeUnknownError,
  emptyInputScopeSet: () => emptyInputScopeSet,
  endSessionEndpointNotSupported: () => endSessionEndpointNotSupported,
  endpointResolutionError: () => endpointResolutionError,
  hashNotDeserialized: () => hashNotDeserialized,
  invalidAssertion: () => invalidAssertion,
  invalidCacheEnvironment: () => invalidCacheEnvironment,
  invalidCacheRecord: () => invalidCacheRecord,
  invalidClientCredential: () => invalidClientCredential,
  invalidState: () => invalidState,
  keyIdMissing: () => keyIdMissing,
  maxAgeTranspired: () => maxAgeTranspired,
  methodNotImplemented: () => methodNotImplemented,
  missingTenantIdError: () => missingTenantIdError,
  multipleMatchingAccounts: () => multipleMatchingAccounts,
  multipleMatchingAppMetadata: () => multipleMatchingAppMetadata,
  multipleMatchingTokens: () => multipleMatchingTokens,
  nestedAppAuthBridgeDisabled: () => nestedAppAuthBridgeDisabled,
  networkError: () => networkError,
  noAccountFound: () => noAccountFound,
  noAccountInSilentRequest: () => noAccountInSilentRequest,
  noCryptoObject: () => noCryptoObject,
  noNetworkConnectivity: () => noNetworkConnectivity,
  nonceMismatch: () => nonceMismatch,
  nullOrEmptyToken: () => nullOrEmptyToken,
  openIdConfigError: () => openIdConfigError,
  requestCannotBeMade: () => requestCannotBeMade,
  stateMismatch: () => stateMismatch,
  stateNotFound: () => stateNotFound,
  tokenClaimsCnfRequiredForSignedJwt: () => tokenClaimsCnfRequiredForSignedJwt,
  tokenParsingError: () => tokenParsingError,
  tokenRefreshRequired: () => tokenRefreshRequired,
  unexpectedCredentialType: () => unexpectedCredentialType,
  userCanceled: () => userCanceled,
  userTimeoutReached: () => userTimeoutReached
});
var clientInfoDecodingError, clientInfoEmptyError, tokenParsingError, nullOrEmptyToken, endpointResolutionError, networkError, openIdConfigError, hashNotDeserialized, invalidState, stateMismatch, stateNotFound, nonceMismatch, authTimeNotFound, maxAgeTranspired, multipleMatchingTokens, multipleMatchingAccounts, multipleMatchingAppMetadata, requestCannotBeMade, cannotRemoveEmptyScope, cannotAppendScopeSet, emptyInputScopeSet, deviceCodePollingCancelled, deviceCodeExpired, deviceCodeUnknownError, noAccountInSilentRequest, invalidCacheRecord, invalidCacheEnvironment, noAccountFound, noCryptoObject, unexpectedCredentialType, invalidAssertion, invalidClientCredential, tokenRefreshRequired, userTimeoutReached, tokenClaimsCnfRequiredForSignedJwt, authorizationCodeMissingFromServerResponse, bindingKeyNotRemoved, endSessionEndpointNotSupported, keyIdMissing, noNetworkConnectivity, userCanceled, missingTenantIdError, methodNotImplemented, nestedAppAuthBridgeDisabled;
var init_ClientAuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs"() {
    "use strict";
    clientInfoDecodingError = "client_info_decoding_error";
    clientInfoEmptyError = "client_info_empty_error";
    tokenParsingError = "token_parsing_error";
    nullOrEmptyToken = "null_or_empty_token";
    endpointResolutionError = "endpoints_resolution_error";
    networkError = "network_error";
    openIdConfigError = "openid_config_error";
    hashNotDeserialized = "hash_not_deserialized";
    invalidState = "invalid_state";
    stateMismatch = "state_mismatch";
    stateNotFound = "state_not_found";
    nonceMismatch = "nonce_mismatch";
    authTimeNotFound = "auth_time_not_found";
    maxAgeTranspired = "max_age_transpired";
    multipleMatchingTokens = "multiple_matching_tokens";
    multipleMatchingAccounts = "multiple_matching_accounts";
    multipleMatchingAppMetadata = "multiple_matching_appMetadata";
    requestCannotBeMade = "request_cannot_be_made";
    cannotRemoveEmptyScope = "cannot_remove_empty_scope";
    cannotAppendScopeSet = "cannot_append_scopeset";
    emptyInputScopeSet = "empty_input_scopeset";
    deviceCodePollingCancelled = "device_code_polling_cancelled";
    deviceCodeExpired = "device_code_expired";
    deviceCodeUnknownError = "device_code_unknown_error";
    noAccountInSilentRequest = "no_account_in_silent_request";
    invalidCacheRecord = "invalid_cache_record";
    invalidCacheEnvironment = "invalid_cache_environment";
    noAccountFound = "no_account_found";
    noCryptoObject = "no_crypto_object";
    unexpectedCredentialType = "unexpected_credential_type";
    invalidAssertion = "invalid_assertion";
    invalidClientCredential = "invalid_client_credential";
    tokenRefreshRequired = "token_refresh_required";
    userTimeoutReached = "user_timeout_reached";
    tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
    authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
    bindingKeyNotRemoved = "binding_key_not_removed";
    endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
    keyIdMissing = "key_id_missing";
    noNetworkConnectivity = "no_network_connectivity";
    userCanceled = "user_canceled";
    missingTenantIdError = "missing_tenant_id_error";
    methodNotImplemented = "method_not_implemented";
    nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";
  }
});

// node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs
function createClientAuthError(errorCode, additionalMessage) {
  return new ClientAuthError(errorCode, additionalMessage);
}
var ClientAuthErrorMessages, ClientAuthErrorMessage, ClientAuthError;
var init_ClientAuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs"() {
    "use strict";
    init_AuthError();
    init_ClientAuthErrorCodes();
    ClientAuthErrorMessages = {
      [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
      [clientInfoEmptyError]: "The client info was empty",
      [tokenParsingError]: "Token cannot be parsed",
      [nullOrEmptyToken]: "The token is null or empty",
      [endpointResolutionError]: "Endpoints cannot be resolved",
      [networkError]: "Network request failed",
      [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
      [hashNotDeserialized]: "The hash parameters could not be deserialized",
      [invalidState]: "State was not the expected format",
      [stateMismatch]: "State mismatch error",
      [stateNotFound]: "State not found",
      [nonceMismatch]: "Nonce mismatch error",
      [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information.",
      [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
      [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account.",
      [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
      [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
      [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
      [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
      [cannotAppendScopeSet]: "Cannot append ScopeSet",
      [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
      [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
      [deviceCodeExpired]: "Device code is expired.",
      [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
      [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
      [invalidCacheRecord]: "Cache record object was null or undefined.",
      [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
      [noAccountFound]: "No account found in cache for given key.",
      [noCryptoObject]: "No crypto object detected.",
      [unexpectedCredentialType]: "Unexpected credential type.",
      [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
      [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
      [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
      [userTimeoutReached]: "User defined timeout for device code polling reached",
      [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
      [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
      [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
      [endSessionEndpointNotSupported]: "The provided authority does not support logout",
      [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
      [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
      [userCanceled]: "User cancelled the flow.",
      [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
      [methodNotImplemented]: "This method has not been implemented",
      [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled"
    };
    ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: clientInfoDecodingError,
        desc: ClientAuthErrorMessages[clientInfoDecodingError]
      },
      clientInfoEmptyError: {
        code: clientInfoEmptyError,
        desc: ClientAuthErrorMessages[clientInfoEmptyError]
      },
      tokenParsingError: {
        code: tokenParsingError,
        desc: ClientAuthErrorMessages[tokenParsingError]
      },
      nullOrEmptyToken: {
        code: nullOrEmptyToken,
        desc: ClientAuthErrorMessages[nullOrEmptyToken]
      },
      endpointResolutionError: {
        code: endpointResolutionError,
        desc: ClientAuthErrorMessages[endpointResolutionError]
      },
      networkError: {
        code: networkError,
        desc: ClientAuthErrorMessages[networkError]
      },
      unableToGetOpenidConfigError: {
        code: openIdConfigError,
        desc: ClientAuthErrorMessages[openIdConfigError]
      },
      hashNotDeserialized: {
        code: hashNotDeserialized,
        desc: ClientAuthErrorMessages[hashNotDeserialized]
      },
      invalidStateError: {
        code: invalidState,
        desc: ClientAuthErrorMessages[invalidState]
      },
      stateMismatchError: {
        code: stateMismatch,
        desc: ClientAuthErrorMessages[stateMismatch]
      },
      stateNotFoundError: {
        code: stateNotFound,
        desc: ClientAuthErrorMessages[stateNotFound]
      },
      nonceMismatchError: {
        code: nonceMismatch,
        desc: ClientAuthErrorMessages[nonceMismatch]
      },
      authTimeNotFoundError: {
        code: authTimeNotFound,
        desc: ClientAuthErrorMessages[authTimeNotFound]
      },
      maxAgeTranspired: {
        code: maxAgeTranspired,
        desc: ClientAuthErrorMessages[maxAgeTranspired]
      },
      multipleMatchingTokens: {
        code: multipleMatchingTokens,
        desc: ClientAuthErrorMessages[multipleMatchingTokens]
      },
      multipleMatchingAccounts: {
        code: multipleMatchingAccounts,
        desc: ClientAuthErrorMessages[multipleMatchingAccounts]
      },
      multipleMatchingAppMetadata: {
        code: multipleMatchingAppMetadata,
        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata]
      },
      tokenRequestCannotBeMade: {
        code: requestCannotBeMade,
        desc: ClientAuthErrorMessages[requestCannotBeMade]
      },
      removeEmptyScopeError: {
        code: cannotRemoveEmptyScope,
        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope]
      },
      appendScopeSetError: {
        code: cannotAppendScopeSet,
        desc: ClientAuthErrorMessages[cannotAppendScopeSet]
      },
      emptyInputScopeSetError: {
        code: emptyInputScopeSet,
        desc: ClientAuthErrorMessages[emptyInputScopeSet]
      },
      DeviceCodePollingCancelled: {
        code: deviceCodePollingCancelled,
        desc: ClientAuthErrorMessages[deviceCodePollingCancelled]
      },
      DeviceCodeExpired: {
        code: deviceCodeExpired,
        desc: ClientAuthErrorMessages[deviceCodeExpired]
      },
      DeviceCodeUnknownError: {
        code: deviceCodeUnknownError,
        desc: ClientAuthErrorMessages[deviceCodeUnknownError]
      },
      NoAccountInSilentRequest: {
        code: noAccountInSilentRequest,
        desc: ClientAuthErrorMessages[noAccountInSilentRequest]
      },
      invalidCacheRecord: {
        code: invalidCacheRecord,
        desc: ClientAuthErrorMessages[invalidCacheRecord]
      },
      invalidCacheEnvironment: {
        code: invalidCacheEnvironment,
        desc: ClientAuthErrorMessages[invalidCacheEnvironment]
      },
      noAccountFound: {
        code: noAccountFound,
        desc: ClientAuthErrorMessages[noAccountFound]
      },
      noCryptoObj: {
        code: noCryptoObject,
        desc: ClientAuthErrorMessages[noCryptoObject]
      },
      unexpectedCredentialType: {
        code: unexpectedCredentialType,
        desc: ClientAuthErrorMessages[unexpectedCredentialType]
      },
      invalidAssertion: {
        code: invalidAssertion,
        desc: ClientAuthErrorMessages[invalidAssertion]
      },
      invalidClientCredential: {
        code: invalidClientCredential,
        desc: ClientAuthErrorMessages[invalidClientCredential]
      },
      tokenRefreshRequired: {
        code: tokenRefreshRequired,
        desc: ClientAuthErrorMessages[tokenRefreshRequired]
      },
      userTimeoutReached: {
        code: userTimeoutReached,
        desc: ClientAuthErrorMessages[userTimeoutReached]
      },
      tokenClaimsRequired: {
        code: tokenClaimsCnfRequiredForSignedJwt,
        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt]
      },
      noAuthorizationCodeFromServer: {
        code: authorizationCodeMissingFromServerResponse,
        desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse]
      },
      bindingKeyNotRemovedError: {
        code: bindingKeyNotRemoved,
        desc: ClientAuthErrorMessages[bindingKeyNotRemoved]
      },
      logoutNotSupported: {
        code: endSessionEndpointNotSupported,
        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported]
      },
      keyIdMissing: {
        code: keyIdMissing,
        desc: ClientAuthErrorMessages[keyIdMissing]
      },
      noNetworkConnectivity: {
        code: noNetworkConnectivity,
        desc: ClientAuthErrorMessages[noNetworkConnectivity]
      },
      userCanceledError: {
        code: userCanceled,
        desc: ClientAuthErrorMessages[userCanceled]
      },
      missingTenantIdError: {
        code: missingTenantIdError,
        desc: ClientAuthErrorMessages[missingTenantIdError]
      },
      nestedAppAuthBridgeDisabled: {
        code: nestedAppAuthBridgeDisabled,
        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled]
      }
    };
    ClientAuthError = class _ClientAuthError extends AuthError {
      constructor(errorCode, additionalMessage) {
        super(errorCode, additionalMessage ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}` : ClientAuthErrorMessages[errorCode]);
        this.name = "ClientAuthError";
        Object.setPrototypeOf(this, _ClientAuthError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs
var DEFAULT_CRYPTO_IMPLEMENTATION;
var init_ICrypto = __esm({
  "node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Decode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Encode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64UrlEncode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      encodeKid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      async getPublicKeyThumbprint() {
        throw createClientAuthError(methodNotImplemented);
      },
      async removeTokenBindingKey() {
        throw createClientAuthError(methodNotImplemented);
      },
      async clearKeystore() {
        throw createClientAuthError(methodNotImplemented);
      },
      async signJwt() {
        throw createClientAuthError(methodNotImplemented);
      },
      async hashString() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/logger/Logger.mjs
var LogLevel, Logger;
var init_Logger = __esm({
  "node_modules/@azure/msal-common/dist/logger/Logger.mjs"() {
    "use strict";
    init_Constants();
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Error"] = 0] = "Error";
      LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
      LogLevel2[LogLevel2["Info"] = 2] = "Info";
      LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
      LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
    })(LogLevel || (LogLevel = {}));
    Logger = class _Logger {
      constructor(loggerOptions, packageName, packageVersion) {
        this.level = LogLevel.Info;
        const defaultLoggerCallback2 = () => {
          return;
        };
        const setLoggerOptions = loggerOptions || _Logger.createDefaultLoggerOptions();
        this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback2;
        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
        this.level = typeof setLoggerOptions.logLevel === "number" ? setLoggerOptions.logLevel : LogLevel.Info;
        this.correlationId = setLoggerOptions.correlationId || Constants.EMPTY_STRING;
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
      }
      static createDefaultLoggerOptions() {
        return {
          loggerCallback: () => {
          },
          piiLoggingEnabled: false,
          logLevel: LogLevel.Info
        };
      }
      /**
       * Create new Logger with existing configurations.
       */
      clone(packageName, packageVersion, correlationId) {
        return new _Logger({
          loggerCallback: this.localCallback,
          piiLoggingEnabled: this.piiLoggingEnabled,
          logLevel: this.level,
          correlationId: correlationId || this.correlationId
        }, packageName, packageVersion);
      }
      /**
       * Log message with required options.
       */
      logMessage(logMessage, options) {
        if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
          return;
        }
        const timestamp = (/* @__PURE__ */ new Date()).toUTCString();
        const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;
        const log3 = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${LogLevel[options.logLevel]} - ${logMessage}`;
        this.executeCallback(options.logLevel, log3, options.containsPii || false);
      }
      /**
       * Execute callback with message.
       */
      executeCallback(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii);
        }
      }
      /**
       * Logs error messages.
       */
      error(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Error,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs error messages with PII.
       */
      errorPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Error,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages.
       */
      warning(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Warning,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages with PII.
       */
      warningPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Warning,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs info messages.
       */
      info(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Info,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs info messages with PII.
       */
      infoPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Info,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages.
       */
      verbose(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Verbose,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages with PII.
       */
      verbosePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Verbose,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages.
       */
      trace(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Trace,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages with PII.
       */
      tracePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Trace,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Returns whether PII Logging is enabled or not.
       */
      isPiiLoggingEnabled() {
        return this.piiLoggingEnabled || false;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/packageMetadata.mjs
var name, version;
var init_packageMetadata = __esm({
  "node_modules/@azure/msal-common/dist/packageMetadata.mjs"() {
    "use strict";
    name = "@azure/msal-common";
    version = "14.15.0";
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs
var AzureCloudInstance;
var init_AuthorityOptions = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs"() {
    "use strict";
    AzureCloudInstance = {
      // AzureCloudInstance is not specified.
      None: "none",
      // Microsoft Azure public cloud
      AzurePublic: "https://login.microsoftonline.com",
      // Microsoft PPE
      AzurePpe: "https://login.windows-ppe.net",
      // Microsoft Chinese national/regional cloud
      AzureChina: "https://login.chinacloudapi.cn",
      // Microsoft German national/regional cloud ("Black Forest")
      AzureGermany: "https://login.microsoftonline.de",
      // US Government cloud
      AzureUsGovernment: "https://login.microsoftonline.us"
    };
  }
});

// node_modules/@azure/msal-common/dist/account/AuthToken.mjs
var AuthToken_exports = {};
__export(AuthToken_exports, {
  checkMaxAge: () => checkMaxAge,
  extractTokenClaims: () => extractTokenClaims,
  getJWSPayload: () => getJWSPayload
});
function extractTokenClaims(encodedToken, base64Decode) {
  const jswPayload = getJWSPayload(encodedToken);
  try {
    const base64Decoded = base64Decode(jswPayload);
    return JSON.parse(base64Decoded);
  } catch (err) {
    throw createClientAuthError(tokenParsingError);
  }
}
function getJWSPayload(authToken) {
  if (!authToken) {
    throw createClientAuthError(nullOrEmptyToken);
  }
  const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
  const matches = tokenPartsRegex.exec(authToken);
  if (!matches || matches.length < 4) {
    throw createClientAuthError(tokenParsingError);
  }
  return matches[2];
}
function checkMaxAge(authTime, maxAge) {
  const fiveMinuteSkew = 3e5;
  if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
    throw createClientAuthError(maxAgeTranspired);
  }
}
var init_AuthToken = __esm({
  "node_modules/@azure/msal-common/dist/account/AuthToken.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs
var TimeUtils_exports = {};
__export(TimeUtils_exports, {
  delay: () => delay3,
  isTokenExpired: () => isTokenExpired,
  nowSeconds: () => nowSeconds,
  wasClockTurnedBack: () => wasClockTurnedBack
});
function nowSeconds() {
  return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
}
function isTokenExpired(expiresOn, offset) {
  const expirationSec = Number(expiresOn) || 0;
  const offsetCurrentTimeSec = nowSeconds() + offset;
  return offsetCurrentTimeSec > expirationSec;
}
function wasClockTurnedBack(cachedAt) {
  const cachedAtSec = Number(cachedAt);
  return cachedAtSec > nowSeconds();
}
function delay3(t, value) {
  return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
var init_TimeUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs
var CacheHelpers_exports = {};
__export(CacheHelpers_exports, {
  createAccessTokenEntity: () => createAccessTokenEntity,
  createIdTokenEntity: () => createIdTokenEntity,
  createRefreshTokenEntity: () => createRefreshTokenEntity,
  generateAppMetadataKey: () => generateAppMetadataKey,
  generateAuthorityMetadataExpiresAt: () => generateAuthorityMetadataExpiresAt,
  generateCredentialKey: () => generateCredentialKey,
  isAccessTokenEntity: () => isAccessTokenEntity,
  isAppMetadataEntity: () => isAppMetadataEntity,
  isAuthorityMetadataEntity: () => isAuthorityMetadataEntity,
  isAuthorityMetadataExpired: () => isAuthorityMetadataExpired,
  isCredentialEntity: () => isCredentialEntity,
  isIdTokenEntity: () => isIdTokenEntity,
  isRefreshTokenEntity: () => isRefreshTokenEntity,
  isServerTelemetryEntity: () => isServerTelemetryEntity,
  isThrottlingEntity: () => isThrottlingEntity,
  updateAuthorityEndpointMetadata: () => updateAuthorityEndpointMetadata,
  updateCloudDiscoveryMetadata: () => updateCloudDiscoveryMetadata
});
function generateCredentialKey(credentialEntity) {
  const credentialKey = [
    generateAccountId(credentialEntity),
    generateCredentialId(credentialEntity),
    generateTarget(credentialEntity),
    generateClaimsHash(credentialEntity),
    generateScheme(credentialEntity)
  ];
  return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
  const idTokenEntity = {
    credentialType: CredentialType.ID_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: idToken,
    realm: tenantId
  };
  return idTokenEntity;
}
function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
  const atEntity = {
    homeAccountId,
    credentialType: CredentialType.ACCESS_TOKEN,
    secret: accessToken,
    cachedAt: nowSeconds().toString(),
    expiresOn: expiresOn.toString(),
    extendedExpiresOn: extExpiresOn.toString(),
    environment,
    clientId,
    realm: tenantId,
    target: scopes,
    tokenType: tokenType || AuthenticationScheme.BEARER
  };
  if (userAssertionHash) {
    atEntity.userAssertionHash = userAssertionHash;
  }
  if (refreshOn) {
    atEntity.refreshOn = refreshOn.toString();
  }
  if (requestedClaims) {
    atEntity.requestedClaims = requestedClaims;
    atEntity.requestedClaimsHash = requestedClaimsHash;
  }
  if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {
    atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
    switch (atEntity.tokenType) {
      case AuthenticationScheme.POP:
        const tokenClaims = extractTokenClaims(accessToken, base64Decode);
        if (!tokenClaims?.cnf?.kid) {
          throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
        }
        atEntity.keyId = tokenClaims.cnf.kid;
        break;
      case AuthenticationScheme.SSH:
        atEntity.keyId = keyId;
    }
  }
  return atEntity;
}
function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
  const rtEntity = {
    credentialType: CredentialType.REFRESH_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: refreshToken
  };
  if (userAssertionHash) {
    rtEntity.userAssertionHash = userAssertionHash;
  }
  if (familyId) {
    rtEntity.familyId = familyId;
  }
  if (expiresOn) {
    rtEntity.expiresOn = expiresOn.toString();
  }
  return rtEntity;
}
function isCredentialEntity(entity) {
  return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret");
}
function isAccessTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
}
function isIdTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity["credentialType"] === CredentialType.ID_TOKEN;
}
function isRefreshTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
}
function generateAccountId(credentialEntity) {
  const accountId = [
    credentialEntity.homeAccountId,
    credentialEntity.environment
  ];
  return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function generateCredentialId(credentialEntity) {
  const clientOrFamilyId = credentialEntity.credentialType === CredentialType.REFRESH_TOKEN ? credentialEntity.familyId || credentialEntity.clientId : credentialEntity.clientId;
  const credentialId = [
    credentialEntity.credentialType,
    clientOrFamilyId,
    credentialEntity.realm || ""
  ];
  return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function generateTarget(credentialEntity) {
  return (credentialEntity.target || "").toLowerCase();
}
function generateClaimsHash(credentialEntity) {
  return (credentialEntity.requestedClaimsHash || "").toLowerCase();
}
function generateScheme(credentialEntity) {
  return credentialEntity.tokenType && credentialEntity.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credentialEntity.tokenType.toLowerCase() : "";
}
function isServerTelemetryEntity(key, entity) {
  const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
  }
  return validateKey && validateEntity;
}
function isThrottlingEntity(key, entity) {
  let validateKey = false;
  if (key) {
    validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
  }
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty("throttleTime");
  }
  return validateKey && validateEntity;
}
function generateAppMetadataKey({ environment, clientId }) {
  const appMetaDataKeyArray = [
    APP_METADATA,
    environment,
    clientId
  ];
  return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function isAppMetadataEntity(key, entity) {
  if (!entity) {
    return false;
  }
  return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
}
function isAuthorityMetadataEntity(key, entity) {
  if (!entity) {
    return false;
  }
  return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
}
function generateAuthorityMetadataExpiresAt() {
  return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
}
function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;
  authorityMetadata.token_endpoint = updatedValues.token_endpoint;
  authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
  authorityMetadata.issuer = updatedValues.issuer;
  authorityMetadata.endpointsFromNetwork = fromNetwork;
  authorityMetadata.jwks_uri = updatedValues.jwks_uri;
}
function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.aliases = updatedValues.aliases;
  authorityMetadata.preferred_cache = updatedValues.preferred_cache;
  authorityMetadata.preferred_network = updatedValues.preferred_network;
  authorityMetadata.aliasesFromNetwork = fromNetwork;
}
function isAuthorityMetadataExpired(metadata) {
  return metadata.expiresAt <= nowSeconds();
}
var init_CacheHelpers = __esm({
  "node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs"() {
    "use strict";
    init_AuthToken();
    init_ClientAuthError();
    init_Constants();
    init_TimeUtils();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs
var ClientConfigurationErrorCodes_exports = {};
__export(ClientConfigurationErrorCodes_exports, {
  authorityMismatch: () => authorityMismatch,
  authorityUriInsecure: () => authorityUriInsecure,
  cannotAllowNativeBroker: () => cannotAllowNativeBroker,
  cannotSetOIDCOptions: () => cannotSetOIDCOptions,
  claimsRequestParsingError: () => claimsRequestParsingError,
  emptyInputScopesError: () => emptyInputScopesError,
  invalidAuthenticationHeader: () => invalidAuthenticationHeader,
  invalidAuthorityMetadata: () => invalidAuthorityMetadata,
  invalidClaims: () => invalidClaims,
  invalidCloudDiscoveryMetadata: () => invalidCloudDiscoveryMetadata,
  invalidCodeChallengeMethod: () => invalidCodeChallengeMethod,
  invalidPromptValue: () => invalidPromptValue,
  logoutRequestEmpty: () => logoutRequestEmpty,
  missingNonceAuthenticationHeader: () => missingNonceAuthenticationHeader,
  missingSshJwk: () => missingSshJwk,
  missingSshKid: () => missingSshKid,
  pkceParamsMissing: () => pkceParamsMissing,
  redirectUriEmpty: () => redirectUriEmpty,
  tokenRequestEmpty: () => tokenRequestEmpty,
  untrustedAuthority: () => untrustedAuthority,
  urlEmptyError: () => urlEmptyError,
  urlParseError: () => urlParseError
});
var redirectUriEmpty, claimsRequestParsingError, authorityUriInsecure, urlParseError, urlEmptyError, emptyInputScopesError, invalidPromptValue, invalidClaims, tokenRequestEmpty, logoutRequestEmpty, invalidCodeChallengeMethod, pkceParamsMissing, invalidCloudDiscoveryMetadata, invalidAuthorityMetadata, untrustedAuthority, missingSshJwk, missingSshKid, missingNonceAuthenticationHeader, invalidAuthenticationHeader, cannotSetOIDCOptions, cannotAllowNativeBroker, authorityMismatch;
var init_ClientConfigurationErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs"() {
    "use strict";
    redirectUriEmpty = "redirect_uri_empty";
    claimsRequestParsingError = "claims_request_parsing_error";
    authorityUriInsecure = "authority_uri_insecure";
    urlParseError = "url_parse_error";
    urlEmptyError = "empty_url_error";
    emptyInputScopesError = "empty_input_scopes_error";
    invalidPromptValue = "invalid_prompt_value";
    invalidClaims = "invalid_claims";
    tokenRequestEmpty = "token_request_empty";
    logoutRequestEmpty = "logout_request_empty";
    invalidCodeChallengeMethod = "invalid_code_challenge_method";
    pkceParamsMissing = "pkce_params_missing";
    invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
    invalidAuthorityMetadata = "invalid_authority_metadata";
    untrustedAuthority = "untrusted_authority";
    missingSshJwk = "missing_ssh_jwk";
    missingSshKid = "missing_ssh_kid";
    missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
    invalidAuthenticationHeader = "invalid_authentication_header";
    cannotSetOIDCOptions = "cannot_set_OIDCOptions";
    cannotAllowNativeBroker = "cannot_allow_native_broker";
    authorityMismatch = "authority_mismatch";
  }
});

// node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs
function createClientConfigurationError(errorCode) {
  return new ClientConfigurationError(errorCode);
}
var ClientConfigurationErrorMessages, ClientConfigurationErrorMessage, ClientConfigurationError;
var init_ClientConfigurationError = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs"() {
    "use strict";
    init_AuthError();
    init_ClientConfigurationErrorCodes();
    ClientConfigurationErrorMessages = {
      [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
      [claimsRequestParsingError]: "Could not parse the given claims request object.",
      [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
      [urlParseError]: "URL could not be parsed into appropriate segments.",
      [urlEmptyError]: "URL was empty or null.",
      [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
      [invalidPromptValue]: "Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest",
      [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
      [tokenRequestEmpty]: "Token request was empty and not found in cache.",
      [logoutRequestEmpty]: "The logout request was null or undefined.",
      [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
      [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
      [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
      [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
      [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
      [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
      [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
      [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
      [invalidAuthenticationHeader]: "Invalid authentication header provided",
      [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
      [cannotAllowNativeBroker]: "Cannot set allowNativeBroker parameter to true when not in AAD protocol mode.",
      [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority."
    };
    ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: redirectUriEmpty,
        desc: ClientConfigurationErrorMessages[redirectUriEmpty]
      },
      claimsRequestParsingError: {
        code: claimsRequestParsingError,
        desc: ClientConfigurationErrorMessages[claimsRequestParsingError]
      },
      authorityUriInsecure: {
        code: authorityUriInsecure,
        desc: ClientConfigurationErrorMessages[authorityUriInsecure]
      },
      urlParseError: {
        code: urlParseError,
        desc: ClientConfigurationErrorMessages[urlParseError]
      },
      urlEmptyError: {
        code: urlEmptyError,
        desc: ClientConfigurationErrorMessages[urlEmptyError]
      },
      emptyScopesError: {
        code: emptyInputScopesError,
        desc: ClientConfigurationErrorMessages[emptyInputScopesError]
      },
      invalidPrompt: {
        code: invalidPromptValue,
        desc: ClientConfigurationErrorMessages[invalidPromptValue]
      },
      invalidClaimsRequest: {
        code: invalidClaims,
        desc: ClientConfigurationErrorMessages[invalidClaims]
      },
      tokenRequestEmptyError: {
        code: tokenRequestEmpty,
        desc: ClientConfigurationErrorMessages[tokenRequestEmpty]
      },
      logoutRequestEmptyError: {
        code: logoutRequestEmpty,
        desc: ClientConfigurationErrorMessages[logoutRequestEmpty]
      },
      invalidCodeChallengeMethod: {
        code: invalidCodeChallengeMethod,
        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod]
      },
      invalidCodeChallengeParams: {
        code: pkceParamsMissing,
        desc: ClientConfigurationErrorMessages[pkceParamsMissing]
      },
      invalidCloudDiscoveryMetadata: {
        code: invalidCloudDiscoveryMetadata,
        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata]
      },
      invalidAuthorityMetadata: {
        code: invalidAuthorityMetadata,
        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata]
      },
      untrustedAuthority: {
        code: untrustedAuthority,
        desc: ClientConfigurationErrorMessages[untrustedAuthority]
      },
      missingSshJwk: {
        code: missingSshJwk,
        desc: ClientConfigurationErrorMessages[missingSshJwk]
      },
      missingSshKid: {
        code: missingSshKid,
        desc: ClientConfigurationErrorMessages[missingSshKid]
      },
      missingNonceAuthenticationHeader: {
        code: missingNonceAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader]
      },
      invalidAuthenticationHeader: {
        code: invalidAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader]
      },
      cannotSetOIDCOptions: {
        code: cannotSetOIDCOptions,
        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions]
      },
      cannotAllowNativeBroker: {
        code: cannotAllowNativeBroker,
        desc: ClientConfigurationErrorMessages[cannotAllowNativeBroker]
      },
      authorityMismatch: {
        code: authorityMismatch,
        desc: ClientConfigurationErrorMessages[authorityMismatch]
      }
    };
    ClientConfigurationError = class _ClientConfigurationError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ClientConfigurationErrorMessages[errorCode]);
        this.name = "ClientConfigurationError";
        Object.setPrototypeOf(this, _ClientConfigurationError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/StringUtils.mjs
var StringUtils;
var init_StringUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/StringUtils.mjs"() {
    "use strict";
    StringUtils = class {
      /**
       * Check if stringified object is empty
       * @param strObj
       */
      static isEmptyObj(strObj) {
        if (strObj) {
          try {
            const obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0;
          } catch (e) {
          }
        }
        return true;
      }
      static startsWith(str, search) {
        return str.indexOf(search) === 0;
      }
      static endsWith(str, search) {
        return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
      }
      /**
       * Parses string into an object.
       *
       * @param query
       */
      static queryStringToObject(query) {
        const obj = {};
        const params = query.split("&");
        const decode = (s) => decodeURIComponent(s.replace(/\+/g, " "));
        params.forEach((pair) => {
          if (pair.trim()) {
            const [key, value] = pair.split(/=(.+)/g, 2);
            if (key && value) {
              obj[decode(key)] = decode(value);
            }
          }
        });
        return obj;
      }
      /**
       * Trims entries in an array.
       *
       * @param arr
       */
      static trimArrayEntries(arr) {
        return arr.map((entry) => entry.trim());
      }
      /**
       * Removes empty strings from array
       * @param arr
       */
      static removeEmptyStringsFromArray(arr) {
        return arr.filter((entry) => {
          return !!entry;
        });
      }
      /**
       * Attempts to parse a string into JSON
       * @param str
       */
      static jsonParseHelper(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return null;
        }
      }
      /**
       * Tests if a given string matches a given pattern, with support for wildcards and queries.
       * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
       * @param input String to match against
       */
      static matchPattern(pattern, input) {
        const regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
        return regex.test(input);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/request/ScopeSet.mjs
var ScopeSet;
var init_ScopeSet = __esm({
  "node_modules/@azure/msal-common/dist/request/ScopeSet.mjs"() {
    "use strict";
    init_ClientConfigurationError();
    init_StringUtils();
    init_ClientAuthError();
    init_Constants();
    init_ClientConfigurationErrorCodes();
    init_ClientAuthErrorCodes();
    ScopeSet = class _ScopeSet {
      constructor(inputScopes) {
        const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];
        const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        this.validateInputScopes(filteredInput);
        this.scopes = /* @__PURE__ */ new Set();
        filteredInput.forEach((scope) => this.scopes.add(scope));
      }
      /**
       * Factory method to create ScopeSet from space-delimited string
       * @param inputScopeString
       * @param appClientId
       * @param scopesRequired
       */
      static fromString(inputScopeString) {
        const scopeString = inputScopeString || Constants.EMPTY_STRING;
        const inputScopes = scopeString.split(" ");
        return new _ScopeSet(inputScopes);
      }
      /**
       * Creates the set of scopes to search for in cache lookups
       * @param inputScopeString
       * @returns
       */
      static createSearchScopes(inputScopeString) {
        const scopeSet = new _ScopeSet(inputScopeString);
        if (!scopeSet.containsOnlyOIDCScopes()) {
          scopeSet.removeOIDCScopes();
        } else {
          scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
        }
        return scopeSet;
      }
      /**
       * Used to validate the scopes input parameter requested  by the developer.
       * @param {Array<string>} inputScopes - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.
       * @param {boolean} scopesRequired - Boolean indicating whether the scopes array is required or not
       */
      validateInputScopes(inputScopes) {
        if (!inputScopes || inputScopes.length < 1) {
          throw createClientConfigurationError(emptyInputScopesError);
        }
      }
      /**
       * Check if a given scope is present in this set of scopes.
       * @param scope
       */
      containsScope(scope) {
        const lowerCaseScopes = this.printScopesLowerCase().split(" ");
        const lowerCaseScopesSet = new _ScopeSet(lowerCaseScopes);
        return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
      }
      /**
       * Check if a set of scopes is present in this set of scopes.
       * @param scopeSet
       */
      containsScopeSet(scopeSet) {
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false;
        }
        return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every((scope) => this.containsScope(scope));
      }
      /**
       * Check if set of scopes contains only the defaults
       */
      containsOnlyOIDCScopes() {
        let defaultScopeCount = 0;
        OIDC_SCOPES.forEach((defaultScope) => {
          if (this.containsScope(defaultScope)) {
            defaultScopeCount += 1;
          }
        });
        return this.scopes.size === defaultScopeCount;
      }
      /**
       * Appends single scope if passed
       * @param newScope
       */
      appendScope(newScope) {
        if (newScope) {
          this.scopes.add(newScope.trim());
        }
      }
      /**
       * Appends multiple scopes if passed
       * @param newScopes
       */
      appendScopes(newScopes) {
        try {
          newScopes.forEach((newScope) => this.appendScope(newScope));
        } catch (e) {
          throw createClientAuthError(cannotAppendScopeSet);
        }
      }
      /**
       * Removes element from set of scopes.
       * @param scope
       */
      removeScope(scope) {
        if (!scope) {
          throw createClientAuthError(cannotRemoveEmptyScope);
        }
        this.scopes.delete(scope.trim());
      }
      /**
       * Removes default scopes from set of scopes
       * Primarily used to prevent cache misses if the default scopes are not returned from the server
       */
      removeOIDCScopes() {
        OIDC_SCOPES.forEach((defaultScope) => {
          this.scopes.delete(defaultScope);
        });
      }
      /**
       * Combines an array of scopes with the current set of scopes.
       * @param otherScopes
       */
      unionScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        const unionScopes = /* @__PURE__ */ new Set();
        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        return unionScopes;
      }
      /**
       * Check if scopes intersect between this set and another.
       * @param otherScopes
       */
      intersectingScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes();
        }
        const unionScopes = this.unionScopeSets(otherScopes);
        const sizeOtherScopes = otherScopes.getScopeCount();
        const sizeThisScopes = this.getScopeCount();
        const sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
      }
      /**
       * Returns size of set of scopes.
       */
      getScopeCount() {
        return this.scopes.size;
      }
      /**
       * Returns the scopes as an array of string values
       */
      asArray() {
        const array = [];
        this.scopes.forEach((val) => array.push(val));
        return array;
      }
      /**
       * Prints scopes into a space-delimited string
       */
      printScopes() {
        if (this.scopes) {
          const scopeArr = this.asArray();
          return scopeArr.join(" ");
        }
        return Constants.EMPTY_STRING;
      }
      /**
       * Prints scopes into a space-delimited lower-case string (used for caching)
       */
      printScopesLowerCase() {
        return this.printScopes().toLowerCase();
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/account/ClientInfo.mjs
function buildClientInfo(rawClientInfo, base64Decode) {
  if (!rawClientInfo) {
    throw createClientAuthError(clientInfoEmptyError);
  }
  try {
    const decodedClientInfo = base64Decode(rawClientInfo);
    return JSON.parse(decodedClientInfo);
  } catch (e) {
    throw createClientAuthError(clientInfoDecodingError);
  }
}
function buildClientInfoFromHomeAccountId(homeAccountId) {
  if (!homeAccountId) {
    throw createClientAuthError(clientInfoDecodingError);
  }
  const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: clientInfoParts[0],
    utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
  };
}
var init_ClientInfo = __esm({
  "node_modules/@azure/msal-common/dist/account/ClientInfo.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_Constants();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/account/AccountInfo.mjs
function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
  return !!tenantId && !!homeAccountId && tenantId === homeAccountId.split(".")[1];
}
function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
  if (idTokenClaims) {
    const { oid, sub, tid, name: name3, tfp, acr } = idTokenClaims;
    const tenantId2 = tid || tfp || acr || "";
    return {
      tenantId: tenantId2,
      localAccountId: oid || sub || "",
      name: name3,
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId2, homeAccountId)
    };
  } else {
    return {
      tenantId,
      localAccountId,
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId)
    };
  }
}
function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
  let updatedAccountInfo = baseAccountInfo;
  if (tenantProfile) {
    const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
    updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
  }
  if (idTokenClaims) {
    const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
    updatedAccountInfo = {
      ...updatedAccountInfo,
      ...claimsSourcedTenantProfile,
      idTokenClaims,
      idToken: idTokenSecret
    };
    return updatedAccountInfo;
  }
  return updatedAccountInfo;
}
var init_AccountInfo = __esm({
  "node_modules/@azure/msal-common/dist/account/AccountInfo.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs
var AuthorityType;
var init_AuthorityType = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs"() {
    "use strict";
    AuthorityType = {
      Default: 0,
      Adfs: 1,
      Dsts: 2,
      Ciam: 3
    };
  }
});

// node_modules/@azure/msal-common/dist/account/TokenClaims.mjs
function getTenantIdFromIdTokenClaims(idTokenClaims) {
  if (idTokenClaims) {
    const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
    return tenantId || null;
  }
  return null;
}
var init_TokenClaims = __esm({
  "node_modules/@azure/msal-common/dist/account/TokenClaims.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs
var ProtocolMode;
var init_ProtocolMode = __esm({
  "node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs"() {
    "use strict";
    ProtocolMode = {
      AAD: "AAD",
      OIDC: "OIDC"
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs
var AccountEntity;
var init_AccountEntity = __esm({
  "node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs"() {
    "use strict";
    init_Constants();
    init_ClientInfo();
    init_AccountInfo();
    init_ClientAuthError();
    init_AuthorityType();
    init_TokenClaims();
    init_ProtocolMode();
    init_ClientAuthErrorCodes();
    AccountEntity = class _AccountEntity {
      /**
       * Generate Account Id key component as per the schema: <home_account_id>-<environment>
       */
      generateAccountId() {
        const accountId = [this.homeAccountId, this.environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      }
      /**
       * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>
       */
      generateAccountKey() {
        return _AccountEntity.generateAccountCacheKey({
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId
        });
      }
      /**
       * Returns the AccountInfo interface for this account.
       */
      getAccountInfo() {
        return {
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId,
          name: this.name,
          nativeAccountId: this.nativeAccountId,
          authorityType: this.authorityType,
          // Deserialize tenant profiles array into a Map
          tenantProfiles: new Map((this.tenantProfiles || []).map((tenantProfile) => {
            return [tenantProfile.tenantId, tenantProfile];
          }))
        };
      }
      /**
       * Returns true if the account entity is in single tenant format (outdated), false otherwise
       */
      isSingleTenant() {
        return !this.tenantProfiles;
      }
      /**
       * Generates account key from interface
       * @param accountInterface
       */
      static generateAccountCacheKey(accountInterface) {
        const homeTenantId = accountInterface.homeAccountId.split(".")[1];
        const accountKey = [
          accountInterface.homeAccountId,
          accountInterface.environment || "",
          homeTenantId || accountInterface.tenantId || ""
        ];
        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      }
      /**
       * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
       * @param accountDetails
       */
      static createAccount(accountDetails, authority, base64Decode) {
        const account = new _AccountEntity();
        if (authority.authorityType === AuthorityType.Adfs) {
          account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
        } else if (authority.protocolMode === ProtocolMode.AAD) {
          account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
        } else {
          account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
        }
        let clientInfo;
        if (accountDetails.clientInfo && base64Decode) {
          clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);
        }
        account.clientInfo = accountDetails.clientInfo;
        account.homeAccountId = accountDetails.homeAccountId;
        account.nativeAccountId = accountDetails.nativeAccountId;
        const env = accountDetails.environment || authority && authority.getPreferredCache();
        if (!env) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        account.environment = env;
        account.realm = clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || "";
        account.localAccountId = clientInfo?.uid || accountDetails.idTokenClaims?.oid || accountDetails.idTokenClaims?.sub || "";
        const preferredUsername = accountDetails.idTokenClaims?.preferred_username || accountDetails.idTokenClaims?.upn;
        const email = accountDetails.idTokenClaims?.emails ? accountDetails.idTokenClaims.emails[0] : null;
        account.username = preferredUsername || email || "";
        account.name = accountDetails.idTokenClaims?.name || "";
        account.cloudGraphHostName = accountDetails.cloudGraphHostName;
        account.msGraphHost = accountDetails.msGraphHost;
        if (accountDetails.tenantProfiles) {
          account.tenantProfiles = accountDetails.tenantProfiles;
        } else {
          const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
          account.tenantProfiles = [tenantProfile];
        }
        return account;
      }
      /**
       * Creates an AccountEntity object from AccountInfo
       * @param accountInfo
       * @param cloudGraphHostName
       * @param msGraphHost
       * @returns
       */
      static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
        const account = new _AccountEntity();
        account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = accountInfo.homeAccountId;
        account.localAccountId = accountInfo.localAccountId;
        account.nativeAccountId = accountInfo.nativeAccountId;
        account.realm = accountInfo.tenantId;
        account.environment = accountInfo.environment;
        account.username = accountInfo.username;
        account.name = accountInfo.name;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);
        return account;
      }
      /**
       * Generate HomeAccountId from server response
       * @param serverClientInfo
       * @param authType
       */
      static generateHomeAccountId(serverClientInfo, authType, logger26, cryptoObj, idTokenClaims) {
        if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {
          if (serverClientInfo) {
            try {
              const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
              if (clientInfo.uid && clientInfo.utid) {
                return `${clientInfo.uid}.${clientInfo.utid}`;
              }
            } catch (e) {
            }
          }
          logger26.warning("No client info in response");
        }
        return idTokenClaims?.sub || "";
      }
      /**
       * Validates an entity: checks for all expected params
       * @param entity
       */
      static isAccountEntity(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
      }
      /**
       * Helper function to determine whether 2 accountInfo objects represent the same account
       * @param accountA
       * @param accountB
       * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
       */
      static accountInfoIsEqual(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false;
        }
        let claimsMatch = true;
        if (compareClaims) {
          const accountAClaims = accountA.idTokenClaims || {};
          const accountBClaims = accountB.idTokenClaims || {};
          claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
        }
        return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs
var UrlUtils_exports = {};
__export(UrlUtils_exports, {
  getDeserializedResponse: () => getDeserializedResponse,
  stripLeadingHashOrQuery: () => stripLeadingHashOrQuery
});
function stripLeadingHashOrQuery(responseString) {
  if (responseString.startsWith("#/")) {
    return responseString.substring(2);
  } else if (responseString.startsWith("#") || responseString.startsWith("?")) {
    return responseString.substring(1);
  }
  return responseString;
}
function getDeserializedResponse(responseString) {
  if (!responseString || responseString.indexOf("=") < 0) {
    return null;
  }
  try {
    const normalizedResponse = stripLeadingHashOrQuery(responseString);
    const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
    if (deserializedHash.code || deserializedHash.error || deserializedHash.error_description || deserializedHash.state) {
      return deserializedHash;
    }
  } catch (e) {
    throw createClientAuthError(hashNotDeserialized);
  }
  return null;
}
var init_UrlUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/url/UrlString.mjs
var UrlString;
var init_UrlString = __esm({
  "node_modules/@azure/msal-common/dist/url/UrlString.mjs"() {
    "use strict";
    init_ClientConfigurationError();
    init_StringUtils();
    init_Constants();
    init_UrlUtils();
    init_ClientConfigurationErrorCodes();
    UrlString = class _UrlString {
      get urlString() {
        return this._urlString;
      }
      constructor(url) {
        this._urlString = url;
        if (!this._urlString) {
          throw createClientConfigurationError(urlEmptyError);
        }
        if (!url.includes("#")) {
          this._urlString = _UrlString.canonicalizeUri(url);
        }
      }
      /**
       * Ensure urls are lower case and end with a / character.
       * @param url
       */
      static canonicalizeUri(url) {
        if (url) {
          let lowerCaseUrl = url.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, "?")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1);
          } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2);
          }
          if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
            lowerCaseUrl += "/";
          }
          return lowerCaseUrl;
        }
        return url;
      }
      /**
       * Throws if urlString passed is not a valid authority URI string.
       */
      validateAsUri() {
        let components;
        try {
          components = this.getUrlComponents();
        } catch (e) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
          throw createClientConfigurationError(authorityUriInsecure);
        }
      }
      /**
       * Given a url and a query string return the url with provided query string appended
       * @param url
       * @param queryString
       */
      static appendQueryString(url, queryString) {
        if (!queryString) {
          return url;
        }
        return url.indexOf("?") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;
      }
      /**
       * Returns a url with the hash removed
       * @param url
       */
      static removeHashFromUrl(url) {
        return _UrlString.canonicalizeUri(url.split("#")[0]);
      }
      /**
       * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
       * @param href The url
       * @param tenantId The tenant id to replace
       */
      replaceTenantPath(tenantId) {
        const urlObject = this.getUrlComponents();
        const pathArray = urlObject.PathSegments;
        if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
          pathArray[0] = tenantId;
        }
        return _UrlString.constructAuthorityUriFromObject(urlObject);
      }
      /**
       * Parses out the components from a url string.
       * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
       */
      getUrlComponents() {
        const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        const match = this.urlString.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        const urlComponents = {
          Protocol: match[1],
          HostNameAndPort: match[4],
          AbsolutePath: match[5],
          QueryString: match[7]
        };
        let pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter((val) => val && val.length > 0);
        urlComponents.PathSegments = pathSegments;
        if (urlComponents.QueryString && urlComponents.QueryString.endsWith("/")) {
          urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
        }
        return urlComponents;
      }
      static getDomainFromUrl(url) {
        const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        const match = url.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        return match[2];
      }
      static getAbsoluteUrl(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
          const url = new _UrlString(baseUrl);
          const baseComponents = url.getUrlComponents();
          return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
      }
      static constructAuthorityUriFromObject(urlObject) {
        return new _UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
      }
      /**
       * Check if the hash of the URL string contains known properties
       * @deprecated This API will be removed in a future version
       */
      static hashContainsKnownProperties(response) {
        return !!getDeserializedResponse(response);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs
function getAliasesFromStaticSources(staticAuthorityOptions, logger26) {
  let staticAliases;
  const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
  if (canonicalAuthority) {
    const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
    staticAliases = getAliasesFromMetadata(authorityHost, staticAuthorityOptions.cloudDiscoveryMetadata?.metadata, AuthorityMetadataSource.CONFIG, logger26) || getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger26) || staticAuthorityOptions.knownAuthorities;
  }
  return staticAliases || [];
}
function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger26) {
  logger26?.trace(`getAliasesFromMetadata called with source: ${source}`);
  if (authorityHost && cloudDiscoveryMetadata) {
    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
    if (metadata) {
      logger26?.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);
      return metadata.aliases;
    } else {
      logger26?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);
    }
  }
  return null;
}
function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
  const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
  return metadata;
}
function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
  for (let i = 0; i < response.length; i++) {
    const metadata = response[i];
    if (metadata.aliases.includes(authorityHost)) {
      return metadata;
    }
  }
  return null;
}
var rawMetdataJSON, EndpointMetadata, InstanceDiscoveryMetadata, InstanceDiscoveryMetadataAliases;
var init_AuthorityMetadata = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs"() {
    "use strict";
    init_UrlString();
    init_Constants();
    rawMetdataJSON = {
      endpointMetadata: {
        "login.microsoftonline.com": {
          token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout"
        },
        "login.chinacloudapi.cn": {
          token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
          authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout"
        },
        "login.microsoftonline.us": {
          token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout"
        }
      },
      instanceDiscoveryMetadata: {
        tenant_discovery_endpoint: "https://{canonicalAuthority}/v2.0/.well-known/openid-configuration",
        metadata: [
          {
            preferred_network: "login.microsoftonline.com",
            preferred_cache: "login.windows.net",
            aliases: [
              "login.microsoftonline.com",
              "login.windows.net",
              "login.microsoft.com",
              "sts.windows.net"
            ]
          },
          {
            preferred_network: "login.partner.microsoftonline.cn",
            preferred_cache: "login.partner.microsoftonline.cn",
            aliases: [
              "login.partner.microsoftonline.cn",
              "login.chinacloudapi.cn"
            ]
          },
          {
            preferred_network: "login.microsoftonline.de",
            preferred_cache: "login.microsoftonline.de",
            aliases: ["login.microsoftonline.de"]
          },
          {
            preferred_network: "login.microsoftonline.us",
            preferred_cache: "login.microsoftonline.us",
            aliases: [
              "login.microsoftonline.us",
              "login.usgovcloudapi.net"
            ]
          },
          {
            preferred_network: "login-us.microsoftonline.com",
            preferred_cache: "login-us.microsoftonline.com",
            aliases: ["login-us.microsoftonline.com"]
          }
        ]
      }
    };
    EndpointMetadata = rawMetdataJSON.endpointMetadata;
    InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
    InstanceDiscoveryMetadataAliases = /* @__PURE__ */ new Set();
    InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
      metadataEntry.aliases.forEach((alias) => {
        InstanceDiscoveryMetadataAliases.add(alias);
      });
    });
  }
});

// node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs
var cacheQuotaExceededErrorCode, cacheUnknownErrorCode;
var init_CacheErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs"() {
    "use strict";
    cacheQuotaExceededErrorCode = "cache_quota_exceeded";
    cacheUnknownErrorCode = "cache_error_unknown";
  }
});

// node_modules/@azure/msal-common/dist/error/CacheError.mjs
var CacheErrorMessages, CacheError;
var init_CacheError = __esm({
  "node_modules/@azure/msal-common/dist/error/CacheError.mjs"() {
    "use strict";
    init_CacheErrorCodes();
    CacheErrorMessages = {
      [cacheQuotaExceededErrorCode]: "Exceeded cache storage capacity.",
      [cacheUnknownErrorCode]: "Unexpected error occurred when using cache storage."
    };
    CacheError = class _CacheError extends Error {
      constructor(errorCode, errorMessage) {
        const message = errorMessage || (CacheErrorMessages[errorCode] ? CacheErrorMessages[errorCode] : CacheErrorMessages[cacheUnknownErrorCode]);
        super(`${errorCode}: ${message}`);
        Object.setPrototypeOf(this, _CacheError.prototype);
        this.name = "CacheError";
        this.errorCode = errorCode;
        this.errorMessage = message;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/CacheManager.mjs
var CacheManager, DefaultStorageClass;
var init_CacheManager = __esm({
  "node_modules/@azure/msal-common/dist/cache/CacheManager.mjs"() {
    "use strict";
    init_Constants();
    init_CacheHelpers();
    init_ScopeSet();
    init_AccountEntity();
    init_ClientAuthError();
    init_AccountInfo();
    init_AuthToken();
    init_packageMetadata();
    init_AuthorityMetadata();
    init_CacheError();
    init_ClientAuthErrorCodes();
    init_CacheErrorCodes();
    CacheManager = class _CacheManager {
      constructor(clientId, cryptoImpl, logger26, staticAuthorityOptions) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
        this.commonLogger = logger26.clone(name, version);
        this.staticAuthorityOptions = staticAuthorityOptions;
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter) {
        return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter || {}), accountFilter);
      }
      /**
       * Gets first tenanted AccountInfo object found based on provided filters
       */
      getAccountInfoFilteredBy(accountFilter) {
        const allAccounts = this.getAllAccounts(accountFilter);
        if (allAccounts.length > 1) {
          const sortedAccounts = allAccounts.sort((account) => {
            return account.idTokenClaims ? -1 : 1;
          });
          return sortedAccounts[0];
        } else if (allAccounts.length === 1) {
          return allAccounts[0];
        } else {
          return null;
        }
      }
      /**
       * Returns a single matching
       * @param accountFilter
       * @returns
       */
      getBaseAccountInfo(accountFilter) {
        const accountEntities = this.getAccountsFilteredBy(accountFilter);
        if (accountEntities.length > 0) {
          return accountEntities[0].getAccountInfo();
        } else {
          return null;
        }
      }
      /**
       * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
       * and builds the account info objects from the matching ID token's claims
       * @param cachedAccounts
       * @param accountFilter
       * @returns Array of AccountInfo objects that match account and tenant profile filters
       */
      buildTenantProfiles(cachedAccounts, accountFilter) {
        return cachedAccounts.flatMap((accountEntity) => {
          return this.getTenantProfilesFromAccountEntity(accountEntity, accountFilter?.tenantId, accountFilter);
        });
      }
      getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter) {
        let tenantedAccountInfo = null;
        let idTokenClaims;
        if (tenantProfileFilter) {
          if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
            return null;
          }
        }
        const idToken = this.getIdToken(accountInfo, tokenKeys, tenantProfile.tenantId);
        if (idToken) {
          idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
          if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
            return null;
          }
        }
        tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);
        return tenantedAccountInfo;
      }
      getTenantProfilesFromAccountEntity(accountEntity, targetTenantId, tenantProfileFilter) {
        const accountInfo = accountEntity.getAccountInfo();
        let searchTenantProfiles = accountInfo.tenantProfiles || /* @__PURE__ */ new Map();
        const tokenKeys = this.getTokenKeys();
        if (targetTenantId) {
          const tenantProfile = searchTenantProfiles.get(targetTenantId);
          if (tenantProfile) {
            searchTenantProfiles = /* @__PURE__ */ new Map([
              [targetTenantId, tenantProfile]
            ]);
          } else {
            return [];
          }
        }
        const matchingTenantProfiles = [];
        searchTenantProfiles.forEach((tenantProfile) => {
          const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter);
          if (tenantedAccountInfo) {
            matchingTenantProfiles.push(tenantedAccountInfo);
          }
        });
        return matchingTenantProfiles;
      }
      tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
        if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
          return false;
        }
        if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {
          return false;
        }
        if (tenantProfileFilter.isHomeTenant !== void 0 && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
          return false;
        }
        return true;
      }
      idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
        if (tenantProfileFilter) {
          if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
            return false;
          }
          if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
            return false;
          }
          if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
            return false;
          }
          if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
            return false;
          }
          if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
            return false;
          }
        }
        return true;
      }
      /**
       * saves a cache record
       * @param cacheRecord {CacheRecord}
       * @param storeInCache {?StoreInCache}
       * @param correlationId {?string} correlation id
       */
      async saveCacheRecord(cacheRecord, storeInCache, correlationId) {
        if (!cacheRecord) {
          throw createClientAuthError(invalidCacheRecord);
        }
        try {
          if (!!cacheRecord.account) {
            this.setAccount(cacheRecord.account);
          }
          if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {
            this.setIdTokenCredential(cacheRecord.idToken);
          }
          if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {
            await this.saveAccessToken(cacheRecord.accessToken);
          }
          if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {
            this.setRefreshTokenCredential(cacheRecord.refreshToken);
          }
          if (!!cacheRecord.appMetadata) {
            this.setAppMetadata(cacheRecord.appMetadata);
          }
        } catch (e) {
          this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);
          if (e instanceof Error) {
            this.commonLogger?.errorPii(`CacheManager.saveCacheRecord: ${e.message}`, correlationId);
            if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED" || e.message.includes("exceeded the quota")) {
              this.commonLogger?.error(`CacheManager.saveCacheRecord: exceeded storage quota`, correlationId);
              throw new CacheError(cacheQuotaExceededErrorCode);
            } else {
              throw new CacheError(e.name, e.message);
            }
          } else {
            this.commonLogger?.errorPii(`CacheManager.saveCacheRecord: ${e}`, correlationId);
            throw new CacheError(cacheUnknownErrorCode);
          }
        }
      }
      /**
       * saves access token credential
       * @param credential
       */
      async saveAccessToken(credential) {
        const accessTokenFilter = {
          clientId: credential.clientId,
          credentialType: credential.credentialType,
          environment: credential.environment,
          homeAccountId: credential.homeAccountId,
          realm: credential.realm,
          tokenType: credential.tokenType,
          requestedClaimsHash: credential.requestedClaimsHash
        };
        const tokenKeys = this.getTokenKeys();
        const currentScopes = ScopeSet.fromString(credential.target);
        const removedAccessTokens = [];
        tokenKeys.accessToken.forEach((key) => {
          if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
            return;
          }
          const tokenEntity = this.getAccessTokenCredential(key);
          if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
            const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
            if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
              removedAccessTokens.push(this.removeAccessToken(key));
            }
          }
        });
        await Promise.all(removedAccessTokens);
        this.setAccessTokenCredential(credential);
      }
      /**
       * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
       * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
       * @param accountFilter - An object containing Account properties to filter by
       */
      getAccountsFilteredBy(accountFilter) {
        const allAccountKeys = this.getAccountKeys();
        const matchingAccounts = [];
        allAccountKeys.forEach((cacheKey) => {
          if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId)) {
            return;
          }
          const entity = this.getAccount(cacheKey, this.commonLogger);
          if (!entity) {
            return;
          }
          if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
            return;
          }
          if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {
            return;
          }
          if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {
            return;
          }
          if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {
            return;
          }
          if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
            return;
          }
          if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {
            return;
          }
          const tenantProfileFilter = {
            localAccountId: accountFilter?.localAccountId,
            name: accountFilter?.name
          };
          const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {
            return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
          });
          if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
            return;
          }
          matchingAccounts.push(entity);
        });
        return matchingAccounts;
      }
      /**
       * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided
       * @param key
       * @param homeAccountId
       * @param tenantId
       * @returns
       */
      isAccountKey(key, homeAccountId, tenantId) {
        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {
          return false;
        }
        if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {
          return false;
        }
        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {
          return false;
        }
        return true;
      }
      /**
       * Returns true if the given key matches our credential key schema.
       * @param key
       */
      isCredentialKey(key) {
        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {
          return false;
        }
        const lowerCaseKey = key.toLowerCase();
        if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {
          return false;
        }
        if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {
          const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;
          const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;
          if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {
            return false;
          }
        } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Returns whether or not the given credential entity matches the filter
       * @param entity
       * @param filter
       * @returns
       */
      credentialMatchesFilter(entity, filter) {
        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
          return false;
        }
        if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
          return false;
        }
        if (typeof filter.homeAccountId === "string" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {
          return false;
        }
        if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
          return false;
        }
        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
          return false;
        }
        if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {
          return false;
        }
        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
          return false;
        }
        if (!!filter.target && !this.matchTarget(entity, filter.target)) {
          return false;
        }
        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
          if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
            return false;
          }
        }
        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
          if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {
            return false;
          }
          if (filter.tokenType === AuthenticationScheme.SSH) {
            if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
       * @param filter
       */
      getAppMetadataFilteredBy(filter) {
        const allCacheKeys = this.getKeys();
        const matchingAppMetadata = {};
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAppMetadata(cacheKey)) {
            return;
          }
          const entity = this.getAppMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
            return;
          }
          if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
            return;
          }
          matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
      }
      /**
       * retrieve authorityMetadata that contains a matching alias
       * @param filter
       */
      getAuthorityMetadataByAlias(host) {
        const allCacheKeys = this.getAuthorityMetadataKeys();
        let matchedEntity = null;
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {
            return;
          }
          const entity = this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (entity.aliases.indexOf(host) === -1) {
            return;
          }
          matchedEntity = entity;
        });
        return matchedEntity;
      }
      /**
       * Removes all accounts and related tokens from cache.
       */
      async removeAllAccounts() {
        const allAccountKeys = this.getAccountKeys();
        const removedAccounts = [];
        allAccountKeys.forEach((cacheKey) => {
          removedAccounts.push(this.removeAccount(cacheKey));
        });
        await Promise.all(removedAccounts);
      }
      /**
       * Removes the account and related tokens for a given account key
       * @param account
       */
      async removeAccount(accountKey) {
        const account = this.getAccount(accountKey, this.commonLogger);
        if (!account) {
          return;
        }
        await this.removeAccountContext(account);
        this.removeItem(accountKey);
      }
      /**
       * Removes credentials associated with the provided account
       * @param account
       */
      async removeAccountContext(account) {
        const allTokenKeys = this.getTokenKeys();
        const accountId = account.generateAccountId();
        const removedCredentials = [];
        allTokenKeys.idToken.forEach((key) => {
          if (key.indexOf(accountId) === 0) {
            this.removeIdToken(key);
          }
        });
        allTokenKeys.accessToken.forEach((key) => {
          if (key.indexOf(accountId) === 0) {
            removedCredentials.push(this.removeAccessToken(key));
          }
        });
        allTokenKeys.refreshToken.forEach((key) => {
          if (key.indexOf(accountId) === 0) {
            this.removeRefreshToken(key);
          }
        });
        await Promise.all(removedCredentials);
      }
      /**
       * Migrates a single-tenant account and all it's associated alternate cross-tenant account objects in the
       * cache into a condensed multi-tenant account object with tenant profiles.
       * @param accountKey
       * @param accountEntity
       * @param logger
       * @returns
       */
      updateOutdatedCachedAccount(accountKey, accountEntity, logger26) {
        if (accountEntity && accountEntity.isSingleTenant()) {
          this.commonLogger?.verbose("updateOutdatedCachedAccount: Found a single-tenant (outdated) account entity in the cache, migrating to multi-tenant account entity");
          const matchingAccountKeys = this.getAccountKeys().filter((key) => {
            return key.startsWith(accountEntity.homeAccountId);
          });
          const accountsToMerge = [];
          matchingAccountKeys.forEach((key) => {
            const account = this.getCachedAccountEntity(key);
            if (account) {
              accountsToMerge.push(account);
            }
          });
          const baseAccount = accountsToMerge.find((account) => {
            return tenantIdMatchesHomeTenant(account.realm, account.homeAccountId);
          }) || accountsToMerge[0];
          baseAccount.tenantProfiles = accountsToMerge.map((account) => {
            return {
              tenantId: account.realm,
              localAccountId: account.localAccountId,
              name: account.name,
              isHomeTenant: tenantIdMatchesHomeTenant(account.realm, account.homeAccountId)
            };
          });
          const updatedAccount = _CacheManager.toObject(new AccountEntity(), {
            ...baseAccount
          });
          const newAccountKey = updatedAccount.generateAccountKey();
          matchingAccountKeys.forEach((key) => {
            if (key !== newAccountKey) {
              this.removeOutdatedAccount(accountKey);
            }
          });
          this.setAccount(updatedAccount);
          logger26?.verbose("Updated an outdated account entity in the cache");
          return updatedAccount;
        }
        return accountEntity;
      }
      /**
       * returns a boolean if the given credential is removed
       * @param credential
       */
      async removeAccessToken(key) {
        const credential = this.getAccessTokenCredential(key);
        if (!credential) {
          return;
        }
        if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {
          if (credential.tokenType === AuthenticationScheme.POP) {
            const accessTokenWithAuthSchemeEntity = credential;
            const kid = accessTokenWithAuthSchemeEntity.keyId;
            if (kid) {
              try {
                await this.cryptoImpl.removeTokenBindingKey(kid);
              } catch (error) {
                throw createClientAuthError(bindingKeyNotRemoved);
              }
            }
          }
        }
        return this.removeItem(key);
      }
      /**
       * Removes all app metadata objects from cache.
       */
      removeAppMetadata() {
        const allCacheKeys = this.getKeys();
        allCacheKeys.forEach((cacheKey) => {
          if (this.isAppMetadata(cacheKey)) {
            this.removeItem(cacheKey);
          }
        });
        return true;
      }
      /**
       * Retrieve AccountEntity from cache
       * @param account
       */
      readAccountFromCache(account) {
        const accountKey = AccountEntity.generateAccountCacheKey(account);
        return this.getAccount(accountKey, this.commonLogger);
      }
      /**
       * Retrieve IdTokenEntity from cache
       * @param account {AccountInfo}
       * @param tokenKeys {?TokenKeys}
       * @param targetRealm {?string}
       * @param performanceClient {?IPerformanceClient}
       * @param correlationId {?string}
       */
      getIdToken(account, tokenKeys, targetRealm, performanceClient, correlationId) {
        this.commonLogger.trace("CacheManager - getIdToken called");
        const idTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.clientId,
          realm: targetRealm
        };
        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, tokenKeys);
        const numIdTokens = idTokenMap.size;
        if (numIdTokens < 1) {
          this.commonLogger.info("CacheManager:getIdToken - No token found");
          return null;
        } else if (numIdTokens > 1) {
          let tokensToBeRemoved = idTokenMap;
          if (!targetRealm) {
            const homeIdTokenMap = /* @__PURE__ */ new Map();
            idTokenMap.forEach((idToken, key) => {
              if (idToken.realm === account.tenantId) {
                homeIdTokenMap.set(key, idToken);
              }
            });
            const numHomeIdTokens = homeIdTokenMap.size;
            if (numHomeIdTokens < 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
              return idTokenMap.values().next().value;
            } else if (numHomeIdTokens === 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
              return homeIdTokenMap.values().next().value;
            } else {
              tokensToBeRemoved = homeIdTokenMap;
            }
          }
          this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
          tokensToBeRemoved.forEach((idToken, key) => {
            this.removeIdToken(key);
          });
          if (performanceClient && correlationId) {
            performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
          }
          return null;
        }
        this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
        return idTokenMap.values().next().value;
      }
      /**
       * Gets all idTokens matching the given filter
       * @param filter
       * @returns
       */
      getIdTokensByFilter(filter, tokenKeys) {
        const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
        const idTokens = /* @__PURE__ */ new Map();
        idTokenKeys.forEach((key) => {
          if (!this.idTokenKeyMatchesFilter(key, {
            clientId: this.clientId,
            ...filter
          })) {
            return;
          }
          const idToken = this.getIdTokenCredential(key);
          if (idToken && this.credentialMatchesFilter(idToken, filter)) {
            idTokens.set(key, idToken);
          }
        });
        return idTokens;
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @returns
       */
      idTokenKeyMatchesFilter(inputKey, filter) {
        const key = inputKey.toLowerCase();
        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Removes idToken from the cache
       * @param key
       */
      removeIdToken(key) {
        this.removeItem(key);
      }
      /**
       * Removes refresh token from the cache
       * @param key
       */
      removeRefreshToken(key) {
        this.removeItem(key);
      }
      /**
       * Retrieve AccessTokenEntity from cache
       * @param account {AccountInfo}
       * @param request {BaseAuthRequest}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       * @param correlationId {?string}
       */
      getAccessToken(account, request3, tokenKeys, targetRealm, performanceClient, correlationId) {
        this.commonLogger.trace("CacheManager - getAccessToken called");
        const scopes = ScopeSet.createSearchScopes(request3.scopes);
        const authScheme = request3.authenticationScheme || AuthenticationScheme.BEARER;
        const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        const accessTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType,
          clientId: this.clientId,
          realm: targetRealm || account.tenantId,
          target: scopes,
          tokenType: authScheme,
          keyId: request3.sshKid,
          requestedClaimsHash: request3.requestedClaimsHash
        };
        const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
        const accessTokens = [];
        accessTokenKeys.forEach((key) => {
          if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
            const accessToken = this.getAccessTokenCredential(key);
            if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
              accessTokens.push(accessToken);
            }
          }
        });
        const numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          this.commonLogger.info("CacheManager:getAccessToken - No token found");
          return null;
        } else if (numAccessTokens > 1) {
          this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them");
          accessTokens.forEach((accessToken) => {
            void this.removeAccessToken(generateCredentialKey(accessToken));
          });
          if (performanceClient && correlationId) {
            performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
          }
          return null;
        }
        this.commonLogger.info("CacheManager:getAccessToken - Returning access token");
        return accessTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @param keyMustContainAllScopes
       * @returns
       */
      accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {
        const key = inputKey.toLowerCase();
        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {
          return false;
        }
        if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
          return false;
        }
        if (filter.target) {
          const scopes = filter.target.asArray();
          for (let i = 0; i < scopes.length; i++) {
            if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {
              return false;
            } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {
              return true;
            }
          }
        }
        return true;
      }
      /**
       * Gets all access tokens matching the filter
       * @param filter
       * @returns
       */
      getAccessTokensByFilter(filter) {
        const tokenKeys = this.getTokenKeys();
        const accessTokens = [];
        tokenKeys.accessToken.forEach((key) => {
          if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {
            return;
          }
          const accessToken = this.getAccessTokenCredential(key);
          if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {
            accessTokens.push(accessToken);
          }
        });
        return accessTokens;
      }
      /**
       * Helper to retrieve the appropriate refresh token from cache
       * @param account {AccountInfo}
       * @param familyRT {boolean}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       * @param correlationId {?string}
       */
      getRefreshToken(account, familyRT, tokenKeys, performanceClient, correlationId) {
        this.commonLogger.trace("CacheManager - getRefreshToken called");
        const id = familyRT ? THE_FAMILY_ID : void 0;
        const refreshTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.REFRESH_TOKEN,
          clientId: this.clientId,
          familyId: id
        };
        const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
        const refreshTokens = [];
        refreshTokenKeys.forEach((key) => {
          if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
            const refreshToken = this.getRefreshTokenCredential(key);
            if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
              refreshTokens.push(refreshToken);
            }
          }
        });
        const numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
          return null;
        }
        if (numRefreshTokens > 1 && performanceClient && correlationId) {
          performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
        }
        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
        return refreshTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       */
      refreshTokenKeyMatchesFilter(inputKey, filter) {
        const key = inputKey.toLowerCase();
        if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {
          return false;
        }
        if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Retrieve AppMetadataEntity from cache
       */
      readAppMetadataFromCache(environment) {
        const appMetadataFilter = {
          environment,
          clientId: this.clientId
        };
        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);
        const numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null;
        } else if (numAppMetadata > 1) {
          throw createClientAuthError(multipleMatchingAppMetadata);
        }
        return appMetadataEntries[0];
      }
      /**
       * Return the family_id value associated  with FOCI
       * @param environment
       * @param clientId
       */
      isAppMetadataFOCI(environment) {
        const appMetadata = this.readAppMetadataFromCache(environment);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
      }
      /**
       * helper to match account ids
       * @param value
       * @param homeAccountId
       */
      matchHomeAccountId(entity, homeAccountId) {
        return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
      }
      /**
       * helper to match account ids
       * @param entity
       * @param localAccountId
       * @returns
       */
      matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
        return localAccountId === idTokenLocalAccountId;
      }
      matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
        return tenantProfile.localAccountId === localAccountId;
      }
      /**
       * helper to match names
       * @param entity
       * @param name
       * @returns true if the downcased name properties are present and match in the filter and the entity
       */
      matchName(claims, name3) {
        return !!(name3.toLowerCase() === claims.name?.toLowerCase());
      }
      /**
       * helper to match usernames
       * @param entity
       * @param username
       * @returns
       */
      matchUsername(cachedUsername, filterUsername) {
        return !!(cachedUsername && typeof cachedUsername === "string" && filterUsername?.toLowerCase() === cachedUsername.toLowerCase());
      }
      /**
       * helper to match assertion
       * @param value
       * @param oboAssertion
       */
      matchUserAssertionHash(entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
      }
      /**
       * helper to match environment
       * @param value
       * @param environment
       */
      matchEnvironment(entity, environment) {
        if (this.staticAuthorityOptions) {
          const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
          if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {
            return true;
          }
        }
        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true;
        }
        return false;
      }
      /**
       * helper to match credential type
       * @param entity
       * @param credentialType
       */
      matchCredentialType(entity, credentialType) {
        return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
      }
      /**
       * helper to match client ids
       * @param entity
       * @param clientId
       */
      matchClientId(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
      }
      /**
       * helper to match family ids
       * @param entity
       * @param familyId
       */
      matchFamilyId(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
      }
      /**
       * helper to match realm
       * @param entity
       * @param realm
       */
      matchRealm(entity, realm) {
        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());
      }
      /**
       * helper to match nativeAccountId
       * @param entity
       * @param nativeAccountId
       * @returns boolean indicating the match result
       */
      matchNativeAccountId(entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
      }
      /**
       * helper to match loginHint which can be either:
       * 1. login_hint ID token claim
       * 2. username in cached account object
       * 3. upn in ID token claims
       * @param entity
       * @param loginHint
       * @returns
       */
      matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
        if (tokenClaims.login_hint === loginHint) {
          return true;
        }
        if (tokenClaims.preferred_username === loginHint) {
          return true;
        }
        if (tokenClaims.upn === loginHint) {
          return true;
        }
        return false;
      }
      /**
       * Helper to match sid
       * @param entity
       * @param sid
       * @returns true if the sid claim is present and matches the filter
       */
      matchSid(idTokenClaims, sid) {
        return idTokenClaims.sid === sid;
      }
      matchAuthorityType(entity, authorityType) {
        return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());
      }
      /**
       * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
       * @param entity
       * @param target
       */
      matchTarget(entity, target) {
        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        if (isNotAccessTokenCredential || !entity.target) {
          return false;
        }
        const entityScopeSet = ScopeSet.fromString(entity.target);
        return entityScopeSet.containsScopeSet(target);
      }
      /**
       * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
       * @param entity
       * @param tokenType
       */
      matchTokenType(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
      }
      /**
       * Returns true if the credential's keyId matches the one in the request, false otherwise
       * @param entity
       * @param keyId
       */
      matchKeyId(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
      }
      /**
       * returns if a given cache entity is of the type appmetadata
       * @param key
       */
      isAppMetadata(key) {
        return key.indexOf(APP_METADATA) !== -1;
      }
      /**
       * returns if a given cache entity is of the type authoritymetadata
       * @param key
       */
      isAuthorityMetadata(key) {
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
      }
      /**
       * returns cache key used for cloud instance metadata
       */
      generateAuthorityMetadataCacheKey(authority) {
        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
      }
      /**
       * Helper to convert serialized data to object
       * @param obj
       * @param json
       */
      static toObject(obj, json) {
        for (const propertyName in json) {
          obj[propertyName] = json[propertyName];
        }
        return obj;
      }
    };
    DefaultStorageClass = class extends CacheManager {
      setAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      getCachedAccountEntity() {
        throw createClientAuthError(methodNotImplemented);
      }
      setIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      setRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      setServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      getServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadataKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      setThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      getThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      removeItem() {
        throw createClientAuthError(methodNotImplemented);
      }
      getKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccountKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getTokenKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      async clear() {
        throw createClientAuthError(methodNotImplemented);
      }
      updateCredentialCacheKey() {
        throw createClientAuthError(methodNotImplemented);
      }
      removeOutdatedAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs
function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials, libraryInfo, telemetry, serverTelemetryManager, persistencePlugin, serializableCache }) {
  const loggerOptions = {
    ...DEFAULT_LOGGER_IMPLEMENTATION,
    ...userLoggerOption
  };
  return {
    authOptions: buildAuthOptions(userAuthOptions),
    systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },
    loggerOptions,
    cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },
    storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions)),
    networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
    serverTelemetryManager: serverTelemetryManager || null,
    persistencePlugin: persistencePlugin || null,
    serializableCache: serializableCache || null
  };
}
function buildAuthOptions(authOptions) {
  return {
    clientCapabilities: [],
    azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
    skipAuthorityMetadataCache: false,
    instanceAware: false,
    ...authOptions
  };
}
function isOidcProtocolMode(config) {
  return config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC;
}
var DEFAULT_SYSTEM_OPTIONS, DEFAULT_LOGGER_IMPLEMENTATION, DEFAULT_CACHE_OPTIONS, DEFAULT_NETWORK_IMPLEMENTATION, DEFAULT_LIBRARY_INFO, DEFAULT_CLIENT_CREDENTIALS, DEFAULT_AZURE_CLOUD_OPTIONS, DEFAULT_TELEMETRY_OPTIONS;
var init_ClientConfiguration = __esm({
  "node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs"() {
    "use strict";
    init_ICrypto();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_AuthorityOptions();
    init_CacheManager();
    init_ProtocolMode();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    DEFAULT_SYSTEM_OPTIONS = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
      preventCorsPreflight: false
    };
    DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: LogLevel.Info,
      correlationId: Constants.EMPTY_STRING
    };
    DEFAULT_CACHE_OPTIONS = {
      claimsBasedCachingEnabled: false
    };
    DEFAULT_NETWORK_IMPLEMENTATION = {
      async sendGetRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      },
      async sendPostRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    DEFAULT_LIBRARY_INFO = {
      sku: Constants.SKU,
      version,
      cpu: Constants.EMPTY_STRING,
      os: Constants.EMPTY_STRING
    };
    DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: void 0
    };
    DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: AzureCloudInstance.None,
      tenant: `${Constants.DEFAULT_COMMON_TENANT}`
    };
    DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: "",
        appVersion: ""
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/ServerError.mjs
var ServerError;
var init_ServerError = __esm({
  "node_modules/@azure/msal-common/dist/error/ServerError.mjs"() {
    "use strict";
    init_AuthError();
    ServerError = class _ServerError extends AuthError {
      constructor(errorCode, errorMessage, subError, errorNo, status) {
        super(errorCode, errorMessage, subError);
        this.name = "ServerError";
        this.errorNo = errorNo;
        this.status = status;
        Object.setPrototypeOf(this, _ServerError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs
var ThrottlingUtils;
var init_ThrottlingUtils = __esm({
  "node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs"() {
    "use strict";
    init_Constants();
    init_ServerError();
    ThrottlingUtils = class _ThrottlingUtils {
      /**
       * Prepares a RequestThumbprint to be stored as a key.
       * @param thumbprint
       */
      static generateThrottlingStorageKey(thumbprint) {
        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
      }
      /**
       * Performs necessary throttling checks before a network request.
       * @param cacheManager
       * @param thumbprint
       */
      static preProcess(cacheManager, thumbprint) {
        const key = _ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
        const value = cacheManager.getThrottlingCache(key);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key);
            return;
          }
          throw new ServerError(value.errorCodes?.join(" ") || Constants.EMPTY_STRING, value.errorMessage, value.subError);
        }
      }
      /**
       * Performs necessary throttling checks after a network request.
       * @param cacheManager
       * @param thumbprint
       * @param response
       */
      static postProcess(cacheManager, thumbprint, response) {
        if (_ThrottlingUtils.checkResponseStatus(response) || _ThrottlingUtils.checkResponseForRetryAfter(response)) {
          const thumbprintValue = {
            throttleTime: _ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
            error: response.body.error,
            errorCodes: response.body.error_codes,
            errorMessage: response.body.error_description,
            subError: response.body.suberror
          };
          cacheManager.setThrottlingCache(_ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue);
        }
      }
      /**
       * Checks a NetworkResponse object's status codes against 429 or 5xx
       * @param response
       */
      static checkResponseStatus(response) {
        return response.status === 429 || response.status >= 500 && response.status < 600;
      }
      /**
       * Checks a NetworkResponse object's RetryAfter header
       * @param response
       */
      static checkResponseForRetryAfter(response) {
        if (response.headers) {
          return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
        }
        return false;
      }
      /**
       * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
       * @param throttleTime
       */
      static calculateThrottleTime(throttleTime) {
        const time = throttleTime <= 0 ? 0 : throttleTime;
        const currentSeconds = Date.now() / 1e3;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
      }
      static removeThrottle(cacheManager, clientId, request3, homeAccountIdentifier) {
        const thumbprint = {
          clientId,
          authority: request3.authority,
          scopes: request3.scopes,
          homeAccountIdentifier,
          claims: request3.claims,
          authenticationScheme: request3.authenticationScheme,
          resourceRequestMethod: request3.resourceRequestMethod,
          resourceRequestUri: request3.resourceRequestUri,
          shrClaims: request3.shrClaims,
          sshKid: request3.sshKid
        };
        const key = this.generateThrottlingStorageKey(thumbprint);
        cacheManager.removeItem(key);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/network/NetworkManager.mjs
var NetworkManager;
var init_NetworkManager = __esm({
  "node_modules/@azure/msal-common/dist/network/NetworkManager.mjs"() {
    "use strict";
    init_ThrottlingUtils();
    init_AuthError();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    NetworkManager = class {
      constructor(networkClient, cacheManager) {
        this.networkClient = networkClient;
        this.cacheManager = cacheManager;
      }
      /**
       * Wraps sendPostRequestAsync with necessary preflight and postflight logic
       * @param thumbprint
       * @param tokenEndpoint
       * @param options
       */
      async sendPostRequest(thumbprint, tokenEndpoint, options) {
        ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
        let response;
        try {
          response = await this.networkClient.sendPostRequestAsync(tokenEndpoint, options);
        } catch (e) {
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createClientAuthError(networkError);
          }
        }
        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
        return response;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/account/CcsCredential.mjs
var CcsCredentialType;
var init_CcsCredential = __esm({
  "node_modules/@azure/msal-common/dist/account/CcsCredential.mjs"() {
    "use strict";
    CcsCredentialType = {
      HOME_ACCOUNT_ID: "home_account_id",
      UPN: "UPN"
    };
  }
});

// node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs
var AADServerParamKeys_exports = {};
__export(AADServerParamKeys_exports, {
  ACCESS_TOKEN: () => ACCESS_TOKEN,
  CCS_HEADER: () => CCS_HEADER,
  CLAIMS: () => CLAIMS,
  CLIENT_ASSERTION: () => CLIENT_ASSERTION,
  CLIENT_ASSERTION_TYPE: () => CLIENT_ASSERTION_TYPE,
  CLIENT_ID: () => CLIENT_ID,
  CLIENT_INFO: () => CLIENT_INFO2,
  CLIENT_REQUEST_ID: () => CLIENT_REQUEST_ID,
  CLIENT_SECRET: () => CLIENT_SECRET,
  CODE: () => CODE,
  CODE_CHALLENGE: () => CODE_CHALLENGE,
  CODE_CHALLENGE_METHOD: () => CODE_CHALLENGE_METHOD,
  CODE_VERIFIER: () => CODE_VERIFIER,
  DEVICE_CODE: () => DEVICE_CODE,
  DOMAIN_HINT: () => DOMAIN_HINT,
  ERROR: () => ERROR,
  ERROR_DESCRIPTION: () => ERROR_DESCRIPTION,
  EXPIRES_IN: () => EXPIRES_IN,
  FOCI: () => FOCI,
  GRANT_TYPE: () => GRANT_TYPE,
  ID_TOKEN: () => ID_TOKEN,
  ID_TOKEN_HINT: () => ID_TOKEN_HINT,
  LOGIN_HINT: () => LOGIN_HINT,
  LOGOUT_HINT: () => LOGOUT_HINT,
  NATIVE_BROKER: () => NATIVE_BROKER,
  NONCE: () => NONCE,
  OBO_ASSERTION: () => OBO_ASSERTION,
  ON_BEHALF_OF: () => ON_BEHALF_OF,
  POST_LOGOUT_URI: () => POST_LOGOUT_URI,
  PROMPT: () => PROMPT,
  REDIRECT_URI: () => REDIRECT_URI,
  REFRESH_TOKEN: () => REFRESH_TOKEN,
  REFRESH_TOKEN_EXPIRES_IN: () => REFRESH_TOKEN_EXPIRES_IN,
  REQUESTED_TOKEN_USE: () => REQUESTED_TOKEN_USE,
  REQ_CNF: () => REQ_CNF,
  RESPONSE_MODE: () => RESPONSE_MODE,
  RESPONSE_TYPE: () => RESPONSE_TYPE,
  RETURN_SPA_CODE: () => RETURN_SPA_CODE,
  SCOPE: () => SCOPE,
  SESSION_STATE: () => SESSION_STATE,
  SID: () => SID,
  STATE: () => STATE,
  TOKEN_TYPE: () => TOKEN_TYPE,
  X_APP_NAME: () => X_APP_NAME,
  X_APP_VER: () => X_APP_VER,
  X_CLIENT_CPU: () => X_CLIENT_CPU,
  X_CLIENT_CURR_TELEM: () => X_CLIENT_CURR_TELEM,
  X_CLIENT_EXTRA_SKU: () => X_CLIENT_EXTRA_SKU,
  X_CLIENT_LAST_TELEM: () => X_CLIENT_LAST_TELEM,
  X_CLIENT_OS: () => X_CLIENT_OS,
  X_CLIENT_SKU: () => X_CLIENT_SKU,
  X_CLIENT_VER: () => X_CLIENT_VER,
  X_MS_LIB_CAPABILITY: () => X_MS_LIB_CAPABILITY
});
var CLIENT_ID, REDIRECT_URI, RESPONSE_TYPE, RESPONSE_MODE, GRANT_TYPE, CLAIMS, SCOPE, ERROR, ERROR_DESCRIPTION, ACCESS_TOKEN, ID_TOKEN, REFRESH_TOKEN, EXPIRES_IN, REFRESH_TOKEN_EXPIRES_IN, STATE, NONCE, PROMPT, SESSION_STATE, CLIENT_INFO2, CODE, CODE_CHALLENGE, CODE_CHALLENGE_METHOD, CODE_VERIFIER, CLIENT_REQUEST_ID, X_CLIENT_SKU, X_CLIENT_VER, X_CLIENT_OS, X_CLIENT_CPU, X_CLIENT_CURR_TELEM, X_CLIENT_LAST_TELEM, X_MS_LIB_CAPABILITY, X_APP_NAME, X_APP_VER, POST_LOGOUT_URI, ID_TOKEN_HINT, DEVICE_CODE, CLIENT_SECRET, CLIENT_ASSERTION, CLIENT_ASSERTION_TYPE, TOKEN_TYPE, REQ_CNF, OBO_ASSERTION, REQUESTED_TOKEN_USE, ON_BEHALF_OF, FOCI, CCS_HEADER, RETURN_SPA_CODE, NATIVE_BROKER, LOGOUT_HINT, SID, LOGIN_HINT, DOMAIN_HINT, X_CLIENT_EXTRA_SKU;
var init_AADServerParamKeys = __esm({
  "node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs"() {
    "use strict";
    CLIENT_ID = "client_id";
    REDIRECT_URI = "redirect_uri";
    RESPONSE_TYPE = "response_type";
    RESPONSE_MODE = "response_mode";
    GRANT_TYPE = "grant_type";
    CLAIMS = "claims";
    SCOPE = "scope";
    ERROR = "error";
    ERROR_DESCRIPTION = "error_description";
    ACCESS_TOKEN = "access_token";
    ID_TOKEN = "id_token";
    REFRESH_TOKEN = "refresh_token";
    EXPIRES_IN = "expires_in";
    REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";
    STATE = "state";
    NONCE = "nonce";
    PROMPT = "prompt";
    SESSION_STATE = "session_state";
    CLIENT_INFO2 = "client_info";
    CODE = "code";
    CODE_CHALLENGE = "code_challenge";
    CODE_CHALLENGE_METHOD = "code_challenge_method";
    CODE_VERIFIER = "code_verifier";
    CLIENT_REQUEST_ID = "client-request-id";
    X_CLIENT_SKU = "x-client-SKU";
    X_CLIENT_VER = "x-client-VER";
    X_CLIENT_OS = "x-client-OS";
    X_CLIENT_CPU = "x-client-CPU";
    X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
    X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
    X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
    X_APP_NAME = "x-app-name";
    X_APP_VER = "x-app-ver";
    POST_LOGOUT_URI = "post_logout_redirect_uri";
    ID_TOKEN_HINT = "id_token_hint";
    DEVICE_CODE = "device_code";
    CLIENT_SECRET = "client_secret";
    CLIENT_ASSERTION = "client_assertion";
    CLIENT_ASSERTION_TYPE = "client_assertion_type";
    TOKEN_TYPE = "token_type";
    REQ_CNF = "req_cnf";
    OBO_ASSERTION = "assertion";
    REQUESTED_TOKEN_USE = "requested_token_use";
    ON_BEHALF_OF = "on_behalf_of";
    FOCI = "foci";
    CCS_HEADER = "X-AnchorMailbox";
    RETURN_SPA_CODE = "return_spa_code";
    NATIVE_BROKER = "nativebroker";
    LOGOUT_HINT = "logout_hint";
    SID = "sid";
    LOGIN_HINT = "login_hint";
    DOMAIN_HINT = "domain_hint";
    X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
  }
});

// node_modules/@azure/msal-common/dist/request/RequestValidator.mjs
var RequestValidator;
var init_RequestValidator = __esm({
  "node_modules/@azure/msal-common/dist/request/RequestValidator.mjs"() {
    "use strict";
    init_ClientConfigurationError();
    init_Constants();
    init_ClientConfigurationErrorCodes();
    RequestValidator = class {
      /**
       * Utility to check if the `redirectUri` in the request is a non-null value
       * @param redirectUri
       */
      static validateRedirectUri(redirectUri) {
        if (!redirectUri) {
          throw createClientConfigurationError(redirectUriEmpty);
        }
      }
      /**
       * Utility to validate prompt sent by the user in the request
       * @param prompt
       */
      static validatePrompt(prompt) {
        const promptValues = [];
        for (const value in PromptValue) {
          promptValues.push(PromptValue[value]);
        }
        if (promptValues.indexOf(prompt) < 0) {
          throw createClientConfigurationError(invalidPromptValue);
        }
      }
      static validateClaims(claims) {
        try {
          JSON.parse(claims);
        } catch (e) {
          throw createClientConfigurationError(invalidClaims);
        }
      }
      /**
       * Utility to validate code_challenge and code_challenge_method
       * @param codeChallenge
       * @param codeChallengeMethod
       */
      static validateCodeChallengeParams(codeChallenge, codeChallengeMethod) {
        if (!codeChallenge || !codeChallengeMethod) {
          throw createClientConfigurationError(pkceParamsMissing);
        } else {
          this.validateCodeChallengeMethod(codeChallengeMethod);
        }
      }
      /**
       * Utility to validate code_challenge_method
       * @param codeChallengeMethod
       */
      static validateCodeChallengeMethod(codeChallengeMethod) {
        if ([
          CodeChallengeMethodValues.PLAIN,
          CodeChallengeMethodValues.S256
        ].indexOf(codeChallengeMethod) < 0) {
          throw createClientConfigurationError(invalidCodeChallengeMethod);
        }
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs
var RequestParameterBuilder;
var init_RequestParameterBuilder = __esm({
  "node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs"() {
    "use strict";
    init_Constants();
    init_AADServerParamKeys();
    init_ScopeSet();
    init_ClientConfigurationError();
    init_RequestValidator();
    init_ClientConfigurationErrorCodes();
    RequestParameterBuilder = class {
      constructor() {
        this.parameters = /* @__PURE__ */ new Map();
      }
      /**
       * add response_type = code
       */
      addResponseTypeCode() {
        this.parameters.set(RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE));
      }
      /**
       * add response_type = token id_token
       */
      addResponseTypeForTokenAndIdToken() {
        this.parameters.set(RESPONSE_TYPE, encodeURIComponent(`${Constants.TOKEN_RESPONSE_TYPE} ${Constants.ID_TOKEN_RESPONSE_TYPE}`));
      }
      /**
       * add response_mode. defaults to query.
       * @param responseMode
       */
      addResponseMode(responseMode) {
        this.parameters.set(RESPONSE_MODE, encodeURIComponent(responseMode ? responseMode : ResponseMode.QUERY));
      }
      /**
       * Add flag to indicate STS should attempt to use WAM if available
       */
      addNativeBroker() {
        this.parameters.set(NATIVE_BROKER, encodeURIComponent("1"));
      }
      /**
       * add scopes. set addOidcScopes to false to prevent default scopes in non-user scenarios
       * @param scopeSet
       * @param addOidcScopes
       */
      addScopes(scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
        if (addOidcScopes && !defaultScopes.includes("openid") && !scopes.includes("openid")) {
          defaultScopes.push("openid");
        }
        const requestScopes = addOidcScopes ? [...scopes || [], ...defaultScopes] : scopes || [];
        const scopeSet = new ScopeSet(requestScopes);
        this.parameters.set(SCOPE, encodeURIComponent(scopeSet.printScopes()));
      }
      /**
       * add clientId
       * @param clientId
       */
      addClientId(clientId) {
        this.parameters.set(CLIENT_ID, encodeURIComponent(clientId));
      }
      /**
       * add redirect_uri
       * @param redirectUri
       */
      addRedirectUri(redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(REDIRECT_URI, encodeURIComponent(redirectUri));
      }
      /**
       * add post logout redirectUri
       * @param redirectUri
       */
      addPostLogoutRedirectUri(redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(POST_LOGOUT_URI, encodeURIComponent(redirectUri));
      }
      /**
       * add id_token_hint to logout request
       * @param idTokenHint
       */
      addIdTokenHint(idTokenHint) {
        this.parameters.set(ID_TOKEN_HINT, encodeURIComponent(idTokenHint));
      }
      /**
       * add domain_hint
       * @param domainHint
       */
      addDomainHint(domainHint) {
        this.parameters.set(DOMAIN_HINT, encodeURIComponent(domainHint));
      }
      /**
       * add login_hint
       * @param loginHint
       */
      addLoginHint(loginHint) {
        this.parameters.set(LOGIN_HINT, encodeURIComponent(loginHint));
      }
      /**
       * Adds the CCS (Cache Credential Service) query parameter for login_hint
       * @param loginHint
       */
      addCcsUpn(loginHint) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent(`UPN:${loginHint}`));
      }
      /**
       * Adds the CCS (Cache Credential Service) query parameter for account object
       * @param loginHint
       */
      addCcsOid(clientInfo) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent(`Oid:${clientInfo.uid}@${clientInfo.utid}`));
      }
      /**
       * add sid
       * @param sid
       */
      addSid(sid) {
        this.parameters.set(SID, encodeURIComponent(sid));
      }
      /**
       * add claims
       * @param claims
       */
      addClaims(claims, clientCapabilities) {
        const mergedClaims = this.addClientCapabilitiesToClaims(claims, clientCapabilities);
        RequestValidator.validateClaims(mergedClaims);
        this.parameters.set(CLAIMS, encodeURIComponent(mergedClaims));
      }
      /**
       * add correlationId
       * @param correlationId
       */
      addCorrelationId(correlationId) {
        this.parameters.set(CLIENT_REQUEST_ID, encodeURIComponent(correlationId));
      }
      /**
       * add library info query params
       * @param libraryInfo
       */
      addLibraryInfo(libraryInfo) {
        this.parameters.set(X_CLIENT_SKU, libraryInfo.sku);
        this.parameters.set(X_CLIENT_VER, libraryInfo.version);
        if (libraryInfo.os) {
          this.parameters.set(X_CLIENT_OS, libraryInfo.os);
        }
        if (libraryInfo.cpu) {
          this.parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
        }
      }
      /**
       * Add client telemetry parameters
       * @param appTelemetry
       */
      addApplicationTelemetry(appTelemetry) {
        if (appTelemetry?.appName) {
          this.parameters.set(X_APP_NAME, appTelemetry.appName);
        }
        if (appTelemetry?.appVersion) {
          this.parameters.set(X_APP_VER, appTelemetry.appVersion);
        }
      }
      /**
       * add prompt
       * @param prompt
       */
      addPrompt(prompt) {
        RequestValidator.validatePrompt(prompt);
        this.parameters.set(`${PROMPT}`, encodeURIComponent(prompt));
      }
      /**
       * add state
       * @param state
       */
      addState(state3) {
        if (state3) {
          this.parameters.set(STATE, encodeURIComponent(state3));
        }
      }
      /**
       * add nonce
       * @param nonce
       */
      addNonce(nonce) {
        this.parameters.set(NONCE, encodeURIComponent(nonce));
      }
      /**
       * add code_challenge and code_challenge_method
       * - throw if either of them are not passed
       * @param codeChallenge
       * @param codeChallengeMethod
       */
      addCodeChallengeParams(codeChallenge, codeChallengeMethod) {
        RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);
        if (codeChallenge && codeChallengeMethod) {
          this.parameters.set(CODE_CHALLENGE, encodeURIComponent(codeChallenge));
          this.parameters.set(CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod));
        } else {
          throw createClientConfigurationError(pkceParamsMissing);
        }
      }
      /**
       * add the `authorization_code` passed by the user to exchange for a token
       * @param code
       */
      addAuthorizationCode(code) {
        this.parameters.set(CODE, encodeURIComponent(code));
      }
      /**
       * add the `authorization_code` passed by the user to exchange for a token
       * @param code
       */
      addDeviceCode(code) {
        this.parameters.set(DEVICE_CODE, encodeURIComponent(code));
      }
      /**
       * add the `refreshToken` passed by the user
       * @param refreshToken
       */
      addRefreshToken(refreshToken) {
        this.parameters.set(REFRESH_TOKEN, encodeURIComponent(refreshToken));
      }
      /**
       * add the `code_verifier` passed by the user to exchange for a token
       * @param codeVerifier
       */
      addCodeVerifier(codeVerifier) {
        this.parameters.set(CODE_VERIFIER, encodeURIComponent(codeVerifier));
      }
      /**
       * add client_secret
       * @param clientSecret
       */
      addClientSecret(clientSecret) {
        this.parameters.set(CLIENT_SECRET, encodeURIComponent(clientSecret));
      }
      /**
       * add clientAssertion for confidential client flows
       * @param clientAssertion
       */
      addClientAssertion(clientAssertion) {
        if (clientAssertion) {
          this.parameters.set(CLIENT_ASSERTION, encodeURIComponent(clientAssertion));
        }
      }
      /**
       * add clientAssertionType for confidential client flows
       * @param clientAssertionType
       */
      addClientAssertionType(clientAssertionType) {
        if (clientAssertionType) {
          this.parameters.set(CLIENT_ASSERTION_TYPE, encodeURIComponent(clientAssertionType));
        }
      }
      /**
       * add OBO assertion for confidential client flows
       * @param clientAssertion
       */
      addOboAssertion(oboAssertion) {
        this.parameters.set(OBO_ASSERTION, encodeURIComponent(oboAssertion));
      }
      /**
       * add grant type
       * @param grantType
       */
      addRequestTokenUse(tokenUse) {
        this.parameters.set(REQUESTED_TOKEN_USE, encodeURIComponent(tokenUse));
      }
      /**
       * add grant type
       * @param grantType
       */
      addGrantType(grantType) {
        this.parameters.set(GRANT_TYPE, encodeURIComponent(grantType));
      }
      /**
       * add client info
       *
       */
      addClientInfo() {
        this.parameters.set(CLIENT_INFO, "1");
      }
      /**
       * add extraQueryParams
       * @param eQParams
       */
      addExtraQueryParameters(eQParams) {
        Object.entries(eQParams).forEach(([key, value]) => {
          if (!this.parameters.has(key) && value) {
            this.parameters.set(key, value);
          }
        });
      }
      addClientCapabilitiesToClaims(claims, clientCapabilities) {
        let mergedClaims;
        if (!claims) {
          mergedClaims = {};
        } else {
          try {
            mergedClaims = JSON.parse(claims);
          } catch (e) {
            throw createClientConfigurationError(invalidClaims);
          }
        }
        if (clientCapabilities && clientCapabilities.length > 0) {
          if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
          }
          mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
            values: clientCapabilities
          };
        }
        return JSON.stringify(mergedClaims);
      }
      /**
       * adds `username` for Password Grant flow
       * @param username
       */
      addUsername(username) {
        this.parameters.set(PasswordGrantConstants.username, encodeURIComponent(username));
      }
      /**
       * adds `password` for Password Grant flow
       * @param password
       */
      addPassword(password) {
        this.parameters.set(PasswordGrantConstants.password, encodeURIComponent(password));
      }
      /**
       * add pop_jwk to query params
       * @param cnfString
       */
      addPopToken(cnfString) {
        if (cnfString) {
          this.parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
          this.parameters.set(REQ_CNF, encodeURIComponent(cnfString));
        }
      }
      /**
       * add SSH JWK and key ID to query params
       */
      addSshJwk(sshJwkString) {
        if (sshJwkString) {
          this.parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
          this.parameters.set(REQ_CNF, encodeURIComponent(sshJwkString));
        }
      }
      /**
       * add server telemetry fields
       * @param serverTelemetryManager
       */
      addServerTelemetry(serverTelemetryManager) {
        this.parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
        this.parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
      }
      /**
       * Adds parameter that indicates to the server that throttling is supported
       */
      addThrottling() {
        this.parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
      }
      /**
       * Adds logout_hint parameter for "silent" logout which prevent server account picker
       */
      addLogoutHint(logoutHint) {
        this.parameters.set(LOGOUT_HINT, encodeURIComponent(logoutHint));
      }
      /**
       * Utility to create a URL from the params map
       */
      createQueryString() {
        const queryParameterArray = new Array();
        this.parameters.forEach((value, key) => {
          queryParameterArray.push(`${key}=${value}`);
        });
        return queryParameterArray.join("&");
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs
function isOpenIdConfigResponse(response) {
  return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
}
var init_OpenIdConfigResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs
function isCloudInstanceDiscoveryResponse(response) {
  return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
}
var init_CloudInstanceDiscoveryResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs
function isCloudInstanceDiscoveryErrorResponse(response) {
  return response.hasOwnProperty("error") && response.hasOwnProperty("error_description");
}
var init_CloudInstanceDiscoveryErrorResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs
var PerformanceEvents, PerformanceEventAbbreviations;
var init_PerformanceEvent = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs"() {
    "use strict";
    PerformanceEvents = {
      /**
       * acquireTokenByCode API (msal-browser and msal-node).
       * Used to acquire tokens by trading an authorization code against the token endpoint.
       */
      AcquireTokenByCode: "acquireTokenByCode",
      /**
       * acquireTokenByRefreshToken API (msal-browser and msal-node).
       * Used to renew an access token using a refresh token against the token endpoint.
       */
      AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
      /**
       * acquireTokenSilent API (msal-browser and msal-node).
       * Used to silently acquire a new access token (from the cache or the network).
       */
      AcquireTokenSilent: "acquireTokenSilent",
      /**
       * acquireTokenSilentAsync (msal-browser).
       * Internal API for acquireTokenSilent.
       */
      AcquireTokenSilentAsync: "acquireTokenSilentAsync",
      /**
       * acquireTokenPopup (msal-browser).
       * Used to acquire a new access token interactively through pop ups
       */
      AcquireTokenPopup: "acquireTokenPopup",
      /**
       * acquireTokenPreRedirect (msal-browser).
       * First part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenPreRedirect: "acquireTokenPreRedirect",
      /**
       * acquireTokenRedirect (msal-browser).
       * Second part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenRedirect: "acquireTokenRedirect",
      /**
       * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
       * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
       */
      CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
      /**
       * signJwt API in CryptoOpts class (msal-browser).
       * Used to signed a pop token.
       */
      CryptoOptsSignJwt: "cryptoOptsSignJwt",
      /**
       * acquireToken API in the SilentCacheClient class (msal-browser).
       * Used to read access tokens from the cache.
       */
      SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
      /**
       * acquireToken API in the SilentIframeClient class (msal-browser).
       * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
       */
      SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
      AwaitConcurrentIframe: "awaitConcurrentIframe",
      /**
       * acquireToken API in SilentRereshClient (msal-browser).
       * Used to acquire a new set of tokens from the token endpoint using a refresh token.
       */
      SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
      /**
       * ssoSilent API (msal-browser).
       * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
       */
      SsoSilent: "ssoSilent",
      /**
       * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
       * Used to load authority metadata for a request.
       */
      StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
      /**
       * acquireToken APIs in msal-browser.
       * Used to make an /authorize endpoint call with native brokering enabled.
       */
      FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
      /**
       * acquireToken API in NativeInteractionClient class (msal-browser).
       * Used to acquire a token from Native component when native brokering is enabled.
       */
      NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
      /**
       * Time spent creating default headers for requests to token endpoint
       */
      BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
      /**
       * Time spent sending/waiting for the response of a request to the token endpoint
       */
      RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
      AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
      /**
       * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
       */
      BrokerHandhshake: "brokerHandshake",
      /**
       * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
       */
      AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
      /**
       * Time taken for token acquisition by broker
       */
      AcquireTokenByBroker: "acquireTokenByBroker",
      /**
       * Time spent on the network for refresh token acquisition
       */
      RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
      /**
       * Time taken for acquiring refresh token , records RT size
       */
      RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
      /**
       * Time taken for acquiring cached refresh token
       */
      RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
      /**
       * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
      /**
       * Helper function to create token request body in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
      /**
       * acquireTokenFromCache (msal-browser).
       * Internal API for acquiring token from cache
       */
      AcquireTokenFromCache: "acquireTokenFromCache",
      SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
      SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
      /**
       * acquireTokenBySilentIframe (msal-browser).
       * Internal API for acquiring token by silent Iframe
       */
      AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
      /**
       * Internal API for initializing base request in BaseInteractionClient (msal-browser)
       */
      InitializeBaseRequest: "initializeBaseRequest",
      /**
       * Internal API for initializing silent request in SilentCacheClient (msal-browser)
       */
      InitializeSilentRequest: "initializeSilentRequest",
      InitializeClientApplication: "initializeClientApplication",
      /**
       * Helper function in SilentIframeClient class (msal-browser).
       */
      SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
      /**
       * SilentHandler
       */
      SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
      SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
      SilentHandlerLoadFrame: "silentHandlerLoadFrame",
      SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
      /**
       * Helper functions in StandardInteractionClient class (msal-browser)
       */
      StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
      StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
      StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
      StandardInteractionClientInitializeAuthorizationCodeRequest: "standardInteractionClientInitializeAuthorizationCodeRequest",
      /**
       * getAuthCodeUrl API (msal-browser and msal-node).
       */
      GetAuthCodeUrl: "getAuthCodeUrl",
      /**
       * Functions from InteractionHandler (msal-browser)
       */
      HandleCodeResponseFromServer: "handleCodeResponseFromServer",
      HandleCodeResponse: "handleCodeResponse",
      UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
      /**
       * APIs in Authorization Code Client (msal-common)
       */
      AuthClientAcquireToken: "authClientAcquireToken",
      AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
      AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
      AuthClientCreateQueryString: "authClientCreateQueryString",
      /**
       * Generate functions in PopTokenGenerator (msal-common)
       */
      PopTokenGenerateCnf: "popTokenGenerateCnf",
      PopTokenGenerateKid: "popTokenGenerateKid",
      /**
       * handleServerTokenResponse API in ResponseHandler (msal-common)
       */
      HandleServerTokenResponse: "handleServerTokenResponse",
      DeserializeResponse: "deserializeResponse",
      /**
       * Authority functions
       */
      AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
      AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
      AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
      AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
      AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
      AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
      AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
      AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
      /**
       * Region Discovery functions
       */
      RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
      RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
      RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
      AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
      GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
      GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
      HandleRedirectPromiseMeasurement: "handleRedirectPromise",
      HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
      UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
      UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
      NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
      NativeGenerateAuthResult: "nativeGenerateAuthResult",
      RemoveHiddenIframe: "removeHiddenIframe",
      /**
       * Cache operations
       */
      ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
      CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
      /**
       * Crypto Operations
       */
      GeneratePkceCodes: "generatePkceCodes",
      GenerateCodeVerifier: "generateCodeVerifier",
      GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
      Sha256Digest: "sha256Digest",
      GetRandomValues: "getRandomValues"
    };
    PerformanceEventAbbreviations = /* @__PURE__ */ new Map([
      [PerformanceEvents.AcquireTokenByCode, "ATByCode"],
      [PerformanceEvents.AcquireTokenByRefreshToken, "ATByRT"],
      [PerformanceEvents.AcquireTokenSilent, "ATS"],
      [PerformanceEvents.AcquireTokenSilentAsync, "ATSAsync"],
      [PerformanceEvents.AcquireTokenPopup, "ATPopup"],
      [PerformanceEvents.AcquireTokenRedirect, "ATRedirect"],
      [
        PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,
        "CryptoGetPKThumb"
      ],
      [PerformanceEvents.CryptoOptsSignJwt, "CryptoSignJwt"],
      [PerformanceEvents.SilentCacheClientAcquireToken, "SltCacheClientAT"],
      [PerformanceEvents.SilentIframeClientAcquireToken, "SltIframeClientAT"],
      [PerformanceEvents.SilentRefreshClientAcquireToken, "SltRClientAT"],
      [PerformanceEvents.SsoSilent, "SsoSlt"],
      [
        PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,
        "StdIntClientGetDiscAuth"
      ],
      [
        PerformanceEvents.FetchAccountIdWithNativeBroker,
        "FetchAccIdWithNtvBroker"
      ],
      [
        PerformanceEvents.NativeInteractionClientAcquireToken,
        "NtvIntClientAT"
      ],
      [
        PerformanceEvents.BaseClientCreateTokenRequestHeaders,
        "BaseClientCreateTReqHead"
      ],
      [
        PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,
        "RTClientExecPost"
      ],
      [
        PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
        "AuthCodeClientExecPost"
      ],
      [PerformanceEvents.BrokerHandhshake, "BrokerHandshake"],
      [
        PerformanceEvents.AcquireTokenByRefreshTokenInBroker,
        "ATByRTInBroker"
      ],
      [PerformanceEvents.AcquireTokenByBroker, "ATByBroker"],
      [
        PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
        "RTClientExecTReq"
      ],
      [PerformanceEvents.RefreshTokenClientAcquireToken, "RTClientAT"],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
        "RTClientATWithCachedRT"
      ],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,
        "RTClientATByRT"
      ],
      [
        PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
        "RTClientCreateTReqBody"
      ],
      [PerformanceEvents.AcquireTokenFromCache, "ATFromCache"],
      [
        PerformanceEvents.SilentFlowClientAcquireCachedToken,
        "SltFlowClientATCached"
      ],
      [
        PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
        "SltFlowClientGenResFromCache"
      ],
      [PerformanceEvents.AcquireTokenBySilentIframe, "ATBySltIframe"],
      [PerformanceEvents.InitializeBaseRequest, "InitBaseReq"],
      [PerformanceEvents.InitializeSilentRequest, "InitSltReq"],
      [
        PerformanceEvents.InitializeClientApplication,
        "InitClientApplication"
      ],
      [PerformanceEvents.SilentIframeClientTokenHelper, "SIClientTHelper"],
      [
        PerformanceEvents.SilentHandlerInitiateAuthRequest,
        "SHandlerInitAuthReq"
      ],
      [
        PerformanceEvents.SilentHandlerMonitorIframeForHash,
        "SltHandlerMonitorIframeForHash"
      ],
      [PerformanceEvents.SilentHandlerLoadFrame, "SHandlerLoadFrame"],
      [PerformanceEvents.SilentHandlerLoadFrameSync, "SHandlerLoadFrameSync"],
      [
        PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,
        "StdIntClientCreateAuthCodeClient"
      ],
      [
        PerformanceEvents.StandardInteractionClientGetClientConfiguration,
        "StdIntClientGetClientConf"
      ],
      [
        PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,
        "StdIntClientInitAuthReq"
      ],
      [
        PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest,
        "StdIntClientInitAuthCodeReq"
      ],
      [PerformanceEvents.GetAuthCodeUrl, "GetAuthCodeUrl"],
      [
        PerformanceEvents.HandleCodeResponseFromServer,
        "HandleCodeResFromServer"
      ],
      [PerformanceEvents.HandleCodeResponse, "HandleCodeResp"],
      [PerformanceEvents.UpdateTokenEndpointAuthority, "UpdTEndpointAuth"],
      [PerformanceEvents.AuthClientAcquireToken, "AuthClientAT"],
      [PerformanceEvents.AuthClientExecuteTokenRequest, "AuthClientExecTReq"],
      [
        PerformanceEvents.AuthClientCreateTokenRequestBody,
        "AuthClientCreateTReqBody"
      ],
      [
        PerformanceEvents.AuthClientCreateQueryString,
        "AuthClientCreateQueryStr"
      ],
      [PerformanceEvents.PopTokenGenerateCnf, "PopTGenCnf"],
      [PerformanceEvents.PopTokenGenerateKid, "PopTGenKid"],
      [PerformanceEvents.HandleServerTokenResponse, "HandleServerTRes"],
      [PerformanceEvents.DeserializeResponse, "DeserializeRes"],
      [
        PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,
        "AuthFactCreateDiscInst"
      ],
      [
        PerformanceEvents.AuthorityResolveEndpointsAsync,
        "AuthResolveEndpointsAsync"
      ],
      [
        PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,
        "AuthResolveEndpointsFromLocal"
      ],
      [
        PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
        "AuthGetCDMetaFromNet"
      ],
      [
        PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
        "AuthUpdCDMeta"
      ],
      [
        PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
        "AuthUpdCDMetaFromNet"
      ],
      [
        PerformanceEvents.AuthorityUpdateEndpointMetadata,
        "AuthUpdEndpointMeta"
      ],
      [
        PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
        "AuthUpdMetaWithRegInfo"
      ],
      [PerformanceEvents.RegionDiscoveryDetectRegion, "RegDiscDetectReg"],
      [
        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
        "RegDiscGetRegFromIMDS"
      ],
      [
        PerformanceEvents.RegionDiscoveryGetCurrentVersion,
        "RegDiscGetCurrentVer"
      ],
      [PerformanceEvents.AcquireTokenByCodeAsync, "ATByCodeAsync"],
      [
        PerformanceEvents.GetEndpointMetadataFromNetwork,
        "GetEndpointMetaFromNet"
      ],
      [
        PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement,
        "GetCDMetaFromNet"
      ],
      [
        PerformanceEvents.HandleRedirectPromiseMeasurement,
        "HandleRedirectPromise"
      ],
      [
        PerformanceEvents.HandleNativeRedirectPromiseMeasurement,
        "HandleNtvRedirectPromise"
      ],
      [
        PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement,
        "UpdateCDMeta"
      ],
      [
        PerformanceEvents.UsernamePasswordClientAcquireToken,
        "UserPassClientAT"
      ],
      [
        PerformanceEvents.NativeMessageHandlerHandshake,
        "NtvMsgHandlerHandshake"
      ],
      [PerformanceEvents.NativeGenerateAuthResult, "NtvGenAuthRes"],
      [PerformanceEvents.RemoveHiddenIframe, "RemoveHiddenIframe"],
      [
        PerformanceEvents.ClearTokensAndKeysWithClaims,
        "ClearTAndKeysWithClaims"
      ],
      [PerformanceEvents.CacheManagerGetRefreshToken, "CacheManagerGetRT"],
      [PerformanceEvents.GeneratePkceCodes, "GenPkceCodes"],
      [PerformanceEvents.GenerateCodeVerifier, "GenCodeVerifier"],
      [
        PerformanceEvents.GenerateCodeChallengeFromVerifier,
        "GenCodeChallengeFromVerifier"
      ],
      [PerformanceEvents.Sha256Digest, "Sha256Digest"],
      [PerformanceEvents.GetRandomValues, "GetRandomValues"]
    ]);
  }
});

// node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs
var invoke, invokeAsync;
var init_FunctionWrappers = __esm({
  "node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs"() {
    "use strict";
    invoke = (callback, eventName, logger26, telemetryClient, correlationId) => {
      return (...args) => {
        logger26.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        try {
          const result = callback(...args);
          inProgressEvent?.end({
            success: true
          });
          logger26.trace(`Returning result from ${eventName}`);
          return result;
        } catch (e) {
          logger26.trace(`Error occurred in ${eventName}`);
          try {
            logger26.trace(JSON.stringify(e));
          } catch (e2) {
            logger26.trace("Unable to print error message.");
          }
          inProgressEvent?.end({
            success: false
          }, e);
          throw e;
        }
      };
    };
    invokeAsync = (callback, eventName, logger26, telemetryClient, correlationId) => {
      return (...args) => {
        logger26.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        telemetryClient?.setPreQueueTime(eventName, correlationId);
        return callback(...args).then((response) => {
          logger26.trace(`Returning result from ${eventName}`);
          inProgressEvent?.end({
            success: true
          });
          return response;
        }).catch((e) => {
          logger26.trace(`Error occurred in ${eventName}`);
          try {
            logger26.trace(JSON.stringify(e));
          } catch (e2) {
            logger26.trace("Unable to print error message.");
          }
          inProgressEvent?.end({
            success: false
          }, e);
          throw e;
        });
      };
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs
var RegionDiscovery;
var init_RegionDiscovery = __esm({
  "node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs"() {
    "use strict";
    init_Constants();
    init_PerformanceEvent();
    init_FunctionWrappers();
    RegionDiscovery = class _RegionDiscovery {
      constructor(networkInterface, logger26, performanceClient, correlationId) {
        this.networkInterface = networkInterface;
        this.logger = logger26;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
      }
      /**
       * Detect the region from the application's environment.
       *
       * @returns Promise<string | null>
       */
      async detectRegion(environmentRegion, regionDiscoveryMetadata) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
        let autodetectedRegionName = environmentRegion;
        if (!autodetectedRegionName) {
          const options = _RegionDiscovery.IMDS_OPTIONS;
          try {
            const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);
            if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
              autodetectedRegionName = localIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
            if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {
              const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
              if (!currentIMDSVersion) {
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return null;
              }
              const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
              if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                autodetectedRegionName = currentIMDSVersionResponse.body;
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
              }
            }
          } catch (e) {
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            return null;
          }
        } else {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
        }
        if (!autodetectedRegionName) {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
        }
        return autodetectedRegionName || null;
      }
      /**
       * Make the call to the IMDS endpoint
       *
       * @param imdsEndpointUrl
       * @returns Promise<NetworkResponse<string>>
       */
      async getRegionFromIMDS(version3, options) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
        return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version3}&format=text`, options, Constants.IMDS_TIMEOUT);
      }
      /**
       * Get the most recent version of the IMDS endpoint available
       *
       * @returns Promise<string | null>
       */
      async getCurrentVersion(options) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);
          if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
            return response.body["newest-versions"][0];
          }
          return null;
        } catch (e) {
          return null;
        }
      }
    };
    RegionDiscovery.IMDS_OPTIONS = {
      headers: {
        Metadata: "true"
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/Authority.mjs
function getTenantFromAuthorityString(authority) {
  const authorityUrl = new UrlString(authority);
  const authorityUrlComponents = authorityUrl.getUrlComponents();
  const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();
  switch (tenantId) {
    case AADAuthorityConstants.COMMON:
    case AADAuthorityConstants.ORGANIZATIONS:
    case AADAuthorityConstants.CONSUMERS:
      return void 0;
    default:
      return tenantId;
  }
}
function formatAuthorityUri(authorityUri) {
  return authorityUri.endsWith(Constants.FORWARD_SLASH) ? authorityUri : `${authorityUri}${Constants.FORWARD_SLASH}`;
}
function buildStaticAuthorityOptions(authOptions) {
  const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
  let cloudDiscoveryMetadata = void 0;
  if (rawCloudDiscoveryMetadata) {
    try {
      cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
    } catch (e) {
      throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
    }
  }
  return {
    canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : void 0,
    knownAuthorities: authOptions.knownAuthorities,
    cloudDiscoveryMetadata
  };
}
var Authority;
var init_Authority = __esm({
  "node_modules/@azure/msal-common/dist/authority/Authority.mjs"() {
    "use strict";
    init_AuthorityType();
    init_OpenIdConfigResponse();
    init_UrlString();
    init_ClientAuthError();
    init_Constants();
    init_AuthorityMetadata();
    init_ClientConfigurationError();
    init_ProtocolMode();
    init_AuthorityOptions();
    init_CloudInstanceDiscoveryResponse();
    init_CloudInstanceDiscoveryErrorResponse();
    init_RegionDiscovery();
    init_AuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_CacheHelpers();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    Authority = class _Authority {
      constructor(authority, networkInterface, cacheManager, authorityOptions, logger26, correlationId, performanceClient, managedIdentity) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscoveryMetadata = {
          region_used: void 0,
          region_source: void 0,
          region_outcome: void 0
        };
        this.logger = logger26;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
        this.managedIdentity = managedIdentity || false;
        this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
      }
      /**
       * Get {@link AuthorityType}
       * @param authorityUri {@link IUri}
       * @private
       */
      getAuthorityType(authorityUri) {
        if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          return AuthorityType.Ciam;
        }
        const pathSegments = authorityUri.PathSegments;
        if (pathSegments.length) {
          switch (pathSegments[0].toLowerCase()) {
            case Constants.ADFS:
              return AuthorityType.Adfs;
            case Constants.DSTS:
              return AuthorityType.Dsts;
          }
        }
        return AuthorityType.Default;
      }
      // See above for AuthorityType
      get authorityType() {
        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
      }
      /**
       * ProtocolMode enum representing the way endpoints are constructed.
       */
      get protocolMode() {
        return this.authorityOptions.protocolMode;
      }
      /**
       * Returns authorityOptions which can be used to reinstantiate a new authority instance
       */
      get options() {
        return this.authorityOptions;
      }
      /**
       * A URL that is the authority set by the developer
       */
      get canonicalAuthority() {
        return this._canonicalAuthority.urlString;
      }
      /**
       * Sets canonical authority.
       */
      set canonicalAuthority(url) {
        this._canonicalAuthority = new UrlString(url);
        this._canonicalAuthority.validateAsUri();
        this._canonicalAuthorityUrlComponents = null;
      }
      /**
       * Get authority components.
       */
      get canonicalAuthorityUrlComponents() {
        if (!this._canonicalAuthorityUrlComponents) {
          this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
        }
        return this._canonicalAuthorityUrlComponents;
      }
      /**
       * Get hostname and port i.e. login.microsoftonline.com
       */
      get hostnameAndPort() {
        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
      }
      /**
       * Get tenant for authority.
       */
      get tenant() {
        return this.canonicalAuthorityUrlComponents.PathSegments[0];
      }
      /**
       * OAuth /authorize endpoint for requests
       */
      get authorizationEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.authorization_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth /token endpoint for requests
       */
      get tokenEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      get deviceCodeEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth logout endpoint for requests
       */
      get endSessionEndpoint() {
        if (this.discoveryComplete()) {
          if (!this.metadata.end_session_endpoint) {
            throw createClientAuthError(endSessionEndpointNotSupported);
          }
          return this.replacePath(this.metadata.end_session_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth issuer for requests
       */
      get selfSignedJwtAudience() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.issuer);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Jwks_uri for token signing keys
       */
      get jwksUri() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.jwks_uri);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
       * @param authorityUri {@link IUri}
       * @private
       */
      canReplaceTenant(authorityUri) {
        return authorityUri.PathSegments.length === 1 && !_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode === ProtocolMode.AAD;
      }
      /**
       * Replaces tenant in url path with current tenant. Defaults to common.
       * @param urlString
       */
      replaceTenant(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
      }
      /**
       * Replaces path such as tenant or policy with the current tenant or policy.
       * @param urlString
       */
      replacePath(urlString) {
        let endpoint = urlString;
        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach((currentPart, index) => {
          let cachedPart = cachedAuthorityParts[index];
          if (index === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {
            const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
            if (cachedPart !== tenantId) {
              this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
              cachedPart = tenantId;
            }
          }
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
          }
        });
        return this.replaceTenant(endpoint);
      }
      /**
       * The default open id configuration endpoint for any canonical authority.
       */
      get defaultOpenIdConfigurationEndpoint() {
        const canonicalAuthorityHost = this.hostnameAndPort;
        if (this.canonicalAuthority.endsWith("v2.0/") || this.authorityType === AuthorityType.Adfs || this.protocolMode !== ProtocolMode.AAD && !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost)) {
          return `${this.canonicalAuthority}.well-known/openid-configuration`;
        }
        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
      }
      /**
       * Boolean that returns whether or not tenant discovery has been completed.
       */
      discoveryComplete() {
        return !!this.metadata;
      }
      /**
       * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
       * and the /authorize, /token and logout endpoints.
       */
      async resolveEndpointsAsync() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
        const metadataEntity = this.getCurrentMetadataEntity();
        const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
        const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
          source: endpointSource
        });
        this.performanceClient?.addFields({
          cloudDiscoverySource,
          authorityEndpointSource: endpointSource
        }, this.correlationId);
      }
      /**
       * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
       * from the configured canonical authority
       * @returns
       */
      getCurrentMetadataEntity() {
        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
        if (!metadataEntity) {
          metadataEntity = {
            aliases: [],
            preferred_cache: this.hostnameAndPort,
            preferred_network: this.hostnameAndPort,
            canonical_authority: this.canonicalAuthority,
            authorization_endpoint: "",
            token_endpoint: "",
            end_session_endpoint: "",
            issuer: "",
            aliasesFromNetwork: false,
            endpointsFromNetwork: false,
            expiresAt: generateAuthorityMetadataExpiresAt(),
            jwks_uri: ""
          };
        }
        return metadataEntity;
      }
      /**
       * Updates cached metadata based on metadata source and sets the instance's metadata
       * property to the same value
       * @param metadataEntity
       * @param cloudDiscoverySource
       * @param endpointMetadataResult
       */
      updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {
          metadataEntity.expiresAt = generateAuthorityMetadataExpiresAt();
          metadataEntity.canonical_authority = this.canonicalAuthority;
        }
        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
        this.metadata = metadataEntity;
      }
      /**
       * Update AuthorityMetadataEntity with new endpoints and return where the information came from
       * @param metadataEntity
       */
      async updateEndpointMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
        if (localMetadata) {
          if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {
            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
              if (localMetadata.metadata) {
                const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
                metadataEntity.canonical_authority = this.canonicalAuthority;
              }
            }
          }
          return localMetadata.source;
        }
        let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
            metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
          }
          updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        } else {
          throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
        }
      }
      /**
       * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
       * response if the source is hardcoded metadata
       * @param metadataEntity
       * @returns
       */
      updateEndpointMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
        const configMetadata = this.getEndpointMetadataFromConfig();
        if (configMetadata) {
          this.logger.verbose("Found endpoint metadata in authority configuration");
          updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
          return {
            source: AuthorityMetadataSource.CONFIG
          };
        }
        this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
        if (this.authorityOptions.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
          if (hardcodedMetadata) {
            updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
            return {
              source: AuthorityMetadataSource.HARDCODED_VALUES,
              metadata: hardcodedMetadata
            };
          } else {
            this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
          }
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found endpoint metadata in the cache.");
          return { source: AuthorityMetadataSource.CACHE };
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Compares the number of url components after the domain to determine if the cached
       * authority metadata can be used for the requested authority. Protects against same domain different
       * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
       * @param metadataEntity
       */
      isAuthoritySameType(metadataEntity) {
        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
      }
      /**
       * Parse authorityMetadata config option
       */
      getEndpointMetadataFromConfig() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata);
          } catch (e) {
            throw createClientConfigurationError(invalidAuthorityMetadata);
          }
        }
        return null;
      }
      /**
       * Gets OAuth endpoints from the given OpenID configuration endpoint.
       *
       * @param hasHardcodedMetadata boolean
       */
      async getEndpointMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
        const options = {};
        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
          const isValidResponse = isOpenIdConfigResponse(response.body);
          if (isValidResponse) {
            return response.body;
          } else {
            this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
            return null;
          }
        } catch (e) {
          this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
          return null;
        }
      }
      /**
       * Get OAuth endpoints for common authorities.
       */
      getEndpointMetadataFromHardcodedValues() {
        if (this.hostnameAndPort in EndpointMetadata) {
          return EndpointMetadata[this.hostnameAndPort];
        }
        return null;
      }
      /**
       * Update the retrieved metadata with regional information.
       * User selected Azure region will be used if configured.
       */
      async updateMetadataWithRegionalInformation(metadata) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
        const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;
        if (userConfiguredAzureRegion) {
          if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
            this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
            return _Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
          }
          const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration?.environmentRegion, this.regionDiscoveryMetadata);
          if (autodetectedRegionName) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
            this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
            return _Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
          }
          this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
        }
        return metadata;
      }
      /**
       * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
       * and returns where the information was retrieved from
       * @param metadataEntity
       * @returns AuthorityMetadataSource
       */
      async updateCloudDiscoveryMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
        const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
        if (localMetadataSource) {
          return localMetadataSource;
        }
        const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        }
        throw createClientConfigurationError(untrustedAuthority);
      }
      updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);
        const metadata = this.getCloudDiscoveryMetadataFromConfig();
        if (metadata) {
          this.logger.verbose("Found cloud discovery metadata in authority configuration");
          updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
          return AuthorityMetadataSource.CONFIG;
        }
        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
        if (this.options.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
          if (hardcodedMetadata) {
            this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
            updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
            return AuthorityMetadataSource.HARDCODED_VALUES;
          }
          this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found cloud discovery metadata in the cache.");
          return AuthorityMetadataSource.CACHE;
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Parse cloudDiscoveryMetadata config or check knownAuthorities
       */
      getCloudDiscoveryMetadataFromConfig() {
        if (this.authorityType === AuthorityType.Ciam) {
          this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
          try {
            this.logger.verbose("Attempting to parse the cloud discovery metadata.");
            const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
            this.logger.verbose("Parsed the cloud discovery metadata.");
            if (metadata) {
              this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
              return metadata;
            } else {
              this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
            }
          } catch (e) {
            this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
            throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
          }
        }
        if (this.isInKnownAuthorities()) {
          this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
      }
      /**
       * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
       *
       * @param hasHardcodedMetadata boolean
       */
      async getCloudDiscoveryMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
        const options = {};
        let match = null;
        try {
          const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
          let typedResponseBody;
          let metadata;
          if (isCloudInstanceDiscoveryResponse(response.body)) {
            typedResponseBody = response.body;
            metadata = typedResponseBody.metadata;
            this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
          } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
            this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
            typedResponseBody = response.body;
            if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
              this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
              return null;
            }
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
            this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
            metadata = [];
          } else {
            this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
            return null;
          }
          this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
          match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
        } catch (error) {
          if (error instanceof AuthError) {
            this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.
Error: ${error.errorCode}
Error Description: ${error.errorMessage}`);
          } else {
            const typedError = error;
            this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.
Error: ${typedError.name}
Error Description: ${typedError.message}`);
          }
          return null;
        }
        if (!match) {
          this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
          this.logger.verbose("Creating custom Authority for custom domain scenario.");
          match = _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return match;
      }
      /**
       * Helper function to determine if this host is included in the knownAuthorities config option
       */
      isInKnownAuthorities() {
        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
          return authority && UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;
        });
        return matches.length > 0;
      }
      /**
       * helper function to populate the authority based on azureCloudOptions
       * @param authorityString
       * @param azureCloudOptions
       */
      static generateAuthority(authorityString, azureCloudOptions) {
        let authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
          const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
      }
      /**
       * Creates cloud discovery metadata object from a given host
       * @param host
       */
      static createCloudDiscoveryMetadataFromHost(host) {
        return {
          preferred_network: host,
          preferred_cache: host,
          aliases: [host]
        };
      }
      /**
       * helper function to generate environment from authority object
       */
      getPreferredCache() {
        if (this.managedIdentity) {
          return Constants.DEFAULT_AUTHORITY_HOST;
        } else if (this.discoveryComplete()) {
          return this.metadata.preferred_cache;
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns whether or not the provided host is an alias of this authority instance
       * @param host
       */
      isAlias(host) {
        return this.metadata.aliases.indexOf(host) > -1;
      }
      /**
       * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
       * @param host
       */
      isAliasOfKnownMicrosoftAuthority(host) {
        return InstanceDiscoveryMetadataAliases.has(host);
      }
      /**
       * Checks whether the provided host is that of a public cloud authority
       *
       * @param authority string
       * @returns bool
       */
      static isPublicCloudAuthority(host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
      }
      /**
       * Rebuild the authority string with the region
       *
       * @param host string
       * @param region string
       */
      static buildRegionalAuthorityString(host, region, queryString) {
        const authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        const authorityUrlParts = authorityUrlInstance.getUrlComponents();
        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
        }
        const url = UrlString.constructAuthorityUriFromObject({
          ...authorityUrlInstance.getUrlComponents(),
          HostNameAndPort: hostNameAndPort
        }).urlString;
        if (queryString)
          return `${url}?${queryString}`;
        return url;
      }
      /**
       * Replace the endpoints in the metadata object with their regional equivalents.
       *
       * @param metadata OpenIdConfigResponse
       * @param azureRegion string
       */
      static replaceWithRegionalInformation(metadata, azureRegion) {
        const regionalMetadata = { ...metadata };
        regionalMetadata.authorization_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
        regionalMetadata.token_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
        if (regionalMetadata.end_session_endpoint) {
          regionalMetadata.end_session_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
        }
        return regionalMetadata;
      }
      /**
       * Transform CIAM_AUTHORIY as per the below rules:
       * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
       *
       * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
       * `ciamlogin.com` can also change in the future and we should accommodate the same
       *
       * @param authority
       */
      static transformCIAMAuthority(authority) {
        let ciamAuthority = authority;
        const authorityUrl = new UrlString(authority);
        const authorityUrlComponents = authorityUrl.getUrlComponents();
        if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
          ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;
        }
        return ciamAuthority;
      }
    };
    Authority.reservedTenantDomains = /* @__PURE__ */ new Set([
      "{tenant}",
      "{tenantid}",
      AADAuthorityConstants.COMMON,
      AADAuthorityConstants.CONSUMERS,
      AADAuthorityConstants.ORGANIZATIONS
    ]);
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs
var AuthorityFactory_exports = {};
__export(AuthorityFactory_exports, {
  createDiscoveredInstance: () => createDiscoveredInstance
});
async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger26, correlationId, performanceClient) {
  performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
  const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
  const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger26, correlationId, performanceClient);
  try {
    await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger26, performanceClient, correlationId)();
    return acquireTokenAuthority;
  } catch (e) {
    throw createClientAuthError(endpointResolutionError);
  }
}
var init_AuthorityFactory = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs"() {
    "use strict";
    init_Authority();
    init_ClientAuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/client/BaseClient.mjs
var BaseClient;
var init_BaseClient = __esm({
  "node_modules/@azure/msal-common/dist/client/BaseClient.mjs"() {
    "use strict";
    init_ClientConfiguration();
    init_NetworkManager();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_CcsCredential();
    init_ClientInfo();
    init_RequestParameterBuilder();
    init_AuthorityFactory();
    init_PerformanceEvent();
    BaseClient = class {
      constructor(configuration, performanceClient) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name, version);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.networkManager = new NetworkManager(this.networkClient, this.cacheManager);
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority;
        this.performanceClient = performanceClient;
      }
      /**
       * Creates default headers for requests to token endpoint
       */
      createTokenRequestHeaders(ccsCred) {
        const headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
              break;
          }
        }
        return headers;
      }
      /**
       * Http post to token endpoint
       * @param tokenEndpoint
       * @param queryString
       * @param headers
       * @param thumbprint
       */
      async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
        if (queuedEvent) {
          this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);
        }
        const response = await this.networkManager.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers });
        this.performanceClient?.addFields({
          refreshTokenSize: response.body.refresh_token?.length || 0,
          httpVerToken: response.headers?.[HeaderNames.X_MS_HTTP_VERSION] || ""
        }, correlationId);
        if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
          this.config.serverTelemetryManager.clearTelemetryCache();
        }
        return response;
      }
      /**
       * Updates the authority object of the client. Endpoint discovery must be completed.
       * @param updatedAuthority
       */
      async updateAuthority(cloudInstanceHostname, correlationId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
        const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
        this.authority = cloudInstanceAuthority;
      }
      /**
       * Creates query string for the /token request
       * @param request
       */
      createTokenQueryParameters(request3) {
        const parameterBuilder = new RequestParameterBuilder();
        if (request3.tokenQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request3.tokenQueryParameters);
        }
        return parameterBuilder.createQueryString();
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs
var InteractionRequiredAuthErrorCodes_exports = {};
__export(InteractionRequiredAuthErrorCodes_exports, {
  badToken: () => badToken,
  consentRequired: () => consentRequired,
  interactionRequired: () => interactionRequired,
  loginRequired: () => loginRequired,
  nativeAccountUnavailable: () => nativeAccountUnavailable,
  noTokensFound: () => noTokensFound,
  refreshTokenExpired: () => refreshTokenExpired
});
var noTokensFound, nativeAccountUnavailable, refreshTokenExpired, interactionRequired, consentRequired, loginRequired, badToken;
var init_InteractionRequiredAuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs"() {
    "use strict";
    noTokensFound = "no_tokens_found";
    nativeAccountUnavailable = "native_account_unavailable";
    refreshTokenExpired = "refresh_token_expired";
    interactionRequired = "interaction_required";
    consentRequired = "consent_required";
    loginRequired = "login_required";
    badToken = "bad_token";
  }
});

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs
function isInteractionRequiredError(errorCode, errorString, subError) {
  const isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
  const isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
  const isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some((irErrorCode) => {
    return errorString.indexOf(irErrorCode) > -1;
  });
  return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
}
function createInteractionRequiredAuthError(errorCode) {
  return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
}
var InteractionRequiredServerErrorMessage, InteractionRequiredAuthSubErrorMessage, InteractionRequiredAuthErrorMessages, InteractionRequiredAuthErrorMessage, InteractionRequiredAuthError;
var init_InteractionRequiredAuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs"() {
    "use strict";
    init_Constants();
    init_AuthError();
    init_InteractionRequiredAuthErrorCodes();
    InteractionRequiredServerErrorMessage = [
      interactionRequired,
      consentRequired,
      loginRequired,
      badToken
    ];
    InteractionRequiredAuthSubErrorMessage = [
      "message_only",
      "additional_action",
      "basic_action",
      "user_password_expired",
      "consent_required",
      "bad_token"
    ];
    InteractionRequiredAuthErrorMessages = {
      [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
      [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
      [refreshTokenExpired]: "Refresh token has expired.",
      [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve."
    };
    InteractionRequiredAuthErrorMessage = {
      noTokensFoundError: {
        code: noTokensFound,
        desc: InteractionRequiredAuthErrorMessages[noTokensFound]
      },
      native_account_unavailable: {
        code: nativeAccountUnavailable,
        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable]
      },
      bad_token: {
        code: badToken,
        desc: InteractionRequiredAuthErrorMessages[badToken]
      }
    };
    InteractionRequiredAuthError = class _InteractionRequiredAuthError extends AuthError {
      constructor(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims, errorNo) {
        super(errorCode, errorMessage, subError);
        Object.setPrototypeOf(this, _InteractionRequiredAuthError.prototype);
        this.timestamp = timestamp || Constants.EMPTY_STRING;
        this.traceId = traceId || Constants.EMPTY_STRING;
        this.correlationId = correlationId || Constants.EMPTY_STRING;
        this.claims = claims || Constants.EMPTY_STRING;
        this.name = "InteractionRequiredAuthError";
        this.errorNo = errorNo;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs
var ProtocolUtils;
var init_ProtocolUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs"() {
    "use strict";
    init_Constants();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    ProtocolUtils = class _ProtocolUtils {
      /**
       * Appends user state with random guid, or returns random guid.
       * @param userState
       * @param randomGuid
       */
      static setRequestState(cryptoObj, userState, meta) {
        const libraryState = _ProtocolUtils.generateLibraryState(cryptoObj, meta);
        return userState ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;
      }
      /**
       * Generates the state value used by the common library.
       * @param randomGuid
       * @param cryptoObj
       */
      static generateLibraryState(cryptoObj, meta) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        const stateObj = {
          id: cryptoObj.createNewGuid()
        };
        if (meta) {
          stateObj.meta = meta;
        }
        const stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
      }
      /**
       * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
       * @param state
       * @param cryptoObj
       */
      static parseRequestState(cryptoObj, state3) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        if (!state3) {
          throw createClientAuthError(invalidState);
        }
        try {
          const splitState = state3.split(Constants.RESOURCE_DELIM);
          const libraryState = splitState[0];
          const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
          const libraryStateString = cryptoObj.base64Decode(libraryState);
          const libraryStateObj = JSON.parse(libraryStateString);
          return {
            userRequestState: userState || Constants.EMPTY_STRING,
            libraryState: libraryStateObj
          };
        } catch (e) {
          throw createClientAuthError(invalidState);
        }
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs
var KeyLocation, PopTokenGenerator;
var init_PopTokenGenerator = __esm({
  "node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs"() {
    "use strict";
    init_TimeUtils();
    init_UrlString();
    init_PerformanceEvent();
    init_FunctionWrappers();
    KeyLocation = {
      SW: "sw",
      UHW: "uhw"
    };
    PopTokenGenerator = class {
      constructor(cryptoUtils, performanceClient) {
        this.cryptoUtils = cryptoUtils;
        this.performanceClient = performanceClient;
      }
      /**
       * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
       * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
       * @param request
       * @returns
       */
      async generateCnf(request3, logger26) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request3.correlationId);
        const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger26, this.performanceClient, request3.correlationId)(request3);
        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
        return {
          kid: reqCnf.kid,
          reqCnfString
        };
      }
      /**
       * Generates key_id for a SHR token request
       * @param request
       * @returns
       */
      async generateKid(request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request3.correlationId);
        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request3);
        return {
          kid: kidThumbprint,
          xms_ksl: KeyLocation.SW
        };
      }
      /**
       * Signs the POP access_token with the local generated key-pair
       * @param accessToken
       * @param request
       * @returns
       */
      async signPopToken(accessToken, keyId, request3) {
        return this.signPayload(accessToken, keyId, request3);
      }
      /**
       * Utility function to generate the signed JWT for an access_token
       * @param payload
       * @param kid
       * @param request
       * @param claims
       * @returns
       */
      async signPayload(payload, keyId, request3, claims) {
        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions } = request3;
        const resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
        const resourceUrlComponents = resourceUrlString?.getUrlComponents();
        return this.cryptoUtils.signJwt({
          at: payload,
          ts: nowSeconds(),
          m: resourceRequestMethod?.toUpperCase(),
          u: resourceUrlComponents?.HostNameAndPort,
          nonce: shrNonce || this.cryptoUtils.createNewGuid(),
          p: resourceUrlComponents?.AbsolutePath,
          q: resourceUrlComponents?.QueryString ? [[], resourceUrlComponents.QueryString] : void 0,
          client_claims: shrClaims || void 0,
          ...claims
        }, keyId, shrOptions, request3.correlationId);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs
var TokenCacheContext;
var init_TokenCacheContext = __esm({
  "node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs"() {
    "use strict";
    TokenCacheContext = class {
      constructor(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
      }
      /**
       * boolean which indicates the changes in cache
       */
      get cacheHasChanged() {
        return this.hasChanged;
      }
      /**
       * function to retrieve the token cache
       */
      get tokenCache() {
        return this.cache;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs
function parseServerErrorNo(serverResponse) {
  const errorCodePrefix = "code=";
  const errorCodePrefixIndex = serverResponse.error_uri?.lastIndexOf(errorCodePrefix);
  return errorCodePrefixIndex && errorCodePrefixIndex >= 0 ? serverResponse.error_uri?.substring(errorCodePrefixIndex + errorCodePrefix.length) : void 0;
}
function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger26) {
  logger26?.verbose("setCachedAccount called");
  const accountKeys = cacheStorage.getAccountKeys();
  const baseAccountKey = accountKeys.find((accountKey) => {
    return accountKey.startsWith(homeAccountId);
  });
  let cachedAccount = null;
  if (baseAccountKey) {
    cachedAccount = cacheStorage.getAccount(baseAccountKey, logger26);
  }
  const baseAccount = cachedAccount || AccountEntity.createAccount({
    homeAccountId,
    idTokenClaims,
    clientInfo,
    environment,
    cloudGraphHostName: authCodePayload?.cloud_graph_host_name,
    msGraphHost: authCodePayload?.msgraph_host,
    nativeAccountId
  }, authority, base64Decode);
  const tenantProfiles = baseAccount.tenantProfiles || [];
  const tenantId = claimsTenantId || baseAccount.realm;
  if (tenantId && !tenantProfiles.find((tenantProfile) => {
    return tenantProfile.tenantId === tenantId;
  })) {
    const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
    tenantProfiles.push(newTenantProfile);
  }
  baseAccount.tenantProfiles = tenantProfiles;
  return baseAccount;
}
var ResponseHandler;
var init_ResponseHandler = __esm({
  "node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ServerError();
    init_ScopeSet();
    init_AccountEntity();
    init_InteractionRequiredAuthError();
    init_ProtocolUtils();
    init_Constants();
    init_PopTokenGenerator();
    init_TokenCacheContext();
    init_PerformanceEvent();
    init_AuthToken();
    init_TokenClaims();
    init_AccountInfo();
    init_CacheHelpers();
    init_ClientAuthErrorCodes();
    ResponseHandler = class _ResponseHandler {
      constructor(clientId, cacheStorage, cryptoObj, logger26, serializableCache, persistencePlugin, performanceClient) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger26;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
        this.performanceClient = performanceClient;
      }
      /**
       * Function which validates server authorization code response.
       * @param serverResponseHash
       * @param requestState
       * @param cryptoObj
       */
      validateServerAuthorizationCodeResponse(serverResponse, requestState) {
        if (!serverResponse.state || !requestState) {
          throw serverResponse.state ? createClientAuthError(stateNotFound, "Cached State") : createClientAuthError(stateNotFound, "Server State");
        }
        let decodedServerResponseState;
        let decodedRequestState;
        try {
          decodedServerResponseState = decodeURIComponent(serverResponse.state);
        } catch (e) {
          throw createClientAuthError(invalidState, serverResponse.state);
        }
        try {
          decodedRequestState = decodeURIComponent(requestState);
        } catch (e) {
          throw createClientAuthError(invalidState, serverResponse.state);
        }
        if (decodedServerResponseState !== decodedRequestState) {
          throw createClientAuthError(stateMismatch);
        }
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          const serverErrorNo = parseServerErrorNo(serverResponse);
          if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || "", serverResponse.trace_id || "", serverResponse.correlation_id || "", serverResponse.claims || "", serverErrorNo);
          }
          throw new ServerError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverErrorNo);
        }
      }
      /**
       * Function which validates server authorization token response.
       * @param serverResponse
       * @param refreshAccessToken
       */
      validateTokenResponse(serverResponse, refreshAccessToken) {
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          const errString = `Error(s): ${serverResponse.error_codes || Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants.NOT_AVAILABLE}`;
          const serverErrorNo = serverResponse.error_codes?.length ? serverResponse.error_codes[0] : void 0;
          const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
          if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.
${serverError}`);
            return;
          } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.
${serverError}`);
            return;
          }
          if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING, serverErrorNo);
          }
          throw serverError;
        }
      }
      /**
       * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
       * @param serverTokenResponse
       * @param authority
       */
      async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request3, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
        let idTokenClaims;
        if (serverTokenResponse.id_token) {
          idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);
          if (authCodePayload && authCodePayload.nonce) {
            if (idTokenClaims.nonce !== authCodePayload.nonce) {
              throw createClientAuthError(nonceMismatch);
            }
          }
          if (request3.maxAge || request3.maxAge === 0) {
            const authTime = idTokenClaims.auth_time;
            if (!authTime) {
              throw createClientAuthError(authTimeNotFound);
            }
            checkMaxAge(authTime, request3.maxAge);
          }
        }
        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
        let requestStateObj;
        if (!!authCodePayload && !!authCodePayload.state) {
          requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
        }
        serverTokenResponse.key_id = serverTokenResponse.key_id || request3.sshKid || void 0;
        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request3, idTokenClaims, userAssertionHash, authCodePayload);
        let cacheContext;
        try {
          if (this.persistencePlugin && this.serializableCache) {
            this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
            cacheContext = new TokenCacheContext(this.serializableCache, true);
            await this.persistencePlugin.beforeCacheAccess(cacheContext);
          }
          if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
            const key = cacheRecord.account.generateAccountKey();
            const account = this.cacheStorage.getAccount(key, this.logger);
            if (!account) {
              this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
              return await _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request3, idTokenClaims, requestStateObj, void 0, serverRequestId);
            }
          }
          await this.cacheStorage.saveCacheRecord(cacheRecord, request3.storeInCache, request3.correlationId);
        } finally {
          if (this.persistencePlugin && this.serializableCache && cacheContext) {
            this.logger.verbose("Persistence enabled, calling afterCacheAccess");
            await this.persistencePlugin.afterCacheAccess(cacheContext);
          }
        }
        return _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request3, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
      }
      /**
       * Generates CacheRecord
       * @param serverTokenResponse
       * @param idTokenObj
       * @param authority
       */
      generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request3, idTokenClaims, userAssertionHash, authCodePayload) {
        const env = authority.getPreferredCache();
        if (!env) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
        let cachedIdToken;
        let cachedAccount;
        if (serverTokenResponse.id_token && !!idTokenClaims) {
          cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
          cachedAccount = buildAccountToCache(
            this.cacheStorage,
            authority,
            this.homeAccountIdentifier,
            this.cryptoObj.base64Decode,
            idTokenClaims,
            serverTokenResponse.client_info,
            env,
            claimsTenantId,
            authCodePayload,
            void 0,
            // nativeAccountId
            this.logger
          );
        }
        let cachedAccessToken = null;
        if (serverTokenResponse.access_token) {
          const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request3.scopes || []);
          const expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
          const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
          const refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
          const tokenExpirationSeconds = reqTimestamp + expiresIn;
          const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
          cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request3.claims, request3.requestedClaimsHash);
        }
        let cachedRefreshToken = null;
        if (serverTokenResponse.refresh_token) {
          let rtExpiresOn;
          if (serverTokenResponse.refresh_token_expires_in) {
            const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === "string" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;
            rtExpiresOn = reqTimestamp + rtExpiresIn;
          }
          cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
        }
        let cachedAppMetadata = null;
        if (serverTokenResponse.foci) {
          cachedAppMetadata = {
            clientId: this.clientId,
            environment: env,
            familyId: serverTokenResponse.foci
          };
        }
        return {
          account: cachedAccount,
          idToken: cachedIdToken,
          accessToken: cachedAccessToken,
          refreshToken: cachedRefreshToken,
          appMetadata: cachedAppMetadata
        };
      }
      /**
       * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
       *
       * Optionally takes a state string that is set as-is in the response.
       *
       * @param cacheRecord
       * @param idTokenObj
       * @param fromTokenCache
       * @param stateString
       */
      static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request3, idTokenClaims, requestState, serverTokenResponse, requestId) {
        let accessToken = Constants.EMPTY_STRING;
        let responseScopes = [];
        let expiresOn = null;
        let extExpiresOn;
        let refreshOn;
        let familyId = Constants.EMPTY_STRING;
        if (cacheRecord.accessToken) {
          if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request3.popKid) {
            const popTokenGenerator = new PopTokenGenerator(cryptoObj);
            const { secret, keyId } = cacheRecord.accessToken;
            if (!keyId) {
              throw createClientAuthError(keyIdMissing);
            }
            accessToken = await popTokenGenerator.signPopToken(secret, keyId, request3);
          } else {
            accessToken = cacheRecord.accessToken.secret;
          }
          responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
          expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1e3);
          extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1e3);
          if (cacheRecord.accessToken.refreshOn) {
            refreshOn = new Date(Number(cacheRecord.accessToken.refreshOn) * 1e3);
          }
        }
        if (cacheRecord.appMetadata) {
          familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : "";
        }
        const uid = idTokenClaims?.oid || idTokenClaims?.sub || "";
        const tid = idTokenClaims?.tid || "";
        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {
          cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;
        }
        const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(
          cacheRecord.account.getAccountInfo(),
          void 0,
          // tenantProfile optional
          idTokenClaims,
          cacheRecord.idToken?.secret
        ) : null;
        return {
          authority: authority.canonicalAuthority,
          uniqueId: uid,
          tenantId: tid,
          scopes: responseScopes,
          account: accountInfo,
          idToken: cacheRecord?.idToken?.secret || "",
          idTokenClaims: idTokenClaims || {},
          accessToken,
          fromCache: fromTokenCache,
          expiresOn,
          extExpiresOn,
          refreshOn,
          correlationId: request3.correlationId,
          requestId: requestId || Constants.EMPTY_STRING,
          familyId,
          tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,
          state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
          cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,
          msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,
          code: serverTokenResponse?.spa_code,
          fromNativeBroker: false
        };
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs
async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
  if (typeof clientAssertion === "string") {
    return clientAssertion;
  } else {
    const config = {
      clientId,
      tokenEndpoint
    };
    return clientAssertion(config);
  }
}
var init_ClientAssertionUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs
var AuthorizationCodeClient;
var init_AuthorizationCodeClient = __esm({
  "node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs"() {
    "use strict";
    init_BaseClient();
    init_RequestParameterBuilder();
    init_Constants();
    init_AADServerParamKeys();
    init_ClientConfiguration();
    init_ResponseHandler();
    init_StringUtils();
    init_ClientAuthError();
    init_UrlString();
    init_PopTokenGenerator();
    init_TimeUtils();
    init_ClientInfo();
    init_CcsCredential();
    init_ClientConfigurationError();
    init_RequestValidator();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAssertionUtils();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    AuthorizationCodeClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
        this.includeRedirectUri = true;
        this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;
      }
      /**
       * Creates the URL of the authorization request letting the user input credentials and consent to the
       * application. The URL target the /authorize endpoint of the authority configured in the
       * application object.
       *
       * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
       * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
       * acquireToken(AuthorizationCodeRequest)
       * @param request
       */
      async getAuthCodeUrl(request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request3.correlationId);
        const queryString = await invokeAsync(this.createAuthCodeUrlQueryString.bind(this), PerformanceEvents.AuthClientCreateQueryString, this.logger, this.performanceClient, request3.correlationId)(request3);
        return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);
      }
      /**
       * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
       * authorization_code_grant
       * @param request
       */
      async acquireToken(request3, authCodePayload) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request3.correlationId);
        if (!request3.code) {
          throw createClientAuthError(requestCannotBeMade);
        }
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request3.correlationId)(this.authority, request3);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request3.correlationId)(response.body, this.authority, reqTimestamp, request3, authCodePayload, void 0, void 0, void 0, requestId);
      }
      /**
       * Handles the hash fragment response from public client code request. Returns a code response used by
       * the client to exchange for a token in acquireToken.
       * @param hashFragment
       */
      handleFragmentResponse(serverParams, cachedState) {
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);
        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState);
        if (!serverParams.code) {
          throw createClientAuthError(authorizationCodeMissingFromServerResponse);
        }
        return serverParams;
      }
      /**
       * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param authorityUri
       */
      getLogoutUri(logoutRequest) {
        if (!logoutRequest) {
          throw createClientConfigurationError(logoutRequestEmpty);
        }
        const queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
      }
      /**
       * Executes POST request to token endpoint
       * @param authority
       * @param request
       */
      async executeTokenRequest(authority, request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request3.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request3);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request3.correlationId)(request3);
        let ccsCredential = void 0;
        if (request3.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request3.clientInfo, this.cryptoUtils.base64Decode);
            ccsCredential = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        }
        const headers = this.createTokenRequestHeaders(ccsCredential || request3.ccsCredential);
        const thumbprint = {
          clientId: request3.tokenBodyParameters?.clientId || this.config.authOptions.clientId,
          authority: authority.canonicalAuthority,
          scopes: request3.scopes,
          claims: request3.claims,
          authenticationScheme: request3.authenticationScheme,
          resourceRequestMethod: request3.resourceRequestMethod,
          resourceRequestUri: request3.resourceRequestUri,
          shrClaims: request3.shrClaims,
          sshKid: request3.sshKid
        };
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request3.correlationId)(endpoint, requestBody, headers, thumbprint, request3.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request
       */
      async createTokenRequestBody(request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request3.correlationId);
        const parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(request3.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        if (!this.includeRedirectUri) {
          RequestValidator.validateRedirectUri(request3.redirectUri);
        } else {
          parameterBuilder.addRedirectUri(request3.redirectUri);
        }
        parameterBuilder.addScopes(request3.scopes, true, this.oidcDefaultScopes);
        parameterBuilder.addAuthorizationCode(request3.code);
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        if (request3.codeVerifier) {
          parameterBuilder.addCodeVerifier(request3.codeVerifier);
        }
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          parameterBuilder.addClientAssertion(await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request3.resourceRequestUri));
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);
        parameterBuilder.addClientInfo();
        if (request3.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request3.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request3.correlationId)(request3, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request3.popKid);
          }
          parameterBuilder.addPopToken(reqCnfData);
        } else if (request3.authenticationScheme === AuthenticationScheme.SSH) {
          if (request3.sshJwk) {
            parameterBuilder.addSshJwk(request3.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        const correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        let ccsCred = void 0;
        if (request3.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request3.clientInfo, this.cryptoUtils.base64Decode);
            ccsCred = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        } else {
          ccsCred = request3.ccsCredential;
        }
        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                parameterBuilder.addCcsOid(clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              parameterBuilder.addCcsUpn(ccsCred.credential);
              break;
          }
        }
        if (request3.tokenBodyParameters) {
          parameterBuilder.addExtraQueryParameters(request3.tokenBodyParameters);
        }
        if (request3.enableSpaAuthorizationCode && (!request3.tokenBodyParameters || !request3.tokenBodyParameters[RETURN_SPA_CODE])) {
          parameterBuilder.addExtraQueryParameters({
            [RETURN_SPA_CODE]: "1"
          });
        }
        return parameterBuilder.createQueryString();
      }
      /**
       * This API validates the `AuthorizationCodeUrlRequest` and creates a URL
       * @param request
       */
      async createAuthCodeUrlQueryString(request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request3.correlationId);
        const parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(request3.extraQueryParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        const requestScopes = [
          ...request3.scopes || [],
          ...request3.extraScopesToConsent || []
        ];
        parameterBuilder.addScopes(requestScopes, true, this.oidcDefaultScopes);
        parameterBuilder.addRedirectUri(request3.redirectUri);
        const correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        parameterBuilder.addResponseMode(request3.responseMode);
        parameterBuilder.addResponseTypeCode();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        if (!isOidcProtocolMode(this.config)) {
          parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        }
        parameterBuilder.addClientInfo();
        if (request3.codeChallenge && request3.codeChallengeMethod) {
          parameterBuilder.addCodeChallengeParams(request3.codeChallenge, request3.codeChallengeMethod);
        }
        if (request3.prompt) {
          parameterBuilder.addPrompt(request3.prompt);
        }
        if (request3.domainHint) {
          parameterBuilder.addDomainHint(request3.domainHint);
        }
        if (request3.prompt !== PromptValue.SELECT_ACCOUNT) {
          if (request3.sid && request3.prompt === PromptValue.NONE) {
            this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
            parameterBuilder.addSid(request3.sid);
          } else if (request3.account) {
            const accountSid = this.extractAccountSid(request3.account);
            let accountLoginHintClaim = this.extractLoginHint(request3.account);
            if (accountLoginHintClaim && request3.domainHint) {
              this.logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
              accountLoginHintClaim = null;
            }
            if (accountLoginHintClaim) {
              this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
              parameterBuilder.addLoginHint(accountLoginHintClaim);
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(request3.account.homeAccountId);
                parameterBuilder.addCcsOid(clientInfo);
              } catch (e) {
                this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
              }
            } else if (accountSid && request3.prompt === PromptValue.NONE) {
              this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
              parameterBuilder.addSid(accountSid);
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(request3.account.homeAccountId);
                parameterBuilder.addCcsOid(clientInfo);
              } catch (e) {
                this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
              }
            } else if (request3.loginHint) {
              this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
              parameterBuilder.addLoginHint(request3.loginHint);
              parameterBuilder.addCcsUpn(request3.loginHint);
            } else if (request3.account.username) {
              this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
              parameterBuilder.addLoginHint(request3.account.username);
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(request3.account.homeAccountId);
                parameterBuilder.addCcsOid(clientInfo);
              } catch (e) {
                this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
              }
            }
          } else if (request3.loginHint) {
            this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
            parameterBuilder.addLoginHint(request3.loginHint);
            parameterBuilder.addCcsUpn(request3.loginHint);
          }
        } else {
          this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
        }
        if (request3.nonce) {
          parameterBuilder.addNonce(request3.nonce);
        }
        if (request3.state) {
          parameterBuilder.addState(request3.state);
        }
        if (request3.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        this.addExtraQueryParams(request3, parameterBuilder);
        if (request3.nativeBroker) {
          parameterBuilder.addNativeBroker();
          if (request3.authenticationScheme === AuthenticationScheme.POP) {
            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
            let reqCnfData;
            if (!request3.popKid) {
              const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request3.correlationId)(request3, this.logger);
              reqCnfData = generatedReqCnfData.reqCnfString;
            } else {
              reqCnfData = this.cryptoUtils.encodeKid(request3.popKid);
            }
            parameterBuilder.addPopToken(reqCnfData);
          }
        }
        return parameterBuilder.createQueryString();
      }
      /**
       * This API validates the `EndSessionRequest` and creates a URL
       * @param request
       */
      createLogoutUrlQueryString(request3) {
        const parameterBuilder = new RequestParameterBuilder();
        if (request3.postLogoutRedirectUri) {
          parameterBuilder.addPostLogoutRedirectUri(request3.postLogoutRedirectUri);
        }
        if (request3.correlationId) {
          parameterBuilder.addCorrelationId(request3.correlationId);
        }
        if (request3.idTokenHint) {
          parameterBuilder.addIdTokenHint(request3.idTokenHint);
        }
        if (request3.state) {
          parameterBuilder.addState(request3.state);
        }
        if (request3.logoutHint) {
          parameterBuilder.addLogoutHint(request3.logoutHint);
        }
        this.addExtraQueryParams(request3, parameterBuilder);
        return parameterBuilder.createQueryString();
      }
      addExtraQueryParams(request3, parameterBuilder) {
        const hasRequestInstanceAware = request3.extraQueryParameters && request3.extraQueryParameters.hasOwnProperty("instance_aware");
        if (!hasRequestInstanceAware && this.config.authOptions.instanceAware) {
          request3.extraQueryParameters = request3.extraQueryParameters || {};
          request3.extraQueryParameters["instance_aware"] = "true";
        }
        if (request3.extraQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request3.extraQueryParameters);
        }
      }
      /**
       * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.
       * @param account
       */
      extractAccountSid(account) {
        return account.idTokenClaims?.sid || null;
      }
      extractLoginHint(account) {
        return account.idTokenClaims?.login_hint || null;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs
var DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS, RefreshTokenClient;
var init_RefreshTokenClient = __esm({
  "node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs"() {
    "use strict";
    init_ClientConfiguration();
    init_BaseClient();
    init_RequestParameterBuilder();
    init_Constants();
    init_AADServerParamKeys();
    init_ResponseHandler();
    init_PopTokenGenerator();
    init_StringUtils();
    init_ClientConfigurationError();
    init_ClientAuthError();
    init_ServerError();
    init_TimeUtils();
    init_UrlString();
    init_CcsCredential();
    init_ClientInfo();
    init_InteractionRequiredAuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_CacheHelpers();
    init_ClientAssertionUtils();
    init_ClientConfigurationErrorCodes();
    init_ClientAuthErrorCodes();
    init_InteractionRequiredAuthErrorCodes();
    DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300;
    RefreshTokenClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      async acquireToken(request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request3.correlationId);
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request3.correlationId)(request3, this.authority);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request3.correlationId)(response.body, this.authority, reqTimestamp, request3, void 0, void 0, true, request3.forceCache, requestId);
      }
      /**
       * Gets cached refresh token and attaches to request, then calls acquireToken API
       * @param request
       */
      async acquireTokenByRefreshToken(request3) {
        if (!request3) {
          throw createClientConfigurationError(tokenRequestEmpty);
        }
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request3.correlationId);
        if (!request3.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const isFOCI = this.cacheManager.isAppMetadataFOCI(request3.account.environment);
        if (isFOCI) {
          try {
            return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request3.correlationId)(request3, true);
          } catch (e) {
            const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;
            const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
            if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
              return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request3.correlationId)(request3, false);
            } else {
              throw e;
            }
          }
        }
        return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request3.correlationId)(request3, false);
      }
      /**
       * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
       * @param request
       */
      async acquireTokenWithCachedRefreshToken(request3, foci) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request3.correlationId);
        const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request3.correlationId)(request3.account, foci, void 0, this.performanceClient, request3.correlationId);
        if (!refreshToken) {
          throw createInteractionRequiredAuthError(noTokensFound);
        }
        if (refreshToken.expiresOn && isTokenExpired(refreshToken.expiresOn, request3.refreshTokenExpirationOffsetSeconds || DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {
          throw createInteractionRequiredAuthError(refreshTokenExpired);
        }
        const refreshTokenRequest = {
          ...request3,
          refreshToken: refreshToken.secret,
          authenticationScheme: request3.authenticationScheme || AuthenticationScheme.BEARER,
          ccsCredential: {
            credential: request3.account.homeAccountId,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          }
        };
        try {
          return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request3.correlationId)(refreshTokenRequest);
        } catch (e) {
          if (e instanceof InteractionRequiredAuthError && e.subError === badToken) {
            this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
            const badRefreshTokenKey = generateCredentialKey(refreshToken);
            this.cacheManager.removeRefreshToken(badRefreshTokenKey);
          }
          throw e;
        }
      }
      /**
       * Constructs the network message and makes a NW call to the underlying secure token service
       * @param request
       * @param authority
       */
      async executeTokenRequest(request3, authority) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request3.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request3);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request3.correlationId)(request3);
        const headers = this.createTokenRequestHeaders(request3.ccsCredential);
        const thumbprint = {
          clientId: request3.tokenBodyParameters?.clientId || this.config.authOptions.clientId,
          authority: authority.canonicalAuthority,
          scopes: request3.scopes,
          claims: request3.claims,
          authenticationScheme: request3.authenticationScheme,
          resourceRequestMethod: request3.resourceRequestMethod,
          resourceRequestUri: request3.resourceRequestUri,
          shrClaims: request3.shrClaims,
          sshKid: request3.sshKid
        };
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request3.correlationId)(endpoint, requestBody, headers, thumbprint, request3.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
      }
      /**
       * Helper function to create the token request body
       * @param request
       */
      async createTokenRequestBody(request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request3.correlationId);
        const correlationId = request3.correlationId;
        const parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(request3.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        if (request3.redirectUri) {
          parameterBuilder.addRedirectUri(request3.redirectUri);
        }
        parameterBuilder.addScopes(request3.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);
        parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        parameterBuilder.addCorrelationId(correlationId);
        parameterBuilder.addRefreshToken(request3.refreshToken);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          parameterBuilder.addClientAssertion(await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request3.resourceRequestUri));
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (request3.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request3.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request3.correlationId)(request3, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request3.popKid);
          }
          parameterBuilder.addPopToken(reqCnfData);
        } else if (request3.authenticationScheme === AuthenticationScheme.SSH) {
          if (request3.sshJwk) {
            parameterBuilder.addSshJwk(request3.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request3.ccsCredential) {
          switch (request3.ccsCredential.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(request3.ccsCredential.credential);
                parameterBuilder.addCcsOid(clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              parameterBuilder.addCcsUpn(request3.ccsCredential.credential);
              break;
          }
        }
        if (request3.tokenBodyParameters) {
          parameterBuilder.addExtraQueryParameters(request3.tokenBodyParameters);
        }
        return parameterBuilder.createQueryString();
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs
var SilentFlowClient;
var init_SilentFlowClient = __esm({
  "node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs"() {
    "use strict";
    init_BaseClient();
    init_TimeUtils();
    init_RefreshTokenClient();
    init_ClientAuthError();
    init_ResponseHandler();
    init_Constants();
    init_StringUtils();
    init_AuthToken();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_Authority();
    init_ClientAuthErrorCodes();
    SilentFlowClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      /**
       * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew
       * the given token and returns the renewed token
       * @param request
       */
      async acquireToken(request3) {
        try {
          const [authResponse, cacheOutcome] = await this.acquireCachedToken({
            ...request3,
            scopes: request3.scopes?.length ? request3.scopes : [...OIDC_DEFAULT_SCOPES]
          });
          if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
            this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
            const refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);
            refreshTokenClient.acquireTokenByRefreshToken(request3).catch(() => {
            });
          }
          return authResponse;
        } catch (e) {
          if (e instanceof ClientAuthError && e.errorCode === tokenRefreshRequired) {
            const refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);
            return refreshTokenClient.acquireTokenByRefreshToken(request3);
          } else {
            throw e;
          }
        }
      }
      /**
       * Retrieves token from cache or throws an error if it must be refreshed.
       * @param request
       */
      async acquireCachedToken(request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request3.correlationId);
        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
        if (request3.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request3.claims)) {
          this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request3.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        }
        if (!request3.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const requestTenantId = request3.account.tenantId || getTenantFromAuthorityString(request3.authority);
        const tokenKeys = this.cacheManager.getTokenKeys();
        const cachedAccessToken = this.cacheManager.getAccessToken(request3.account, request3, tokenKeys, requestTenantId, this.performanceClient, request3.correlationId);
        if (!cachedAccessToken) {
          this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request3.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (wasClockTurnedBack(cachedAccessToken.cachedAt) || isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
          this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request3.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {
          lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
        }
        const environment = request3.authority || this.authority.getPreferredCache();
        const cacheRecord = {
          account: this.cacheManager.readAccountFromCache(request3.account),
          accessToken: cachedAccessToken,
          idToken: this.cacheManager.getIdToken(request3.account, tokenKeys, requestTenantId, this.performanceClient, request3.correlationId),
          refreshToken: null,
          appMetadata: this.cacheManager.readAppMetadataFromCache(environment)
        };
        this.setCacheOutcome(lastCacheOutcome, request3.correlationId);
        if (this.config.serverTelemetryManager) {
          this.config.serverTelemetryManager.incrementCacheHits();
        }
        return [
          await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request3.correlationId)(cacheRecord, request3),
          lastCacheOutcome
        ];
      }
      setCacheOutcome(cacheOutcome, correlationId) {
        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);
        this.performanceClient?.addFields({
          cacheOutcome
        }, correlationId);
        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
          this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
        }
      }
      /**
       * Helper function to build response object from the CacheRecord
       * @param cacheRecord
       */
      async generateResultFromCacheRecord(cacheRecord, request3) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request3.correlationId);
        let idTokenClaims;
        if (cacheRecord.idToken) {
          idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
        }
        if (request3.maxAge || request3.maxAge === 0) {
          const authTime = idTokenClaims?.auth_time;
          if (!authTime) {
            throw createClientAuthError(authTimeNotFound);
          }
          checkMaxAge(authTime, request3.maxAge);
        }
        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request3, idTokenClaims);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs
function makeExtraSkuString(params) {
  const { skus, libraryName, libraryVersion, extensionName, extensionVersion } = params;
  const skuMap = /* @__PURE__ */ new Map([
    [0, [libraryName, libraryVersion]],
    [2, [extensionName, extensionVersion]]
  ]);
  let skuArr = [];
  if (skus?.length) {
    skuArr = skus.split(skuGroupSeparator);
    if (skuArr.length < 4) {
      return skus;
    }
  } else {
    skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
  }
  skuMap.forEach((value, key) => {
    if (value.length === 2 && value[0]?.length && value[1]?.length) {
      setSku({
        skuArr,
        index: key,
        skuName: value[0],
        skuVersion: value[1]
      });
    }
  });
  return skuArr.join(skuGroupSeparator);
}
function setSku(params) {
  const { skuArr, index, skuName, skuVersion } = params;
  if (index >= skuArr.length) {
    return;
  }
  skuArr[index] = [skuName, skuVersion].join(skuValueSeparator);
}
var skuGroupSeparator, skuValueSeparator, ServerTelemetryManager;
var init_ServerTelemetryManager = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs"() {
    "use strict";
    init_Constants();
    init_AuthError();
    skuGroupSeparator = ",";
    skuValueSeparator = "|";
    ServerTelemetryManager = class _ServerTelemetryManager {
      constructor(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
      }
      /**
       * API to add MSER Telemetry to request
       */
      generateCurrentRequestHeaderValue() {
        const request3 = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
        if (nativeBrokerErrorCode?.length) {
          platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
        }
        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const regionDiscoveryFields = this.getRegionDiscoveryFields();
        const requestWithRegionDiscoveryFields = [
          request3,
          regionDiscoveryFields
        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          requestWithRegionDiscoveryFields,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to add MSER Telemetry for the last failed request
       */
      generateLastRequestHeaderValue() {
        const lastRequests = this.getLastRequests();
        const maxErrors = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errorCount = lastRequests.errors.length;
        const overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          lastRequests.cacheHits,
          failedRequests,
          errors,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to cache token failures for MSER data capture
       * @param error
       */
      cacheFailedRequest(error) {
        const lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (error instanceof Error && !!error && error.toString()) {
          if (error instanceof AuthError) {
            if (error.subError) {
              lastRequests.errors.push(error.subError);
            } else if (error.errorCode) {
              lastRequests.errors.push(error.errorCode);
            } else {
              lastRequests.errors.push(error.toString());
            }
          } else {
            lastRequests.errors.push(error.toString());
          }
        } else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return;
      }
      /**
       * Update server telemetry cache entry by incrementing cache hit counter
       */
      incrementCacheHits() {
        const lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return lastRequests.cacheHits;
      }
      /**
       * Get the server telemetry entity from cache or initialize a new one
       */
      getLastRequests() {
        const initialValue = {
          failedRequests: [],
          errors: [],
          cacheHits: 0
        };
        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
      }
      /**
       * Remove server telemetry cache entry
       */
      clearTelemetryCache() {
        const lastRequests = this.getLastRequests();
        const numErrorsFlushed = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey);
        } else {
          const serverTelemEntity = {
            failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
            errors: lastRequests.errors.slice(numErrorsFlushed),
            cacheHits: 0
          };
          this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
        }
      }
      /**
       * Returns the maximum number of errors that can be flushed to the server in the next network request
       * @param serverTelemetryEntity
       */
      static maxErrorsToSend(serverTelemetryEntity) {
        let i;
        let maxErrors = 0;
        let dataSize = 0;
        const errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
          const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
          const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
          dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1;
          } else {
            break;
          }
        }
        return maxErrors;
      }
      /**
       * Get the region discovery fields
       *
       * @returns string
       */
      getRegionDiscoveryFields() {
        const regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
        return regionDiscoveryFields.join(",");
      }
      /**
       * Update the region discovery metadata
       *
       * @param regionDiscoveryMetadata
       * @returns void
       */
      updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
      }
      /**
       * Set cache outcome
       */
      setCacheOutcome(cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
      }
      setNativeBrokerErrorCode(errorCode) {
        const lastRequests = this.getLastRequests();
        lastRequests.nativeBrokerErrorCode = errorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
      }
      getNativeBrokerErrorCode() {
        return this.getLastRequests().nativeBrokerErrorCode;
      }
      clearNativeBrokerErrorCode() {
        const lastRequests = this.getLastRequests();
        delete lastRequests.nativeBrokerErrorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
      }
      static makeExtraSkuString(params) {
        return makeExtraSkuString(params);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/index-node.mjs
var init_index_node = __esm({
  "node_modules/@azure/msal-common/dist/index-node.mjs"() {
    "use strict";
    init_AuthorizationCodeClient();
    init_RefreshTokenClient();
    init_SilentFlowClient();
    init_BaseClient();
    init_CcsCredential();
    init_Authority();
    init_AuthorityOptions();
    init_ProtocolMode();
    init_CacheManager();
    init_AccountEntity();
    init_UrlString();
    init_ICrypto();
    init_RequestParameterBuilder();
    init_ResponseHandler();
    init_ScopeSet();
    init_Logger();
    init_InteractionRequiredAuthError();
    init_InteractionRequiredAuthErrorCodes();
    init_AuthError();
    init_AuthErrorCodes();
    init_ServerError();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationError();
    init_ClientConfigurationErrorCodes();
    init_Constants();
    init_StringUtils();
    init_ServerTelemetryManager();
    init_AuthToken();
    init_AuthorityFactory();
    init_CacheHelpers();
    init_TimeUtils();
    init_UrlUtils();
    init_AADServerParamKeys();
    init_TokenCacheContext();
    init_ClientAssertionUtils();
  }
});

// node_modules/@azure/msal-node/dist/cache/serializer/Deserializer.mjs
var Deserializer;
var init_Deserializer = __esm({
  "node_modules/@azure/msal-node/dist/cache/serializer/Deserializer.mjs"() {
    "use strict";
    init_index_node();
    Deserializer = class {
      /**
       * Parse the JSON blob in memory and deserialize the content
       * @param cachedJson
       */
      static deserializeJSONBlob(jsonFile) {
        const deserializedCache = !jsonFile ? {} : JSON.parse(jsonFile);
        return deserializedCache;
      }
      /**
       * Deserializes accounts to AccountEntity objects
       * @param accounts
       */
      static deserializeAccounts(accounts) {
        const accountObjects = {};
        if (accounts) {
          Object.keys(accounts).map(function(key) {
            const serializedAcc = accounts[key];
            const mappedAcc = {
              homeAccountId: serializedAcc.home_account_id,
              environment: serializedAcc.environment,
              realm: serializedAcc.realm,
              localAccountId: serializedAcc.local_account_id,
              username: serializedAcc.username,
              authorityType: serializedAcc.authority_type,
              name: serializedAcc.name,
              clientInfo: serializedAcc.client_info,
              lastModificationTime: serializedAcc.last_modification_time,
              lastModificationApp: serializedAcc.last_modification_app,
              tenantProfiles: serializedAcc.tenantProfiles?.map((serializedTenantProfile) => {
                return JSON.parse(serializedTenantProfile);
              })
            };
            const account = new AccountEntity();
            CacheManager.toObject(account, mappedAcc);
            accountObjects[key] = account;
          });
        }
        return accountObjects;
      }
      /**
       * Deserializes id tokens to IdTokenEntity objects
       * @param idTokens
       */
      static deserializeIdTokens(idTokens) {
        const idObjects = {};
        if (idTokens) {
          Object.keys(idTokens).map(function(key) {
            const serializedIdT = idTokens[key];
            const idToken = {
              homeAccountId: serializedIdT.home_account_id,
              environment: serializedIdT.environment,
              credentialType: serializedIdT.credential_type,
              clientId: serializedIdT.client_id,
              secret: serializedIdT.secret,
              realm: serializedIdT.realm
            };
            idObjects[key] = idToken;
          });
        }
        return idObjects;
      }
      /**
       * Deserializes access tokens to AccessTokenEntity objects
       * @param accessTokens
       */
      static deserializeAccessTokens(accessTokens) {
        const atObjects = {};
        if (accessTokens) {
          Object.keys(accessTokens).map(function(key) {
            const serializedAT = accessTokens[key];
            const accessToken = {
              homeAccountId: serializedAT.home_account_id,
              environment: serializedAT.environment,
              credentialType: serializedAT.credential_type,
              clientId: serializedAT.client_id,
              secret: serializedAT.secret,
              realm: serializedAT.realm,
              target: serializedAT.target,
              cachedAt: serializedAT.cached_at,
              expiresOn: serializedAT.expires_on,
              extendedExpiresOn: serializedAT.extended_expires_on,
              refreshOn: serializedAT.refresh_on,
              keyId: serializedAT.key_id,
              tokenType: serializedAT.token_type,
              requestedClaims: serializedAT.requestedClaims,
              requestedClaimsHash: serializedAT.requestedClaimsHash,
              userAssertionHash: serializedAT.userAssertionHash
            };
            atObjects[key] = accessToken;
          });
        }
        return atObjects;
      }
      /**
       * Deserializes refresh tokens to RefreshTokenEntity objects
       * @param refreshTokens
       */
      static deserializeRefreshTokens(refreshTokens) {
        const rtObjects = {};
        if (refreshTokens) {
          Object.keys(refreshTokens).map(function(key) {
            const serializedRT = refreshTokens[key];
            const refreshToken = {
              homeAccountId: serializedRT.home_account_id,
              environment: serializedRT.environment,
              credentialType: serializedRT.credential_type,
              clientId: serializedRT.client_id,
              secret: serializedRT.secret,
              familyId: serializedRT.family_id,
              target: serializedRT.target,
              realm: serializedRT.realm
            };
            rtObjects[key] = refreshToken;
          });
        }
        return rtObjects;
      }
      /**
       * Deserializes appMetadata to AppMetaData objects
       * @param appMetadata
       */
      static deserializeAppMetadata(appMetadata) {
        const appMetadataObjects = {};
        if (appMetadata) {
          Object.keys(appMetadata).map(function(key) {
            const serializedAmdt = appMetadata[key];
            appMetadataObjects[key] = {
              clientId: serializedAmdt.client_id,
              environment: serializedAmdt.environment,
              familyId: serializedAmdt.family_id
            };
          });
        }
        return appMetadataObjects;
      }
      /**
       * Deserialize an inMemory Cache
       * @param jsonCache
       */
      static deserializeAllCache(jsonCache) {
        return {
          accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
          idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
          accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
          refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
          appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
        };
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/internals.mjs
var internals_exports = {};
__export(internals_exports, {
  Deserializer: () => Deserializer,
  Serializer: () => Serializer
});
var init_internals = __esm({
  "node_modules/@azure/msal-node/dist/internals.mjs"() {
    "use strict";
    init_Serializer();
    init_Deserializer();
  }
});

// node_modules/@azure/msal-node/dist/utils/Constants.mjs
var AUTHORIZATION_HEADER_NAME, METADATA_HEADER_NAME, APP_SERVICE_SECRET_HEADER_NAME, SERVICE_FABRIC_SECRET_HEADER_NAME, API_VERSION_QUERY_PARAMETER_NAME, RESOURCE_BODY_OR_QUERY_PARAMETER_NAME, DEFAULT_MANAGED_IDENTITY_ID, MANAGED_IDENTITY_DEFAULT_TENANT, DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY, ManagedIdentityEnvironmentVariableNames, ManagedIdentitySourceNames, ManagedIdentityIdType, HttpMethod, ProxyStatus, REGION_ENVIRONMENT_VARIABLE, RANDOM_OCTET_SIZE, Hash, CharSet, Constants2, ApiId, JwtConstants, LOOPBACK_SERVER_CONSTANTS, AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES, MANAGED_IDENTITY_MAX_RETRIES, MANAGED_IDENTITY_RETRY_DELAY, MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON;
var init_Constants2 = __esm({
  "node_modules/@azure/msal-node/dist/utils/Constants.mjs"() {
    "use strict";
    init_index_node();
    AUTHORIZATION_HEADER_NAME = "Authorization";
    METADATA_HEADER_NAME = "Metadata";
    APP_SERVICE_SECRET_HEADER_NAME = "X-IDENTITY-HEADER";
    SERVICE_FABRIC_SECRET_HEADER_NAME = "secret";
    API_VERSION_QUERY_PARAMETER_NAME = "api-version";
    RESOURCE_BODY_OR_QUERY_PARAMETER_NAME = "resource";
    DEFAULT_MANAGED_IDENTITY_ID = "system_assigned_managed_identity";
    MANAGED_IDENTITY_DEFAULT_TENANT = "managed_identity";
    DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY = `https://login.microsoftonline.com/${MANAGED_IDENTITY_DEFAULT_TENANT}/`;
    ManagedIdentityEnvironmentVariableNames = {
      AZURE_POD_IDENTITY_AUTHORITY_HOST: "AZURE_POD_IDENTITY_AUTHORITY_HOST",
      IDENTITY_ENDPOINT: "IDENTITY_ENDPOINT",
      IDENTITY_HEADER: "IDENTITY_HEADER",
      IDENTITY_SERVER_THUMBPRINT: "IDENTITY_SERVER_THUMBPRINT",
      IMDS_ENDPOINT: "IMDS_ENDPOINT",
      MSI_ENDPOINT: "MSI_ENDPOINT"
    };
    ManagedIdentitySourceNames = {
      APP_SERVICE: "AppService",
      AZURE_ARC: "AzureArc",
      CLOUD_SHELL: "CloudShell",
      DEFAULT_TO_IMDS: "DefaultToImds",
      IMDS: "Imds",
      SERVICE_FABRIC: "ServiceFabric"
    };
    ManagedIdentityIdType = {
      SYSTEM_ASSIGNED: "system-assigned",
      USER_ASSIGNED_CLIENT_ID: "user-assigned-client-id",
      USER_ASSIGNED_RESOURCE_ID: "user-assigned-resource-id",
      USER_ASSIGNED_OBJECT_ID: "user-assigned-object-id"
    };
    HttpMethod = {
      GET: "get",
      POST: "post"
    };
    ProxyStatus = {
      SUCCESS: HttpStatus.SUCCESS,
      SUCCESS_RANGE_START: HttpStatus.SUCCESS_RANGE_START,
      SUCCESS_RANGE_END: HttpStatus.SUCCESS_RANGE_END,
      SERVER_ERROR: HttpStatus.SERVER_ERROR
    };
    REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";
    RANDOM_OCTET_SIZE = 32;
    Hash = {
      SHA256: "sha256"
    };
    CharSet = {
      CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
    };
    Constants2 = {
      MSAL_SKU: "msal.js.node",
      JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
      AUTHORIZATION_PENDING: "authorization_pending",
      HTTP_PROTOCOL: "http://",
      LOCALHOST: "localhost"
    };
    ApiId = {
      acquireTokenSilent: 62,
      acquireTokenByUsernamePassword: 371,
      acquireTokenByDeviceCode: 671,
      acquireTokenByClientCredential: 771,
      acquireTokenByCode: 871,
      acquireTokenByRefreshToken: 872
    };
    JwtConstants = {
      ALGORITHM: "alg",
      RSA_256: "RS256",
      PSS_256: "PS256",
      X5T_256: "x5t#S256",
      X5T: "x5t",
      X5C: "x5c",
      AUDIENCE: "aud",
      EXPIRATION_TIME: "exp",
      ISSUER: "iss",
      SUBJECT: "sub",
      NOT_BEFORE: "nbf",
      JWT_ID: "jti"
    };
    LOOPBACK_SERVER_CONSTANTS = {
      INTERVAL_MS: 100,
      TIMEOUT_MS: 5e3
    };
    AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES = 4096;
    MANAGED_IDENTITY_MAX_RETRIES = 3;
    MANAGED_IDENTITY_RETRY_DELAY = 1e3;
    MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON = [
      HttpStatus.NOT_FOUND,
      HttpStatus.REQUEST_TIMEOUT,
      HttpStatus.TOO_MANY_REQUESTS,
      HttpStatus.SERVER_ERROR,
      HttpStatus.SERVICE_UNAVAILABLE,
      HttpStatus.GATEWAY_TIMEOUT
    ];
  }
});

// node_modules/@azure/msal-node/dist/utils/NetworkUtils.mjs
var NetworkUtils;
var init_NetworkUtils = __esm({
  "node_modules/@azure/msal-node/dist/utils/NetworkUtils.mjs"() {
    "use strict";
    NetworkUtils = class {
      static getNetworkResponse(headers, body, statusCode) {
        return {
          headers,
          body,
          status: statusCode
        };
      }
      /*
       * Utility function that converts a URL object into an ordinary options object as expected by the
       * http.request and https.request APIs.
       * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090
       */
      static urlToHttpOptions(url) {
        const options = {
          protocol: url.protocol,
          hostname: url.hostname && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
          hash: url.hash,
          search: url.search,
          pathname: url.pathname,
          path: `${url.pathname || ""}${url.search || ""}`,
          href: url.href
        };
        if (url.port !== "") {
          options.port = Number(url.port);
        }
        if (url.username || url.password) {
          options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;
        }
        return options;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/network/HttpClient.mjs
var import_http, import_https, HttpClient, networkRequestViaProxy, networkRequestViaHttps, parseBody;
var init_HttpClient = __esm({
  "node_modules/@azure/msal-node/dist/network/HttpClient.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    init_NetworkUtils();
    import_http = __toESM(require("http"), 1);
    import_https = __toESM(require("https"), 1);
    HttpClient = class {
      constructor(proxyUrl, customAgentOptions) {
        this.proxyUrl = proxyUrl || "";
        this.customAgentOptions = customAgentOptions || {};
      }
      /**
       * Http Get request
       * @param url
       * @param options
       */
      async sendGetRequestAsync(url, options, timeout) {
        if (this.proxyUrl) {
          return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.GET, options, this.customAgentOptions, timeout);
        } else {
          return networkRequestViaHttps(url, HttpMethod.GET, options, this.customAgentOptions, timeout);
        }
      }
      /**
       * Http Post request
       * @param url
       * @param options
       */
      async sendPostRequestAsync(url, options) {
        if (this.proxyUrl) {
          return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.POST, options, this.customAgentOptions);
        } else {
          return networkRequestViaHttps(url, HttpMethod.POST, options, this.customAgentOptions);
        }
      }
    };
    networkRequestViaProxy = (destinationUrlString, proxyUrlString, httpMethod, options, agentOptions, timeout) => {
      const destinationUrl = new URL(destinationUrlString);
      const proxyUrl = new URL(proxyUrlString);
      const headers = options?.headers || {};
      const tunnelRequestOptions = {
        host: proxyUrl.hostname,
        port: proxyUrl.port,
        method: "CONNECT",
        path: destinationUrl.hostname,
        headers
      };
      if (agentOptions && Object.keys(agentOptions).length) {
        tunnelRequestOptions.agent = new import_http.default.Agent(agentOptions);
      }
      let postRequestStringContent = "";
      if (httpMethod === HttpMethod.POST) {
        const body = options?.body || "";
        postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
      } else {
        if (timeout) {
          tunnelRequestOptions.timeout = timeout;
        }
      }
      const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` + postRequestStringContent + "\r\n";
      return new Promise((resolve, reject) => {
        const request3 = import_http.default.request(tunnelRequestOptions);
        if (timeout) {
          request3.on("timeout", () => {
            request3.destroy();
            reject(new Error("Request time out"));
          });
        }
        request3.end();
        request3.on("connect", (response, socket) => {
          const proxyStatusCode = response?.statusCode || ProxyStatus.SERVER_ERROR;
          if (proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START || proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END) {
            request3.destroy();
            socket.destroy();
            reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${response?.statusMessage || "Unknown"}`));
          }
          socket.write(outgoingRequestString);
          const data = [];
          socket.on("data", (chunk) => {
            data.push(chunk);
          });
          socket.on("end", () => {
            const dataString = Buffer.concat([...data]).toString();
            const dataStringArray = dataString.split("\r\n");
            const httpStatusCode = parseInt(dataStringArray[0].split(" ")[1]);
            const statusMessage = dataStringArray[0].split(" ").slice(2).join(" ");
            const body = dataStringArray[dataStringArray.length - 1];
            const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
            const entries = /* @__PURE__ */ new Map();
            headersArray.forEach((header) => {
              const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
              const headerKey = headerKeyValue[0];
              let headerValue = headerKeyValue[1];
              try {
                const object = JSON.parse(headerValue);
                if (object && typeof object === "object") {
                  headerValue = object;
                }
              } catch (e) {
              }
              entries.set(headerKey, headerValue);
            });
            const headers2 = Object.fromEntries(entries);
            const parsedHeaders = headers2;
            const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, parseBody(httpStatusCode, statusMessage, parsedHeaders, body), httpStatusCode);
            if ((httpStatusCode < HttpStatus.SUCCESS_RANGE_START || httpStatusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
            networkResponse.body["error"] !== Constants2.AUTHORIZATION_PENDING) {
              request3.destroy();
            }
            resolve(networkResponse);
          });
          socket.on("error", (chunk) => {
            request3.destroy();
            socket.destroy();
            reject(new Error(chunk.toString()));
          });
        });
        request3.on("error", (chunk) => {
          request3.destroy();
          reject(new Error(chunk.toString()));
        });
      });
    };
    networkRequestViaHttps = (urlString, httpMethod, options, agentOptions, timeout) => {
      const isPostRequest = httpMethod === HttpMethod.POST;
      const body = options?.body || "";
      const url = new URL(urlString);
      const headers = options?.headers || {};
      const customOptions = {
        method: httpMethod,
        headers,
        ...NetworkUtils.urlToHttpOptions(url)
      };
      if (agentOptions && Object.keys(agentOptions).length) {
        customOptions.agent = new import_https.default.Agent(agentOptions);
      }
      if (isPostRequest) {
        customOptions.headers = {
          ...customOptions.headers,
          "Content-Length": body.length
        };
      } else {
        if (timeout) {
          customOptions.timeout = timeout;
        }
      }
      return new Promise((resolve, reject) => {
        let request3;
        if (customOptions.protocol === "http:") {
          request3 = import_http.default.request(customOptions);
        } else {
          request3 = import_https.default.request(customOptions);
        }
        if (isPostRequest) {
          request3.write(body);
        }
        if (timeout) {
          request3.on("timeout", () => {
            request3.destroy();
            reject(new Error("Request time out"));
          });
        }
        request3.end();
        request3.on("response", (response) => {
          const headers2 = response.headers;
          const statusCode = response.statusCode;
          const statusMessage = response.statusMessage;
          const data = [];
          response.on("data", (chunk) => {
            data.push(chunk);
          });
          response.on("end", () => {
            const body2 = Buffer.concat([...data]).toString();
            const parsedHeaders = headers2;
            const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, parseBody(statusCode, statusMessage, parsedHeaders, body2), statusCode);
            if ((statusCode < HttpStatus.SUCCESS_RANGE_START || statusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
            networkResponse.body["error"] !== Constants2.AUTHORIZATION_PENDING) {
              request3.destroy();
            }
            resolve(networkResponse);
          });
        });
        request3.on("error", (chunk) => {
          request3.destroy();
          reject(new Error(chunk.toString()));
        });
      });
    };
    parseBody = (statusCode, statusMessage, headers, body) => {
      let parsedBody;
      try {
        parsedBody = JSON.parse(body);
      } catch (error) {
        let errorType;
        let errorDescriptionHelper;
        if (statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START && statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END) {
          errorType = "client_error";
          errorDescriptionHelper = "A client";
        } else if (statusCode >= HttpStatus.SERVER_ERROR_RANGE_START && statusCode <= HttpStatus.SERVER_ERROR_RANGE_END) {
          errorType = "server_error";
          errorDescriptionHelper = "A server";
        } else {
          errorType = "unknown_error";
          errorDescriptionHelper = "An unknown";
        }
        parsedBody = {
          error: errorType,
          error_description: `${errorDescriptionHelper} error occured.
Http status code: ${statusCode}
Http status message: ${statusMessage || "Unknown"}
Headers: ${JSON.stringify(headers)}`
        };
      }
      return parsedBody;
    };
  }
});

// node_modules/@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs
var invalidFileExtension, invalidFilePath, invalidManagedIdentityIdType, invalidSecret, missingId, networkUnavailable, platformNotSupported, unableToCreateAzureArc, unableToCreateCloudShell, unableToCreateSource, unableToReadSecretFile, userAssignedNotAvailableAtRuntime, wwwAuthenticateHeaderMissing, wwwAuthenticateHeaderUnsupportedFormat, MsiEnvironmentVariableUrlMalformedErrorCodes;
var init_ManagedIdentityErrorCodes = __esm({
  "node_modules/@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs"() {
    "use strict";
    init_Constants2();
    invalidFileExtension = "invalid_file_extension";
    invalidFilePath = "invalid_file_path";
    invalidManagedIdentityIdType = "invalid_managed_identity_id_type";
    invalidSecret = "invalid_secret";
    missingId = "missing_client_id";
    networkUnavailable = "network_unavailable";
    platformNotSupported = "platform_not_supported";
    unableToCreateAzureArc = "unable_to_create_azure_arc";
    unableToCreateCloudShell = "unable_to_create_cloud_shell";
    unableToCreateSource = "unable_to_create_source";
    unableToReadSecretFile = "unable_to_read_secret_file";
    userAssignedNotAvailableAtRuntime = "user_assigned_not_available_at_runtime";
    wwwAuthenticateHeaderMissing = "www_authenticate_header_missing";
    wwwAuthenticateHeaderUnsupportedFormat = "www_authenticate_header_unsupported_format";
    MsiEnvironmentVariableUrlMalformedErrorCodes = {
      [ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]: "azure_pod_identity_authority_host_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT]: "identity_endpoint_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT]: "imds_endpoint_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT]: "msi_endpoint_url_malformed"
    };
  }
});

// node_modules/@azure/msal-node/dist/error/ManagedIdentityError.mjs
function createManagedIdentityError(errorCode) {
  return new ManagedIdentityError(errorCode);
}
var ManagedIdentityErrorMessages, ManagedIdentityError;
var init_ManagedIdentityError = __esm({
  "node_modules/@azure/msal-node/dist/error/ManagedIdentityError.mjs"() {
    "use strict";
    init_index_node();
    init_ManagedIdentityErrorCodes();
    init_Constants2();
    ManagedIdentityErrorMessages = {
      [invalidFileExtension]: "The file path in the WWW-Authenticate header does not contain a .key file.",
      [invalidFilePath]: "The file path in the WWW-Authenticate header is not in a valid Windows or Linux Format.",
      [invalidManagedIdentityIdType]: "More than one ManagedIdentityIdType was provided.",
      [invalidSecret]: "The secret in the file on the file path in the WWW-Authenticate header is greater than 4096 bytes.",
      [platformNotSupported]: "The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.",
      [missingId]: "A ManagedIdentityId id was not provided.",
      [MsiEnvironmentVariableUrlMalformedErrorCodes.AZURE_POD_IDENTITY_AUTHORITY_HOST]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.IDENTITY_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.IMDS_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.MSI_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' environment variable is malformed.`,
      [networkUnavailable]: "Authentication unavailable. The request to the managed identity endpoint timed out.",
      [unableToCreateAzureArc]: "Azure Arc Managed Identities can only be system assigned.",
      [unableToCreateCloudShell]: "Cloud Shell Managed Identities can only be system assigned.",
      [unableToCreateSource]: "Unable to create a Managed Identity source based on environment variables.",
      [unableToReadSecretFile]: "Unable to read the secret file.",
      [userAssignedNotAvailableAtRuntime]: "Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.",
      [wwwAuthenticateHeaderMissing]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is missing.",
      [wwwAuthenticateHeaderUnsupportedFormat]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is in an unsupported format."
    };
    ManagedIdentityError = class _ManagedIdentityError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ManagedIdentityErrorMessages[errorCode]);
        this.name = "ManagedIdentityError";
        Object.setPrototypeOf(this, _ManagedIdentityError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/config/ManagedIdentityId.mjs
var ManagedIdentityId;
var init_ManagedIdentityId = __esm({
  "node_modules/@azure/msal-node/dist/config/ManagedIdentityId.mjs"() {
    "use strict";
    init_ManagedIdentityError();
    init_Constants2();
    init_ManagedIdentityErrorCodes();
    ManagedIdentityId = class {
      get id() {
        return this._id;
      }
      set id(value) {
        this._id = value;
      }
      get idType() {
        return this._idType;
      }
      set idType(value) {
        this._idType = value;
      }
      constructor(managedIdentityIdParams) {
        const userAssignedClientId = managedIdentityIdParams?.userAssignedClientId;
        const userAssignedResourceId = managedIdentityIdParams?.userAssignedResourceId;
        const userAssignedObjectId = managedIdentityIdParams?.userAssignedObjectId;
        if (userAssignedClientId) {
          if (userAssignedResourceId || userAssignedObjectId) {
            throw createManagedIdentityError(invalidManagedIdentityIdType);
          }
          this.id = userAssignedClientId;
          this.idType = ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID;
        } else if (userAssignedResourceId) {
          if (userAssignedClientId || userAssignedObjectId) {
            throw createManagedIdentityError(invalidManagedIdentityIdType);
          }
          this.id = userAssignedResourceId;
          this.idType = ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID;
        } else if (userAssignedObjectId) {
          if (userAssignedClientId || userAssignedResourceId) {
            throw createManagedIdentityError(invalidManagedIdentityIdType);
          }
          this.id = userAssignedObjectId;
          this.idType = ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID;
        } else {
          this.id = DEFAULT_MANAGED_IDENTITY_ID;
          this.idType = ManagedIdentityIdType.SYSTEM_ASSIGNED;
        }
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/retry/LinearRetryPolicy.mjs
var LinearRetryPolicy;
var init_LinearRetryPolicy = __esm({
  "node_modules/@azure/msal-node/dist/retry/LinearRetryPolicy.mjs"() {
    "use strict";
    LinearRetryPolicy = class {
      constructor(maxRetries, retryDelay, httpStatusCodesToRetryOn) {
        this.maxRetries = maxRetries;
        this.retryDelay = retryDelay;
        this.httpStatusCodesToRetryOn = httpStatusCodesToRetryOn;
      }
      retryAfterMillisecondsToSleep(retryHeader) {
        if (!retryHeader) {
          return 0;
        }
        let millisToSleep = Math.round(parseFloat(retryHeader) * 1e3);
        if (isNaN(millisToSleep)) {
          millisToSleep = Math.max(
            0,
            // .valueOf() is needed to subtract dates in TypeScript
            new Date(retryHeader).valueOf() - (/* @__PURE__ */ new Date()).valueOf()
          );
        }
        return millisToSleep;
      }
      async pauseForRetry(httpStatusCode, currentRetry, retryAfterHeader) {
        if (this.httpStatusCodesToRetryOn.includes(httpStatusCode) && currentRetry < this.maxRetries) {
          const retryAfterDelay = this.retryAfterMillisecondsToSleep(retryAfterHeader);
          await new Promise((resolve) => {
            return setTimeout(resolve, retryAfterDelay || this.retryDelay);
          });
          return true;
        }
        return false;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/network/HttpClientWithRetries.mjs
var HttpClientWithRetries;
var init_HttpClientWithRetries = __esm({
  "node_modules/@azure/msal-node/dist/network/HttpClientWithRetries.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    HttpClientWithRetries = class {
      constructor(httpClientNoRetries, retryPolicy2) {
        this.httpClientNoRetries = httpClientNoRetries;
        this.retryPolicy = retryPolicy2;
      }
      async sendNetworkRequestAsyncHelper(httpMethod, url, options) {
        if (httpMethod === HttpMethod.GET) {
          return this.httpClientNoRetries.sendGetRequestAsync(url, options);
        } else {
          return this.httpClientNoRetries.sendPostRequestAsync(url, options);
        }
      }
      async sendNetworkRequestAsync(httpMethod, url, options) {
        let response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);
        let currentRetry = 0;
        while (await this.retryPolicy.pauseForRetry(response.status, currentRetry, response.headers[HeaderNames.RETRY_AFTER])) {
          response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);
          currentRetry++;
        }
        return response;
      }
      async sendGetRequestAsync(url, options) {
        return this.sendNetworkRequestAsync(HttpMethod.GET, url, options);
      }
      async sendPostRequestAsync(url, options) {
        return this.sendNetworkRequestAsync(HttpMethod.POST, url, options);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/error/NodeAuthError.mjs
var NodeAuthErrorMessage, NodeAuthError;
var init_NodeAuthError = __esm({
  "node_modules/@azure/msal-node/dist/error/NodeAuthError.mjs"() {
    "use strict";
    init_index_node();
    NodeAuthErrorMessage = {
      invalidLoopbackAddressType: {
        code: "invalid_loopback_server_address_type",
        desc: "Loopback server address is not type string. This is unexpected."
      },
      unableToLoadRedirectUri: {
        code: "unable_to_load_redirectUrl",
        desc: "Loopback server callback was invoked without a url. This is unexpected."
      },
      noAuthCodeInResponse: {
        code: "no_auth_code_in_response",
        desc: "No auth code found in the server response. Please check your network trace to determine what happened."
      },
      noLoopbackServerExists: {
        code: "no_loopback_server_exists",
        desc: "No loopback server exists yet."
      },
      loopbackServerAlreadyExists: {
        code: "loopback_server_already_exists",
        desc: "Loopback server already exists. Cannot create another."
      },
      loopbackServerTimeout: {
        code: "loopback_server_timeout",
        desc: "Timed out waiting for auth code listener to be registered."
      },
      stateNotFoundError: {
        code: "state_not_found",
        desc: "State not found. Please verify that the request originated from msal."
      },
      thumbprintMissing: {
        code: "thumbprint_missing_from_client_certificate",
        desc: "Client certificate does not contain a SHA-1 or SHA-256 thumbprint."
      }
    };
    NodeAuthError = class _NodeAuthError extends AuthError {
      constructor(errorCode, errorMessage) {
        super(errorCode, errorMessage);
        this.name = "NodeAuthError";
      }
      /**
       * Creates an error thrown if loopback server address is of type string.
       */
      static createInvalidLoopbackAddressTypeError() {
        return new _NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server is unable to get a url.
       */
      static createUnableToLoadRedirectUrlError() {
        return new _NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
      }
      /**
       * Creates an error thrown if the server response does not contain an auth code.
       */
      static createNoAuthCodeInResponseError() {
        return new _NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server has not been spun up yet.
       */
      static createNoLoopbackServerExistsError() {
        return new _NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
      }
      /**
       * Creates an error thrown if a loopback server already exists when attempting to create another one.
       */
      static createLoopbackServerAlreadyExistsError() {
        return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server times out registering the auth code listener.
       */
      static createLoopbackServerTimeoutError() {
        return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
      }
      /**
       * Creates an error thrown when the state is not present.
       */
      static createStateNotFoundError() {
        return new _NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);
      }
      /**
       * Creates an error thrown when client certificate was provided, but neither the SHA-1 or SHA-256 thumbprints were provided
       */
      static createThumbprintMissingError() {
        return new _NodeAuthError(NodeAuthErrorMessage.thumbprintMissing.code, NodeAuthErrorMessage.thumbprintMissing.desc);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/config/Configuration.mjs
function buildAppConfiguration({ auth, broker, cache, system, telemetry }) {
  const systemOptions = {
    ...DEFAULT_SYSTEM_OPTIONS2,
    networkClient: new HttpClient(system?.proxyUrl, system?.customAgentOptions),
    loggerOptions: system?.loggerOptions || DEFAULT_LOGGER_OPTIONS,
    disableInternalRetries: system?.disableInternalRetries || false
  };
  if (!!auth.clientCertificate && !!!auth.clientCertificate.thumbprint && !!!auth.clientCertificate.thumbprintSha256) {
    throw NodeAuthError.createStateNotFoundError();
  }
  return {
    auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },
    broker: { ...broker },
    cache: { ...DEFAULT_CACHE_OPTIONS2, ...cache },
    system: { ...systemOptions, ...system },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS2, ...telemetry }
  };
}
function buildManagedIdentityConfiguration({ managedIdentityIdParams, system }) {
  const managedIdentityId = new ManagedIdentityId(managedIdentityIdParams);
  const loggerOptions = system?.loggerOptions || DEFAULT_LOGGER_OPTIONS;
  let networkClient;
  if (system?.networkClient) {
    networkClient = system.networkClient;
  } else {
    networkClient = new HttpClient(system?.proxyUrl, system?.customAgentOptions);
  }
  if (!system?.disableInternalRetries) {
    const linearRetryPolicy = new LinearRetryPolicy(MANAGED_IDENTITY_MAX_RETRIES, MANAGED_IDENTITY_RETRY_DELAY, MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON);
    networkClient = new HttpClientWithRetries(networkClient, linearRetryPolicy);
  }
  return {
    managedIdentityId,
    system: {
      loggerOptions,
      networkClient
    }
  };
}
var DEFAULT_AUTH_OPTIONS, DEFAULT_CACHE_OPTIONS2, DEFAULT_LOGGER_OPTIONS, DEFAULT_SYSTEM_OPTIONS2, DEFAULT_TELEMETRY_OPTIONS2;
var init_Configuration = __esm({
  "node_modules/@azure/msal-node/dist/config/Configuration.mjs"() {
    "use strict";
    init_index_node();
    init_HttpClient();
    init_ManagedIdentityId();
    init_Constants2();
    init_LinearRetryPolicy();
    init_HttpClientWithRetries();
    init_NodeAuthError();
    DEFAULT_AUTH_OPTIONS = {
      clientId: Constants.EMPTY_STRING,
      authority: Constants.DEFAULT_AUTHORITY,
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: Constants.EMPTY_STRING,
      clientCertificate: {
        thumbprint: Constants.EMPTY_STRING,
        thumbprintSha256: Constants.EMPTY_STRING,
        privateKey: Constants.EMPTY_STRING,
        x5c: Constants.EMPTY_STRING
      },
      knownAuthorities: [],
      cloudDiscoveryMetadata: Constants.EMPTY_STRING,
      authorityMetadata: Constants.EMPTY_STRING,
      clientCapabilities: [],
      protocolMode: ProtocolMode.AAD,
      azureCloudOptions: {
        azureCloudInstance: AzureCloudInstance.None,
        tenant: Constants.EMPTY_STRING
      },
      skipAuthorityMetadataCache: false
    };
    DEFAULT_CACHE_OPTIONS2 = {
      claimsBasedCachingEnabled: false
    };
    DEFAULT_LOGGER_OPTIONS = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: LogLevel.Info
    };
    DEFAULT_SYSTEM_OPTIONS2 = {
      loggerOptions: DEFAULT_LOGGER_OPTIONS,
      networkClient: new HttpClient(),
      proxyUrl: Constants.EMPTY_STRING,
      customAgentOptions: {},
      disableInternalRetries: false
    };
    DEFAULT_TELEMETRY_OPTIONS2 = {
      application: {
        appName: Constants.EMPTY_STRING,
        appVersion: Constants.EMPTY_STRING
      }
    };
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto2.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto2, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    "use strict";
    import_crypto2 = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-node/regex.js"() {
    "use strict";
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-node/validate.js"() {
    "use strict";
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    "use strict";
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    "use strict";
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    "use strict";
    init_v4();
  }
});

// node_modules/@azure/msal-node/dist/crypto/GuidGenerator.mjs
var GuidGenerator;
var init_GuidGenerator = __esm({
  "node_modules/@azure/msal-node/dist/crypto/GuidGenerator.mjs"() {
    "use strict";
    init_esm_node();
    GuidGenerator = class {
      /**
       *
       * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
       * uuidv4 generates guids from cryprtographically-string random
       */
      generateGuid() {
        return v4_default();
      }
      /**
       * verifies if a string is  GUID
       * @param guid
       */
      isGuid(guid) {
        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return regexGuid.test(guid);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/utils/EncodingUtils.mjs
var EncodingUtils;
var init_EncodingUtils = __esm({
  "node_modules/@azure/msal-node/dist/utils/EncodingUtils.mjs"() {
    "use strict";
    init_index_node();
    EncodingUtils = class _EncodingUtils {
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param str text
       */
      static base64Encode(str, encoding) {
        return Buffer.from(str, encoding).toString("base64");
      }
      /**
       * encode a URL
       * @param str
       */
      static base64EncodeUrl(str, encoding) {
        return _EncodingUtils.base64Encode(str, encoding).replace(/=/g, Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
      }
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param base64Str Base64 encoded text
       */
      static base64Decode(base64Str) {
        return Buffer.from(base64Str, "base64").toString("utf8");
      }
      /**
       * @param base64Str Base64 encoded Url
       */
      static base64DecodeUrl(base64Str) {
        let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");
        while (str.length % 4) {
          str += "=";
        }
        return _EncodingUtils.base64Decode(str);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/crypto/HashUtils.mjs
var import_crypto3, HashUtils;
var init_HashUtils = __esm({
  "node_modules/@azure/msal-node/dist/crypto/HashUtils.mjs"() {
    "use strict";
    init_Constants2();
    import_crypto3 = __toESM(require("crypto"), 1);
    HashUtils = class {
      /**
       * generate 'SHA256' hash
       * @param buffer
       */
      sha256(buffer) {
        return import_crypto3.default.createHash(Hash.SHA256).update(buffer).digest();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/crypto/PkceGenerator.mjs
var import_crypto4, PkceGenerator;
var init_PkceGenerator = __esm({
  "node_modules/@azure/msal-node/dist/crypto/PkceGenerator.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    init_EncodingUtils();
    init_HashUtils();
    import_crypto4 = __toESM(require("crypto"), 1);
    PkceGenerator = class {
      constructor() {
        this.hashUtils = new HashUtils();
      }
      /**
       * generates the codeVerfier and the challenge from the codeVerfier
       * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
       */
      async generatePkceCodes() {
        const verifier = this.generateCodeVerifier();
        const challenge = this.generateCodeChallengeFromVerifier(verifier);
        return { verifier, challenge };
      }
      /**
       * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
       */
      generateCodeVerifier() {
        const charArr = [];
        const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;
        while (charArr.length <= RANDOM_OCTET_SIZE) {
          const byte = import_crypto4.default.randomBytes(1)[0];
          if (byte >= maxNumber) {
            continue;
          }
          const index = byte % CharSet.CV_CHARSET.length;
          charArr.push(CharSet.CV_CHARSET[index]);
        }
        const verifier = charArr.join(Constants.EMPTY_STRING);
        return EncodingUtils.base64EncodeUrl(verifier);
      }
      /**
       * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
       * @param codeVerifier
       */
      generateCodeChallengeFromVerifier(codeVerifier) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString("base64"), "base64");
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/crypto/CryptoProvider.mjs
var CryptoProvider;
var init_CryptoProvider = __esm({
  "node_modules/@azure/msal-node/dist/crypto/CryptoProvider.mjs"() {
    "use strict";
    init_GuidGenerator();
    init_EncodingUtils();
    init_PkceGenerator();
    init_HashUtils();
    CryptoProvider = class {
      constructor() {
        this.pkceGenerator = new PkceGenerator();
        this.guidGenerator = new GuidGenerator();
        this.hashUtils = new HashUtils();
      }
      /**
       * base64 URL safe encoded string
       */
      base64UrlEncode() {
        throw new Error("Method not implemented.");
      }
      /**
       * Stringifies and base64Url encodes input public key
       * @param inputKid
       * @returns Base64Url encoded public key
       */
      encodeKid() {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a new random GUID - used to populate state and nonce.
       * @returns string (GUID)
       */
      createNewGuid() {
        return this.guidGenerator.generateGuid();
      }
      /**
       * Encodes input string to base64.
       * @param input - string to be encoded
       */
      base64Encode(input) {
        return EncodingUtils.base64Encode(input);
      }
      /**
       * Decodes input string from base64.
       * @param input - string to be decoded
       */
      base64Decode(input) {
        return EncodingUtils.base64Decode(input);
      }
      /**
       * Generates PKCE codes used in Authorization Code Flow.
       */
      generatePkceCodes() {
        return this.pkceGenerator.generatePkceCodes();
      }
      /**
       * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
       */
      getPublicKeyThumbprint() {
        throw new Error("Method not implemented.");
      }
      /**
       * Removes cryptographic keypair from key store matching the keyId passed in
       * @param kid
       */
      removeTokenBindingKey() {
        throw new Error("Method not implemented.");
      }
      /**
       * Removes all cryptographic keys from Keystore
       */
      clearKeystore() {
        throw new Error("Method not implemented.");
      }
      /**
       * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
       */
      signJwt() {
        throw new Error("Method not implemented.");
      }
      /**
       * Returns the SHA-256 hash of an input string
       */
      async hashString(plainText) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString("base64"), "base64");
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/cache/NodeStorage.mjs
var NodeStorage;
var init_NodeStorage = __esm({
  "node_modules/@azure/msal-node/dist/cache/NodeStorage.mjs"() {
    "use strict";
    init_index_node();
    init_Deserializer();
    init_Serializer();
    NodeStorage = class extends CacheManager {
      constructor(logger26, clientId, cryptoImpl, staticAuthorityOptions) {
        super(clientId, cryptoImpl, logger26, staticAuthorityOptions);
        this.cache = {};
        this.changeEmitters = [];
        this.logger = logger26;
      }
      /**
       * Queue up callbacks
       * @param func - a callback function for cache change indication
       */
      registerChangeEmitter(func) {
        this.changeEmitters.push(func);
      }
      /**
       * Invoke the callback when cache changes
       */
      emitChange() {
        this.changeEmitters.forEach((func) => func.call(null));
      }
      /**
       * Converts cacheKVStore to InMemoryCache
       * @param cache - key value store
       */
      cacheToInMemoryCache(cache) {
        const inMemoryCache = {
          accounts: {},
          idTokens: {},
          accessTokens: {},
          refreshTokens: {},
          appMetadata: {}
        };
        for (const key in cache) {
          const value = cache[key];
          if (typeof value !== "object") {
            continue;
          }
          if (value instanceof AccountEntity) {
            inMemoryCache.accounts[key] = value;
          } else if (CacheHelpers_exports.isIdTokenEntity(value)) {
            inMemoryCache.idTokens[key] = value;
          } else if (CacheHelpers_exports.isAccessTokenEntity(value)) {
            inMemoryCache.accessTokens[key] = value;
          } else if (CacheHelpers_exports.isRefreshTokenEntity(value)) {
            inMemoryCache.refreshTokens[key] = value;
          } else if (CacheHelpers_exports.isAppMetadataEntity(key, value)) {
            inMemoryCache.appMetadata[key] = value;
          } else {
            continue;
          }
        }
        return inMemoryCache;
      }
      /**
       * converts inMemoryCache to CacheKVStore
       * @param inMemoryCache - kvstore map for inmemory
       */
      inMemoryCacheToCache(inMemoryCache) {
        let cache = this.getCache();
        cache = {
          ...cache,
          ...inMemoryCache.accounts,
          ...inMemoryCache.idTokens,
          ...inMemoryCache.accessTokens,
          ...inMemoryCache.refreshTokens,
          ...inMemoryCache.appMetadata
        };
        return cache;
      }
      /**
       * gets the current in memory cache for the client
       */
      getInMemoryCache() {
        this.logger.trace("Getting in-memory cache");
        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
        return inMemoryCache;
      }
      /**
       * sets the current in memory cache for the client
       * @param inMemoryCache - key value map in memory
       */
      setInMemoryCache(inMemoryCache) {
        this.logger.trace("Setting in-memory cache");
        const cache = this.inMemoryCacheToCache(inMemoryCache);
        this.setCache(cache);
        this.emitChange();
      }
      /**
       * get the current cache key-value store
       */
      getCache() {
        this.logger.trace("Getting cache key-value store");
        return this.cache;
      }
      /**
       * sets the current cache (key value store)
       * @param cacheMap - key value map
       */
      setCache(cache) {
        this.logger.trace("Setting cache key value store");
        this.cache = cache;
        this.emitChange();
      }
      /**
       * Gets cache item with given key.
       * @param key - lookup key for the cache entry
       */
      getItem(key) {
        this.logger.tracePii(`Item key: ${key}`);
        const cache = this.getCache();
        return cache[key];
      }
      /**
       * Gets cache item with given key-value
       * @param key - lookup key for the cache entry
       * @param value - value of the cache entry
       */
      setItem(key, value) {
        this.logger.tracePii(`Item key: ${key}`);
        const cache = this.getCache();
        cache[key] = value;
        this.setCache(cache);
      }
      getAccountKeys() {
        const inMemoryCache = this.getInMemoryCache();
        const accountKeys = Object.keys(inMemoryCache.accounts);
        return accountKeys;
      }
      getTokenKeys() {
        const inMemoryCache = this.getInMemoryCache();
        const tokenKeys = {
          idToken: Object.keys(inMemoryCache.idTokens),
          accessToken: Object.keys(inMemoryCache.accessTokens),
          refreshToken: Object.keys(inMemoryCache.refreshTokens)
        };
        return tokenKeys;
      }
      /**
       * fetch the account entity
       * @param accountKey - lookup key to fetch cache type AccountEntity
       */
      getAccount(accountKey) {
        const accountEntity = this.getCachedAccountEntity(accountKey);
        if (accountEntity && AccountEntity.isAccountEntity(accountEntity)) {
          return this.updateOutdatedCachedAccount(accountKey, accountEntity);
        }
        return null;
      }
      /**
       * Reads account from cache, builds it into an account entity and returns it.
       * @param accountKey
       * @returns
       */
      getCachedAccountEntity(accountKey) {
        const cachedAccount = this.getItem(accountKey);
        return cachedAccount ? Object.assign(new AccountEntity(), this.getItem(accountKey)) : null;
      }
      /**
       * set account entity
       * @param account - cache value to be set of type AccountEntity
       */
      setAccount(account) {
        const accountKey = account.generateAccountKey();
        this.setItem(accountKey, account);
      }
      /**
       * fetch the idToken credential
       * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
       */
      getIdTokenCredential(idTokenKey) {
        const idToken = this.getItem(idTokenKey);
        if (CacheHelpers_exports.isIdTokenEntity(idToken)) {
          return idToken;
        }
        return null;
      }
      /**
       * set idToken credential
       * @param idToken - cache value to be set of type IdTokenEntity
       */
      setIdTokenCredential(idToken) {
        const idTokenKey = CacheHelpers_exports.generateCredentialKey(idToken);
        this.setItem(idTokenKey, idToken);
      }
      /**
       * fetch the accessToken credential
       * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
       */
      getAccessTokenCredential(accessTokenKey) {
        const accessToken = this.getItem(accessTokenKey);
        if (CacheHelpers_exports.isAccessTokenEntity(accessToken)) {
          return accessToken;
        }
        return null;
      }
      /**
       * set accessToken credential
       * @param accessToken -  cache value to be set of type AccessTokenEntity
       */
      setAccessTokenCredential(accessToken) {
        const accessTokenKey = CacheHelpers_exports.generateCredentialKey(accessToken);
        this.setItem(accessTokenKey, accessToken);
      }
      /**
       * fetch the refreshToken credential
       * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
       */
      getRefreshTokenCredential(refreshTokenKey) {
        const refreshToken = this.getItem(refreshTokenKey);
        if (CacheHelpers_exports.isRefreshTokenEntity(refreshToken)) {
          return refreshToken;
        }
        return null;
      }
      /**
       * set refreshToken credential
       * @param refreshToken - cache value to be set of type RefreshTokenEntity
       */
      setRefreshTokenCredential(refreshToken) {
        const refreshTokenKey = CacheHelpers_exports.generateCredentialKey(refreshToken);
        this.setItem(refreshTokenKey, refreshToken);
      }
      /**
       * fetch appMetadata entity from the platform cache
       * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
       */
      getAppMetadata(appMetadataKey) {
        const appMetadata = this.getItem(appMetadataKey);
        if (CacheHelpers_exports.isAppMetadataEntity(appMetadataKey, appMetadata)) {
          return appMetadata;
        }
        return null;
      }
      /**
       * set appMetadata entity to the platform cache
       * @param appMetadata - cache value to be set of type AppMetadataEntity
       */
      setAppMetadata(appMetadata) {
        const appMetadataKey = CacheHelpers_exports.generateAppMetadataKey(appMetadata);
        this.setItem(appMetadataKey, appMetadata);
      }
      /**
       * fetch server telemetry entity from the platform cache
       * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
       */
      getServerTelemetry(serverTelemetrykey) {
        const serverTelemetryEntity = this.getItem(serverTelemetrykey);
        if (serverTelemetryEntity && CacheHelpers_exports.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
          return serverTelemetryEntity;
        }
        return null;
      }
      /**
       * set server telemetry entity to the platform cache
       * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
       * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
       */
      setServerTelemetry(serverTelemetryKey, serverTelemetry) {
        this.setItem(serverTelemetryKey, serverTelemetry);
      }
      /**
       * fetch authority metadata entity from the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       */
      getAuthorityMetadata(key) {
        const authorityMetadataEntity = this.getItem(key);
        if (authorityMetadataEntity && CacheHelpers_exports.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {
          return authorityMetadataEntity;
        }
        return null;
      }
      /**
       * Get all authority metadata keys
       */
      getAuthorityMetadataKeys() {
        return this.getKeys().filter((key) => {
          return this.isAuthorityMetadata(key);
        });
      }
      /**
       * set authority metadata entity to the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       * @param metadata - cache value to be set of type AuthorityMetadataEntity
       */
      setAuthorityMetadata(key, metadata) {
        this.setItem(key, metadata);
      }
      /**
       * fetch throttling entity from the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       */
      getThrottlingCache(throttlingCacheKey) {
        const throttlingCache = this.getItem(throttlingCacheKey);
        if (throttlingCache && CacheHelpers_exports.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
          return throttlingCache;
        }
        return null;
      }
      /**
       * set throttling entity to the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       * @param throttlingCache - cache value to be set of type ThrottlingEntity
       */
      setThrottlingCache(throttlingCacheKey, throttlingCache) {
        this.setItem(throttlingCacheKey, throttlingCache);
      }
      /**
       * Removes the cache item from memory with the given key.
       * @param key - lookup key to remove a cache entity
       * @param inMemory - key value map of the cache
       */
      removeItem(key) {
        this.logger.tracePii(`Item key: ${key}`);
        let result = false;
        const cache = this.getCache();
        if (!!cache[key]) {
          delete cache[key];
          result = true;
        }
        if (result) {
          this.setCache(cache);
          this.emitChange();
        }
        return result;
      }
      /**
       * Remove account entity from the platform cache if it's outdated
       * @param accountKey
       */
      removeOutdatedAccount(accountKey) {
        this.removeItem(accountKey);
      }
      /**
       * Checks whether key is in cache.
       * @param key - look up key for a cache entity
       */
      containsKey(key) {
        return this.getKeys().includes(key);
      }
      /**
       * Gets all keys in window.
       */
      getKeys() {
        this.logger.trace("Retrieving all cache keys");
        const cache = this.getCache();
        return [...Object.keys(cache)];
      }
      /**
       * Clears all cache entries created by MSAL (except tokens).
       */
      async clear() {
        this.logger.trace("Clearing cache entries created by MSAL");
        const cacheKeys = this.getKeys();
        cacheKeys.forEach((key) => {
          this.removeItem(key);
        });
        this.emitChange();
      }
      /**
       * Initialize in memory cache from an exisiting cache vault
       * @param cache - blob formatted cache (JSON)
       */
      static generateInMemoryCache(cache) {
        return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
      }
      /**
       * retrieves the final JSON
       * @param inMemoryCache - itemised cache read from the JSON
       */
      static generateJsonCache(inMemoryCache) {
        return Serializer.serializeAllCache(inMemoryCache);
      }
      /**
       * Updates a credential's cache key if the current cache key is outdated
       */
      updateCredentialCacheKey(currentCacheKey, credential) {
        const updatedCacheKey = CacheHelpers_exports.generateCredentialKey(credential);
        if (currentCacheKey !== updatedCacheKey) {
          const cacheItem = this.getItem(currentCacheKey);
          if (cacheItem) {
            this.removeItem(currentCacheKey);
            this.setItem(updatedCacheKey, cacheItem);
            this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
            return updatedCacheKey;
          } else {
            this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
          }
        }
        return currentCacheKey;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/cache/TokenCache.mjs
var defaultSerializedCache, TokenCache;
var init_TokenCache = __esm({
  "node_modules/@azure/msal-node/dist/cache/TokenCache.mjs"() {
    "use strict";
    init_index_node();
    init_Deserializer();
    init_Serializer();
    defaultSerializedCache = {
      Account: {},
      IdToken: {},
      AccessToken: {},
      RefreshToken: {},
      AppMetadata: {}
    };
    TokenCache = class {
      constructor(storage, logger26, cachePlugin) {
        this.cacheHasChanged = false;
        this.storage = storage;
        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
        if (cachePlugin) {
          this.persistence = cachePlugin;
        }
        this.logger = logger26;
      }
      /**
       * Set to true if cache state has changed since last time serialize or writeToPersistence was called
       */
      hasChanged() {
        return this.cacheHasChanged;
      }
      /**
       * Serializes in memory cache to JSON
       */
      serialize() {
        this.logger.trace("Serializing in-memory cache");
        let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
        if (this.cacheSnapshot) {
          this.logger.trace("Reading cache snapshot from disk");
          finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
        } else {
          this.logger.trace("No cache snapshot to merge");
        }
        this.cacheHasChanged = false;
        return JSON.stringify(finalState);
      }
      /**
       * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
       * @param cache - blob formatted cache
       */
      deserialize(cache) {
        this.logger.trace("Deserializing JSON to in-memory cache");
        this.cacheSnapshot = cache;
        if (this.cacheSnapshot) {
          this.logger.trace("Reading cache snapshot from disk");
          const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
          this.storage.setInMemoryCache(deserializedCache);
        } else {
          this.logger.trace("No cache snapshot to deserialize");
        }
      }
      /**
       * Fetches the cache key-value map
       */
      getKVStore() {
        return this.storage.getCache();
      }
      /**
       * API that retrieves all accounts currently in cache to the user
       */
      async getAllAccounts() {
        this.logger.trace("getAllAccounts called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, true);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          return this.storage.getAllAccounts();
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId - unique identifier for an account (uid.utid)
       */
      async getAccountByHomeId(homeAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (homeAccountId && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null;
        } else {
          return null;
        }
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
       */
      async getAccountByLocalId(localAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (localAccountId && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null;
        } else {
          return null;
        }
      }
      /**
       * API to remove a specific account and the relevant data from cache
       * @param account - AccountInfo passed by the user
       */
      async removeAccount(account) {
        this.logger.trace("removeAccount called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, true);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Called when the cache has changed state.
       */
      handleChangeEvent() {
        this.cacheHasChanged = true;
      }
      /**
       * Merge in memory cache with the cache snapshot.
       * @param oldState - cache before changes
       * @param currentState - current cache state in the library
       */
      mergeState(oldState, currentState) {
        this.logger.trace("Merging in-memory cache with cache snapshot");
        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
        return this.mergeUpdates(stateAfterRemoval, currentState);
      }
      /**
       * Deep update of oldState based on newState values
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeUpdates(oldState, newState) {
        Object.keys(newState).forEach((newKey) => {
          const newValue = newState[newKey];
          if (!oldState.hasOwnProperty(newKey)) {
            if (newValue !== null) {
              oldState[newKey] = newValue;
            }
          } else {
            const newValueNotNull = newValue !== null;
            const newValueIsObject = typeof newValue === "object";
            const newValueIsNotArray = !Array.isArray(newValue);
            const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;
            if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
              this.mergeUpdates(oldState[newKey], newValue);
            } else {
              oldState[newKey] = newValue;
            }
          }
        });
        return oldState;
      }
      /**
       * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
       * oldState that are not recognized, they are left untouched.
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovals(oldState, newState) {
        this.logger.trace("Remove updated entries in cache");
        const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
        const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
        return {
          ...oldState,
          Account: accounts,
          AccessToken: accessTokens,
          RefreshToken: refreshTokens,
          IdToken: idTokens,
          AppMetadata: appMetadata
        };
      }
      /**
       * Helper to merge new cache with the old one
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovalsDict(oldState, newState) {
        const finalState = { ...oldState };
        Object.keys(oldState).forEach((oldKey) => {
          if (!newState || !newState.hasOwnProperty(oldKey)) {
            delete finalState[oldKey];
          }
        });
        return finalState;
      }
      /**
       * Helper to overlay as a part of cache merge
       * @param passedInCache - cache read from the blob
       */
      overlayDefaults(passedInCache) {
        this.logger.trace("Overlaying input cache with the default cache");
        return {
          Account: {
            ...defaultSerializedCache.Account,
            ...passedInCache.Account
          },
          IdToken: {
            ...defaultSerializedCache.IdToken,
            ...passedInCache.IdToken
          },
          AccessToken: {
            ...defaultSerializedCache.AccessToken,
            ...passedInCache.AccessToken
          },
          RefreshToken: {
            ...defaultSerializedCache.RefreshToken,
            ...passedInCache.RefreshToken
          },
          AppMetadata: {
            ...defaultSerializedCache.AppMetadata,
            ...passedInCache.AppMetadata
          }
        };
      }
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/jsonwebtoken/node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jsonwebtoken/node_modules/jws/lib/data-stream.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util2 = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util2.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jsonwebtoken/node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jsonwebtoken/node_modules/jwa/index.js"(exports2, module2) {
    "use strict";
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto4 = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util2 = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto4.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util2.format.bind(util2, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto4.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto4.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto4.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto4.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto4.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto4.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto4.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto4.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto4.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jsonwebtoken/node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jsonwebtoken/node_modules/jws/lib/tostring.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jsonwebtoken/node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jsonwebtoken/node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util2 = require("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util2.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util2.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util2.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jsonwebtoken/node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jsonwebtoken/node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util2 = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject2(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject2(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util2.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jsonwebtoken/node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jsonwebtoken/node_modules/jws/index.js"(exports2) {
    "use strict";
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    "use strict";
    var jws = require_jws();
    module2.exports = function(jwt2, options) {
      options = options || {};
      var decoded = jws.decode(jwt2, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    "use strict";
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    "use strict";
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    "use strict";
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    "use strict";
    var ms = require_ms();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name3, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name3, index, value);
      t[name3] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof _SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release2, identifier, identifierBase) {
        switch (release2) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release2}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = (version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse2;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var valid = (version3, options) => {
      const v = parse2(version3, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var clean = (version3, options) => {
      const s = parse2(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version3, release2, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release2, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var diff = (version1, version22) => {
      const v1 = parse2(version1, null, true);
      const v2 = parse2(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var prerelease = (version3, options) => {
      const parsed = parse2(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_2, M, m, p, pr) => {
        debug("tilde", comp, _2, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_2, M, m, p, pr) => {
        debug("caret", comp, _2, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version3, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version3, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions2, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions2.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions2, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions2.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version3, range, hilo, options) => {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version3, range, options) => outside(version3, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version3, range, options) => outside(version3, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions2, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions2.sort((a, b) => compare(a, b, options));
      for (const version3 of v) {
        const included = satisfies(version3, range, options);
        if (included) {
          prev = version3;
          if (!first) {
            first = version3;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants2 = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants2.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports2, module2) {
    "use strict";
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports2, module2) {
    "use strict";
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports2, module2) {
    "use strict";
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module2.exports = function(algorithm, key) {
      if (!algorithm || !key)
        return;
      const keyType = key.asymmetricKeyType;
      if (!keyType)
        return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    "use strict";
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    "use strict";
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require("crypto");
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_2) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_3) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    "use strict";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    "use strict";
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    "use strict";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    "use strict";
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    "use strict";
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    "use strict";
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    "use strict";
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    "use strict";
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey: createPrivateKey2 } = require("crypto");
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate2(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate2(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate2(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey2(secretOrPrivateKey);
        } catch (_2) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_3) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ClientAssertion.mjs
var import_jsonwebtoken, ClientAssertion;
var init_ClientAssertion = __esm({
  "node_modules/@azure/msal-node/dist/client/ClientAssertion.mjs"() {
    "use strict";
    import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
    init_index_node();
    init_EncodingUtils();
    init_Constants2();
    ClientAssertion = class _ClientAssertion {
      /**
       * Initialize the ClientAssertion class from the clientAssertion passed by the user
       * @param assertion - refer https://tools.ietf.org/html/rfc7521
       */
      static fromAssertion(assertion) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.jwt = assertion;
        return clientAssertion;
      }
      /**
       * @deprecated Use fromCertificateWithSha256Thumbprint instead, with a SHA-256 thumprint
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificate(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        clientAssertion.useSha256 = false;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificateWithSha256Thumbprint(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        clientAssertion.useSha256 = true;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
       * @param cryptoProvider - library's crypto helper
       * @param issuer - iss claim
       * @param jwtAudience - aud claim
       */
      getJwt(cryptoProvider, issuer, jwtAudience) {
        if (this.privateKey && this.thumbprint) {
          if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {
            return this.jwt;
          }
          return this.createJwt(cryptoProvider, issuer, jwtAudience);
        }
        if (this.jwt) {
          return this.jwt;
        }
        throw createClientAuthError(ClientAuthErrorCodes_exports.invalidAssertion);
      }
      /**
       * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
       */
      createJwt(cryptoProvider, issuer, jwtAudience) {
        this.issuer = issuer;
        this.jwtAudience = jwtAudience;
        const issuedAt = TimeUtils_exports.nowSeconds();
        this.expirationTime = issuedAt + 600;
        const algorithm = this.useSha256 ? JwtConstants.PSS_256 : JwtConstants.RSA_256;
        const header = {
          alg: algorithm
        };
        const thumbprintHeader = this.useSha256 ? JwtConstants.X5T_256 : JwtConstants.X5T;
        Object.assign(header, {
          [thumbprintHeader]: EncodingUtils.base64EncodeUrl(this.thumbprint, "hex")
        });
        if (this.publicCertificate) {
          Object.assign(header, {
            [JwtConstants.X5C]: this.publicCertificate
          });
        }
        const payload = {
          [JwtConstants.AUDIENCE]: this.jwtAudience,
          [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
          [JwtConstants.ISSUER]: this.issuer,
          [JwtConstants.SUBJECT]: this.issuer,
          [JwtConstants.NOT_BEFORE]: issuedAt,
          [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()
        };
        this.jwt = import_jsonwebtoken.default.sign(payload, this.privateKey, { header });
        return this.jwt;
      }
      /**
       * Utility API to check expiration
       */
      isExpired() {
        return this.expirationTime < TimeUtils_exports.nowSeconds();
      }
      /**
       * Extracts the raw certs from a given certificate string and returns them in an array.
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static parseCertificate(publicCertificate) {
        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
        const certs = [];
        let matches;
        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
          certs.push(matches[1].replace(/\r*\n/g, Constants.EMPTY_STRING));
        }
        return certs;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/packageMetadata.mjs
var name2, version2;
var init_packageMetadata2 = __esm({
  "node_modules/@azure/msal-node/dist/packageMetadata.mjs"() {
    "use strict";
    name2 = "@azure/msal-node";
    version2 = "2.14.0";
  }
});

// node_modules/@azure/msal-node/dist/client/UsernamePasswordClient.mjs
var UsernamePasswordClient;
var init_UsernamePasswordClient = __esm({
  "node_modules/@azure/msal-node/dist/client/UsernamePasswordClient.mjs"() {
    "use strict";
    init_index_node();
    UsernamePasswordClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * API to acquire a token by passing the username and password to the service in exchage of credentials
       * password_grant
       * @param request
       */
      async acquireToken(request3) {
        this.logger.info("in acquireToken call in username-password client");
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        const response = await this.executeTokenRequest(this.authority, request3);
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        const tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request3);
        return tokenResponse;
      }
      /**
       * Executes POST request to token endpoint
       * @param authority
       * @param request
       */
      async executeTokenRequest(authority, request3) {
        const queryParametersString = this.createTokenQueryParameters(request3);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await this.createTokenRequestBody(request3);
        const headers = this.createTokenRequestHeaders({
          credential: request3.username,
          type: CcsCredentialType.UPN
        });
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: authority.canonicalAuthority,
          scopes: request3.scopes,
          claims: request3.claims,
          authenticationScheme: request3.authenticationScheme,
          resourceRequestMethod: request3.resourceRequestMethod,
          resourceRequestUri: request3.resourceRequestUri,
          shrClaims: request3.shrClaims,
          sshKid: request3.sshKid
        };
        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request3.correlationId);
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request
       */
      async createTokenRequestBody(request3) {
        const parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addUsername(request3.username);
        parameterBuilder.addPassword(request3.password);
        parameterBuilder.addScopes(request3.scopes);
        parameterBuilder.addResponseTypeForTokenAndIdToken();
        parameterBuilder.addGrantType(GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        const correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        const clientAssertion = this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          parameterBuilder.addClientAssertion(await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request3.resourceRequestUri));
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request3.username) {
          parameterBuilder.addCcsUpn(request3.username);
        }
        return parameterBuilder.createQueryString();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ClientApplication.mjs
var ClientApplication;
var init_ClientApplication = __esm({
  "node_modules/@azure/msal-node/dist/client/ClientApplication.mjs"() {
    "use strict";
    init_index_node();
    init_Configuration();
    init_CryptoProvider();
    init_NodeStorage();
    init_Constants2();
    init_TokenCache();
    init_ClientAssertion();
    init_packageMetadata2();
    init_NodeAuthError();
    init_UsernamePasswordClient();
    ClientApplication = class {
      /**
       * Constructor for the ClientApplication
       */
      constructor(configuration) {
        this.config = buildAppConfiguration(configuration);
        this.cryptoProvider = new CryptoProvider();
        this.logger = new Logger(this.config.system.loggerOptions, name2, version2);
        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider, buildStaticAuthorityOptions(this.config.auth));
        this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
      }
      /**
       * Creates the URL of the authorization request, letting the user input credentials and consent to the
       * application. The URL targets the /authorize endpoint of the authority configured in the
       * application object.
       *
       * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
       * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
       * `acquireTokenByCode(AuthorizationCodeRequest)`.
       */
      async getAuthCodeUrl(request3) {
        this.logger.info("getAuthCodeUrl called", request3.correlationId);
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3),
          responseMode: request3.responseMode || ResponseMode.QUERY,
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request3.azureCloudOptions);
        const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
        this.logger.verbose("Auth code client created", validRequest.correlationId);
        return authorizationCodeClient.getAuthCodeUrl(validRequest);
      }
      /**
       * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
       * Authorization Code flow.
       *
       * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
       * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
       * AuthorizationCodeRequest are the same.
       */
      async acquireTokenByCode(request3, authCodePayLoad) {
        this.logger.info("acquireTokenByCode called");
        if (request3.state && authCodePayLoad) {
          this.logger.info("acquireTokenByCode - validating state");
          this.validateState(request3.state, authCodePayLoad.state || "");
          authCodePayLoad = { ...authCodePayLoad, state: "" };
        }
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3),
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
        try {
          const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
          this.logger.verbose("Auth code client created", validRequest.correlationId);
          return await authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token by exchanging the refresh token provided for a new set of tokens.
       *
       * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
       * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
       * handle the caching and refreshing of tokens automatically.
       */
      async acquireTokenByRefreshToken(request3) {
        this.logger.info("acquireTokenByRefreshToken called", request3.correlationId);
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3),
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
        try {
          const refreshTokenClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
          this.logger.verbose("Refresh token client created", validRequest.correlationId);
          return await refreshTokenClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token silently when a user specifies the account the token is requested for.
       *
       * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
       * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
       * In case the refresh_token is expired or not found, an error is thrown
       * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
       */
      async acquireTokenSilent(request3) {
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3),
          forceRefresh: request3.forceRefresh || false
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
        try {
          const silentFlowClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const silentFlowClient = new SilentFlowClient(silentFlowClientConfig);
          this.logger.verbose("Silent flow client created", validRequest.correlationId);
          return await silentFlowClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires tokens with password grant by exchanging client applications username and password for credentials
       *
       * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
       * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
       * Microsoft's documentation and recommendations are at:
       * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
       *
       * @param request - UsenamePasswordRequest
       */
      async acquireTokenByUsernamePassword(request3) {
        this.logger.info("acquireTokenByUsernamePassword called", request3.correlationId);
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3)
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
        try {
          const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
          this.logger.verbose("Username password client created", validRequest.correlationId);
          return await usernamePasswordClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        this.logger.info("getTokenCache called");
        return this.tokenCache;
      }
      /**
       * Validates OIDC state by comparing the user cached state with the state received from the server.
       *
       * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against
       * CSRF attacks.
       * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.
       * @param state
       * @param cachedState
       */
      validateState(state3, cachedState) {
        if (!state3) {
          throw NodeAuthError.createStateNotFoundError();
        }
        if (state3 !== cachedState) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.stateMismatch);
        }
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.logger;
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger - Logger instance
       */
      setLogger(logger26) {
        this.logger = logger26;
      }
      /**
       * Builds the common configuration to be passed to the common component based on the platform configurarion
       * @param authority - user passed authority in configuration
       * @param serverTelemetryManager - initializes servertelemetry if passed
       */
      async buildOauthClientConfiguration(authority, requestCorrelationId, serverTelemetryManager, azureRegionConfiguration, azureCloudOptions) {
        this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
        const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions;
        const discoveredAuthority = await this.createAuthority(authority, requestCorrelationId, azureRegionConfiguration, userAzureCloudOptions);
        this.logger.info(`Building oauth client configuration with the following authority: ${discoveredAuthority.tokenEndpoint}.`, requestCorrelationId);
        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
        const clientConfiguration = {
          authOptions: {
            clientId: this.config.auth.clientId,
            authority: discoveredAuthority,
            clientCapabilities: this.config.auth.clientCapabilities
          },
          loggerOptions: {
            logLevel: this.config.system.loggerOptions.logLevel,
            loggerCallback: this.config.system.loggerOptions.loggerCallback,
            piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
            correlationId: requestCorrelationId
          },
          cacheOptions: {
            claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
          },
          cryptoInterface: this.cryptoProvider,
          networkInterface: this.config.system.networkClient,
          storageInterface: this.storage,
          serverTelemetryManager,
          clientCredentials: {
            clientSecret: this.clientSecret,
            clientAssertion: await this.getClientAssertion(discoveredAuthority)
          },
          libraryInfo: {
            sku: Constants2.MSAL_SKU,
            version: version2,
            cpu: process.arch || Constants.EMPTY_STRING,
            os: process.platform || Constants.EMPTY_STRING
          },
          telemetry: this.config.telemetry,
          persistencePlugin: this.config.cache.cachePlugin,
          serializableCache: this.tokenCache
        };
        return clientConfiguration;
      }
      async getClientAssertion(authority) {
        if (this.developerProvidedClientAssertion) {
          this.clientAssertion = ClientAssertion.fromAssertion(await getClientAssertion(this.developerProvidedClientAssertion, this.config.auth.clientId, authority.tokenEndpoint));
        }
        return this.clientAssertion && {
          assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
          assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE
        };
      }
      /**
       * Generates a request with the default scopes & generates a correlationId.
       * @param authRequest - BaseAuthRequest for initialization
       */
      async initializeBaseRequest(authRequest) {
        this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {
          this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
        }
        authRequest.authenticationScheme = AuthenticationScheme.BEARER;
        if (this.config.cache.claimsBasedCachingEnabled && authRequest.claims && // Checks for empty stringified object "{}" which doesn't qualify as requested claims
        !StringUtils.isEmptyObj(authRequest.claims)) {
          authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
        }
        return {
          ...authRequest,
          scopes: [
            ...authRequest && authRequest.scopes || [],
            ...OIDC_DEFAULT_SCOPES
          ],
          correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
          authority: authRequest.authority || this.config.auth.authority
        };
      }
      /**
       * Initializes the server telemetry payload
       * @param apiId - Id for a specific request
       * @param correlationId - GUID
       * @param forceRefresh - boolean to indicate network call
       */
      initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
        const telemetryPayload = {
          clientId: this.config.auth.clientId,
          correlationId,
          apiId,
          forceRefresh: forceRefresh || false
        };
        return new ServerTelemetryManager(telemetryPayload, this.storage);
      }
      /**
       * Create authority instance. If authority not passed in request, default to authority set on the application
       * object. If no authority set in application object, then default to common authority.
       * @param authorityString - authority from user configuration
       */
      async createAuthority(authorityString, requestCorrelationId, azureRegionConfiguration, azureCloudOptions) {
        this.logger.verbose("createAuthority called", requestCorrelationId);
        const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions);
        const authorityOptions = {
          protocolMode: this.config.auth.protocolMode,
          knownAuthorities: this.config.auth.knownAuthorities,
          cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
          authorityMetadata: this.config.auth.authorityMetadata,
          azureRegionConfiguration,
          skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
        };
        return AuthorityFactory_exports.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger, requestCorrelationId);
      }
      /**
       * Clear the cache
       */
      clearCache() {
        void this.storage.clear();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/network/LoopbackClient.mjs
var import_http2, LoopbackClient;
var init_LoopbackClient = __esm({
  "node_modules/@azure/msal-node/dist/network/LoopbackClient.mjs"() {
    "use strict";
    init_index_node();
    import_http2 = __toESM(require("http"), 1);
    init_NodeAuthError();
    init_Constants2();
    LoopbackClient = class {
      /**
       * Spins up a loopback server which returns the server response when the localhost redirectUri is hit
       * @param successTemplate
       * @param errorTemplate
       * @returns
       */
      async listenForAuthCode(successTemplate, errorTemplate) {
        if (this.server) {
          throw NodeAuthError.createLoopbackServerAlreadyExistsError();
        }
        return new Promise((resolve, reject) => {
          this.server = import_http2.default.createServer((req, res) => {
            const url = req.url;
            if (!url) {
              res.end(errorTemplate || "Error occurred loading redirectUrl");
              reject(NodeAuthError.createUnableToLoadRedirectUrlError());
              return;
            } else if (url === Constants.FORWARD_SLASH) {
              res.end(successTemplate || "Auth code was successfully acquired. You can close this window now.");
              return;
            }
            const redirectUri = this.getRedirectUri();
            const parsedUrl = new URL(url, redirectUri);
            const authCodeResponse = UrlUtils_exports.getDeserializedResponse(parsedUrl.search) || {};
            if (authCodeResponse.code) {
              res.writeHead(HttpStatus.REDIRECT, {
                location: redirectUri
              });
              res.end();
            }
            if (authCodeResponse.error) {
              res.end(errorTemplate || `Error occurred: ${authCodeResponse.error}`);
            }
            resolve(authCodeResponse);
          });
          this.server.listen(0, "127.0.0.1");
        });
      }
      /**
       * Get the port that the loopback server is running on
       * @returns
       */
      getRedirectUri() {
        if (!this.server || !this.server.listening) {
          throw NodeAuthError.createNoLoopbackServerExistsError();
        }
        const address = this.server.address();
        if (!address || typeof address === "string" || !address.port) {
          this.closeServer();
          throw NodeAuthError.createInvalidLoopbackAddressTypeError();
        }
        const port = address && address.port;
        return `${Constants2.HTTP_PROTOCOL}${Constants2.LOCALHOST}:${port}`;
      }
      /**
       * Close the loopback server
       */
      closeServer() {
        if (this.server) {
          this.server.close();
          if (typeof this.server.closeAllConnections === "function") {
            this.server.closeAllConnections();
          }
          this.server.unref();
          this.server = void 0;
        }
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/DeviceCodeClient.mjs
var DeviceCodeClient;
var init_DeviceCodeClient = __esm({
  "node_modules/@azure/msal-node/dist/client/DeviceCodeClient.mjs"() {
    "use strict";
    init_index_node();
    DeviceCodeClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * Gets device code from device code endpoint, calls back to with device code response, and
       * polls token endpoint to exchange device code for tokens
       * @param request
       */
      async acquireToken(request3) {
        const deviceCodeResponse = await this.getDeviceCode(request3);
        request3.deviceCodeCallback(deviceCodeResponse);
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        const response = await this.acquireTokenWithDeviceCode(request3, deviceCodeResponse);
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response);
        return responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request3);
      }
      /**
       * Creates device code request and executes http GET
       * @param request
       */
      async getDeviceCode(request3) {
        const queryParametersString = this.createExtraQueryParameters(request3);
        const endpoint = UrlString.appendQueryString(this.authority.deviceCodeEndpoint, queryParametersString);
        const queryString = this.createQueryString(request3);
        const headers = this.createTokenRequestHeaders();
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: request3.authority,
          scopes: request3.scopes,
          claims: request3.claims,
          authenticationScheme: request3.authenticationScheme,
          resourceRequestMethod: request3.resourceRequestMethod,
          resourceRequestUri: request3.resourceRequestUri,
          shrClaims: request3.shrClaims,
          sshKid: request3.sshKid
        };
        return this.executePostRequestToDeviceCodeEndpoint(endpoint, queryString, headers, thumbprint);
      }
      /**
       * Creates query string for the device code request
       * @param request
       */
      createExtraQueryParameters(request3) {
        const parameterBuilder = new RequestParameterBuilder();
        if (request3.extraQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request3.extraQueryParameters);
        }
        return parameterBuilder.createQueryString();
      }
      /**
       * Executes POST request to device code endpoint
       * @param deviceCodeEndpoint
       * @param queryString
       * @param headers
       */
      async executePostRequestToDeviceCodeEndpoint(deviceCodeEndpoint, queryString, headers, thumbprint) {
        const { body: { user_code: userCode, device_code: deviceCode, verification_uri: verificationUri, expires_in: expiresIn, interval, message } } = await this.networkManager.sendPostRequest(thumbprint, deviceCodeEndpoint, {
          body: queryString,
          headers
        });
        return {
          userCode,
          deviceCode,
          verificationUri,
          expiresIn,
          interval,
          message
        };
      }
      /**
       * Create device code endpoint query parameters and returns string
       */
      createQueryString(request3) {
        const parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addScopes(request3.scopes);
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        if (request3.extraQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request3.extraQueryParameters);
        }
        if (request3.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
      }
      /**
       * Breaks the polling with specific conditions.
       * @param request CommonDeviceCodeRequest
       * @param deviceCodeResponse DeviceCodeResponse
       */
      continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
        if (userSpecifiedCancelFlag) {
          this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
          throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodePollingCancelled);
        } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils_exports.nowSeconds() > userSpecifiedTimeout) {
          this.logger.error(`User defined timeout for device code polling reached. The timeout was set for ${userSpecifiedTimeout}`);
          throw createClientAuthError(ClientAuthErrorCodes_exports.userTimeoutReached);
        } else if (TimeUtils_exports.nowSeconds() > deviceCodeExpirationTime) {
          if (userSpecifiedTimeout) {
            this.logger.verbose(`User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for ${userSpecifiedTimeout}`);
          }
          this.logger.error(`Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`);
          throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodeExpired);
        }
        return true;
      }
      /**
       * Creates token request with device code response and polls token endpoint at interval set by the device code
       * response
       * @param request
       * @param deviceCodeResponse
       */
      async acquireTokenWithDeviceCode(request3, deviceCodeResponse) {
        const queryParametersString = this.createTokenQueryParameters(request3);
        const endpoint = UrlString.appendQueryString(this.authority.tokenEndpoint, queryParametersString);
        const requestBody = this.createTokenRequestBody(request3, deviceCodeResponse);
        const headers = this.createTokenRequestHeaders();
        const userSpecifiedTimeout = request3.timeout ? TimeUtils_exports.nowSeconds() + request3.timeout : void 0;
        const deviceCodeExpirationTime = TimeUtils_exports.nowSeconds() + deviceCodeResponse.expiresIn;
        const pollingIntervalMilli = deviceCodeResponse.interval * 1e3;
        while (this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request3.cancel)) {
          const thumbprint = {
            clientId: this.config.authOptions.clientId,
            authority: request3.authority,
            scopes: request3.scopes,
            claims: request3.claims,
            authenticationScheme: request3.authenticationScheme,
            resourceRequestMethod: request3.resourceRequestMethod,
            resourceRequestUri: request3.resourceRequestUri,
            shrClaims: request3.shrClaims,
            sshKid: request3.sshKid
          };
          const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request3.correlationId);
          if (response.body && response.body.error) {
            if (response.body.error === Constants.AUTHORIZATION_PENDING) {
              this.logger.info("Authorization pending. Continue polling.");
              await TimeUtils_exports.delay(pollingIntervalMilli);
            } else {
              this.logger.info("Unexpected error in polling from the server");
              throw createAuthError(AuthErrorCodes_exports.postRequestFailed, response.body.error);
            }
          } else {
            this.logger.verbose("Authorization completed successfully. Polling stopped.");
            return response.body;
          }
        }
        this.logger.error("Polling stopped for unknown reasons.");
        throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodeUnknownError);
      }
      /**
       * Creates query parameters and converts to string.
       * @param request
       * @param deviceCodeResponse
       */
      createTokenRequestBody(request3, deviceCodeResponse) {
        const requestParameters = new RequestParameterBuilder();
        requestParameters.addScopes(request3.scopes);
        requestParameters.addClientId(this.config.authOptions.clientId);
        requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);
        requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);
        const correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        requestParameters.addCorrelationId(correlationId);
        requestParameters.addClientInfo();
        requestParameters.addLibraryInfo(this.config.libraryInfo);
        requestParameters.addApplicationTelemetry(this.config.telemetry.application);
        requestParameters.addThrottling();
        if (this.serverTelemetryManager) {
          requestParameters.addServerTelemetry(this.serverTelemetryManager);
        }
        if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          requestParameters.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        return requestParameters.createQueryString();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/PublicClientApplication.mjs
var PublicClientApplication;
var init_PublicClientApplication = __esm({
  "node_modules/@azure/msal-node/dist/client/PublicClientApplication.mjs"() {
    "use strict";
    init_Constants2();
    init_index_node();
    init_ClientApplication();
    init_NodeAuthError();
    init_LoopbackClient();
    init_DeviceCodeClient();
    init_packageMetadata2();
    PublicClientApplication = class extends ClientApplication {
      /**
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.
       * - authority: the authority URL for your application.
       *
       * AAD authorities are of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
       * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * Azure B2C authorities are of the form https://\{instance\}/\{tenant\}/\{policy\}. Each policy is considered
       * its own authority. You will have to set the all of the knownAuthorities at the time of the client application
       * construction.
       *
       * ADFS authorities are of the form https://\{instance\}/adfs.
       */
      constructor(configuration) {
        super(configuration);
        if (this.config.broker.nativeBrokerPlugin) {
          if (this.config.broker.nativeBrokerPlugin.isBrokerAvailable) {
            this.nativeBrokerPlugin = this.config.broker.nativeBrokerPlugin;
            this.nativeBrokerPlugin.setLogger(this.config.system.loggerOptions);
          } else {
            this.logger.warning("NativeBroker implementation was provided but the broker is unavailable.");
          }
        }
        this.skus = ServerTelemetryManager.makeExtraSkuString({
          libraryName: Constants2.MSAL_SKU,
          libraryVersion: version2
        });
      }
      /**
       * Acquires a token from the authority using OAuth2.0 device code flow.
       * This flow is designed for devices that do not have access to a browser or have input constraints.
       * The authorization server issues a DeviceCode object with a verification code, an end-user code,
       * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be
       * instructed to use another device to navigate to the verification URI to input credentials.
       * Since the client cannot receive incoming requests, it polls the authorization server repeatedly
       * until the end-user completes input of credentials.
       */
      async acquireTokenByDeviceCode(request3) {
        this.logger.info("acquireTokenByDeviceCode called", request3.correlationId);
        const validRequest = Object.assign(request3, await this.initializeBaseRequest(request3));
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);
        try {
          const deviceCodeConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);
          this.logger.verbose("Device code client created", validRequest.correlationId);
          return await deviceCodeClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token interactively via the browser by requesting an authorization code then exchanging it for a token.
       */
      async acquireTokenInteractive(request3) {
        const correlationId = request3.correlationId || this.cryptoProvider.createNewGuid();
        this.logger.trace("acquireTokenInteractive called", correlationId);
        const { openBrowser, successTemplate, errorTemplate, windowHandle, loopbackClient: customLoopbackClient, ...remainingProperties } = request3;
        if (this.nativeBrokerPlugin) {
          const brokerRequest = {
            ...remainingProperties,
            clientId: this.config.auth.clientId,
            scopes: request3.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri: `${Constants2.HTTP_PROTOCOL}${Constants2.LOCALHOST}`,
            authority: request3.authority || this.config.auth.authority,
            correlationId,
            extraParameters: {
              ...remainingProperties.extraQueryParameters,
              ...remainingProperties.tokenQueryParameters,
              [AADServerParamKeys_exports.X_CLIENT_EXTRA_SKU]: this.skus
            },
            accountId: remainingProperties.account?.nativeAccountId
          };
          return this.nativeBrokerPlugin.acquireTokenInteractive(brokerRequest, windowHandle);
        }
        const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();
        const loopbackClient = customLoopbackClient || new LoopbackClient();
        let authCodeResponse = {};
        let authCodeListenerError = null;
        try {
          const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate).then((response) => {
            authCodeResponse = response;
          }).catch((e) => {
            authCodeListenerError = e;
          });
          const redirectUri = await this.waitForRedirectUri(loopbackClient);
          const validRequest = {
            ...remainingProperties,
            correlationId,
            scopes: request3.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri,
            responseMode: ResponseMode.QUERY,
            codeChallenge: challenge,
            codeChallengeMethod: CodeChallengeMethodValues.S256
          };
          const authCodeUrl = await this.getAuthCodeUrl(validRequest);
          await openBrowser(authCodeUrl);
          await authCodeListener;
          if (authCodeListenerError) {
            throw authCodeListenerError;
          }
          if (authCodeResponse.error) {
            throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
          } else if (!authCodeResponse.code) {
            throw NodeAuthError.createNoAuthCodeInResponseError();
          }
          const clientInfo = authCodeResponse.client_info;
          const tokenRequest = {
            code: authCodeResponse.code,
            codeVerifier: verifier,
            clientInfo: clientInfo || Constants.EMPTY_STRING,
            ...validRequest
          };
          return await this.acquireTokenByCode(tokenRequest);
        } finally {
          loopbackClient.closeServer();
        }
      }
      /**
       * Returns a token retrieved either from the cache or by exchanging the refresh token for a fresh access token. If brokering is enabled the token request will be serviced by the broker.
       * @param request
       * @returns
       */
      async acquireTokenSilent(request3) {
        const correlationId = request3.correlationId || this.cryptoProvider.createNewGuid();
        this.logger.trace("acquireTokenSilent called", correlationId);
        if (this.nativeBrokerPlugin) {
          const brokerRequest = {
            ...request3,
            clientId: this.config.auth.clientId,
            scopes: request3.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri: `${Constants2.HTTP_PROTOCOL}${Constants2.LOCALHOST}`,
            authority: request3.authority || this.config.auth.authority,
            correlationId,
            extraParameters: {
              ...request3.tokenQueryParameters,
              [AADServerParamKeys_exports.X_CLIENT_EXTRA_SKU]: this.skus
            },
            accountId: request3.account.nativeAccountId,
            forceRefresh: request3.forceRefresh || false
          };
          return this.nativeBrokerPlugin.acquireTokenSilent(brokerRequest);
        }
        return super.acquireTokenSilent(request3);
      }
      /**
       * Removes cache artifacts associated with the given account
       * @param request
       * @returns
       */
      async signOut(request3) {
        if (this.nativeBrokerPlugin && request3.account.nativeAccountId) {
          const signoutRequest = {
            clientId: this.config.auth.clientId,
            accountId: request3.account.nativeAccountId,
            correlationId: request3.correlationId || this.cryptoProvider.createNewGuid()
          };
          await this.nativeBrokerPlugin.signOut(signoutRequest);
        }
        await this.getTokenCache().removeAccount(request3.account);
      }
      /**
       * Returns all cached accounts for this application. If brokering is enabled this request will be serviced by the broker.
       * @returns
       */
      async getAllAccounts() {
        if (this.nativeBrokerPlugin) {
          const correlationId = this.cryptoProvider.createNewGuid();
          return this.nativeBrokerPlugin.getAllAccounts(this.config.auth.clientId, correlationId);
        }
        return this.getTokenCache().getAllAccounts();
      }
      /**
       * Attempts to retrieve the redirectUri from the loopback server. If the loopback server does not start listening for requests within the timeout this will throw.
       * @param loopbackClient
       * @returns
       */
      async waitForRedirectUri(loopbackClient) {
        return new Promise((resolve, reject) => {
          let ticks = 0;
          const id = setInterval(() => {
            if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {
              clearInterval(id);
              reject(NodeAuthError.createLoopbackServerTimeoutError());
              return;
            }
            try {
              const r = loopbackClient.getRedirectUri();
              clearInterval(id);
              resolve(r);
              return;
            } catch (e) {
              if (e instanceof AuthError && e.errorCode === NodeAuthErrorMessage.noLoopbackServerExists.code) {
                ticks++;
                return;
              }
              clearInterval(id);
              reject(e);
              return;
            }
          }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
        });
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ClientCredentialClient.mjs
var ClientCredentialClient;
var init_ClientCredentialClient = __esm({
  "node_modules/@azure/msal-node/dist/client/ClientCredentialClient.mjs"() {
    "use strict";
    init_index_node();
    ClientCredentialClient = class extends BaseClient {
      constructor(configuration, appTokenProvider) {
        super(configuration);
        this.appTokenProvider = appTokenProvider;
      }
      /**
       * Public API to acquire a token with ClientCredential Flow for Confidential clients
       * @param request
       */
      async acquireToken(request3) {
        if (request3.skipCache || request3.claims) {
          return this.executeTokenRequest(request3, this.authority);
        }
        const [cachedAuthenticationResult, lastCacheOutcome] = await this.getCachedAuthenticationResult(request3, this.config, this.cryptoUtils, this.authority, this.cacheManager, this.serverTelemetryManager);
        if (cachedAuthenticationResult) {
          if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
            this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
            const refreshAccessToken = true;
            await this.executeTokenRequest(request3, this.authority, refreshAccessToken);
          }
          return cachedAuthenticationResult;
        } else {
          return this.executeTokenRequest(request3, this.authority);
        }
      }
      /**
       * looks up cache if the tokens are cached already
       */
      async getCachedAuthenticationResult(request3, config, cryptoUtils, authority, cacheManager, serverTelemetryManager) {
        const clientConfiguration = config;
        const managedIdentityConfiguration = config;
        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
        let cacheContext;
        if (clientConfiguration.serializableCache && clientConfiguration.persistencePlugin) {
          cacheContext = new TokenCacheContext(clientConfiguration.serializableCache, false);
          await clientConfiguration.persistencePlugin.beforeCacheAccess(cacheContext);
        }
        const cachedAccessToken = this.readAccessTokenFromCache(authority, managedIdentityConfiguration.managedIdentityId?.id || clientConfiguration.authOptions.clientId, new ScopeSet(request3.scopes || []), cacheManager);
        if (clientConfiguration.serializableCache && clientConfiguration.persistencePlugin && cacheContext) {
          await clientConfiguration.persistencePlugin.afterCacheAccess(cacheContext);
        }
        if (!cachedAccessToken) {
          serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
          return [null, CacheOutcome.NO_CACHED_ACCESS_TOKEN];
        }
        if (TimeUtils_exports.isTokenExpired(cachedAccessToken.expiresOn, clientConfiguration.systemOptions?.tokenRenewalOffsetSeconds || DEFAULT_TOKEN_RENEWAL_OFFSET_SEC)) {
          serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
          return [null, CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED];
        }
        if (cachedAccessToken.refreshOn && TimeUtils_exports.isTokenExpired(cachedAccessToken.refreshOn.toString(), 0)) {
          lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
          serverTelemetryManager?.setCacheOutcome(CacheOutcome.PROACTIVELY_REFRESHED);
        }
        return [
          await ResponseHandler.generateAuthenticationResult(cryptoUtils, authority, {
            account: null,
            idToken: null,
            accessToken: cachedAccessToken,
            refreshToken: null,
            appMetadata: null
          }, true, request3),
          lastCacheOutcome
        ];
      }
      /**
       * Reads access token from the cache
       */
      readAccessTokenFromCache(authority, id, scopeSet, cacheManager) {
        const accessTokenFilter = {
          homeAccountId: Constants.EMPTY_STRING,
          environment: authority.canonicalAuthorityUrlComponents.HostNameAndPort,
          credentialType: CredentialType.ACCESS_TOKEN,
          clientId: id,
          realm: authority.tenant,
          target: ScopeSet.createSearchScopes(scopeSet.asArray())
        };
        const accessTokens = cacheManager.getAccessTokensByFilter(accessTokenFilter);
        if (accessTokens.length < 1) {
          return null;
        } else if (accessTokens.length > 1) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.multipleMatchingTokens);
        }
        return accessTokens[0];
      }
      /**
       * Makes a network call to request the token from the service
       * @param request
       * @param authority
       */
      async executeTokenRequest(request3, authority, refreshAccessToken) {
        let serverTokenResponse;
        let reqTimestamp;
        if (this.appTokenProvider) {
          this.logger.info("Using appTokenProvider extensibility.");
          const appTokenPropviderParameters = {
            correlationId: request3.correlationId,
            tenantId: this.config.authOptions.authority.tenant,
            scopes: request3.scopes,
            claims: request3.claims
          };
          reqTimestamp = TimeUtils_exports.nowSeconds();
          const appTokenProviderResult = await this.appTokenProvider(appTokenPropviderParameters);
          serverTokenResponse = {
            access_token: appTokenProviderResult.accessToken,
            expires_in: appTokenProviderResult.expiresInSeconds,
            refresh_in: appTokenProviderResult.refreshInSeconds,
            token_type: AuthenticationScheme.BEARER
          };
        } else {
          const queryParametersString = this.createTokenQueryParameters(request3);
          const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
          const requestBody = await this.createTokenRequestBody(request3);
          const headers = this.createTokenRequestHeaders();
          const thumbprint = {
            clientId: this.config.authOptions.clientId,
            authority: request3.authority,
            scopes: request3.scopes,
            claims: request3.claims,
            authenticationScheme: request3.authenticationScheme,
            resourceRequestMethod: request3.resourceRequestMethod,
            resourceRequestUri: request3.resourceRequestUri,
            shrClaims: request3.shrClaims,
            sshKid: request3.sshKid
          };
          this.logger.info("Sending token request to endpoint: " + authority.tokenEndpoint);
          reqTimestamp = TimeUtils_exports.nowSeconds();
          const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request3.correlationId);
          serverTokenResponse = response.body;
          serverTokenResponse.status = response.status;
        }
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
        const tokenResponse = await responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request3);
        return tokenResponse;
      }
      /**
       * generate the request to the server in the acceptable format
       * @param request
       */
      async createTokenRequestBody(request3) {
        const parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addScopes(request3.scopes, false);
        parameterBuilder.addGrantType(GrantType.CLIENT_CREDENTIALS_GRANT);
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        const correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        const clientAssertion = request3.clientAssertion || this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          parameterBuilder.addClientAssertion(await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request3.resourceRequestUri));
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/OnBehalfOfClient.mjs
var OnBehalfOfClient;
var init_OnBehalfOfClient = __esm({
  "node_modules/@azure/msal-node/dist/client/OnBehalfOfClient.mjs"() {
    "use strict";
    init_index_node();
    init_EncodingUtils();
    OnBehalfOfClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * Public API to acquire tokens with on behalf of flow
       * @param request
       */
      async acquireToken(request3) {
        this.scopeSet = new ScopeSet(request3.scopes || []);
        this.userAssertionHash = await this.cryptoUtils.hashString(request3.oboAssertion);
        if (request3.skipCache || request3.claims) {
          return this.executeTokenRequest(request3, this.authority, this.userAssertionHash);
        }
        try {
          return await this.getCachedAuthenticationResult(request3);
        } catch (e) {
          return await this.executeTokenRequest(request3, this.authority, this.userAssertionHash);
        }
      }
      /**
       * look up cache for tokens
       * Find idtoken in the cache
       * Find accessToken based on user assertion and account info in the cache
       * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires
       * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session
       * @param request
       */
      async getCachedAuthenticationResult(request3) {
        const cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request3);
        if (!cachedAccessToken) {
          this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
          this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
          throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
        } else if (TimeUtils_exports.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
          this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
          this.logger.info(`OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);
          throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
        }
        const cachedIdToken = this.readIdTokenFromCacheForOBO(cachedAccessToken.homeAccountId);
        let idTokenClaims;
        let cachedAccount = null;
        if (cachedIdToken) {
          idTokenClaims = AuthToken_exports.extractTokenClaims(cachedIdToken.secret, EncodingUtils.base64Decode);
          const localAccountId = idTokenClaims.oid || idTokenClaims.sub;
          const accountInfo = {
            homeAccountId: cachedIdToken.homeAccountId,
            environment: cachedIdToken.environment,
            tenantId: cachedIdToken.realm,
            username: Constants.EMPTY_STRING,
            localAccountId: localAccountId || Constants.EMPTY_STRING
          };
          cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);
        }
        if (this.config.serverTelemetryManager) {
          this.config.serverTelemetryManager.incrementCacheHits();
        }
        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
          account: cachedAccount,
          accessToken: cachedAccessToken,
          idToken: cachedIdToken,
          refreshToken: null,
          appMetadata: null
        }, true, request3, idTokenClaims);
      }
      /**
       * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager
       * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service
       * @param atHomeAccountId {string}
       */
      readIdTokenFromCacheForOBO(atHomeAccountId) {
        const idTokenFilter = {
          homeAccountId: atHomeAccountId,
          environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.config.authOptions.clientId,
          realm: this.authority.tenant
        };
        const idTokenMap = this.cacheManager.getIdTokensByFilter(idTokenFilter);
        if (Object.values(idTokenMap).length < 1) {
          return null;
        }
        return Object.values(idTokenMap)[0];
      }
      /**
       * Fetches the cached access token based on incoming assertion
       * @param clientId
       * @param request
       * @param userAssertionHash
       */
      readAccessTokenFromCacheForOBO(clientId, request3) {
        const authScheme = request3.authenticationScheme || AuthenticationScheme.BEARER;
        const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        const accessTokenFilter = {
          credentialType,
          clientId,
          target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),
          tokenType: authScheme,
          keyId: request3.sshKid,
          requestedClaimsHash: request3.requestedClaimsHash,
          userAssertionHash: this.userAssertionHash
        };
        const accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter);
        const numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          return null;
        } else if (numAccessTokens > 1) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.multipleMatchingTokens);
        }
        return accessTokens[0];
      }
      /**
       * Make a network call to the server requesting credentials
       * @param request
       * @param authority
       */
      async executeTokenRequest(request3, authority, userAssertionHash) {
        const queryParametersString = this.createTokenQueryParameters(request3);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await this.createTokenRequestBody(request3);
        const headers = this.createTokenRequestHeaders();
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: request3.authority,
          scopes: request3.scopes,
          claims: request3.claims,
          authenticationScheme: request3.authenticationScheme,
          resourceRequestMethod: request3.resourceRequestMethod,
          resourceRequestUri: request3.resourceRequestUri,
          shrClaims: request3.shrClaims,
          sshKid: request3.sshKid
        };
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request3.correlationId);
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        const tokenResponse = await responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request3, void 0, userAssertionHash);
        return tokenResponse;
      }
      /**
       * generate a server request in accepable format
       * @param request
       */
      async createTokenRequestBody(request3) {
        const parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addScopes(request3.scopes);
        parameterBuilder.addGrantType(GrantType.JWT_BEARER);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        const correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        parameterBuilder.addRequestTokenUse(AADServerParamKeys_exports.ON_BEHALF_OF);
        parameterBuilder.addOboAssertion(request3.oboAssertion);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        const clientAssertion = this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          parameterBuilder.addClientAssertion(await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request3.resourceRequestUri));
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (request3.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ConfidentialClientApplication.mjs
var ConfidentialClientApplication;
var init_ConfidentialClientApplication = __esm({
  "node_modules/@azure/msal-node/dist/client/ConfidentialClientApplication.mjs"() {
    "use strict";
    init_ClientApplication();
    init_ClientAssertion();
    init_Constants2();
    init_index_node();
    init_ClientCredentialClient();
    init_OnBehalfOfClient();
    ConfidentialClientApplication = class extends ClientApplication {
      /**
       * Constructor for the ConfidentialClientApplication
       *
       * Required attributes in the Configuration object are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal
       * - authority: the authority URL for your application.
       * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.
       *
       * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
       * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * In Azure B2C, authority is of the form https://\{instance\}/tfp/\{tenant\}/\{policyName\}/
       * Full B2C functionality will be available in this library in future versions.
       *
       * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance
       */
      constructor(configuration) {
        super(configuration);
        this.setClientCredential();
        this.appTokenProvider = void 0;
      }
      /**
       * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and
       * is meant for Azure SDK to enhance Managed Identity support.
       *
       * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.
       */
      SetAppTokenProvider(provider) {
        this.appTokenProvider = provider;
      }
      /**
       * Acquires tokens from the authority for the application (not for an end user).
       */
      async acquireTokenByClientCredential(request3) {
        this.logger.info("acquireTokenByClientCredential called", request3.correlationId);
        let clientAssertion;
        if (request3.clientAssertion) {
          clientAssertion = {
            assertion: await getClientAssertion(
              request3.clientAssertion,
              this.config.auth.clientId
              // tokenEndpoint will be undefined. resourceRequestUri is omitted in ClientCredentialRequest
            ),
            assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE
          };
        }
        const baseRequest = await this.initializeBaseRequest(request3);
        const validBaseRequest = {
          ...baseRequest,
          scopes: baseRequest.scopes.filter((scope) => !OIDC_DEFAULT_SCOPES.includes(scope))
        };
        const validRequest = {
          ...request3,
          ...validBaseRequest,
          clientAssertion
        };
        const authority = new UrlString(validRequest.authority);
        const tenantId = authority.getUrlComponents().PathSegments[0];
        if (Object.values(AADAuthorityConstants).includes(tenantId)) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.missingTenantIdError);
        }
        const azureRegionConfiguration = {
          azureRegion: validRequest.azureRegion,
          environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);
        try {
          const clientCredentialConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, azureRegionConfiguration, request3.azureCloudOptions);
          const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);
          this.logger.verbose("Client credential client created", validRequest.correlationId);
          return await clientCredentialClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires tokens from the authority for the application.
       *
       * Used in scenarios where the current app is a middle-tier service which was called with a token
       * representing an end user. The current app can use the token (oboAssertion) to request another
       * token to access downstream web API, on behalf of that user.
       *
       * The current middle-tier app has no user interaction to obtain consent.
       * See how to gain consent upfront for your middle-tier app from this article.
       * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application
       */
      async acquireTokenOnBehalfOf(request3) {
        this.logger.info("acquireTokenOnBehalfOf called", request3.correlationId);
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3)
        };
        try {
          const onBehalfOfConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request3.azureCloudOptions);
          const oboClient = new OnBehalfOfClient(onBehalfOfConfig);
          this.logger.verbose("On behalf of client created", validRequest.correlationId);
          return await oboClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          throw e;
        }
      }
      setClientCredential() {
        const clientSecretNotEmpty = !!this.config.auth.clientSecret;
        const clientAssertionNotEmpty = !!this.config.auth.clientAssertion;
        const certificateNotEmpty = (!!this.config.auth.clientCertificate?.thumbprint || !!this.config.auth.clientCertificate?.thumbprintSha256) && !!this.config.auth.clientCertificate?.privateKey;
        if (this.appTokenProvider) {
          return;
        }
        if (clientSecretNotEmpty && clientAssertionNotEmpty || clientAssertionNotEmpty && certificateNotEmpty || clientSecretNotEmpty && certificateNotEmpty) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.invalidClientCredential);
        }
        if (this.config.auth.clientSecret) {
          this.clientSecret = this.config.auth.clientSecret;
          return;
        }
        if (this.config.auth.clientAssertion) {
          this.developerProvidedClientAssertion = this.config.auth.clientAssertion;
          return;
        }
        if (!certificateNotEmpty) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.invalidClientCredential);
        } else {
          this.clientAssertion = !!this.config.auth.clientCertificate.thumbprintSha256 ? ClientAssertion.fromCertificateWithSha256Thumbprint(this.config.auth.clientCertificate.thumbprintSha256, this.config.auth.clientCertificate.privateKey, this.config.auth.clientCertificate.x5c) : ClientAssertion.fromCertificate(
            // guaranteed to be a string, due to prior error checking in this function
            this.config.auth.clientCertificate.thumbprint,
            this.config.auth.clientCertificate.privateKey,
            this.config.auth.clientCertificate.x5c
          );
        }
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs
var ManagedIdentityUserAssignedIdQueryParameterNames, BaseManagedIdentitySource;
var init_BaseManagedIdentitySource = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    init_ManagedIdentityError();
    init_ManagedIdentityErrorCodes();
    ManagedIdentityUserAssignedIdQueryParameterNames = {
      MANAGED_IDENTITY_CLIENT_ID: "client_id",
      MANAGED_IDENTITY_OBJECT_ID: "object_id",
      MANAGED_IDENTITY_RESOURCE_ID: "mi_res_id"
    };
    BaseManagedIdentitySource = class {
      constructor(logger26, nodeStorage, networkClient, cryptoProvider) {
        this.logger = logger26;
        this.nodeStorage = nodeStorage;
        this.networkClient = networkClient;
        this.cryptoProvider = cryptoProvider;
      }
      async getServerTokenResponseAsync(response, _networkClient, _networkRequest, _networkRequestOptions) {
        return this.getServerTokenResponse(response);
      }
      getServerTokenResponse(response) {
        let refreshIn, expiresIn;
        if (response.body.expires_on) {
          expiresIn = response.body.expires_on - TimeUtils_exports.nowSeconds();
          if (expiresIn > 2 * 3600) {
            refreshIn = expiresIn / 2;
          }
        }
        const serverTokenResponse = {
          status: response.status,
          // success
          access_token: response.body.access_token,
          expires_in: expiresIn,
          scope: response.body.resource,
          token_type: response.body.token_type,
          refresh_in: refreshIn,
          // error
          correlation_id: response.body.correlation_id || response.body.correlationId,
          error: typeof response.body.error === "string" ? response.body.error : response.body.error?.code,
          error_description: response.body.message || (typeof response.body.error === "string" ? response.body.error_description : response.body.error?.message),
          error_codes: response.body.error_codes,
          timestamp: response.body.timestamp,
          trace_id: response.body.trace_id
        };
        return serverTokenResponse;
      }
      async acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
        const networkRequest = this.createRequest(managedIdentityRequest.resource, managedIdentityId);
        const headers = networkRequest.headers;
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        const networkRequestOptions = { headers };
        if (Object.keys(networkRequest.bodyParameters).length) {
          networkRequestOptions.body = networkRequest.computeParametersBodyString();
        }
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        let response;
        try {
          if (networkRequest.httpMethod === HttpMethod.POST) {
            response = await this.networkClient.sendPostRequestAsync(networkRequest.computeUri(), networkRequestOptions);
          } else {
            response = await this.networkClient.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);
          }
        } catch (error) {
          if (error instanceof AuthError) {
            throw error;
          } else {
            throw createClientAuthError(ClientAuthErrorCodes_exports.networkError);
          }
        }
        const responseHandler = new ResponseHandler(managedIdentityId.id, this.nodeStorage, this.cryptoProvider, this.logger, null, null);
        const serverTokenResponse = await this.getServerTokenResponseAsync(response, this.networkClient, networkRequest, networkRequestOptions);
        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
        return responseHandler.handleServerTokenResponse(serverTokenResponse, fakeAuthority, reqTimestamp, managedIdentityRequest);
      }
      getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityIdType) {
        switch (managedIdentityIdType) {
          case ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID:
            this.logger.info("[Managed Identity] Adding user assigned client id to the request.");
            return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID;
          case ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID:
            this.logger.info("[Managed Identity] Adding user assigned resource id to the request.");
            return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID;
          case ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID:
            this.logger.info("[Managed Identity] Adding user assigned object id to the request.");
            return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_OBJECT_ID;
          default:
            throw createManagedIdentityError(invalidManagedIdentityIdType);
        }
      }
    };
    BaseManagedIdentitySource.getValidatedEnvVariableUrlString = (envVariableStringName, envVariable, sourceName, logger26) => {
      try {
        return new UrlString(envVariable).urlString;
      } catch (error) {
        logger26.info(`[Managed Identity] ${sourceName} managed identity is unavailable because the '${envVariableStringName}' environment variable is malformed.`);
        throw createManagedIdentityError(MsiEnvironmentVariableUrlMalformedErrorCodes[envVariableStringName]);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs
var ManagedIdentityRequestParameters;
var init_ManagedIdentityRequestParameters = __esm({
  "node_modules/@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs"() {
    "use strict";
    init_index_node();
    ManagedIdentityRequestParameters = class {
      constructor(httpMethod, endpoint) {
        this.httpMethod = httpMethod;
        this._baseEndpoint = endpoint;
        this.headers = {};
        this.bodyParameters = {};
        this.queryParameters = {};
      }
      computeUri() {
        const parameterBuilder = new RequestParameterBuilder();
        if (this.queryParameters) {
          parameterBuilder.addExtraQueryParameters(this.queryParameters);
        }
        const queryParametersString = parameterBuilder.createQueryString();
        return UrlString.appendQueryString(this._baseEndpoint, queryParametersString);
      }
      computeParametersBodyString() {
        const parameterBuilder = new RequestParameterBuilder();
        if (this.bodyParameters) {
          parameterBuilder.addExtraQueryParameters(this.bodyParameters);
        }
        return parameterBuilder.createQueryString();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs
var APP_SERVICE_MSI_API_VERSION, AppService;
var init_AppService = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs"() {
    "use strict";
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ManagedIdentityRequestParameters();
    APP_SERVICE_MSI_API_VERSION = "2019-08-01";
    AppService = class _AppService extends BaseManagedIdentitySource {
      constructor(logger26, nodeStorage, networkClient, cryptoProvider, identityEndpoint, identityHeader) {
        super(logger26, nodeStorage, networkClient, cryptoProvider);
        this.identityEndpoint = identityEndpoint;
        this.identityHeader = identityHeader;
      }
      static getEnvironmentVariables() {
        const identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
        const identityHeader = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER];
        return [identityEndpoint, identityHeader];
      }
      static tryCreate(logger26, nodeStorage, networkClient, cryptoProvider) {
        const [identityEndpoint, identityHeader] = _AppService.getEnvironmentVariables();
        if (!identityEndpoint || !identityHeader) {
          logger26.info(`[Managed Identity] ${ManagedIdentitySourceNames.APP_SERVICE} managed identity is unavailable because one or both of the '${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}' and '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variables are not defined.`);
          return null;
        }
        const validatedIdentityEndpoint = _AppService.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.APP_SERVICE, logger26);
        logger26.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.APP_SERVICE} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.APP_SERVICE} managed identity.`);
        return new _AppService(logger26, nodeStorage, networkClient, cryptoProvider, identityEndpoint, identityHeader);
      }
      createRequest(resource, managedIdentityId) {
        const request3 = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
        request3.headers[APP_SERVICE_SECRET_HEADER_NAME] = this.identityHeader;
        request3.queryParameters[API_VERSION_QUERY_PARAMETER_NAME] = APP_SERVICE_MSI_API_VERSION;
        request3.queryParameters[RESOURCE_BODY_OR_QUERY_PARAMETER_NAME] = resource;
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          request3.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;
        }
        return request3;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs
var import_fs2, import_path3, ARC_API_VERSION, DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT, HIMDS_EXECUTABLE_HELPER_STRING, SUPPORTED_AZURE_ARC_PLATFORMS, AZURE_ARC_FILE_DETECTION, AzureArc;
var init_AzureArc = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs"() {
    "use strict";
    init_index_node();
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_ManagedIdentityError();
    init_Constants2();
    import_fs2 = require("fs");
    import_path3 = __toESM(require("path"), 1);
    init_ManagedIdentityErrorCodes();
    ARC_API_VERSION = "2019-11-01";
    DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT = "http://127.0.0.1:40342/metadata/identity/oauth2/token";
    HIMDS_EXECUTABLE_HELPER_STRING = "N/A: himds executable exists";
    SUPPORTED_AZURE_ARC_PLATFORMS = {
      win32: `${process.env["ProgramData"]}\\AzureConnectedMachineAgent\\Tokens\\`,
      linux: "/var/opt/azcmagent/tokens/"
    };
    AZURE_ARC_FILE_DETECTION = {
      win32: `${process.env["ProgramFiles"]}\\AzureConnectedMachineAgent\\himds.exe`,
      linux: "/opt/azcmagent/bin/himds"
    };
    AzureArc = class _AzureArc extends BaseManagedIdentitySource {
      constructor(logger26, nodeStorage, networkClient, cryptoProvider, identityEndpoint) {
        super(logger26, nodeStorage, networkClient, cryptoProvider);
        this.identityEndpoint = identityEndpoint;
      }
      static getEnvironmentVariables() {
        let identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
        let imdsEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT];
        if (!identityEndpoint || !imdsEndpoint) {
          const fileDetectionPath = AZURE_ARC_FILE_DETECTION[process.platform];
          try {
            (0, import_fs2.accessSync)(fileDetectionPath, import_fs2.constants.F_OK | import_fs2.constants.R_OK);
            identityEndpoint = DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT;
            imdsEndpoint = HIMDS_EXECUTABLE_HELPER_STRING;
          } catch (err) {
          }
        }
        return [identityEndpoint, imdsEndpoint];
      }
      static tryCreate(logger26, nodeStorage, networkClient, cryptoProvider, managedIdentityId) {
        const [identityEndpoint, imdsEndpoint] = _AzureArc.getEnvironmentVariables();
        if (!identityEndpoint || !imdsEndpoint) {
          logger26.info(`[Managed Identity] ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is unavailable through environment variables because one or both of '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' and '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' are not defined. ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is also unavailable through file detection.`);
          return null;
        }
        if (imdsEndpoint === HIMDS_EXECUTABLE_HELPER_STRING) {
          logger26.info(`[Managed Identity] ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is available through file detection. Defaulting to known ${ManagedIdentitySourceNames.AZURE_ARC} endpoint: ${DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT}. Creating ${ManagedIdentitySourceNames.AZURE_ARC} managed identity.`);
        } else {
          const validatedIdentityEndpoint = _AzureArc.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.AZURE_ARC, logger26);
          validatedIdentityEndpoint.endsWith("/") ? validatedIdentityEndpoint.slice(0, -1) : validatedIdentityEndpoint;
          _AzureArc.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT, imdsEndpoint, ManagedIdentitySourceNames.AZURE_ARC, logger26);
          logger26.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.AZURE_ARC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.AZURE_ARC} managed identity.`);
        }
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          throw createManagedIdentityError(unableToCreateAzureArc);
        }
        return new _AzureArc(logger26, nodeStorage, networkClient, cryptoProvider, identityEndpoint);
      }
      createRequest(resource) {
        const request3 = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint.replace("localhost", "127.0.0.1"));
        request3.headers[METADATA_HEADER_NAME] = "true";
        request3.queryParameters[API_VERSION_QUERY_PARAMETER_NAME] = ARC_API_VERSION;
        request3.queryParameters[RESOURCE_BODY_OR_QUERY_PARAMETER_NAME] = resource;
        return request3;
      }
      async getServerTokenResponseAsync(originalResponse, networkClient, networkRequest, networkRequestOptions) {
        let retryResponse;
        if (originalResponse.status === HttpStatus.UNAUTHORIZED) {
          const wwwAuthHeader = originalResponse.headers["www-authenticate"];
          if (!wwwAuthHeader) {
            throw createManagedIdentityError(wwwAuthenticateHeaderMissing);
          }
          if (!wwwAuthHeader.includes("Basic realm=")) {
            throw createManagedIdentityError(wwwAuthenticateHeaderUnsupportedFormat);
          }
          const secretFilePath = wwwAuthHeader.split("Basic realm=")[1];
          if (!SUPPORTED_AZURE_ARC_PLATFORMS.hasOwnProperty(process.platform)) {
            throw createManagedIdentityError(platformNotSupported);
          }
          const expectedSecretFilePath = SUPPORTED_AZURE_ARC_PLATFORMS[process.platform];
          const fileName = import_path3.default.basename(secretFilePath);
          if (!fileName.endsWith(".key")) {
            throw createManagedIdentityError(invalidFileExtension);
          }
          if (expectedSecretFilePath + fileName !== secretFilePath) {
            throw createManagedIdentityError(invalidFilePath);
          }
          let secretFileSize;
          try {
            secretFileSize = await (0, import_fs2.statSync)(secretFilePath).size;
          } catch (e) {
            throw createManagedIdentityError(unableToReadSecretFile);
          }
          if (secretFileSize > AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES) {
            throw createManagedIdentityError(invalidSecret);
          }
          let secret;
          try {
            secret = (0, import_fs2.readFileSync)(secretFilePath, "utf-8");
          } catch (e) {
            throw createManagedIdentityError(unableToReadSecretFile);
          }
          const authHeaderValue = `Basic ${secret}`;
          this.logger.info(`[Managed Identity] Adding authorization header to the request.`);
          networkRequest.headers[AUTHORIZATION_HEADER_NAME] = authHeaderValue;
          try {
            retryResponse = await networkClient.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);
          } catch (error) {
            if (error instanceof AuthError) {
              throw error;
            } else {
              throw createClientAuthError(ClientAuthErrorCodes_exports.networkError);
            }
          }
        }
        return this.getServerTokenResponse(retryResponse || originalResponse);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs
var CloudShell;
var init_CloudShell = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs"() {
    "use strict";
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ManagedIdentityError();
    init_ManagedIdentityErrorCodes();
    CloudShell = class _CloudShell extends BaseManagedIdentitySource {
      constructor(logger26, nodeStorage, networkClient, cryptoProvider, msiEndpoint) {
        super(logger26, nodeStorage, networkClient, cryptoProvider);
        this.msiEndpoint = msiEndpoint;
      }
      static getEnvironmentVariables() {
        const msiEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];
        return [msiEndpoint];
      }
      static tryCreate(logger26, nodeStorage, networkClient, cryptoProvider, managedIdentityId) {
        const [msiEndpoint] = _CloudShell.getEnvironmentVariables();
        if (!msiEndpoint) {
          logger26.info(`[Managed Identity] ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity is unavailable because the '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT} environment variable is not defined.`);
          return null;
        }
        const validatedMsiEndpoint = _CloudShell.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT, msiEndpoint, ManagedIdentitySourceNames.CLOUD_SHELL, logger26);
        logger26.info(`[Managed Identity] Environment variable validation passed for ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity.`);
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          throw createManagedIdentityError(unableToCreateCloudShell);
        }
        return new _CloudShell(logger26, nodeStorage, networkClient, cryptoProvider, msiEndpoint);
      }
      createRequest(resource) {
        const request3 = new ManagedIdentityRequestParameters(HttpMethod.POST, this.msiEndpoint);
        request3.headers[METADATA_HEADER_NAME] = "true";
        request3.bodyParameters[RESOURCE_BODY_OR_QUERY_PARAMETER_NAME] = resource;
        return request3;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs
var IMDS_TOKEN_PATH, DEFAULT_IMDS_ENDPOINT, IMDS_API_VERSION, Imds;
var init_Imds = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs"() {
    "use strict";
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
    IMDS_TOKEN_PATH = "/metadata/identity/oauth2/token";
    DEFAULT_IMDS_ENDPOINT = `http://169.254.169.254${IMDS_TOKEN_PATH}`;
    IMDS_API_VERSION = "2018-02-01";
    Imds = class _Imds extends BaseManagedIdentitySource {
      constructor(logger26, nodeStorage, networkClient, cryptoProvider, identityEndpoint) {
        super(logger26, nodeStorage, networkClient, cryptoProvider);
        this.identityEndpoint = identityEndpoint;
      }
      static tryCreate(logger26, nodeStorage, networkClient, cryptoProvider) {
        let validatedIdentityEndpoint;
        if (process.env[ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]) {
          logger26.info(`[Managed Identity] Environment variable ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} for ${ManagedIdentitySourceNames.IMDS} returned endpoint: ${process.env[ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]}`);
          validatedIdentityEndpoint = _Imds.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST, `${process.env[ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]}${IMDS_TOKEN_PATH}`, ManagedIdentitySourceNames.IMDS, logger26);
        } else {
          logger26.info(`[Managed Identity] Unable to find ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} environment variable for ${ManagedIdentitySourceNames.IMDS}, using the default endpoint.`);
          validatedIdentityEndpoint = DEFAULT_IMDS_ENDPOINT;
        }
        return new _Imds(logger26, nodeStorage, networkClient, cryptoProvider, validatedIdentityEndpoint);
      }
      createRequest(resource, managedIdentityId) {
        const request3 = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
        request3.headers[METADATA_HEADER_NAME] = "true";
        request3.queryParameters[API_VERSION_QUERY_PARAMETER_NAME] = IMDS_API_VERSION;
        request3.queryParameters[RESOURCE_BODY_OR_QUERY_PARAMETER_NAME] = resource;
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          request3.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;
        }
        return request3;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs
var SERVICE_FABRIC_MSI_API_VERSION, ServiceFabric;
var init_ServiceFabric = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs"() {
    "use strict";
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
    SERVICE_FABRIC_MSI_API_VERSION = "2019-07-01-preview";
    ServiceFabric = class _ServiceFabric extends BaseManagedIdentitySource {
      constructor(logger26, nodeStorage, networkClient, cryptoProvider, identityEndpoint, identityHeader) {
        super(logger26, nodeStorage, networkClient, cryptoProvider);
        this.identityEndpoint = identityEndpoint;
        this.identityHeader = identityHeader;
      }
      static getEnvironmentVariables() {
        const identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
        const identityHeader = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER];
        const identityServerThumbprint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_SERVER_THUMBPRINT];
        return [identityEndpoint, identityHeader, identityServerThumbprint];
      }
      static tryCreate(logger26, nodeStorage, networkClient, cryptoProvider, managedIdentityId) {
        const [identityEndpoint, identityHeader, identityServerThumbprint] = _ServiceFabric.getEnvironmentVariables();
        if (!identityEndpoint || !identityHeader || !identityServerThumbprint) {
          logger26.info(`[Managed Identity] ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity is unavailable because one or all of the '${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}', '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' or '${ManagedIdentityEnvironmentVariableNames.IDENTITY_SERVER_THUMBPRINT}' environment variables are not defined.`);
          return null;
        }
        const validatedIdentityEndpoint = _ServiceFabric.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.SERVICE_FABRIC, logger26);
        logger26.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity.`);
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          logger26.warning(`[Managed Identity] ${ManagedIdentitySourceNames.SERVICE_FABRIC} user assigned managed identity is configured in the cluster, not during runtime. See also: https://learn.microsoft.com/en-us/azure/service-fabric/configure-existing-cluster-enable-managed-identity-token-service.`);
        }
        return new _ServiceFabric(logger26, nodeStorage, networkClient, cryptoProvider, identityEndpoint, identityHeader);
      }
      createRequest(resource, managedIdentityId) {
        const request3 = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
        request3.headers[SERVICE_FABRIC_SECRET_HEADER_NAME] = this.identityHeader;
        request3.queryParameters[API_VERSION_QUERY_PARAMETER_NAME] = SERVICE_FABRIC_MSI_API_VERSION;
        request3.queryParameters[RESOURCE_BODY_OR_QUERY_PARAMETER_NAME] = resource;
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          request3.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;
        }
        return request3;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentityClient.mjs
var ManagedIdentityClient;
var init_ManagedIdentityClient = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentityClient.mjs"() {
    "use strict";
    init_AppService();
    init_AzureArc();
    init_CloudShell();
    init_Imds();
    init_ServiceFabric();
    init_ManagedIdentityError();
    init_Constants2();
    init_ManagedIdentityErrorCodes();
    ManagedIdentityClient = class _ManagedIdentityClient {
      constructor(logger26, nodeStorage, networkClient, cryptoProvider) {
        this.logger = logger26;
        this.nodeStorage = nodeStorage;
        this.networkClient = networkClient;
        this.cryptoProvider = cryptoProvider;
      }
      async sendManagedIdentityTokenRequest(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
        if (!_ManagedIdentityClient.identitySource) {
          _ManagedIdentityClient.identitySource = this.selectManagedIdentitySource(this.logger, this.nodeStorage, this.networkClient, this.cryptoProvider, managedIdentityId);
        }
        return _ManagedIdentityClient.identitySource.acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken);
      }
      allEnvironmentVariablesAreDefined(environmentVariables) {
        return Object.values(environmentVariables).every((environmentVariable) => {
          return environmentVariable !== void 0;
        });
      }
      /**
       * Determine the Managed Identity Source based on available environment variables. This API is consumed by ManagedIdentityApplication's getManagedIdentitySource.
       * @returns ManagedIdentitySourceNames - The Managed Identity source's name
       */
      getManagedIdentitySource() {
        _ManagedIdentityClient.sourceName = this.allEnvironmentVariablesAreDefined(ServiceFabric.getEnvironmentVariables()) ? ManagedIdentitySourceNames.SERVICE_FABRIC : this.allEnvironmentVariablesAreDefined(AppService.getEnvironmentVariables()) ? ManagedIdentitySourceNames.APP_SERVICE : this.allEnvironmentVariablesAreDefined(CloudShell.getEnvironmentVariables()) ? ManagedIdentitySourceNames.CLOUD_SHELL : this.allEnvironmentVariablesAreDefined(AzureArc.getEnvironmentVariables()) ? ManagedIdentitySourceNames.AZURE_ARC : ManagedIdentitySourceNames.DEFAULT_TO_IMDS;
        return _ManagedIdentityClient.sourceName;
      }
      /**
       * Tries to create a managed identity source for all sources
       * @returns the managed identity Source
       */
      selectManagedIdentitySource(logger26, nodeStorage, networkClient, cryptoProvider, managedIdentityId) {
        const source = ServiceFabric.tryCreate(logger26, nodeStorage, networkClient, cryptoProvider, managedIdentityId) || AppService.tryCreate(logger26, nodeStorage, networkClient, cryptoProvider) || CloudShell.tryCreate(logger26, nodeStorage, networkClient, cryptoProvider, managedIdentityId) || AzureArc.tryCreate(logger26, nodeStorage, networkClient, cryptoProvider, managedIdentityId) || Imds.tryCreate(logger26, nodeStorage, networkClient, cryptoProvider);
        if (!source) {
          throw createManagedIdentityError(unableToCreateSource);
        }
        return source;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentityApplication.mjs
var ManagedIdentityApplication;
var init_ManagedIdentityApplication = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentityApplication.mjs"() {
    "use strict";
    init_index_node();
    init_Configuration();
    init_packageMetadata2();
    init_CryptoProvider();
    init_ClientCredentialClient();
    init_ManagedIdentityClient();
    init_NodeStorage();
    init_Constants2();
    ManagedIdentityApplication = class _ManagedIdentityApplication {
      constructor(configuration) {
        this.config = buildManagedIdentityConfiguration(configuration || {});
        this.logger = new Logger(this.config.system.loggerOptions, name2, version2);
        const fakeStatusAuthorityOptions = {
          canonicalAuthority: Constants.DEFAULT_AUTHORITY
        };
        if (!_ManagedIdentityApplication.nodeStorage) {
          _ManagedIdentityApplication.nodeStorage = new NodeStorage(this.logger, this.config.managedIdentityId.id, DEFAULT_CRYPTO_IMPLEMENTATION, fakeStatusAuthorityOptions);
        }
        this.networkClient = this.config.system.networkClient;
        this.cryptoProvider = new CryptoProvider();
        const fakeAuthorityOptions = {
          protocolMode: ProtocolMode.AAD,
          knownAuthorities: [DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY],
          cloudDiscoveryMetadata: "",
          authorityMetadata: ""
        };
        this.fakeAuthority = new Authority(
          DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY,
          this.networkClient,
          _ManagedIdentityApplication.nodeStorage,
          fakeAuthorityOptions,
          this.logger,
          this.cryptoProvider.createNewGuid(),
          // correlationID
          void 0,
          true
        );
        this.fakeClientCredentialClient = new ClientCredentialClient({
          authOptions: {
            clientId: this.config.managedIdentityId.id,
            authority: this.fakeAuthority
          }
        });
        this.managedIdentityClient = new ManagedIdentityClient(this.logger, _ManagedIdentityApplication.nodeStorage, this.networkClient, this.cryptoProvider);
      }
      /**
       * Acquire an access token from the cache or the managed identity
       * @param managedIdentityRequest - the ManagedIdentityRequestParams object passed in by the developer
       * @returns the access token
       */
      async acquireToken(managedIdentityRequestParams) {
        if (!managedIdentityRequestParams.resource) {
          throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.urlEmptyError);
        }
        const managedIdentityRequest = {
          forceRefresh: managedIdentityRequestParams.forceRefresh,
          resource: managedIdentityRequestParams.resource.replace("/.default", ""),
          scopes: [
            managedIdentityRequestParams.resource.replace("/.default", "")
          ],
          authority: this.fakeAuthority.canonicalAuthority,
          correlationId: this.cryptoProvider.createNewGuid()
        };
        if (managedIdentityRequest.forceRefresh) {
          return this.managedIdentityClient.sendManagedIdentityTokenRequest(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);
        }
        const [cachedAuthenticationResult, lastCacheOutcome] = await this.fakeClientCredentialClient.getCachedAuthenticationResult(managedIdentityRequest, this.config, this.cryptoProvider, this.fakeAuthority, _ManagedIdentityApplication.nodeStorage);
        if (cachedAuthenticationResult) {
          if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
            this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
            const refreshAccessToken = true;
            await this.managedIdentityClient.sendManagedIdentityTokenRequest(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority, refreshAccessToken);
          }
          return cachedAuthenticationResult;
        } else {
          return this.managedIdentityClient.sendManagedIdentityTokenRequest(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);
        }
      }
      /**
       * Determine the Managed Identity Source based on available environment variables. This API is consumed by Azure Identity SDK.
       * @returns ManagedIdentitySourceNames - The Managed Identity source's name
       */
      getManagedIdentitySource() {
        return ManagedIdentityClient.sourceName || this.managedIdentityClient.getManagedIdentitySource();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs
var DistributedCachePlugin;
var init_DistributedCachePlugin = __esm({
  "node_modules/@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs"() {
    "use strict";
    init_index_node();
    DistributedCachePlugin = class {
      constructor(client, partitionManager) {
        this.client = client;
        this.partitionManager = partitionManager;
      }
      async beforeCacheAccess(cacheContext) {
        const partitionKey = await this.partitionManager.getKey();
        const cacheData = await this.client.get(partitionKey);
        cacheContext.tokenCache.deserialize(cacheData);
      }
      async afterCacheAccess(cacheContext) {
        if (cacheContext.cacheHasChanged) {
          const kvStore = cacheContext.tokenCache.getKVStore();
          const accountEntities = Object.values(kvStore).filter((value) => AccountEntity.isAccountEntity(value));
          if (accountEntities.length > 0) {
            const accountEntity = accountEntities[0];
            const partitionKey = await this.partitionManager.extractKey(accountEntity);
            await this.client.set(partitionKey, cacheContext.tokenCache.serialize());
          }
        }
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  AuthError: () => AuthError,
  AuthErrorCodes: () => AuthErrorCodes_exports,
  AuthErrorMessage: () => AuthErrorMessage,
  AzureCloudInstance: () => AzureCloudInstance,
  ClientApplication: () => ClientApplication,
  ClientAssertion: () => ClientAssertion,
  ClientAuthError: () => ClientAuthError,
  ClientAuthErrorCodes: () => ClientAuthErrorCodes_exports,
  ClientAuthErrorMessage: () => ClientAuthErrorMessage,
  ClientConfigurationError: () => ClientConfigurationError,
  ClientConfigurationErrorCodes: () => ClientConfigurationErrorCodes_exports,
  ClientConfigurationErrorMessage: () => ClientConfigurationErrorMessage,
  ClientCredentialClient: () => ClientCredentialClient,
  ConfidentialClientApplication: () => ConfidentialClientApplication,
  CryptoProvider: () => CryptoProvider,
  DeviceCodeClient: () => DeviceCodeClient,
  DistributedCachePlugin: () => DistributedCachePlugin,
  InteractionRequiredAuthError: () => InteractionRequiredAuthError,
  InteractionRequiredAuthErrorCodes: () => InteractionRequiredAuthErrorCodes_exports,
  InteractionRequiredAuthErrorMessage: () => InteractionRequiredAuthErrorMessage,
  LogLevel: () => LogLevel,
  Logger: () => Logger,
  ManagedIdentityApplication: () => ManagedIdentityApplication,
  ManagedIdentitySourceNames: () => ManagedIdentitySourceNames,
  NodeStorage: () => NodeStorage,
  OnBehalfOfClient: () => OnBehalfOfClient,
  PromptValue: () => PromptValue,
  ProtocolMode: () => ProtocolMode,
  PublicClientApplication: () => PublicClientApplication,
  ResponseMode: () => ResponseMode,
  ServerError: () => ServerError,
  TokenCache: () => TokenCache,
  TokenCacheContext: () => TokenCacheContext,
  UsernamePasswordClient: () => UsernamePasswordClient,
  buildAppConfiguration: () => buildAppConfiguration,
  internals: () => internals_exports,
  version: () => version2
});
var init_dist = __esm({
  "node_modules/@azure/msal-node/dist/index.mjs"() {
    "use strict";
    init_internals();
    init_PublicClientApplication();
    init_ConfidentialClientApplication();
    init_ClientApplication();
    init_ClientCredentialClient();
    init_DeviceCodeClient();
    init_OnBehalfOfClient();
    init_ManagedIdentityApplication();
    init_UsernamePasswordClient();
    init_Configuration();
    init_ClientAssertion();
    init_TokenCache();
    init_NodeStorage();
    init_DistributedCachePlugin();
    init_Constants2();
    init_CryptoProvider();
    init_index_node();
    init_packageMetadata2();
  }
});

// node_modules/@azure/identity/dist-esm/src/msal/msal.js
var init_msal = __esm({
  "node_modules/@azure/identity/dist-esm/src/msal/msal.js"() {
    "use strict";
    init_dist();
  }
});

// node_modules/@azure/identity/dist-esm/src/msal/utils.js
function ensureValidMsalToken(scopes, msalToken, getTokenOptions) {
  const error = (message) => {
    logger6.getToken.info(message);
    return new AuthenticationRequiredError({
      scopes: Array.isArray(scopes) ? scopes : [scopes],
      getTokenOptions,
      message
    });
  };
  if (!msalToken) {
    throw error("No response");
  }
  if (!msalToken.expiresOn) {
    throw error(`Response had no "expiresOn" property.`);
  }
  if (!msalToken.accessToken) {
    throw error(`Response had no "accessToken" property.`);
  }
}
function getAuthority(tenantId, host) {
  if (!host) {
    host = DefaultAuthorityHost;
  }
  if (new RegExp(`${tenantId}/?$`).test(host)) {
    return host;
  }
  if (host.endsWith("/")) {
    return host + tenantId;
  } else {
    return `${host}/${tenantId}`;
  }
}
function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {
  if (tenantId === "adfs" && authorityHost || disableInstanceDiscovery) {
    return [authorityHost];
  }
  return [];
}
function getMSALLogLevel(logLevel) {
  switch (logLevel) {
    case "error":
      return dist_exports.LogLevel.Error;
    case "info":
      return dist_exports.LogLevel.Info;
    case "verbose":
      return dist_exports.LogLevel.Verbose;
    case "warning":
      return dist_exports.LogLevel.Warning;
    default:
      return dist_exports.LogLevel.Info;
  }
}
function handleMsalError(scopes, error, getTokenOptions) {
  if (error.name === "AuthError" || error.name === "ClientAuthError" || error.name === "BrowserAuthError") {
    const msalError = error;
    switch (msalError.errorCode) {
      case "endpoints_resolution_error":
        logger6.info(formatError(scopes, error.message));
        return new CredentialUnavailableError(error.message);
      case "device_code_polling_cancelled":
        return new AbortError2("The authentication has been aborted by the caller.");
      case "consent_required":
      case "interaction_required":
      case "login_required":
        logger6.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));
        break;
      default:
        logger6.info(formatError(scopes, `Failed to acquire token: ${error.message}`));
        break;
    }
  }
  if (error.name === "ClientConfigurationError" || error.name === "BrowserConfigurationAuthError" || error.name === "AbortError") {
    return error;
  }
  if (error.name === "NativeAuthError") {
    logger6.info(formatError(scopes, `Error from the native broker: ${error.message} with status code: ${error.statusCode}`));
    return error;
  }
  return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });
}
function publicToMsal(account) {
  const [environment] = account.authority.match(/([a-z]*\.[a-z]*\.[a-z]*)/) || [""];
  return Object.assign(Object.assign({}, account), { localAccountId: account.homeAccountId, environment });
}
function msalToPublic(clientId, account) {
  const record = {
    authority: getAuthority(account.tenantId, account.environment),
    homeAccountId: account.homeAccountId,
    tenantId: account.tenantId || DefaultTenantId,
    username: account.username,
    clientId,
    version: LatestAuthenticationRecordVersion
  };
  return record;
}
function serializeAuthenticationRecord(record) {
  return JSON.stringify(record);
}
function deserializeAuthenticationRecord(serializedRecord) {
  const parsed = JSON.parse(serializedRecord);
  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {
    throw Error("Unsupported AuthenticationRecord version");
  }
  return parsed;
}
var logger6, LatestAuthenticationRecordVersion, defaultLoggerCallback;
var init_utils3 = __esm({
  "node_modules/@azure/identity/dist-esm/src/msal/utils.js"() {
    "use strict";
    init_errors();
    init_logging();
    init_constants();
    init_esm3();
    init_src();
    init_msal();
    logger6 = credentialLogger("IdentityUtils");
    LatestAuthenticationRecordVersion = "1.0";
    defaultLoggerCallback = (credLogger, platform = isNode ? "Node" : "Browser") => (level, message, containsPii) => {
      if (containsPii) {
        return;
      }
      switch (level) {
        case dist_exports.LogLevel.Error:
          credLogger.info(`MSAL ${platform} V2 error: ${message}`);
          return;
        case dist_exports.LogLevel.Info:
          credLogger.info(`MSAL ${platform} V2 info message: ${message}`);
          return;
        case dist_exports.LogLevel.Verbose:
          credLogger.info(`MSAL ${platform} V2 verbose message: ${message}`);
          return;
        case dist_exports.LogLevel.Warning:
          credLogger.info(`MSAL ${platform} V2 warning: ${message}`);
          return;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/imdsMsi.js
function prepareRequestOptions(scopes, clientId, resourceId, options) {
  var _a3;
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName}: Multiple scopes are not supported.`);
  }
  const { skipQuery, skipMetadataHeader } = options || {};
  let query = "";
  if (!skipQuery) {
    const queryParameters = {
      resource,
      "api-version": imdsApiVersion
    };
    if (clientId) {
      queryParameters.client_id = clientId;
    }
    if (resourceId) {
      queryParameters.msi_res_id = resourceId;
    }
    const params = new URLSearchParams(queryParameters);
    query = `?${params.toString()}`;
  }
  const url = new URL(imdsEndpointPath, (_a3 = process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) !== null && _a3 !== void 0 ? _a3 : imdsHost);
  const rawHeaders = {
    Accept: "application/json",
    Metadata: "true"
  };
  if (skipMetadataHeader) {
    delete rawHeaders.Metadata;
  }
  return {
    // In this case, the `?` should be added in the "query" variable `skipQuery` is not set.
    url: `${url}${query}`,
    method: "GET",
    headers: createHttpHeaders(rawHeaders)
  };
}
var msiName, logger7, imdsMsi;
var init_imdsMsi = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/imdsMsi.js"() {
    "use strict";
    init_esm5();
    init_esm3();
    init_constants3();
    init_errors();
    init_logging();
    init_utils2();
    init_tracing();
    msiName = "ManagedIdentityCredential - IMDS";
    logger7 = credentialLogger(msiName);
    imdsMsi = {
      name: "imdsMsi",
      async isAvailable({ scopes, identityClient, clientId, resourceId, getTokenOptions = {} }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
          logger7.info(`${msiName}: Unavailable. Multiple scopes are not supported.`);
          return false;
        }
        if (process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) {
          return true;
        }
        if (!identityClient) {
          throw new Error("Missing IdentityClient");
        }
        const requestOptions = prepareRequestOptions(resource, clientId, resourceId, {
          skipMetadataHeader: true,
          skipQuery: true
        });
        return tracingClient.withSpan("ManagedIdentityCredential-pingImdsEndpoint", getTokenOptions, async (options) => {
          var _a3, _b2;
          requestOptions.tracingOptions = options.tracingOptions;
          const request3 = createPipelineRequest(requestOptions);
          request3.timeout = ((_a3 = options.requestOptions) === null || _a3 === void 0 ? void 0 : _a3.timeout) || 1e3;
          request3.allowInsecureConnection = true;
          let response;
          try {
            logger7.info(`${msiName}: Pinging the Azure IMDS endpoint`);
            response = await identityClient.sendRequest(request3);
          } catch (err) {
            if (isError(err)) {
              logger7.verbose(`${msiName}: Caught error ${err.name}: ${err.message}`);
            }
            logger7.info(`${msiName}: The Azure IMDS endpoint is unavailable`);
            return false;
          }
          if (response.status === 403) {
            if ((_b2 = response.bodyAsText) === null || _b2 === void 0 ? void 0 : _b2.includes("unreachable")) {
              logger7.info(`${msiName}: The Azure IMDS endpoint is unavailable`);
              logger7.info(`${msiName}: ${response.bodyAsText}`);
              return false;
            }
          }
          logger7.info(`${msiName}: The Azure IMDS endpoint is available`);
          return true;
        });
      },
      async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        if (process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) {
          logger7.info(`${msiName}: Using the Azure IMDS endpoint coming from the environment variable AZURE_POD_IDENTITY_AUTHORITY_HOST=${process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST}.`);
        } else {
          logger7.info(`${msiName}: Using the default Azure IMDS endpoint ${imdsHost}.`);
        }
        let nextDelayInMs = configuration.retryConfig.startDelayInMs;
        for (let retries = 0; retries < configuration.retryConfig.maxRetries; retries++) {
          try {
            const request3 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions(scopes, clientId, resourceId)), { allowInsecureConnection: true }));
            const tokenResponse = await identityClient.sendTokenRequest(request3);
            return tokenResponse && tokenResponse.accessToken || null;
          } catch (error) {
            if (error.statusCode === 404) {
              await delay(nextDelayInMs);
              nextDelayInMs *= configuration.retryConfig.intervalIncrement;
              continue;
            }
            throw error;
          }
        }
        throw new AuthenticationError(404, `${msiName}: Failed to retrieve IMDS token after ${configuration.retryConfig.maxRetries} retries.`);
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/imdsRetryPolicy.js
function imdsRetryPolicy(msiRetryConfig) {
  return retryPolicy([
    {
      name: "imdsRetryPolicy",
      retry: ({ retryCount, response }) => {
        if ((response === null || response === void 0 ? void 0 : response.status) !== 404) {
          return { skipStrategy: true };
        }
        const exponentialDelay = msiRetryConfig.startDelayInMs * Math.pow(2, retryCount);
        const clampedExponentialDelay = Math.min(DEFAULT_CLIENT_MAX_RETRY_INTERVAL2, exponentialDelay);
        const retryAfterInMs = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
        return { retryAfterInMs };
      }
    }
  ], {
    maxRetries: msiRetryConfig.maxRetries
  });
}
var DEFAULT_CLIENT_MAX_RETRY_INTERVAL2;
var init_imdsRetryPolicy = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/imdsRetryPolicy.js"() {
    "use strict";
    init_esm5();
    init_esm3();
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL2 = 1e3 * 64;
  }
});

// node_modules/@azure/identity/dist-esm/src/regionalAuthority.js
function calculateRegionalAuthority(regionalAuthority) {
  var _a3, _b2;
  let azureRegion = regionalAuthority;
  if (azureRegion === void 0 && ((_b2 = (_a3 = globalThis.process) === null || _a3 === void 0 ? void 0 : _a3.env) === null || _b2 === void 0 ? void 0 : _b2.AZURE_REGIONAL_AUTHORITY_NAME) !== void 0) {
    azureRegion = process.env.AZURE_REGIONAL_AUTHORITY_NAME;
  }
  if (azureRegion === RegionalAuthority.AutoDiscoverRegion) {
    return "AUTO_DISCOVER";
  }
  return azureRegion;
}
var RegionalAuthority;
var init_regionalAuthority = __esm({
  "node_modules/@azure/identity/dist-esm/src/regionalAuthority.js"() {
    "use strict";
    (function(RegionalAuthority2) {
      RegionalAuthority2["AutoDiscoverRegion"] = "AutoDiscoverRegion";
      RegionalAuthority2["USWest"] = "westus";
      RegionalAuthority2["USWest2"] = "westus2";
      RegionalAuthority2["USCentral"] = "centralus";
      RegionalAuthority2["USEast"] = "eastus";
      RegionalAuthority2["USEast2"] = "eastus2";
      RegionalAuthority2["USNorthCentral"] = "northcentralus";
      RegionalAuthority2["USSouthCentral"] = "southcentralus";
      RegionalAuthority2["USWestCentral"] = "westcentralus";
      RegionalAuthority2["CanadaCentral"] = "canadacentral";
      RegionalAuthority2["CanadaEast"] = "canadaeast";
      RegionalAuthority2["BrazilSouth"] = "brazilsouth";
      RegionalAuthority2["EuropeNorth"] = "northeurope";
      RegionalAuthority2["EuropeWest"] = "westeurope";
      RegionalAuthority2["UKSouth"] = "uksouth";
      RegionalAuthority2["UKWest"] = "ukwest";
      RegionalAuthority2["FranceCentral"] = "francecentral";
      RegionalAuthority2["FranceSouth"] = "francesouth";
      RegionalAuthority2["SwitzerlandNorth"] = "switzerlandnorth";
      RegionalAuthority2["SwitzerlandWest"] = "switzerlandwest";
      RegionalAuthority2["GermanyNorth"] = "germanynorth";
      RegionalAuthority2["GermanyWestCentral"] = "germanywestcentral";
      RegionalAuthority2["NorwayWest"] = "norwaywest";
      RegionalAuthority2["NorwayEast"] = "norwayeast";
      RegionalAuthority2["AsiaEast"] = "eastasia";
      RegionalAuthority2["AsiaSouthEast"] = "southeastasia";
      RegionalAuthority2["JapanEast"] = "japaneast";
      RegionalAuthority2["JapanWest"] = "japanwest";
      RegionalAuthority2["AustraliaEast"] = "australiaeast";
      RegionalAuthority2["AustraliaSouthEast"] = "australiasoutheast";
      RegionalAuthority2["AustraliaCentral"] = "australiacentral";
      RegionalAuthority2["AustraliaCentral2"] = "australiacentral2";
      RegionalAuthority2["IndiaCentral"] = "centralindia";
      RegionalAuthority2["IndiaSouth"] = "southindia";
      RegionalAuthority2["IndiaWest"] = "westindia";
      RegionalAuthority2["KoreaSouth"] = "koreasouth";
      RegionalAuthority2["KoreaCentral"] = "koreacentral";
      RegionalAuthority2["UAECentral"] = "uaecentral";
      RegionalAuthority2["UAENorth"] = "uaenorth";
      RegionalAuthority2["SouthAfricaNorth"] = "southafricanorth";
      RegionalAuthority2["SouthAfricaWest"] = "southafricawest";
      RegionalAuthority2["ChinaNorth"] = "chinanorth";
      RegionalAuthority2["ChinaEast"] = "chinaeast";
      RegionalAuthority2["ChinaNorth2"] = "chinanorth2";
      RegionalAuthority2["ChinaEast2"] = "chinaeast2";
      RegionalAuthority2["GermanyCentral"] = "germanycentral";
      RegionalAuthority2["GermanyNorthEast"] = "germanynortheast";
      RegionalAuthority2["GovernmentUSVirginia"] = "usgovvirginia";
      RegionalAuthority2["GovernmentUSIowa"] = "usgoviowa";
      RegionalAuthority2["GovernmentUSArizona"] = "usgovarizona";
      RegionalAuthority2["GovernmentUSTexas"] = "usgovtexas";
      RegionalAuthority2["GovernmentUSDodEast"] = "usdodeast";
      RegionalAuthority2["GovernmentUSDodCentral"] = "usdodcentral";
    })(RegionalAuthority || (RegionalAuthority = {}));
  }
});

// node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "node_modules/is-docker/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs2.statSync("/.dockerenv");
        return true;
      } catch (_2) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs2.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_2) {
        return false;
      }
    }
    module2.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "node_modules/is-wsl/index.js"(exports2, module2) {
    "use strict";
    var os3 = require("os");
    var fs2 = require("fs");
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os3.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_2) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module2.exports = isWsl;
    } else {
      module2.exports = isWsl();
    }
  }
});

// node_modules/define-lazy-prop/index.js
var require_define_lazy_prop = __commonJS({
  "node_modules/define-lazy-prop/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (object, propertyName, fn) => {
      const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define2(result);
          return result;
        },
        set(value) {
          define2(value);
        }
      });
      return object;
    };
  }
});

// node_modules/open/index.js
var require_open = __commonJS({
  "node_modules/open/index.js"(exports2, module2) {
    "use strict";
    var path4 = require("path");
    var childProcess2 = require("child_process");
    var { promises: fs2, constants: fsConstants } = require("fs");
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker();
    var defineLazyProperty = require_define_lazy_prop();
    var localXdgOpenPath = path4.join(__dirname, "xdg-open");
    var { platform, arch: arch2 } = process;
    var hasContainerEnv = () => {
      try {
        fs2.statSync("/run/.containerenv");
        return true;
      } catch {
        return false;
      }
    };
    var cachedResult;
    function isInsideContainer() {
      if (cachedResult === void 0) {
        cachedResult = hasContainerEnv() || isDocker();
      }
      return cachedResult;
    }
    var getWslDrivesMountPoint = /* @__PURE__ */ (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs2.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs2.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array, mapper) => {
      let latestError;
      for (const item of array) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    var baseOpen = async (options) => {
      options = {
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false,
        ...options
      };
      if (Array.isArray(options.app)) {
        return pTryEach(options.app, (singleApp) => baseOpen({
          ...options,
          app: singleApp
        }));
      }
      let { name: app, arguments: appArguments = [] } = options.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen({
          ...options,
          app: {
            name: appName,
            arguments: appArguments
          }
        }));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (options.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isInsideContainer() && !app) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "\u2013ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options.target) {
            appArguments.unshift(options.target);
          }
        } else if (options.target) {
          encodedArguments.push(`"${options.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs2.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options.target) {
        cliArguments.push(options.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess2.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (!options.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    var open2 = (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen({
        ...options,
        target
      });
    };
    var openApp = (name3, options) => {
      if (typeof name3 !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen({
        ...options,
        app: {
          name: name3,
          arguments: appArguments
        }
      });
    };
    function detectArchBinary(binary) {
      if (typeof binary === "string" || Array.isArray(binary)) {
        return binary;
      }
      const { [arch2]: archBinary } = binary;
      if (!archBinary) {
        throw new Error(`${arch2} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open2.apps = apps;
    open2.openApp = openApp;
    module2.exports = open2;
  }
});

// node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalOpenBrowser.js
var import_open, interactiveBrowserMockable;
var init_msalOpenBrowser = __esm({
  "node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalOpenBrowser.js"() {
    "use strict";
    import_open = __toESM(require_open());
    interactiveBrowserMockable = {
      open: import_open.default
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalClient.js
function generateMsalConfiguration(clientId, tenantId, msalClientOptions = {}) {
  var _a3, _b2, _c2, _d2;
  const resolvedTenant = resolveTenantId((_a3 = msalClientOptions.logger) !== null && _a3 !== void 0 ? _a3 : msalLogger, tenantId, clientId);
  const authority = getAuthority(resolvedTenant, (_b2 = msalClientOptions.authorityHost) !== null && _b2 !== void 0 ? _b2 : process.env.AZURE_AUTHORITY_HOST);
  const httpClient = new IdentityClient(Object.assign(Object.assign({}, msalClientOptions.tokenCredentialOptions), { authorityHost: authority, loggingOptions: msalClientOptions.loggingOptions }));
  const msalConfig = {
    auth: {
      clientId,
      authority,
      knownAuthorities: getKnownAuthorities(resolvedTenant, authority, msalClientOptions.disableInstanceDiscovery)
    },
    system: {
      networkClient: httpClient,
      loggerOptions: {
        loggerCallback: defaultLoggerCallback((_c2 = msalClientOptions.logger) !== null && _c2 !== void 0 ? _c2 : msalLogger),
        logLevel: getMSALLogLevel(getLogLevel()),
        piiLoggingEnabled: (_d2 = msalClientOptions.loggingOptions) === null || _d2 === void 0 ? void 0 : _d2.enableUnsafeSupportLogging
      }
    }
  };
  return msalConfig;
}
function createMsalClient(clientId, tenantId, createMsalClientOptions = {}) {
  var _a3;
  const state3 = {
    msalConfig: generateMsalConfiguration(clientId, tenantId, createMsalClientOptions),
    cachedAccount: createMsalClientOptions.authenticationRecord ? publicToMsal(createMsalClientOptions.authenticationRecord) : null,
    pluginConfiguration: msalPlugins.generatePluginConfiguration(createMsalClientOptions),
    logger: (_a3 = createMsalClientOptions.logger) !== null && _a3 !== void 0 ? _a3 : msalLogger
  };
  const publicApps = /* @__PURE__ */ new Map();
  async function getPublicApp(options = {}) {
    const appKey = options.enableCae ? "CAE" : "default";
    let publicClientApp = publicApps.get(appKey);
    if (publicClientApp) {
      state3.logger.getToken.info("Existing PublicClientApplication found in cache, returning it.");
      return publicClientApp;
    }
    state3.logger.getToken.info(`Creating new PublicClientApplication with CAE ${options.enableCae ? "enabled" : "disabled"}.`);
    const cachePlugin = options.enableCae ? state3.pluginConfiguration.cache.cachePluginCae : state3.pluginConfiguration.cache.cachePlugin;
    state3.msalConfig.auth.clientCapabilities = options.enableCae ? ["cp1"] : void 0;
    publicClientApp = new PublicClientApplication(Object.assign(Object.assign({}, state3.msalConfig), { broker: { nativeBrokerPlugin: state3.pluginConfiguration.broker.nativeBrokerPlugin }, cache: { cachePlugin: await cachePlugin } }));
    publicApps.set(appKey, publicClientApp);
    return publicClientApp;
  }
  const confidentialApps = /* @__PURE__ */ new Map();
  async function getConfidentialApp(options = {}) {
    const appKey = options.enableCae ? "CAE" : "default";
    let confidentialClientApp = confidentialApps.get(appKey);
    if (confidentialClientApp) {
      state3.logger.getToken.info("Existing ConfidentialClientApplication found in cache, returning it.");
      return confidentialClientApp;
    }
    state3.logger.getToken.info(`Creating new ConfidentialClientApplication with CAE ${options.enableCae ? "enabled" : "disabled"}.`);
    const cachePlugin = options.enableCae ? state3.pluginConfiguration.cache.cachePluginCae : state3.pluginConfiguration.cache.cachePlugin;
    state3.msalConfig.auth.clientCapabilities = options.enableCae ? ["cp1"] : void 0;
    confidentialClientApp = new ConfidentialClientApplication(Object.assign(Object.assign({}, state3.msalConfig), { broker: { nativeBrokerPlugin: state3.pluginConfiguration.broker.nativeBrokerPlugin }, cache: { cachePlugin: await cachePlugin } }));
    confidentialApps.set(appKey, confidentialClientApp);
    return confidentialClientApp;
  }
  async function getTokenSilent(app, scopes, options = {}) {
    if (state3.cachedAccount === null) {
      state3.logger.getToken.info("No cached account found in local state, attempting to load it from MSAL cache.");
      const cache = app.getTokenCache();
      const accounts = await cache.getAllAccounts();
      if (accounts === void 0 || accounts.length === 0) {
        throw new AuthenticationRequiredError({ scopes });
      }
      if (accounts.length > 1) {
        state3.logger.info(`More than one account was found authenticated for this Client ID and Tenant ID.
However, no "authenticationRecord" has been provided for this credential,
therefore we're unable to pick between these accounts.
A new login attempt will be requested, to ensure the correct account is picked.
To work with multiple accounts for the same Client ID and Tenant ID, please provide an "authenticationRecord" when initializing a credential to prevent this from happening.`);
        throw new AuthenticationRequiredError({ scopes });
      }
      state3.cachedAccount = accounts[0];
    }
    if (options.claims) {
      state3.cachedClaims = options.claims;
    }
    const silentRequest = {
      account: state3.cachedAccount,
      scopes,
      claims: state3.cachedClaims
    };
    if (state3.pluginConfiguration.broker.isEnabled) {
      silentRequest.tokenQueryParameters || (silentRequest.tokenQueryParameters = {});
      if (state3.pluginConfiguration.broker.enableMsaPassthrough) {
        silentRequest.tokenQueryParameters["msal_request_type"] = "consumer_passthrough";
      }
    }
    state3.logger.getToken.info("Attempting to acquire token silently");
    return app.acquireTokenSilent(silentRequest);
  }
  function calculateRequestAuthority(options) {
    if (options === null || options === void 0 ? void 0 : options.tenantId) {
      return getAuthority(options.tenantId, createMsalClientOptions.authorityHost);
    }
    return state3.msalConfig.auth.authority;
  }
  async function withSilentAuthentication(msalApp, scopes, options, onAuthenticationRequired) {
    var _a4;
    let response = null;
    try {
      response = await getTokenSilent(msalApp, scopes, options);
    } catch (e) {
      if (e.name !== "AuthenticationRequiredError") {
        throw e;
      }
      if (options.disableAutomaticAuthentication) {
        throw new AuthenticationRequiredError({
          scopes,
          getTokenOptions: options,
          message: "Automatic authentication has been disabled. You may call the authentication() method."
        });
      }
    }
    if (response === null) {
      try {
        response = await onAuthenticationRequired();
      } catch (err) {
        throw handleMsalError(scopes, err, options);
      }
    }
    ensureValidMsalToken(scopes, response, options);
    state3.cachedAccount = (_a4 = response === null || response === void 0 ? void 0 : response.account) !== null && _a4 !== void 0 ? _a4 : null;
    state3.logger.getToken.info(formatSuccess(scopes));
    return {
      token: response.accessToken,
      expiresOnTimestamp: response.expiresOn.getTime()
    };
  }
  async function getTokenByClientSecret(scopes, clientSecret, options = {}) {
    state3.logger.getToken.info(`Attempting to acquire token using client secret`);
    state3.msalConfig.auth.clientSecret = clientSecret;
    const msalApp = await getConfidentialApp(options);
    try {
      const response = await msalApp.acquireTokenByClientCredential({
        scopes,
        authority: calculateRequestAuthority(options),
        azureRegion: calculateRegionalAuthority(),
        claims: options === null || options === void 0 ? void 0 : options.claims
      });
      ensureValidMsalToken(scopes, response, options);
      state3.logger.getToken.info(formatSuccess(scopes));
      return {
        token: response.accessToken,
        expiresOnTimestamp: response.expiresOn.getTime()
      };
    } catch (err) {
      throw handleMsalError(scopes, err, options);
    }
  }
  async function getTokenByClientAssertion(scopes, clientAssertion, options = {}) {
    state3.logger.getToken.info(`Attempting to acquire token using client assertion`);
    state3.msalConfig.auth.clientAssertion = clientAssertion;
    const msalApp = await getConfidentialApp(options);
    try {
      const response = await msalApp.acquireTokenByClientCredential({
        scopes,
        authority: calculateRequestAuthority(options),
        azureRegion: calculateRegionalAuthority(),
        claims: options === null || options === void 0 ? void 0 : options.claims,
        clientAssertion
      });
      ensureValidMsalToken(scopes, response, options);
      state3.logger.getToken.info(formatSuccess(scopes));
      return {
        token: response.accessToken,
        expiresOnTimestamp: response.expiresOn.getTime()
      };
    } catch (err) {
      throw handleMsalError(scopes, err, options);
    }
  }
  async function getTokenByClientCertificate(scopes, certificate, options = {}) {
    state3.logger.getToken.info(`Attempting to acquire token using client certificate`);
    state3.msalConfig.auth.clientCertificate = certificate;
    const msalApp = await getConfidentialApp(options);
    try {
      const response = await msalApp.acquireTokenByClientCredential({
        scopes,
        authority: calculateRequestAuthority(options),
        azureRegion: calculateRegionalAuthority(),
        claims: options === null || options === void 0 ? void 0 : options.claims
      });
      ensureValidMsalToken(scopes, response, options);
      state3.logger.getToken.info(formatSuccess(scopes));
      return {
        token: response.accessToken,
        expiresOnTimestamp: response.expiresOn.getTime()
      };
    } catch (err) {
      throw handleMsalError(scopes, err, options);
    }
  }
  async function getTokenByDeviceCode(scopes, deviceCodeCallback, options = {}) {
    state3.logger.getToken.info(`Attempting to acquire token using device code`);
    const msalApp = await getPublicApp(options);
    return withSilentAuthentication(msalApp, scopes, options, () => {
      var _a4, _b2;
      const requestOptions = {
        scopes,
        cancel: (_b2 = (_a4 = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _a4 === void 0 ? void 0 : _a4.aborted) !== null && _b2 !== void 0 ? _b2 : false,
        deviceCodeCallback,
        authority: calculateRequestAuthority(options),
        claims: options === null || options === void 0 ? void 0 : options.claims
      };
      const deviceCodeRequest = msalApp.acquireTokenByDeviceCode(requestOptions);
      if (options.abortSignal) {
        options.abortSignal.addEventListener("abort", () => {
          requestOptions.cancel = true;
        });
      }
      return deviceCodeRequest;
    });
  }
  async function getTokenByUsernamePassword(scopes, username, password, options = {}) {
    state3.logger.getToken.info(`Attempting to acquire token using username and password`);
    const msalApp = await getPublicApp(options);
    return withSilentAuthentication(msalApp, scopes, options, () => {
      const requestOptions = {
        scopes,
        username,
        password,
        authority: calculateRequestAuthority(options),
        claims: options === null || options === void 0 ? void 0 : options.claims
      };
      return msalApp.acquireTokenByUsernamePassword(requestOptions);
    });
  }
  function getActiveAccount() {
    if (!state3.cachedAccount) {
      return void 0;
    }
    return msalToPublic(clientId, state3.cachedAccount);
  }
  async function getTokenByAuthorizationCode(scopes, redirectUri, authorizationCode, clientSecret, options = {}) {
    state3.logger.getToken.info(`Attempting to acquire token using authorization code`);
    let msalApp;
    if (clientSecret) {
      state3.msalConfig.auth.clientSecret = clientSecret;
      msalApp = await getConfidentialApp(options);
    } else {
      msalApp = await getPublicApp(options);
    }
    return withSilentAuthentication(msalApp, scopes, options, () => {
      return msalApp.acquireTokenByCode({
        scopes,
        redirectUri,
        code: authorizationCode,
        authority: calculateRequestAuthority(options),
        claims: options === null || options === void 0 ? void 0 : options.claims
      });
    });
  }
  async function getTokenOnBehalfOf(scopes, userAssertionToken, clientCredentials, options = {}) {
    msalLogger.getToken.info(`Attempting to acquire token on behalf of another user`);
    if (typeof clientCredentials === "string") {
      msalLogger.getToken.info(`Using client secret for on behalf of flow`);
      state3.msalConfig.auth.clientSecret = clientCredentials;
    } else if (typeof clientCredentials === "function") {
      msalLogger.getToken.info(`Using client assertion callback for on behalf of flow`);
      state3.msalConfig.auth.clientAssertion = clientCredentials;
    } else {
      msalLogger.getToken.info(`Using client certificate for on behalf of flow`);
      state3.msalConfig.auth.clientCertificate = clientCredentials;
    }
    const msalApp = await getConfidentialApp(options);
    try {
      const response = await msalApp.acquireTokenOnBehalfOf({
        scopes,
        authority: calculateRequestAuthority(options),
        claims: options.claims,
        oboAssertion: userAssertionToken
      });
      ensureValidMsalToken(scopes, response, options);
      msalLogger.getToken.info(formatSuccess(scopes));
      return {
        token: response.accessToken,
        expiresOnTimestamp: response.expiresOn.getTime()
      };
    } catch (err) {
      throw handleMsalError(scopes, err, options);
    }
  }
  async function getTokenByInteractiveRequest(scopes, options = {}) {
    msalLogger.getToken.info(`Attempting to acquire token interactively`);
    const app = await getPublicApp(options);
    async function getBrokeredToken(useDefaultBrokerAccount) {
      var _a4;
      msalLogger.verbose("Authentication will resume through the broker");
      const interactiveRequest = createBaseInteractiveRequest();
      if (state3.pluginConfiguration.broker.parentWindowHandle) {
        interactiveRequest.windowHandle = Buffer.from(state3.pluginConfiguration.broker.parentWindowHandle);
      } else {
        msalLogger.warning("Parent window handle is not specified for the broker. This may cause unexpected behavior. Please provide the parentWindowHandle.");
      }
      if (state3.pluginConfiguration.broker.enableMsaPassthrough) {
        ((_a4 = interactiveRequest.tokenQueryParameters) !== null && _a4 !== void 0 ? _a4 : interactiveRequest.tokenQueryParameters = {})["msal_request_type"] = "consumer_passthrough";
      }
      if (useDefaultBrokerAccount) {
        interactiveRequest.prompt = "none";
        msalLogger.verbose("Attempting broker authentication using the default broker account");
      } else {
        msalLogger.verbose("Attempting broker authentication without the default broker account");
      }
      try {
        return await app.acquireTokenInteractive(interactiveRequest);
      } catch (e) {
        msalLogger.verbose(`Failed to authenticate through the broker: ${e.message}`);
        if (useDefaultBrokerAccount) {
          return getBrokeredToken(
            /* useDefaultBrokerAccount: */
            false
          );
        } else {
          throw e;
        }
      }
    }
    function createBaseInteractiveRequest() {
      var _a4, _b2;
      return {
        openBrowser: async (url) => {
          await interactiveBrowserMockable.open(url, { wait: true, newInstance: true });
        },
        scopes,
        authority: calculateRequestAuthority(options),
        claims: options === null || options === void 0 ? void 0 : options.claims,
        loginHint: options === null || options === void 0 ? void 0 : options.loginHint,
        errorTemplate: (_a4 = options === null || options === void 0 ? void 0 : options.browserCustomizationOptions) === null || _a4 === void 0 ? void 0 : _a4.errorMessage,
        successTemplate: (_b2 = options === null || options === void 0 ? void 0 : options.browserCustomizationOptions) === null || _b2 === void 0 ? void 0 : _b2.successMessage
      };
    }
    return withSilentAuthentication(app, scopes, options, async () => {
      var _a4;
      const interactiveRequest = createBaseInteractiveRequest();
      if (state3.pluginConfiguration.broker.isEnabled) {
        return getBrokeredToken((_a4 = state3.pluginConfiguration.broker.useDefaultBrokerAccount) !== null && _a4 !== void 0 ? _a4 : false);
      }
      return app.acquireTokenInteractive(interactiveRequest);
    });
  }
  return {
    getActiveAccount,
    getTokenByClientSecret,
    getTokenByClientAssertion,
    getTokenByClientCertificate,
    getTokenByDeviceCode,
    getTokenByUsernamePassword,
    getTokenByAuthorizationCode,
    getTokenOnBehalfOf,
    getTokenByInteractiveRequest
  };
}
var msalLogger;
var init_msalClient = __esm({
  "node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalClient.js"() {
    "use strict";
    init_dist();
    init_logging();
    init_msalPlugins();
    init_utils3();
    init_errors();
    init_identityClient();
    init_regionalAuthority();
    init_esm();
    init_tenantIdUtils();
    init_msalOpenBrowser();
    msalLogger = credentialLogger("MsalClient");
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/clientAssertionCredential.js
var logger8, ClientAssertionCredential;
var init_clientAssertionCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/clientAssertionCredential.js"() {
    "use strict";
    init_msalClient();
    init_tenantIdUtils();
    init_logging();
    init_tracing();
    logger8 = credentialLogger("ClientAssertionCredential");
    ClientAssertionCredential = class {
      /**
       * Creates an instance of the ClientAssertionCredential with the details
       * needed to authenticate against Microsoft Entra ID with a client
       * assertion provided by the developer through the `getAssertion` function parameter.
       *
       * @param tenantId - The Microsoft Entra tenant (directory) ID.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param getAssertion - A function that retrieves the assertion for the credential to use.
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, getAssertion, options = {}) {
        if (!tenantId || !clientId || !getAssertion) {
          throw new Error("ClientAssertionCredential: tenantId, clientId, and clientAssertion are required parameters.");
        }
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.options = options;
        this.getAssertion = getAssertion;
        this.msalClient = createMsalClient(clientId, tenantId, Object.assign(Object.assign({}, options), { logger: logger8, tokenCredentialOptions: this.options }));
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger8);
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalClient.getTokenByClientAssertion(arrayScopes, this.getAssertion, newOptions);
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/workloadIdentityCredential.js
var import_promises, credentialName, SupportedWorkloadEnvironmentVariables, logger9, WorkloadIdentityCredential;
var init_workloadIdentityCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/workloadIdentityCredential.js"() {
    "use strict";
    init_clientAssertionCredential();
    import_promises = require("fs/promises");
    init_errors();
    init_logging();
    init_tenantIdUtils();
    credentialName = "WorkloadIdentityCredential";
    SupportedWorkloadEnvironmentVariables = [
      "AZURE_TENANT_ID",
      "AZURE_CLIENT_ID",
      "AZURE_FEDERATED_TOKEN_FILE"
    ];
    logger9 = credentialLogger(credentialName);
    WorkloadIdentityCredential = class {
      /**
       * WorkloadIdentityCredential supports Microsoft Entra Workload ID on Kubernetes.
       *
       * @param options - The identity client options to use for authentication.
       */
      constructor(options) {
        this.azureFederatedTokenFileContent = void 0;
        this.cacheDate = void 0;
        const assignedEnv = processEnvVars(SupportedWorkloadEnvironmentVariables).assigned.join(", ");
        logger9.info(`Found the following environment variables: ${assignedEnv}`);
        const workloadIdentityCredentialOptions = options !== null && options !== void 0 ? options : {};
        const tenantId = workloadIdentityCredentialOptions.tenantId || process.env.AZURE_TENANT_ID;
        const clientId = workloadIdentityCredentialOptions.clientId || process.env.AZURE_CLIENT_ID;
        this.federatedTokenFilePath = workloadIdentityCredentialOptions.tokenFilePath || process.env.AZURE_FEDERATED_TOKEN_FILE;
        if (tenantId) {
          checkTenantId(logger9, tenantId);
        }
        if (clientId && tenantId && this.federatedTokenFilePath) {
          logger9.info(`Invoking ClientAssertionCredential with tenant ID: ${tenantId}, clientId: ${workloadIdentityCredentialOptions.clientId} and federated token path: [REDACTED]`);
          this.client = new ClientAssertionCredential(tenantId, clientId, this.readFileContents.bind(this), options);
        }
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options) {
        if (!this.client) {
          const errorMessage = `${credentialName}: is unavailable. tenantId, clientId, and federatedTokenFilePath are required parameters. 
      In DefaultAzureCredential and ManagedIdentityCredential, these can be provided as environment variables - 
      "AZURE_TENANT_ID",
      "AZURE_CLIENT_ID",
      "AZURE_FEDERATED_TOKEN_FILE". See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot  `;
          logger9.info(errorMessage);
          throw new CredentialUnavailableError(errorMessage);
        }
        logger9.info("Invoking getToken() of Client Assertion Credential");
        return this.client.getToken(scopes, options);
      }
      async readFileContents() {
        if (this.cacheDate !== void 0 && Date.now() - this.cacheDate >= 1e3 * 60 * 5) {
          this.azureFederatedTokenFileContent = void 0;
        }
        if (!this.federatedTokenFilePath) {
          throw new CredentialUnavailableError(`${credentialName}: is unavailable. Invalid file path provided ${this.federatedTokenFilePath}.`);
        }
        if (!this.azureFederatedTokenFileContent) {
          const file = await (0, import_promises.readFile)(this.federatedTokenFilePath, "utf8");
          const value = file.trim();
          if (!value) {
            throw new CredentialUnavailableError(`${credentialName}: is unavailable. No content on the file ${this.federatedTokenFilePath}.`);
          } else {
            this.azureFederatedTokenFileContent = value;
            this.cacheDate = Date.now();
          }
        }
        return this.azureFederatedTokenFileContent;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/tokenExchangeMsi.js
var msiName2, logger10, tokenExchangeMsi;
var init_tokenExchangeMsi = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/tokenExchangeMsi.js"() {
    "use strict";
    init_workloadIdentityCredential();
    init_logging();
    msiName2 = "ManagedIdentityCredential - Token Exchange";
    logger10 = credentialLogger(msiName2);
    tokenExchangeMsi = {
      name: "tokenExchangeMsi",
      async isAvailable({ clientId }) {
        const env = process.env;
        const result = Boolean((clientId || env.AZURE_CLIENT_ID) && env.AZURE_TENANT_ID && process.env.AZURE_FEDERATED_TOKEN_FILE);
        if (!result) {
          logger10.info(`${msiName2}: Unavailable. The environment variables needed are: AZURE_CLIENT_ID (or the client ID sent through the parameters), AZURE_TENANT_ID and AZURE_FEDERATED_TOKEN_FILE`);
        }
        return result;
      },
      async getToken(configuration, getTokenOptions = {}) {
        const { scopes, clientId } = configuration;
        const identityClientTokenCredentialOptions = {};
        const workloadIdentityCredential = new WorkloadIdentityCredential(Object.assign(Object.assign({ clientId, tenantId: process.env.AZURE_TENANT_ID, tokenFilePath: process.env.AZURE_FEDERATED_TOKEN_FILE }, identityClientTokenCredentialOptions), { disableInstanceDiscovery: true }));
        return workloadIdentityCredential.getToken(scopes, getTokenOptions);
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/msalMsiProvider.js
function isNetworkError(err) {
  if (err.errorCode === "network_error") {
    return true;
  }
  if (err.code === "ENETUNREACH" || err.code === "EHOSTUNREACH") {
    return true;
  }
  if (err.statusCode === 403 || err.code === 403) {
    if (err.message.includes("unreachable")) {
      return true;
    }
  }
  return false;
}
var logger11, MsalMsiProvider;
var init_msalMsiProvider = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/msalMsiProvider.js"() {
    "use strict";
    init_errors();
    init_logging();
    init_utils3();
    init_identityClient();
    init_dist();
    init_esm();
    init_imdsMsi();
    init_imdsRetryPolicy();
    init_utils2();
    init_tokenExchangeMsi();
    init_tracing();
    logger11 = credentialLogger("ManagedIdentityCredential(MSAL)");
    MsalMsiProvider = class {
      constructor(clientIdOrOptions, options = {}) {
        var _a3, _b2;
        this.msiRetryConfig = {
          maxRetries: 5,
          startDelayInMs: 800,
          intervalIncrement: 2
        };
        let _options = {};
        if (typeof clientIdOrOptions === "string") {
          this.clientId = clientIdOrOptions;
          _options = options;
        } else {
          this.clientId = clientIdOrOptions === null || clientIdOrOptions === void 0 ? void 0 : clientIdOrOptions.clientId;
          _options = clientIdOrOptions !== null && clientIdOrOptions !== void 0 ? clientIdOrOptions : {};
        }
        this.resourceId = _options === null || _options === void 0 ? void 0 : _options.resourceId;
        if (this.clientId && this.resourceId) {
          throw new Error(`ManagedIdentityCredential - Client Id and Resource Id can't be provided at the same time.`);
        }
        _options.allowInsecureConnection = true;
        if (((_a3 = _options === null || _options === void 0 ? void 0 : _options.retryOptions) === null || _a3 === void 0 ? void 0 : _a3.maxRetries) !== void 0) {
          this.msiRetryConfig.maxRetries = _options.retryOptions.maxRetries;
        }
        this.identityClient = new IdentityClient(Object.assign(Object.assign({}, _options), { additionalPolicies: [{ policy: imdsRetryPolicy(this.msiRetryConfig), position: "perCall" }] }));
        this.managedIdentityApp = new ManagedIdentityApplication({
          managedIdentityIdParams: {
            userAssignedClientId: this.clientId,
            userAssignedResourceId: this.resourceId
          },
          system: {
            // todo: proxyUrl?
            disableInternalRetries: true,
            networkClient: this.identityClient,
            loggerOptions: {
              logLevel: getMSALLogLevel(getLogLevel()),
              piiLoggingEnabled: (_b2 = options.loggingOptions) === null || _b2 === void 0 ? void 0 : _b2.enableUnsafeSupportLogging,
              loggerCallback: defaultLoggerCallback(logger11)
            }
          }
        });
        this.isAvailableIdentityClient = new IdentityClient(Object.assign(Object.assign({}, _options), { retryOptions: {
          maxRetries: 0
        } }));
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       * If an unexpected error occurs, an {@link AuthenticationError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        logger11.getToken.info("Using the MSAL provider for Managed Identity.");
        const resource = mapScopesToResource(scopes);
        if (!resource) {
          throw new CredentialUnavailableError(`ManagedIdentityCredential: Multiple scopes are not supported. Scopes: ${JSON.stringify(scopes)}`);
        }
        return tracingClient.withSpan("ManagedIdentityCredential.getToken", options, async () => {
          try {
            const isTokenExchangeMsi = await tokenExchangeMsi.isAvailable({
              scopes,
              clientId: this.clientId,
              getTokenOptions: options,
              identityClient: this.identityClient,
              resourceId: this.resourceId
            });
            const identitySource = this.managedIdentityApp.getManagedIdentitySource();
            const isImdsMsi = identitySource === "DefaultToImds" || identitySource === "Imds";
            if (isTokenExchangeMsi) {
              logger11.getToken.info("Using the token exchange managed identity.");
              const result = await tokenExchangeMsi.getToken({
                scopes,
                clientId: this.clientId,
                identityClient: this.identityClient,
                retryConfig: this.msiRetryConfig,
                resourceId: this.resourceId
              });
              if (result === null) {
                throw new CredentialUnavailableError("The managed identity endpoint was reached, yet no tokens were received.");
              }
              return result;
            } else if (isImdsMsi) {
              logger11.getToken.info("Using the IMDS endpoint to probe for availability.");
              const isAvailable = await imdsMsi.isAvailable({
                scopes,
                clientId: this.clientId,
                getTokenOptions: options,
                identityClient: this.isAvailableIdentityClient,
                resourceId: this.resourceId
              });
              if (!isAvailable) {
                throw new CredentialUnavailableError(`ManagedIdentityCredential: The managed identity endpoint is not available.`);
              }
            }
            logger11.getToken.info("Calling into MSAL for managed identity token.");
            const token = await this.managedIdentityApp.acquireToken({
              resource
            });
            this.ensureValidMsalToken(scopes, token, options);
            logger11.getToken.info(formatSuccess(scopes));
            return {
              expiresOnTimestamp: token.expiresOn.getTime(),
              token: token.accessToken
            };
          } catch (err) {
            logger11.getToken.error(formatError(scopes, err));
            if (err.name === "AuthenticationRequiredError") {
              throw err;
            }
            if (isNetworkError(err)) {
              throw new CredentialUnavailableError(`ManagedIdentityCredential: Network unreachable. Message: ${err.message}`);
            }
            throw new CredentialUnavailableError(`ManagedIdentityCredential: Authentication failed. Message ${err.message}`);
          }
        });
      }
      /**
       * Ensures the validity of the MSAL token
       */
      ensureValidMsalToken(scopes, msalToken, getTokenOptions) {
        const createError = (message) => {
          logger11.getToken.info(message);
          return new AuthenticationRequiredError({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            getTokenOptions,
            message
          });
        };
        if (!msalToken) {
          throw createError("No response");
        }
        if (!msalToken.expiresOn) {
          throw createError(`Response had no "expiresOn" property.`);
        }
        if (!msalToken.accessToken) {
          throw createError(`Response had no "accessToken" property.`);
        }
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/index.js
var ManagedIdentityCredential;
var init_managedIdentityCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/index.js"() {
    "use strict";
    init_msalMsiProvider();
    ManagedIdentityCredential = class {
      /**
       * @internal
       * @hidden
       */
      constructor(clientIdOrOptions, options) {
        this.implProvider = new MsalMsiProvider(clientIdOrOptions, options);
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       * If an unexpected error occurs, an {@link AuthenticationError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options) {
        return this.implProvider.getToken(scopes, options);
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/util/scopeUtils.js
function ensureScopes(scopes) {
  return Array.isArray(scopes) ? scopes : [scopes];
}
function ensureValidScopeForDevTimeCreds(scope, logger26) {
  if (!scope.match(/^[0-9a-zA-Z-_.:/]+$/)) {
    const error = new Error("Invalid scope was specified by the user or calling client");
    logger26.getToken.info(formatError(scope, error));
    throw error;
  }
}
function getScopeResource(scope) {
  return scope.replace(/\/.default$/, "");
}
var init_scopeUtils = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/scopeUtils.js"() {
    "use strict";
    init_logging();
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/azureCliCredential.js
var import_child_process, cliCredentialInternals, logger12, AzureCliCredential;
var init_azureCliCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/azureCliCredential.js"() {
    "use strict";
    init_tenantIdUtils();
    init_logging();
    init_scopeUtils();
    init_errors();
    import_child_process = __toESM(require("child_process"));
    init_tracing();
    cliCredentialInternals = {
      /**
       * @internal
       */
      getSafeWorkingDir() {
        if (process.platform === "win32") {
          if (!process.env.SystemRoot) {
            throw new Error("Azure CLI credential expects a 'SystemRoot' environment variable");
          }
          return process.env.SystemRoot;
        } else {
          return "/bin";
        }
      },
      /**
       * Gets the access token from Azure CLI
       * @param resource - The resource to use when getting the token
       * @internal
       */
      async getAzureCliAccessToken(resource, tenantId, timeout) {
        let tenantSection = [];
        if (tenantId) {
          tenantSection = ["--tenant", tenantId];
        }
        return new Promise((resolve, reject) => {
          try {
            import_child_process.default.execFile("az", [
              "account",
              "get-access-token",
              "--output",
              "json",
              "--resource",
              resource,
              ...tenantSection
            ], { cwd: cliCredentialInternals.getSafeWorkingDir(), shell: true, timeout }, (error, stdout, stderr2) => {
              resolve({ stdout, stderr: stderr2, error });
            });
          } catch (err) {
            reject(err);
          }
        });
      }
    };
    logger12 = credentialLogger("AzureCliCredential");
    AzureCliCredential = class {
      /**
       * Creates an instance of the {@link AzureCliCredential}.
       *
       * To use this credential, ensure that you have already logged
       * in via the 'az' tool using the command "az login" from the commandline.
       *
       * @param options - Options, to optionally allow multi-tenant requests.
       */
      constructor(options) {
        if (options === null || options === void 0 ? void 0 : options.tenantId) {
          checkTenantId(logger12, options === null || options === void 0 ? void 0 : options.tenantId);
          this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
        }
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.timeout = options === null || options === void 0 ? void 0 : options.processTimeoutInMs;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        const tenantId = processMultiTenantRequest(this.tenantId, options, this.additionallyAllowedTenantIds);
        if (tenantId) {
          checkTenantId(logger12, tenantId);
        }
        const scope = typeof scopes === "string" ? scopes : scopes[0];
        logger12.getToken.info(`Using the scope ${scope}`);
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
          var _a3, _b2, _c2, _d2;
          try {
            ensureValidScopeForDevTimeCreds(scope, logger12);
            const resource = getScopeResource(scope);
            const obj = await cliCredentialInternals.getAzureCliAccessToken(resource, tenantId, this.timeout);
            const specificScope = (_a3 = obj.stderr) === null || _a3 === void 0 ? void 0 : _a3.match("(.*)az login --scope(.*)");
            const isLoginError2 = ((_b2 = obj.stderr) === null || _b2 === void 0 ? void 0 : _b2.match("(.*)az login(.*)")) && !specificScope;
            const isNotInstallError = ((_c2 = obj.stderr) === null || _c2 === void 0 ? void 0 : _c2.match("az:(.*)not found")) || ((_d2 = obj.stderr) === null || _d2 === void 0 ? void 0 : _d2.startsWith("'az' is not recognized"));
            if (isNotInstallError) {
              const error = new CredentialUnavailableError("Azure CLI could not be found. Please visit https://aka.ms/azure-cli for installation instructions and then, once installed, authenticate to your Azure account using 'az login'.");
              logger12.getToken.info(formatError(scopes, error));
              throw error;
            }
            if (isLoginError2) {
              const error = new CredentialUnavailableError("Please run 'az login' from a command prompt to authenticate before using this credential.");
              logger12.getToken.info(formatError(scopes, error));
              throw error;
            }
            try {
              const responseData = obj.stdout;
              const response = this.parseRawResponse(responseData);
              logger12.getToken.info(formatSuccess(scopes));
              return response;
            } catch (e) {
              if (obj.stderr) {
                throw new CredentialUnavailableError(obj.stderr);
              }
              throw e;
            }
          } catch (err) {
            const error = err.name === "CredentialUnavailableError" ? err : new CredentialUnavailableError(err.message || "Unknown error while trying to retrieve the access token");
            logger12.getToken.info(formatError(scopes, error));
            throw error;
          }
        });
      }
      /**
       * Parses the raw JSON response from the Azure CLI into a usable AccessToken object
       *
       * @param rawResponse - The raw JSON response from the Azure CLI
       * @returns An access token with the expiry time parsed from the raw response
       *
       * The expiryTime of the credential's access token, in milliseconds, is calculated as follows:
       *
       * When available, expires_on (introduced in Azure CLI v2.54.0) will be preferred. Otherwise falls back to expiresOn.
       */
      parseRawResponse(rawResponse) {
        const response = JSON.parse(rawResponse);
        const token = response.accessToken;
        let expiresOnTimestamp = Number.parseInt(response.expires_on, 10) * 1e3;
        if (!isNaN(expiresOnTimestamp)) {
          logger12.getToken.info("expires_on is available and is valid, using it");
          return {
            token,
            expiresOnTimestamp
          };
        }
        expiresOnTimestamp = new Date(response.expiresOn).getTime();
        if (isNaN(expiresOnTimestamp)) {
          throw new CredentialUnavailableError(`Unexpected response from Azure CLI when getting token. Expected "expiresOn" to be a RFC3339 date string. Got: "${response.expiresOn}"`);
        }
        return {
          token,
          expiresOnTimestamp
        };
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/azureDeveloperCliCredential.js
var import_child_process2, developerCliCredentialInternals, logger13, AzureDeveloperCliCredential;
var init_azureDeveloperCliCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/azureDeveloperCliCredential.js"() {
    "use strict";
    init_logging();
    init_errors();
    import_child_process2 = __toESM(require("child_process"));
    init_tenantIdUtils();
    init_tracing();
    init_scopeUtils();
    developerCliCredentialInternals = {
      /**
       * @internal
       */
      getSafeWorkingDir() {
        if (process.platform === "win32") {
          if (!process.env.SystemRoot) {
            throw new Error("Azure Developer CLI credential expects a 'SystemRoot' environment variable");
          }
          return process.env.SystemRoot;
        } else {
          return "/bin";
        }
      },
      /**
       * Gets the access token from Azure Developer CLI
       * @param scopes - The scopes to use when getting the token
       * @internal
       */
      async getAzdAccessToken(scopes, tenantId, timeout) {
        let tenantSection = [];
        if (tenantId) {
          tenantSection = ["--tenant-id", tenantId];
        }
        return new Promise((resolve, reject) => {
          try {
            import_child_process2.default.execFile("azd", [
              "auth",
              "token",
              "--output",
              "json",
              ...scopes.reduce((previous, current) => previous.concat("--scope", current), []),
              ...tenantSection
            ], {
              cwd: developerCliCredentialInternals.getSafeWorkingDir(),
              timeout
            }, (error, stdout, stderr2) => {
              resolve({ stdout, stderr: stderr2, error });
            });
          } catch (err) {
            reject(err);
          }
        });
      }
    };
    logger13 = credentialLogger("AzureDeveloperCliCredential");
    AzureDeveloperCliCredential = class {
      /**
       * Creates an instance of the {@link AzureDeveloperCliCredential}.
       *
       * To use this credential, ensure that you have already logged
       * in via the 'azd' tool using the command "azd auth login" from the commandline.
       *
       * @param options - Options, to optionally allow multi-tenant requests.
       */
      constructor(options) {
        if (options === null || options === void 0 ? void 0 : options.tenantId) {
          checkTenantId(logger13, options === null || options === void 0 ? void 0 : options.tenantId);
          this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
        }
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.timeout = options === null || options === void 0 ? void 0 : options.processTimeoutInMs;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        const tenantId = processMultiTenantRequest(this.tenantId, options, this.additionallyAllowedTenantIds);
        if (tenantId) {
          checkTenantId(logger13, tenantId);
        }
        let scopeList;
        if (typeof scopes === "string") {
          scopeList = [scopes];
        } else {
          scopeList = scopes;
        }
        logger13.getToken.info(`Using the scopes ${scopes}`);
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
          var _a3, _b2, _c2, _d2;
          try {
            scopeList.forEach((scope) => {
              ensureValidScopeForDevTimeCreds(scope, logger13);
            });
            const obj = await developerCliCredentialInternals.getAzdAccessToken(scopeList, tenantId, this.timeout);
            const isNotLoggedInError = ((_a3 = obj.stderr) === null || _a3 === void 0 ? void 0 : _a3.match("not logged in, run `azd login` to login")) || ((_b2 = obj.stderr) === null || _b2 === void 0 ? void 0 : _b2.match("not logged in, run `azd auth login` to login"));
            const isNotInstallError = ((_c2 = obj.stderr) === null || _c2 === void 0 ? void 0 : _c2.match("azd:(.*)not found")) || ((_d2 = obj.stderr) === null || _d2 === void 0 ? void 0 : _d2.startsWith("'azd' is not recognized"));
            if (isNotInstallError || obj.error && obj.error.code === "ENOENT") {
              const error = new CredentialUnavailableError("Azure Developer CLI couldn't be found. To mitigate this issue, see the troubleshooting guidelines at https://aka.ms/azsdk/js/identity/azdevclicredential/troubleshoot.");
              logger13.getToken.info(formatError(scopes, error));
              throw error;
            }
            if (isNotLoggedInError) {
              const error = new CredentialUnavailableError("Please run 'azd auth login' from a command prompt to authenticate before using this credential. For more information, see the troubleshooting guidelines at https://aka.ms/azsdk/js/identity/azdevclicredential/troubleshoot.");
              logger13.getToken.info(formatError(scopes, error));
              throw error;
            }
            try {
              const resp = JSON.parse(obj.stdout);
              logger13.getToken.info(formatSuccess(scopes));
              return {
                token: resp.token,
                expiresOnTimestamp: new Date(resp.expiresOn).getTime()
              };
            } catch (e) {
              if (obj.stderr) {
                throw new CredentialUnavailableError(obj.stderr);
              }
              throw e;
            }
          } catch (err) {
            const error = err.name === "CredentialUnavailableError" ? err : new CredentialUnavailableError(err.message || "Unknown error while trying to retrieve the access token");
            logger13.getToken.info(formatError(scopes, error));
            throw error;
          }
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/util/processUtils.js
var childProcess, processUtils;
var init_processUtils = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/processUtils.js"() {
    "use strict";
    childProcess = __toESM(require("child_process"));
    processUtils = {
      /**
       * Promisifying childProcess.execFile
       * @internal
       */
      execFile(file, params, options) {
        return new Promise((resolve, reject) => {
          childProcess.execFile(file, params, options, (error, stdout, stderr2) => {
            if (Buffer.isBuffer(stdout)) {
              stdout = stdout.toString("utf8");
            }
            if (Buffer.isBuffer(stderr2)) {
              stderr2 = stderr2.toString("utf8");
            }
            if (stderr2 || error) {
              reject(stderr2 ? new Error(stderr2) : error);
            } else {
              resolve(stdout);
            }
          });
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/azurePowerShellCredential.js
function formatCommand(commandName) {
  if (isWindows) {
    return `${commandName}.exe`;
  } else {
    return commandName;
  }
}
async function runCommands(commands, timeout) {
  const results = [];
  for (const command of commands) {
    const [file, ...parameters] = command;
    const result = await processUtils.execFile(file, parameters, {
      encoding: "utf8",
      timeout
    });
    results.push(result);
  }
  return results;
}
async function parseJsonToken(result) {
  const jsonRegex = /{[^{}]*}/g;
  const matches = result.match(jsonRegex);
  let resultWithoutToken = result;
  if (matches) {
    try {
      for (const item of matches) {
        try {
          const jsonContent = JSON.parse(item);
          if (jsonContent === null || jsonContent === void 0 ? void 0 : jsonContent.Token) {
            resultWithoutToken = resultWithoutToken.replace(item, "");
            if (resultWithoutToken) {
              logger14.getToken.warning(resultWithoutToken);
            }
            return jsonContent;
          }
        } catch (e) {
          continue;
        }
      }
    } catch (e) {
      throw new Error(`Unable to parse the output of PowerShell. Received output: ${result}`);
    }
  }
  throw new Error(`No access token found in the output. Received output: ${result}`);
}
var logger14, isWindows, powerShellErrors, powerShellPublicErrorMessages, isLoginError, isNotInstalledError, commandStack, AzurePowerShellCredential;
var init_azurePowerShellCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/azurePowerShellCredential.js"() {
    "use strict";
    init_tenantIdUtils();
    init_logging();
    init_scopeUtils();
    init_errors();
    init_processUtils();
    init_tracing();
    logger14 = credentialLogger("AzurePowerShellCredential");
    isWindows = process.platform === "win32";
    powerShellErrors = {
      login: "Run Connect-AzAccount to login",
      installed: "The specified module 'Az.Accounts' with version '2.2.0' was not loaded because no valid module file was found in any module directory"
    };
    powerShellPublicErrorMessages = {
      login: "Please run 'Connect-AzAccount' from PowerShell to authenticate before using this credential.",
      installed: `The 'Az.Account' module >= 2.2.0 is not installed. Install the Azure Az PowerShell module with: "Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force".`,
      troubleshoot: `To troubleshoot, visit https://aka.ms/azsdk/js/identity/powershellcredential/troubleshoot.`
    };
    isLoginError = (err) => err.message.match(`(.*)${powerShellErrors.login}(.*)`);
    isNotInstalledError = (err) => err.message.match(powerShellErrors.installed);
    commandStack = [formatCommand("pwsh")];
    if (isWindows) {
      commandStack.push(formatCommand("powershell"));
    }
    AzurePowerShellCredential = class {
      /**
       * Creates an instance of the {@link AzurePowerShellCredential}.
       *
       * To use this credential:
       * - Install the Azure Az PowerShell module with:
       *   `Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force`.
       * - You have already logged in to Azure PowerShell using the command
       * `Connect-AzAccount` from the command line.
       *
       * @param options - Options, to optionally allow multi-tenant requests.
       */
      constructor(options) {
        if (options === null || options === void 0 ? void 0 : options.tenantId) {
          checkTenantId(logger14, options === null || options === void 0 ? void 0 : options.tenantId);
          this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
        }
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.timeout = options === null || options === void 0 ? void 0 : options.processTimeoutInMs;
      }
      /**
       * Gets the access token from Azure PowerShell
       * @param resource - The resource to use when getting the token
       */
      async getAzurePowerShellAccessToken(resource, tenantId, timeout) {
        for (const powerShellCommand of [...commandStack]) {
          try {
            await runCommands([[powerShellCommand, "/?"]], timeout);
          } catch (e) {
            commandStack.shift();
            continue;
          }
          let tenantSection = "";
          if (tenantId) {
            tenantSection = `-TenantId "${tenantId}"`;
          }
          const results = await runCommands([
            [
              powerShellCommand,
              "-NoProfile",
              "-NonInteractive",
              "-Command",
              "Import-Module Az.Accounts -MinimumVersion 2.2.0 -PassThru"
            ],
            [
              powerShellCommand,
              "-NoProfile",
              "-NonInteractive",
              "-Command",
              `Get-AzAccessToken ${tenantSection} -ResourceUrl "${resource}" | ConvertTo-Json`
            ]
          ]);
          const result = results[1];
          return parseJsonToken(result);
        }
        throw new Error(`Unable to execute PowerShell. Ensure that it is installed in your system`);
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If the authentication cannot be performed through PowerShell, a {@link CredentialUnavailableError} will be thrown.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
          const tenantId = processMultiTenantRequest(this.tenantId, options, this.additionallyAllowedTenantIds);
          const scope = typeof scopes === "string" ? scopes : scopes[0];
          if (tenantId) {
            checkTenantId(logger14, tenantId);
          }
          try {
            ensureValidScopeForDevTimeCreds(scope, logger14);
            logger14.getToken.info(`Using the scope ${scope}`);
            const resource = getScopeResource(scope);
            const response = await this.getAzurePowerShellAccessToken(resource, tenantId, this.timeout);
            logger14.getToken.info(formatSuccess(scopes));
            return {
              token: response.Token,
              expiresOnTimestamp: new Date(response.ExpiresOn).getTime()
            };
          } catch (err) {
            if (isNotInstalledError(err)) {
              const error2 = new CredentialUnavailableError(powerShellPublicErrorMessages.installed);
              logger14.getToken.info(formatError(scope, error2));
              throw error2;
            } else if (isLoginError(err)) {
              const error2 = new CredentialUnavailableError(powerShellPublicErrorMessages.login);
              logger14.getToken.info(formatError(scope, error2));
              throw error2;
            }
            const error = new CredentialUnavailableError(`${err}. ${powerShellPublicErrorMessages.troubleshoot}`);
            logger14.getToken.info(formatError(scope, error));
            throw error;
          }
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/chainedTokenCredential.js
var logger15, ChainedTokenCredential;
var init_chainedTokenCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/chainedTokenCredential.js"() {
    "use strict";
    init_errors();
    init_logging();
    init_tracing();
    logger15 = credentialLogger("ChainedTokenCredential");
    ChainedTokenCredential = class {
      /**
       * Creates an instance of ChainedTokenCredential using the given credentials.
       *
       * @param sources - `TokenCredential` implementations to be tried in order.
       *
       * Example usage:
       * ```javascript
       * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
       * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
       * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
       * ```
       */
      constructor(...sources) {
        this._sources = [];
        this._sources = sources;
      }
      /**
       * Returns the first access token returned by one of the chained
       * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
       * when one or more credentials throws an {@link AuthenticationError} and
       * no credentials have returned an access token.
       *
       * This method is called automatically by Azure SDK client libraries. You may call this method
       * directly, but you must also handle token caching and token refreshing.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                `TokenCredential` implementation might make.
       */
      async getToken(scopes, options = {}) {
        const { token } = await this.getTokenInternal(scopes, options);
        return token;
      }
      async getTokenInternal(scopes, options = {}) {
        let token = null;
        let successfulCredential;
        const errors = [];
        return tracingClient.withSpan("ChainedTokenCredential.getToken", options, async (updatedOptions) => {
          for (let i = 0; i < this._sources.length && token === null; i++) {
            try {
              token = await this._sources[i].getToken(scopes, updatedOptions);
              successfulCredential = this._sources[i];
            } catch (err) {
              if (err.name === "CredentialUnavailableError" || err.name === "AuthenticationRequiredError") {
                errors.push(err);
              } else {
                logger15.getToken.info(formatError(scopes, err));
                throw err;
              }
            }
          }
          if (!token && errors.length > 0) {
            const err = new AggregateAuthenticationError(errors, "ChainedTokenCredential authentication failed.");
            logger15.getToken.info(formatError(scopes, err));
            throw err;
          }
          logger15.getToken.info(`Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`);
          if (token === null) {
            throw new CredentialUnavailableError("Failed to retrieve a valid token");
          }
          return { token, successfulCredential };
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/clientCertificateCredential.js
var import_crypto5, import_promises2, credentialName2, logger16, ClientCertificateCredential;
var init_clientCertificateCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/clientCertificateCredential.js"() {
    "use strict";
    init_msalClient();
    import_crypto5 = require("crypto");
    init_tenantIdUtils();
    init_logging();
    import_promises2 = require("fs/promises");
    init_tracing();
    credentialName2 = "ClientCertificateCredential";
    logger16 = credentialLogger(credentialName2);
    ClientCertificateCredential = class {
      constructor(tenantId, clientId, certificatePathOrConfiguration, options = {}) {
        if (!tenantId || !clientId) {
          throw new Error(`${credentialName2}: tenantId and clientId are required parameters.`);
        }
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.sendCertificateChain = options.sendCertificateChain;
        this.certificateConfiguration = Object.assign({}, typeof certificatePathOrConfiguration === "string" ? {
          certificatePath: certificatePathOrConfiguration
        } : certificatePathOrConfiguration);
        const certificate = this.certificateConfiguration.certificate;
        const certificatePath = this.certificateConfiguration.certificatePath;
        if (!this.certificateConfiguration || !(certificate || certificatePath)) {
          throw new Error(`${credentialName2}: Provide either a PEM certificate in string form, or the path to that certificate in the filesystem. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        if (certificate && certificatePath) {
          throw new Error(`${credentialName2}: To avoid unexpected behaviors, providing both the contents of a PEM certificate and the path to a PEM certificate is forbidden. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        this.msalClient = createMsalClient(clientId, tenantId, Object.assign(Object.assign({}, options), { logger: logger16, tokenCredentialOptions: options }));
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName2}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger16);
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          const certificate = await this.buildClientCertificate();
          return this.msalClient.getTokenByClientCertificate(arrayScopes, certificate, newOptions);
        });
      }
      async buildClientCertificate() {
        const parts = await this.parseCertificate();
        let privateKey;
        if (this.certificateConfiguration.certificatePassword !== void 0) {
          privateKey = (0, import_crypto5.createPrivateKey)({
            key: parts.certificateContents,
            passphrase: this.certificateConfiguration.certificatePassword,
            format: "pem"
          }).export({
            format: "pem",
            type: "pkcs8"
          }).toString();
        } else {
          privateKey = parts.certificateContents;
        }
        return {
          thumbprint: parts.thumbprint,
          privateKey,
          x5c: parts.x5c
        };
      }
      async parseCertificate() {
        const certificate = this.certificateConfiguration.certificate;
        const certificatePath = this.certificateConfiguration.certificatePath;
        const certificateContents = certificate || await (0, import_promises2.readFile)(certificatePath, "utf8");
        const x5c = this.sendCertificateChain ? certificateContents : void 0;
        const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
        const publicKeys = [];
        let match;
        do {
          match = certificatePattern.exec(certificateContents);
          if (match) {
            publicKeys.push(match[3]);
          }
        } while (match);
        if (publicKeys.length === 0) {
          throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
        }
        const thumbprint = (0, import_crypto5.createHash)("sha1").update(Buffer.from(publicKeys[0], "base64")).digest("hex").toUpperCase();
        return {
          certificateContents,
          thumbprint,
          x5c
        };
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/clientSecretCredential.js
var logger17, ClientSecretCredential;
var init_clientSecretCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/clientSecretCredential.js"() {
    "use strict";
    init_msalClient();
    init_tenantIdUtils();
    init_logging();
    init_scopeUtils();
    init_tracing();
    logger17 = credentialLogger("ClientSecretCredential");
    ClientSecretCredential = class {
      /**
       * Creates an instance of the ClientSecretCredential with the details
       * needed to authenticate against Microsoft Entra ID with a client
       * secret.
       *
       * @param tenantId - The Microsoft Entra tenant (directory) ID.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param clientSecret - A client secret that was generated for the App Registration.
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, clientSecret, options = {}) {
        if (!tenantId || !clientId || !clientSecret) {
          throw new Error("ClientSecretCredential: tenantId, clientId, and clientSecret are required parameters. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
        }
        this.clientSecret = clientSecret;
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.msalClient = createMsalClient(clientId, tenantId, Object.assign(Object.assign({}, options), { logger: logger17, tokenCredentialOptions: options }));
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger17);
          const arrayScopes = ensureScopes(scopes);
          return this.msalClient.getTokenByClientSecret(arrayScopes, this.clientSecret, newOptions);
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/usernamePasswordCredential.js
var logger18, UsernamePasswordCredential;
var init_usernamePasswordCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/usernamePasswordCredential.js"() {
    "use strict";
    init_tenantIdUtils();
    init_logging();
    init_scopeUtils();
    init_tracing();
    init_msalClient();
    logger18 = credentialLogger("UsernamePasswordCredential");
    UsernamePasswordCredential = class {
      /**
       * Creates an instance of the UsernamePasswordCredential with the details
       * needed to authenticate against Microsoft Entra ID with a username
       * and password.
       *
       * @param tenantId - The Microsoft Entra tenant (directory).
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param username - The user account's e-mail address (user name).
       * @param password - The user account's account password
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, username, password, options = {}) {
        if (!tenantId || !clientId || !username || !password) {
          throw new Error("UsernamePasswordCredential: tenantId, clientId, username and password are required parameters. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
        }
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.username = username;
        this.password = password;
        this.msalClient = createMsalClient(clientId, this.tenantId, Object.assign(Object.assign({}, options), { tokenCredentialOptions: options !== null && options !== void 0 ? options : {} }));
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger18);
          const arrayScopes = ensureScopes(scopes);
          return this.msalClient.getTokenByUsernamePassword(arrayScopes, this.username, this.password, newOptions);
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/environmentCredential.js
function getAdditionallyAllowedTenants() {
  var _a3;
  const additionallyAllowedValues = (_a3 = process.env.AZURE_ADDITIONALLY_ALLOWED_TENANTS) !== null && _a3 !== void 0 ? _a3 : "";
  return additionallyAllowedValues.split(";");
}
var AllSupportedEnvironmentVariables, credentialName3, logger19, EnvironmentCredential;
var init_environmentCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/environmentCredential.js"() {
    "use strict";
    init_errors();
    init_logging();
    init_clientCertificateCredential();
    init_clientSecretCredential();
    init_usernamePasswordCredential();
    init_tenantIdUtils();
    init_tracing();
    AllSupportedEnvironmentVariables = [
      "AZURE_TENANT_ID",
      "AZURE_CLIENT_ID",
      "AZURE_CLIENT_SECRET",
      "AZURE_CLIENT_CERTIFICATE_PATH",
      "AZURE_CLIENT_CERTIFICATE_PASSWORD",
      "AZURE_USERNAME",
      "AZURE_PASSWORD",
      "AZURE_ADDITIONALLY_ALLOWED_TENANTS"
    ];
    credentialName3 = "EnvironmentCredential";
    logger19 = credentialLogger(credentialName3);
    EnvironmentCredential = class {
      /**
       * Creates an instance of the EnvironmentCredential class and decides what credential to use depending on the available environment variables.
       *
       * Required environment variables:
       * - `AZURE_TENANT_ID`: The Microsoft Entra tenant (directory) ID.
       * - `AZURE_CLIENT_ID`: The client (application) ID of an App Registration in the tenant.
       *
       * If setting the AZURE_TENANT_ID, then you can also set the additionally allowed tenants
       * - `AZURE_ADDITIONALLY_ALLOWED_TENANTS`: For multi-tenant applications, specifies additional tenants for which the credential may acquire tokens with a single semicolon delimited string. Use * to allow all tenants.
       *
       * Environment variables used for client credential authentication:
       * - `AZURE_CLIENT_SECRET`: A client secret that was generated for the App Registration.
       * - `AZURE_CLIENT_CERTIFICATE_PATH`: The path to a PEM certificate to use during the authentication, instead of the client secret.
       * - `AZURE_CLIENT_CERTIFICATE_PASSWORD`: (optional) password for the certificate file.
       *
       * Alternatively, users can provide environment variables for username and password authentication:
       * - `AZURE_USERNAME`: Username to authenticate with.
       * - `AZURE_PASSWORD`: Password to authenticate with.
       *
       * If the environment variables required to perform the authentication are missing, a {@link CredentialUnavailableError} will be thrown.
       * If the authentication fails, or if there's an unknown error, an {@link AuthenticationError} will be thrown.
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(options) {
        this._credential = void 0;
        const assigned = processEnvVars(AllSupportedEnvironmentVariables).assigned.join(", ");
        logger19.info(`Found the following environment variables: ${assigned}`);
        const tenantId = process.env.AZURE_TENANT_ID, clientId = process.env.AZURE_CLIENT_ID, clientSecret = process.env.AZURE_CLIENT_SECRET;
        const additionallyAllowedTenantIds = getAdditionallyAllowedTenants();
        const newOptions = Object.assign(Object.assign({}, options), { additionallyAllowedTenantIds });
        if (tenantId) {
          checkTenantId(logger19, tenantId);
        }
        if (tenantId && clientId && clientSecret) {
          logger19.info(`Invoking ClientSecretCredential with tenant ID: ${tenantId}, clientId: ${clientId} and clientSecret: [REDACTED]`);
          this._credential = new ClientSecretCredential(tenantId, clientId, clientSecret, newOptions);
          return;
        }
        const certificatePath = process.env.AZURE_CLIENT_CERTIFICATE_PATH;
        const certificatePassword = process.env.AZURE_CLIENT_CERTIFICATE_PASSWORD;
        if (tenantId && clientId && certificatePath) {
          logger19.info(`Invoking ClientCertificateCredential with tenant ID: ${tenantId}, clientId: ${clientId} and certificatePath: ${certificatePath}`);
          this._credential = new ClientCertificateCredential(tenantId, clientId, { certificatePath, certificatePassword }, newOptions);
          return;
        }
        const username = process.env.AZURE_USERNAME;
        const password = process.env.AZURE_PASSWORD;
        if (tenantId && clientId && username && password) {
          logger19.info(`Invoking UsernamePasswordCredential with tenant ID: ${tenantId}, clientId: ${clientId} and username: ${username}`);
          this._credential = new UsernamePasswordCredential(tenantId, clientId, username, password, newOptions);
        }
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - Optional parameters. See {@link GetTokenOptions}.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName3}.getToken`, options, async (newOptions) => {
          if (this._credential) {
            try {
              const result = await this._credential.getToken(scopes, newOptions);
              logger19.getToken.info(formatSuccess(scopes));
              return result;
            } catch (err) {
              const authenticationError = new AuthenticationError(400, {
                error: `${credentialName3} authentication failed. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`,
                error_description: err.message.toString().split("More details:").join("")
              });
              logger19.getToken.info(formatError(scopes, authenticationError));
              throw authenticationError;
            }
          }
          throw new CredentialUnavailableError(`${credentialName3} is unavailable. No underlying credential could be used. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`);
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/defaultAzureCredential.js
function createDefaultManagedIdentityCredential(options = {}) {
  var _a3, _b2, _c2, _d2;
  (_a3 = options.retryOptions) !== null && _a3 !== void 0 ? _a3 : options.retryOptions = {
    maxRetries: 5,
    retryDelayInMs: 800
  };
  const managedIdentityClientId = (_b2 = options === null || options === void 0 ? void 0 : options.managedIdentityClientId) !== null && _b2 !== void 0 ? _b2 : process.env.AZURE_CLIENT_ID;
  const workloadIdentityClientId = (_c2 = options === null || options === void 0 ? void 0 : options.workloadIdentityClientId) !== null && _c2 !== void 0 ? _c2 : managedIdentityClientId;
  const managedResourceId = options === null || options === void 0 ? void 0 : options.managedIdentityResourceId;
  const workloadFile = process.env.AZURE_FEDERATED_TOKEN_FILE;
  const tenantId = (_d2 = options === null || options === void 0 ? void 0 : options.tenantId) !== null && _d2 !== void 0 ? _d2 : process.env.AZURE_TENANT_ID;
  if (managedResourceId) {
    const managedIdentityResourceIdOptions = Object.assign(Object.assign({}, options), { resourceId: managedResourceId });
    return new ManagedIdentityCredential(managedIdentityResourceIdOptions);
  }
  if (workloadFile && workloadIdentityClientId) {
    const workloadIdentityCredentialOptions = Object.assign(Object.assign({}, options), { tenantId });
    return new ManagedIdentityCredential(workloadIdentityClientId, workloadIdentityCredentialOptions);
  }
  if (managedIdentityClientId) {
    const managedIdentityClientOptions = Object.assign(Object.assign({}, options), { clientId: managedIdentityClientId });
    return new ManagedIdentityCredential(managedIdentityClientOptions);
  }
  return new ManagedIdentityCredential(options);
}
function createDefaultWorkloadIdentityCredential(options) {
  var _a3, _b2, _c2;
  const managedIdentityClientId = (_a3 = options === null || options === void 0 ? void 0 : options.managedIdentityClientId) !== null && _a3 !== void 0 ? _a3 : process.env.AZURE_CLIENT_ID;
  const workloadIdentityClientId = (_b2 = options === null || options === void 0 ? void 0 : options.workloadIdentityClientId) !== null && _b2 !== void 0 ? _b2 : managedIdentityClientId;
  const workloadFile = process.env.AZURE_FEDERATED_TOKEN_FILE;
  const tenantId = (_c2 = options === null || options === void 0 ? void 0 : options.tenantId) !== null && _c2 !== void 0 ? _c2 : process.env.AZURE_TENANT_ID;
  if (workloadFile && workloadIdentityClientId) {
    const workloadIdentityCredentialOptions = Object.assign(Object.assign({}, options), { tenantId, clientId: workloadIdentityClientId, tokenFilePath: workloadFile });
    return new WorkloadIdentityCredential(workloadIdentityCredentialOptions);
  }
  if (tenantId) {
    const workloadIdentityClientTenantOptions = Object.assign(Object.assign({}, options), { tenantId });
    return new WorkloadIdentityCredential(workloadIdentityClientTenantOptions);
  }
  return new WorkloadIdentityCredential(options);
}
function createDefaultAzureDeveloperCliCredential(options = {}) {
  const processTimeoutInMs = options.processTimeoutInMs;
  return new AzureDeveloperCliCredential(Object.assign({ processTimeoutInMs }, options));
}
function createDefaultAzureCliCredential(options = {}) {
  const processTimeoutInMs = options.processTimeoutInMs;
  return new AzureCliCredential(Object.assign({ processTimeoutInMs }, options));
}
function createDefaultAzurePowershellCredential(options = {}) {
  const processTimeoutInMs = options.processTimeoutInMs;
  return new AzurePowerShellCredential(Object.assign({ processTimeoutInMs }, options));
}
function createEnvironmentCredential(options = {}) {
  return new EnvironmentCredential(options);
}
var logger20, UnavailableDefaultCredential, DefaultAzureCredential;
var init_defaultAzureCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/defaultAzureCredential.js"() {
    "use strict";
    init_managedIdentityCredential();
    init_azureCliCredential();
    init_azureDeveloperCliCredential();
    init_azurePowerShellCredential();
    init_chainedTokenCredential();
    init_environmentCredential();
    init_workloadIdentityCredential();
    init_logging();
    logger20 = credentialLogger("DefaultAzureCredential");
    UnavailableDefaultCredential = class {
      constructor(credentialName6, message) {
        this.credentialName = credentialName6;
        this.credentialUnavailableErrorMessage = message;
      }
      getToken() {
        logger20.getToken.info(`Skipping ${this.credentialName}, reason: ${this.credentialUnavailableErrorMessage}`);
        return Promise.resolve(null);
      }
    };
    DefaultAzureCredential = class extends ChainedTokenCredential {
      constructor(options) {
        const credentialFunctions = [
          createEnvironmentCredential,
          createDefaultWorkloadIdentityCredential,
          createDefaultManagedIdentityCredential,
          createDefaultAzureCliCredential,
          createDefaultAzurePowershellCredential,
          createDefaultAzureDeveloperCliCredential
        ];
        const credentials = credentialFunctions.map((createCredentialFn) => {
          try {
            return createCredentialFn(options);
          } catch (err) {
            logger20.warning(`Skipped ${createCredentialFn.name} because of an error creating the credential: ${err}`);
            return new UnavailableDefaultCredential(createCredentialFn.name, err.message);
          }
        });
        super(...credentials);
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/interactiveBrowserCredential.js
var logger21, InteractiveBrowserCredential;
var init_interactiveBrowserCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/interactiveBrowserCredential.js"() {
    "use strict";
    init_tenantIdUtils();
    init_logging();
    init_scopeUtils();
    init_tracing();
    init_msalClient();
    init_constants();
    logger21 = credentialLogger("InteractiveBrowserCredential");
    InteractiveBrowserCredential = class {
      /**
       * Creates an instance of InteractiveBrowserCredential with the details needed.
       *
       * This credential uses the [Authorization Code Flow](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-auth-code-flow).
       * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.
       * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.
       *
       * For Node.js, if a `clientId` is provided, the Microsoft Entra application will need to be configured to have a "Mobile and desktop applications" redirect endpoint.
       * Follow our guide on [setting up Redirect URIs for Desktop apps that calls to web APIs](https://learn.microsoft.com/entra/identity-platform/scenario-desktop-app-registration#redirect-uris).
       *
       * @param options - Options for configuring the client which makes the authentication requests.
       */
      constructor(options) {
        var _a3, _b2, _c2, _d2, _e;
        this.tenantId = resolveTenantId(logger21, options.tenantId, options.clientId);
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        const msalClientOptions = Object.assign(Object.assign({}, options), { tokenCredentialOptions: options, logger: logger21 });
        const ibcNodeOptions = options;
        this.browserCustomizationOptions = ibcNodeOptions.browserCustomizationOptions;
        this.loginHint = ibcNodeOptions.loginHint;
        if ((_a3 = ibcNodeOptions === null || ibcNodeOptions === void 0 ? void 0 : ibcNodeOptions.brokerOptions) === null || _a3 === void 0 ? void 0 : _a3.enabled) {
          if (!((_b2 = ibcNodeOptions === null || ibcNodeOptions === void 0 ? void 0 : ibcNodeOptions.brokerOptions) === null || _b2 === void 0 ? void 0 : _b2.parentWindowHandle)) {
            throw new Error("In order to do WAM authentication, `parentWindowHandle` under `brokerOptions` is a required parameter");
          } else {
            msalClientOptions.brokerOptions = {
              enabled: true,
              parentWindowHandle: ibcNodeOptions.brokerOptions.parentWindowHandle,
              legacyEnableMsaPassthrough: (_c2 = ibcNodeOptions.brokerOptions) === null || _c2 === void 0 ? void 0 : _c2.legacyEnableMsaPassthrough,
              useDefaultBrokerAccount: (_d2 = ibcNodeOptions.brokerOptions) === null || _d2 === void 0 ? void 0 : _d2.useDefaultBrokerAccount
            };
          }
        }
        this.msalClient = createMsalClient((_e = options.clientId) !== null && _e !== void 0 ? _e : DeveloperSignOnClientId, this.tenantId, msalClientOptions);
        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger21);
          const arrayScopes = ensureScopes(scopes);
          return this.msalClient.getTokenByInteractiveRequest(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication, browserCustomizationOptions: this.browserCustomizationOptions, loginHint: this.loginHint }));
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
       *
       * On Node.js, this credential has [Proof Key for Code Exchange (PKCE)](https://datatracker.ietf.org/doc/html/rfc7636) enabled by default.
       * PKCE is a security feature that mitigates authentication code interception attacks.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                  TokenCredential implementation might make.
       */
      async authenticate(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
          const arrayScopes = ensureScopes(scopes);
          await this.msalClient.getTokenByInteractiveRequest(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: false, browserCustomizationOptions: this.browserCustomizationOptions, loginHint: this.loginHint }));
          return this.msalClient.getActiveAccount();
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/deviceCodeCredential.js
function defaultDeviceCodePromptCallback(deviceCodeInfo) {
  console.log(deviceCodeInfo.message);
}
var logger22, DeviceCodeCredential;
var init_deviceCodeCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/deviceCodeCredential.js"() {
    "use strict";
    init_tenantIdUtils();
    init_logging();
    init_scopeUtils();
    init_tracing();
    init_msalClient();
    init_constants();
    logger22 = credentialLogger("DeviceCodeCredential");
    DeviceCodeCredential = class {
      /**
       * Creates an instance of DeviceCodeCredential with the details needed
       * to initiate the device code authorization flow with Microsoft Entra ID.
       *
       * A message will be logged, giving users a code that they can use to authenticate once they go to https://microsoft.com/devicelogin
       *
       * Developers can configure how this message is shown by passing a custom `userPromptCallback`:
       *
       * ```js
       * const credential = new DeviceCodeCredential({
       *   tenantId: env.AZURE_TENANT_ID,
       *   clientId: env.AZURE_CLIENT_ID,
       *   userPromptCallback: (info) => {
       *     console.log("CUSTOMIZED PROMPT CALLBACK", info.message);
       *   }
       * });
       * ```
       *
       * @param options - Options for configuring the client which makes the authentication requests.
       */
      constructor(options) {
        var _a3, _b2;
        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        const clientId = (_a3 = options === null || options === void 0 ? void 0 : options.clientId) !== null && _a3 !== void 0 ? _a3 : DeveloperSignOnClientId;
        const tenantId = resolveTenantId(logger22, options === null || options === void 0 ? void 0 : options.tenantId, clientId);
        this.userPromptCallback = (_b2 = options === null || options === void 0 ? void 0 : options.userPromptCallback) !== null && _b2 !== void 0 ? _b2 : defaultDeviceCodePromptCallback;
        this.msalClient = createMsalClient(clientId, tenantId, Object.assign(Object.assign({}, options), { logger: logger22, tokenCredentialOptions: options || {} }));
        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger22);
          const arrayScopes = ensureScopes(scopes);
          return this.msalClient.getTokenByDeviceCode(arrayScopes, this.userPromptCallback, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                  TokenCredential implementation might make.
       */
      async authenticate(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          await this.msalClient.getTokenByDeviceCode(arrayScopes, this.userPromptCallback, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: false }));
          return this.msalClient.getActiveAccount();
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/azurePipelinesCredential.js
function handleOidcResponse(response) {
  const text = response.bodyAsText;
  if (!text) {
    logger23.error(`${credentialName4}: Authentication Failed. Received null token from OIDC request. Response status- ${response.status}. Complete response - ${JSON.stringify(response)}`);
    throw new AuthenticationError(response.status, {
      error: `${credentialName4}: Authentication Failed. Received null token from OIDC request.`,
      error_description: `${JSON.stringify(response)}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`
    });
  }
  try {
    const result = JSON.parse(text);
    if (result === null || result === void 0 ? void 0 : result.oidcToken) {
      return result.oidcToken;
    } else {
      const errorMessage = `${credentialName4}: Authentication Failed. oidcToken field not detected in the response.`;
      let errorDescription = ``;
      if (response.status !== 200) {
        errorDescription = `Complete response - ${JSON.stringify(result)}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`;
      }
      logger23.error(errorMessage);
      logger23.error(errorDescription);
      throw new AuthenticationError(response.status, {
        error: errorMessage,
        error_description: errorDescription
      });
    }
  } catch (e) {
    const errorDetails = `${credentialName4}: Authentication Failed. oidcToken field not detected in the response.`;
    logger23.error(`Response from service = ${text} and error message = ${e.message}`);
    logger23.error(errorDetails);
    throw new AuthenticationError(response.status, {
      error: errorDetails,
      error_description: `Response = ${text}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`
    });
  }
}
var credentialName4, logger23, OIDC_API_VERSION, AzurePipelinesCredential;
var init_azurePipelinesCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/azurePipelinesCredential.js"() {
    "use strict";
    init_clientAssertionCredential();
    init_errors();
    init_logging();
    init_tenantIdUtils();
    init_esm5();
    init_identityClient();
    credentialName4 = "AzurePipelinesCredential";
    logger23 = credentialLogger(credentialName4);
    OIDC_API_VERSION = "7.1";
    AzurePipelinesCredential = class {
      /**
       * AzurePipelinesCredential supports Federated Identity on Azure Pipelines through Service Connections.
       * @param tenantId - tenantId associated with the service connection
       * @param clientId - clientId associated with the service connection
       * @param serviceConnectionId - Unique ID for the service connection, as found in the querystring's resourceId key
       * @param systemAccessToken - The pipeline's <see href="https://learn.microsoft.com/azure/devops/pipelines/build/variables?view=azure-devops%26tabs=yaml#systemaccesstoken">System.AccessToken</see> value.
       * @param options - The identity client options to use for authentication.
       */
      constructor(tenantId, clientId, serviceConnectionId, systemAccessToken, options) {
        if (!clientId || !tenantId || !serviceConnectionId || !systemAccessToken) {
          throw new CredentialUnavailableError(`${credentialName4}: is unavailable. tenantId, clientId, serviceConnectionId, and systemAccessToken are required parameters.`);
        }
        this.identityClient = new IdentityClient(options);
        checkTenantId(logger23, tenantId);
        logger23.info(`Invoking AzurePipelinesCredential with tenant ID: ${tenantId}, client ID: ${clientId}, and service connection ID: ${serviceConnectionId}`);
        if (!process.env.SYSTEM_OIDCREQUESTURI) {
          throw new CredentialUnavailableError(`${credentialName4}: is unavailable. Ensure that you're running this task in an Azure Pipeline, so that following missing system variable(s) can be defined- "SYSTEM_OIDCREQUESTURI"`);
        }
        const oidcRequestUrl = `${process.env.SYSTEM_OIDCREQUESTURI}?api-version=${OIDC_API_VERSION}&serviceConnectionId=${serviceConnectionId}`;
        logger23.info(`Invoking ClientAssertionCredential with tenant ID: ${tenantId}, client ID: ${clientId} and service connection ID: ${serviceConnectionId}`);
        this.clientAssertionCredential = new ClientAssertionCredential(tenantId, clientId, this.requestOidcToken.bind(this, oidcRequestUrl, systemAccessToken), options);
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} or {@link AuthenticationError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options) {
        if (!this.clientAssertionCredential) {
          const errorMessage = `${credentialName4}: is unavailable. To use Federation Identity in Azure Pipelines, the following parameters are required - 
      tenantId,
      clientId,
      serviceConnectionId,
      systemAccessToken,
      "SYSTEM_OIDCREQUESTURI".      
      See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`;
          logger23.error(errorMessage);
          throw new CredentialUnavailableError(errorMessage);
        }
        logger23.info("Invoking getToken() of Client Assertion Credential");
        return this.clientAssertionCredential.getToken(scopes, options);
      }
      /**
       *
       * @param oidcRequestUrl - oidc request url
       * @param systemAccessToken - system access token
       * @returns OIDC token from Azure Pipelines
       */
      async requestOidcToken(oidcRequestUrl, systemAccessToken) {
        logger23.info("Requesting OIDC token from Azure Pipelines...");
        logger23.info(oidcRequestUrl);
        const request3 = createPipelineRequest({
          url: oidcRequestUrl,
          method: "POST",
          headers: createHttpHeaders({
            "Content-Type": "application/json",
            Authorization: `Bearer ${systemAccessToken}`
          })
        });
        const response = await this.identityClient.sendRequest(request3);
        return handleOidcResponse(response);
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/authorizationCodeCredential.js
var logger24, AuthorizationCodeCredential;
var init_authorizationCodeCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/authorizationCodeCredential.js"() {
    "use strict";
    init_tenantIdUtils();
    init_tenantIdUtils();
    init_logging();
    init_scopeUtils();
    init_tracing();
    init_msalClient();
    logger24 = credentialLogger("AuthorizationCodeCredential");
    AuthorizationCodeCredential = class {
      /**
       * @hidden
       * @internal
       */
      constructor(tenantId, clientId, clientSecretOrAuthorizationCode, authorizationCodeOrRedirectUri, redirectUriOrOptions, options) {
        checkTenantId(logger24, tenantId);
        this.clientSecret = clientSecretOrAuthorizationCode;
        if (typeof redirectUriOrOptions === "string") {
          this.authorizationCode = authorizationCodeOrRedirectUri;
          this.redirectUri = redirectUriOrOptions;
        } else {
          this.authorizationCode = clientSecretOrAuthorizationCode;
          this.redirectUri = authorizationCodeOrRedirectUri;
          this.clientSecret = void 0;
          options = redirectUriOrOptions;
        }
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.msalClient = createMsalClient(clientId, tenantId, Object.assign(Object.assign({}, options), { logger: logger24, tokenCredentialOptions: options !== null && options !== void 0 ? options : {} }));
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
          newOptions.tenantId = tenantId;
          const arrayScopes = ensureScopes(scopes);
          return this.msalClient.getTokenByAuthorizationCode(arrayScopes, this.redirectUri, this.authorizationCode, this.clientSecret, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/onBehalfOfCredential.js
var import_promises3, import_node_crypto, credentialName5, logger25, OnBehalfOfCredential;
var init_onBehalfOfCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/onBehalfOfCredential.js"() {
    "use strict";
    init_tenantIdUtils();
    init_logging();
    init_scopeUtils();
    init_tracing();
    init_msalClient();
    import_promises3 = require("fs/promises");
    import_node_crypto = require("crypto");
    credentialName5 = "OnBehalfOfCredential";
    logger25 = credentialLogger(credentialName5);
    OnBehalfOfCredential = class {
      constructor(options) {
        const { clientSecret } = options;
        const { certificatePath, sendCertificateChain } = options;
        const { getAssertion } = options;
        const { tenantId, clientId, userAssertionToken, additionallyAllowedTenants: additionallyAllowedTenantIds } = options;
        if (!tenantId || !clientId || !(clientSecret || certificatePath || getAssertion) || !userAssertionToken) {
          throw new Error(`${credentialName5}: tenantId, clientId, clientSecret (or certificatePath or getAssertion) and userAssertionToken are required parameters.`);
        }
        this.certificatePath = certificatePath;
        this.clientSecret = clientSecret;
        this.userAssertionToken = userAssertionToken;
        this.sendCertificateChain = sendCertificateChain;
        this.clientAssertion = getAssertion;
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(additionallyAllowedTenantIds);
        this.msalClient = createMsalClient(clientId, this.tenantId, Object.assign(Object.assign({}, options), { logger: logger25, tokenCredentialOptions: options }));
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure the underlying network requests.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName5}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger25);
          const arrayScopes = ensureScopes(scopes);
          if (this.certificatePath) {
            const clientCertificate = await this.buildClientCertificate(this.certificatePath);
            return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, clientCertificate, newOptions);
          } else if (this.clientSecret) {
            return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, this.clientSecret, options);
          } else if (this.clientAssertion) {
            return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, this.clientAssertion, options);
          } else {
            throw new Error("Expected either clientSecret or certificatePath or clientAssertion to be defined.");
          }
        });
      }
      async buildClientCertificate(certificatePath) {
        try {
          const parts = await this.parseCertificate({ certificatePath }, this.sendCertificateChain);
          return {
            thumbprint: parts.thumbprint,
            privateKey: parts.certificateContents,
            x5c: parts.x5c
          };
        } catch (error) {
          logger25.info(formatError("", error));
          throw error;
        }
      }
      async parseCertificate(configuration, sendCertificateChain) {
        const certificatePath = configuration.certificatePath;
        const certificateContents = await (0, import_promises3.readFile)(certificatePath, "utf8");
        const x5c = sendCertificateChain ? certificateContents : void 0;
        const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
        const publicKeys = [];
        let match;
        do {
          match = certificatePattern.exec(certificateContents);
          if (match) {
            publicKeys.push(match[3]);
          }
        } while (match);
        if (publicKeys.length === 0) {
          throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
        }
        const thumbprint = (0, import_node_crypto.createHash)("sha1").update(Buffer.from(publicKeys[0], "base64")).digest("hex").toUpperCase();
        return {
          certificateContents,
          thumbprint,
          x5c
        };
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/tokenProvider.js
function getBearerTokenProvider(credential, scopes, options) {
  const { abortSignal: abortSignal2, tracingOptions } = options || {};
  const pipeline = createEmptyPipeline();
  pipeline.addPolicy(bearerTokenAuthenticationPolicy({ credential, scopes }));
  async function getRefreshedToken() {
    var _a3;
    const res = await pipeline.sendRequest({
      sendRequest: (request3) => Promise.resolve({
        request: request3,
        status: 200,
        headers: request3.headers
      })
    }, createPipelineRequest({
      url: "https://example.com",
      abortSignal: abortSignal2,
      tracingOptions
    }));
    const accessToken = (_a3 = res.headers.get("authorization")) === null || _a3 === void 0 ? void 0 : _a3.split(" ")[1];
    if (!accessToken) {
      throw new Error("Failed to get access token");
    }
    return accessToken;
  }
  return getRefreshedToken;
}
var init_tokenProvider = __esm({
  "node_modules/@azure/identity/dist-esm/src/tokenProvider.js"() {
    "use strict";
    init_esm5();
  }
});

// node_modules/@azure/identity/dist-esm/src/index.js
var src_exports = {};
__export(src_exports, {
  AggregateAuthenticationError: () => AggregateAuthenticationError,
  AggregateAuthenticationErrorName: () => AggregateAuthenticationErrorName,
  AuthenticationError: () => AuthenticationError,
  AuthenticationErrorName: () => AuthenticationErrorName,
  AuthenticationRequiredError: () => AuthenticationRequiredError,
  AuthorizationCodeCredential: () => AuthorizationCodeCredential,
  AzureAuthorityHosts: () => AzureAuthorityHosts,
  AzureCliCredential: () => AzureCliCredential,
  AzureDeveloperCliCredential: () => AzureDeveloperCliCredential,
  AzurePipelinesCredential: () => AzurePipelinesCredential,
  AzurePowerShellCredential: () => AzurePowerShellCredential,
  ChainedTokenCredential: () => ChainedTokenCredential,
  ClientAssertionCredential: () => ClientAssertionCredential,
  ClientCertificateCredential: () => ClientCertificateCredential,
  ClientSecretCredential: () => ClientSecretCredential,
  CredentialUnavailableError: () => CredentialUnavailableError,
  CredentialUnavailableErrorName: () => CredentialUnavailableErrorName,
  DefaultAzureCredential: () => DefaultAzureCredential,
  DeviceCodeCredential: () => DeviceCodeCredential,
  EnvironmentCredential: () => EnvironmentCredential,
  InteractiveBrowserCredential: () => InteractiveBrowserCredential,
  ManagedIdentityCredential: () => ManagedIdentityCredential,
  OnBehalfOfCredential: () => OnBehalfOfCredential,
  UsernamePasswordCredential: () => UsernamePasswordCredential,
  VisualStudioCodeCredential: () => VisualStudioCodeCredential,
  WorkloadIdentityCredential: () => WorkloadIdentityCredential,
  deserializeAuthenticationRecord: () => deserializeAuthenticationRecord,
  getBearerTokenProvider: () => getBearerTokenProvider,
  getDefaultAzureCredential: () => getDefaultAzureCredential,
  logger: () => logger2,
  serializeAuthenticationRecord: () => serializeAuthenticationRecord,
  useIdentityPlugin: () => useIdentityPlugin
});
function getDefaultAzureCredential() {
  return new DefaultAzureCredential();
}
var init_src2 = __esm({
  "node_modules/@azure/identity/dist-esm/src/index.js"() {
    "use strict";
    init_consumer();
    init_defaultAzureCredential();
    init_errors();
    init_utils3();
    init_chainedTokenCredential();
    init_clientSecretCredential();
    init_defaultAzureCredential();
    init_environmentCredential();
    init_clientCertificateCredential();
    init_clientAssertionCredential();
    init_azureCliCredential();
    init_azureDeveloperCliCredential();
    init_interactiveBrowserCredential();
    init_managedIdentityCredential();
    init_deviceCodeCredential();
    init_azurePipelinesCredential();
    init_authorizationCodeCredential();
    init_azurePowerShellCredential();
    init_usernamePasswordCredential();
    init_visualStudioCodeCredential();
    init_onBehalfOfCredential();
    init_workloadIdentityCredential();
    init_logging();
    init_constants();
    init_tokenProvider();
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js
var require_azureKeyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureKeyCredential = void 0;
    var AzureKeyCredential = class {
      /**
       * The value of the key to be used in authentication
       */
      get key() {
        return this._key;
      }
      /**
       * Create an instance of an AzureKeyCredential for use
       * with a service client.
       *
       * @param key - The initial value of the key to use in authentication
       */
      constructor(key) {
        if (!key) {
          throw new Error("key must be a non-empty string");
        }
        this._key = key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newKey - The new key value to be used
       */
      update(newKey) {
        this._key = newKey;
      }
    };
    exports2.AzureKeyCredential = AzureKeyCredential;
  }
});

// node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError = __commonJS({
  "node_modules/@azure/abort-controller/dist/commonjs/AbortError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbortError = void 0;
    var AbortError3 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError3;
  }
});

// node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/@azure/abort-controller/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbortError = void 0;
    var AbortError_js_1 = require_AbortError();
    Object.defineProperty(exports2, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
  }
});

// node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAbortablePromise = createAbortablePromise2;
    var abort_controller_1 = require_commonjs();
    function createAbortablePromise2(buildPromise, options) {
      const { cleanupBeforeAbort, abortSignal: abortSignal2, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
      return new Promise((resolve, reject) => {
        function rejectOnAbort() {
          reject(new abort_controller_1.AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
        }
        function removeListeners() {
          abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.removeEventListener("abort", onAbort);
        }
        function onAbort() {
          cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();
          removeListeners();
          rejectOnAbort();
        }
        if (abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.aborted) {
          return rejectOnAbort();
        }
        try {
          buildPromise((x) => {
            removeListeners();
            resolve(x);
          }, (x) => {
            removeListeners();
            reject(x);
          });
        } catch (err) {
          reject(err);
        }
        abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.addEventListener("abort", onAbort);
      });
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/random.js
var require_random = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRandomIntegerInclusive = getRandomIntegerInclusive2;
    function getRandomIntegerInclusive2(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      const offset = Math.floor(Math.random() * (max - min + 1));
      return offset + min;
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/delay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delay = delay4;
    exports2.calculateRetryDelay = calculateRetryDelay2;
    var createAbortablePromise_js_1 = require_createAbortablePromise();
    var random_js_1 = require_random();
    var StandardAbortMessage3 = "The delay was aborted.";
    function delay4(timeInMs, options) {
      let token;
      const { abortSignal: abortSignal2, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
      return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
        token = setTimeout(resolve, timeInMs);
      }, {
        cleanupBeforeAbort: () => clearTimeout(token),
        abortSignal: abortSignal2,
        abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage3
      });
    }
    function calculateRetryDelay2(retryAttempt, config) {
      const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
      const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
      const retryAfterInMs = clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
      return { retryAfterInMs };
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/aborterUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cancelablePromiseRace = cancelablePromiseRace2;
    async function cancelablePromiseRace2(abortablePromiseBuilders, options) {
      var _a3, _b2;
      const aborter = new AbortController();
      function abortHandler() {
        aborter.abort();
      }
      (_a3 = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.addEventListener("abort", abortHandler);
      try {
        return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
      } finally {
        aborter.abort();
        (_b2 = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _b2 === void 0 ? void 0 : _b2.removeEventListener("abort", abortHandler);
      }
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/object.js
var require_object = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isObject = isObject2;
    function isObject2(input) {
      return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/error.js
var require_error2 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isError = isError2;
    exports2.getErrorMessage = getErrorMessage2;
    var object_js_1 = require_object();
    function isError2(e) {
      if ((0, object_js_1.isObject)(e)) {
        const hasName = typeof e.name === "string";
        const hasMessage = typeof e.message === "string";
        return hasName && hasMessage;
      }
      return false;
    }
    function getErrorMessage2(e) {
      if (isError2(e)) {
        return e.message;
      } else {
        let stringified;
        try {
          if (typeof e === "object" && e) {
            stringified = JSON.stringify(e);
          } else {
            stringified = String(e);
          }
        } catch (err) {
          stringified = "[unable to stringify input]";
        }
        return `Unknown error ${stringified}`;
      }
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeSha256Hmac = computeSha256Hmac2;
    exports2.computeSha256Hash = computeSha256Hash2;
    var crypto_1 = require("crypto");
    async function computeSha256Hmac2(key, stringToSign, encoding) {
      const decodedKey = Buffer.from(key, "base64");
      return (0, crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
    }
    async function computeSha256Hash2(content, encoding) {
      return (0, crypto_1.createHash)("sha256").update(content).digest(encoding);
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/typeGuards.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDefined = isDefined2;
    exports2.isObjectWithProperties = isObjectWithProperties2;
    exports2.objectHasProperty = objectHasProperty2;
    function isDefined2(thing) {
      return typeof thing !== "undefined" && thing !== null;
    }
    function isObjectWithProperties2(thing, properties) {
      if (!isDefined2(thing) || typeof thing !== "object") {
        return false;
      }
      for (const property of properties) {
        if (!objectHasProperty2(thing, property)) {
          return false;
        }
      }
      return true;
    }
    function objectHasProperty2(thing, property) {
      return isDefined2(thing) && typeof thing === "object" && property in thing;
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/uuidUtils.js
var require_uuidUtils = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/uuidUtils.js"(exports2) {
    "use strict";
    var _a3;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomUUID = randomUUID2;
    var crypto_1 = require("crypto");
    var uuidFunction2 = typeof ((_a3 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a3 === void 0 ? void 0 : _a3.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : crypto_1.randomUUID;
    function randomUUID2() {
      return uuidFunction2();
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/checkEnvironment.js
var require_checkEnvironment = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/checkEnvironment.js"(exports2) {
    "use strict";
    var _a3;
    var _b2;
    var _c2;
    var _d2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isReactNative = exports2.isNodeRuntime = exports2.isNode = exports2.isNodeLike = exports2.isBun = exports2.isDeno = exports2.isWebWorker = exports2.isBrowser = void 0;
    exports2.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    exports2.isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a3 = self.constructor) === null || _a3 === void 0 ? void 0 : _a3.name) === "DedicatedWorkerGlobalScope" || ((_b2 = self.constructor) === null || _b2 === void 0 ? void 0 : _b2.name) === "ServiceWorkerGlobalScope" || ((_c2 = self.constructor) === null || _c2 === void 0 ? void 0 : _c2.name) === "SharedWorkerGlobalScope");
    exports2.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    exports2.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    exports2.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d2 = globalThis.process.versions) === null || _d2 === void 0 ? void 0 : _d2.node);
    exports2.isNode = exports2.isNodeLike;
    exports2.isNodeRuntime = exports2.isNodeLike && !exports2.isBun && !exports2.isDeno;
    exports2.isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
  }
});

// node_modules/@azure/core-util/dist/commonjs/bytesEncoding.js
var require_bytesEncoding = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/bytesEncoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uint8ArrayToString = uint8ArrayToString2;
    exports2.stringToUint8Array = stringToUint8Array2;
    function uint8ArrayToString2(bytes, format) {
      return Buffer.from(bytes).toString(format);
    }
    function stringToUint8Array2(value, format) {
      return Buffer.from(value, format);
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringToUint8Array = exports2.uint8ArrayToString = exports2.isWebWorker = exports2.isReactNative = exports2.isDeno = exports2.isNodeRuntime = exports2.isNodeLike = exports2.isNode = exports2.isBun = exports2.isBrowser = exports2.randomUUID = exports2.objectHasProperty = exports2.isObjectWithProperties = exports2.isDefined = exports2.computeSha256Hmac = exports2.computeSha256Hash = exports2.getErrorMessage = exports2.isError = exports2.isObject = exports2.getRandomIntegerInclusive = exports2.createAbortablePromise = exports2.cancelablePromiseRace = exports2.calculateRetryDelay = exports2.delay = void 0;
    var delay_js_1 = require_delay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_js_1.delay;
    } });
    Object.defineProperty(exports2, "calculateRetryDelay", { enumerable: true, get: function() {
      return delay_js_1.calculateRetryDelay;
    } });
    var aborterUtils_js_1 = require_aborterUtils();
    Object.defineProperty(exports2, "cancelablePromiseRace", { enumerable: true, get: function() {
      return aborterUtils_js_1.cancelablePromiseRace;
    } });
    var createAbortablePromise_js_1 = require_createAbortablePromise();
    Object.defineProperty(exports2, "createAbortablePromise", { enumerable: true, get: function() {
      return createAbortablePromise_js_1.createAbortablePromise;
    } });
    var random_js_1 = require_random();
    Object.defineProperty(exports2, "getRandomIntegerInclusive", { enumerable: true, get: function() {
      return random_js_1.getRandomIntegerInclusive;
    } });
    var object_js_1 = require_object();
    Object.defineProperty(exports2, "isObject", { enumerable: true, get: function() {
      return object_js_1.isObject;
    } });
    var error_js_1 = require_error2();
    Object.defineProperty(exports2, "isError", { enumerable: true, get: function() {
      return error_js_1.isError;
    } });
    Object.defineProperty(exports2, "getErrorMessage", { enumerable: true, get: function() {
      return error_js_1.getErrorMessage;
    } });
    var sha256_js_1 = require_sha256();
    Object.defineProperty(exports2, "computeSha256Hash", { enumerable: true, get: function() {
      return sha256_js_1.computeSha256Hash;
    } });
    Object.defineProperty(exports2, "computeSha256Hmac", { enumerable: true, get: function() {
      return sha256_js_1.computeSha256Hmac;
    } });
    var typeGuards_js_1 = require_typeGuards();
    Object.defineProperty(exports2, "isDefined", { enumerable: true, get: function() {
      return typeGuards_js_1.isDefined;
    } });
    Object.defineProperty(exports2, "isObjectWithProperties", { enumerable: true, get: function() {
      return typeGuards_js_1.isObjectWithProperties;
    } });
    Object.defineProperty(exports2, "objectHasProperty", { enumerable: true, get: function() {
      return typeGuards_js_1.objectHasProperty;
    } });
    var uuidUtils_js_1 = require_uuidUtils();
    Object.defineProperty(exports2, "randomUUID", { enumerable: true, get: function() {
      return uuidUtils_js_1.randomUUID;
    } });
    var checkEnvironment_js_1 = require_checkEnvironment();
    Object.defineProperty(exports2, "isBrowser", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isBrowser;
    } });
    Object.defineProperty(exports2, "isBun", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isBun;
    } });
    Object.defineProperty(exports2, "isNode", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNode;
    } });
    Object.defineProperty(exports2, "isNodeLike", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNodeLike;
    } });
    Object.defineProperty(exports2, "isNodeRuntime", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNodeRuntime;
    } });
    Object.defineProperty(exports2, "isDeno", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isDeno;
    } });
    Object.defineProperty(exports2, "isReactNative", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isReactNative;
    } });
    Object.defineProperty(exports2, "isWebWorker", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isWebWorker;
    } });
    var bytesEncoding_js_1 = require_bytesEncoding();
    Object.defineProperty(exports2, "uint8ArrayToString", { enumerable: true, get: function() {
      return bytesEncoding_js_1.uint8ArrayToString;
    } });
    Object.defineProperty(exports2, "stringToUint8Array", { enumerable: true, get: function() {
      return bytesEncoding_js_1.stringToUint8Array;
    } });
  }
});

// node_modules/@azure/core-auth/dist/commonjs/keyCredential.js
var require_keyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/keyCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isKeyCredential = isKeyCredential;
    var core_util_1 = require_commonjs2();
    function isKeyCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js
var require_azureNamedKeyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureNamedKeyCredential = void 0;
    exports2.isNamedKeyCredential = isNamedKeyCredential;
    var core_util_1 = require_commonjs2();
    var AzureNamedKeyCredential = class {
      /**
       * The value of the key to be used in authentication.
       */
      get key() {
        return this._key;
      }
      /**
       * The value of the name to be used in authentication.
       */
      get name() {
        return this._name;
      }
      /**
       * Create an instance of an AzureNamedKeyCredential for use
       * with a service client.
       *
       * @param name - The initial value of the name to use in authentication.
       * @param key - The initial value of the key to use in authentication.
       */
      constructor(name3, key) {
        if (!name3 || !key) {
          throw new TypeError("name and key must be non-empty strings");
        }
        this._name = name3;
        this._key = key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newName - The new name value to be used.
       * @param newKey - The new key value to be used.
       */
      update(newName, newKey) {
        if (!newName || !newKey) {
          throw new TypeError("newName and newKey must be non-empty strings");
        }
        this._name = newName;
        this._key = newKey;
      }
    };
    exports2.AzureNamedKeyCredential = AzureNamedKeyCredential;
    function isNamedKeyCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js
var require_azureSASCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureSASCredential = void 0;
    exports2.isSASCredential = isSASCredential;
    var core_util_1 = require_commonjs2();
    var AzureSASCredential = class {
      /**
       * The value of the shared access signature to be used in authentication
       */
      get signature() {
        return this._signature;
      }
      /**
       * Create an instance of an AzureSASCredential for use
       * with a service client.
       *
       * @param signature - The initial value of the shared access signature to use in authentication
       */
      constructor(signature) {
        if (!signature) {
          throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = signature;
      }
      /**
       * Change the value of the signature.
       *
       * Updates will take effect upon the next request after
       * updating the signature value.
       *
       * @param newSignature - The new shared access signature value to be used
       */
      update(newSignature) {
        if (!newSignature) {
          throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = newSignature;
      }
    };
    exports2.AzureSASCredential = AzureSASCredential;
    function isSASCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js
var require_tokenCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenCredential = isTokenCredential;
    function isTokenCredential(credential) {
      const castCredential = credential;
      return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenCredential = exports2.isSASCredential = exports2.AzureSASCredential = exports2.isNamedKeyCredential = exports2.AzureNamedKeyCredential = exports2.isKeyCredential = exports2.AzureKeyCredential = void 0;
    var azureKeyCredential_js_1 = require_azureKeyCredential();
    Object.defineProperty(exports2, "AzureKeyCredential", { enumerable: true, get: function() {
      return azureKeyCredential_js_1.AzureKeyCredential;
    } });
    var keyCredential_js_1 = require_keyCredential();
    Object.defineProperty(exports2, "isKeyCredential", { enumerable: true, get: function() {
      return keyCredential_js_1.isKeyCredential;
    } });
    var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
    Object.defineProperty(exports2, "AzureNamedKeyCredential", { enumerable: true, get: function() {
      return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
    } });
    Object.defineProperty(exports2, "isNamedKeyCredential", { enumerable: true, get: function() {
      return azureNamedKeyCredential_js_1.isNamedKeyCredential;
    } });
    var azureSASCredential_js_1 = require_azureSASCredential();
    Object.defineProperty(exports2, "AzureSASCredential", { enumerable: true, get: function() {
      return azureSASCredential_js_1.AzureSASCredential;
    } });
    Object.defineProperty(exports2, "isSASCredential", { enumerable: true, get: function() {
      return azureSASCredential_js_1.isSASCredential;
    } });
    var tokenCredential_js_1 = require_tokenCredential();
    Object.defineProperty(exports2, "isTokenCredential", { enumerable: true, get: function() {
      return tokenCredential_js_1.isTokenCredential;
    } });
  }
});

// node_modules/tedious/lib/debug.js
var require_debug2 = __commonJS({
  "node_modules/tedious/lib/debug.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _events = require("events");
    var util2 = _interopRequireWildcard(require("util"));
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    var Debug = class extends _events.EventEmitter {
      /*
        @options    Which debug details should be sent.
                    data    - dump of packet data
                    payload - details of decoded payload
      */
      constructor({
        data = false,
        payload = false,
        packet = false,
        token = false
      } = {}) {
        super();
        this.options = {
          data,
          payload,
          packet,
          token
        };
        this.indent = "  ";
      }
      packet(direction, packet) {
        if (this.haveListeners() && this.options.packet) {
          this.log("");
          this.log(direction);
          this.log(packet.headerToString(this.indent));
        }
      }
      data(packet) {
        if (this.haveListeners() && this.options.data) {
          this.log(packet.dataToString(this.indent));
        }
      }
      payload(generatePayloadText) {
        if (this.haveListeners() && this.options.payload) {
          this.log(generatePayloadText());
        }
      }
      token(token) {
        if (this.haveListeners() && this.options.token) {
          this.log(util2.inspect(token, {
            showHidden: false,
            depth: 5,
            colors: true
          }));
        }
      }
      haveListeners() {
        return this.listeners("debug").length > 0;
      }
      log(text) {
        this.emit("debug", text);
      }
    };
    var _default = exports2.default = Debug;
    module2.exports = Debug;
  }
});

// node_modules/tedious/lib/errors/abort-error.js
var require_abort_error = __commonJS({
  "node_modules/tedious/lib/errors/abort-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var AbortError3 = class extends Error {
      constructor() {
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    exports2.default = AbortError3;
  }
});

// node_modules/tedious/lib/sender.js
var require_sender = __commonJS({
  "node_modules/tedious/lib/sender.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sendInParallel = sendInParallel;
    exports2.sendMessage = sendMessage;
    var _dgram = _interopRequireDefault(require("dgram"));
    var _net = _interopRequireDefault(require("net"));
    var _nodeUrl = _interopRequireDefault(require("url"));
    var _abortError = _interopRequireDefault(require_abort_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function sendInParallel(addresses, port, request3, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      return await new Promise((resolve, reject) => {
        const sockets = [];
        let errorCount = 0;
        const onError = (err) => {
          errorCount++;
          if (errorCount === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            clearSockets();
            reject(err);
          }
        };
        const onMessage = (message) => {
          signal.removeEventListener("abort", onAbort);
          clearSockets();
          resolve(message);
        };
        const onAbort = () => {
          clearSockets();
          reject(new _abortError.default());
        };
        const clearSockets = () => {
          for (const socket of sockets) {
            socket.removeListener("error", onError);
            socket.removeListener("message", onMessage);
            socket.close();
          }
        };
        signal.addEventListener("abort", onAbort, {
          once: true
        });
        for (let j = 0; j < addresses.length; j++) {
          const udpType = addresses[j].family === 6 ? "udp6" : "udp4";
          const socket = _dgram.default.createSocket(udpType);
          sockets.push(socket);
          socket.on("error", onError);
          socket.on("message", onMessage);
          socket.send(request3, 0, request3.length, port, addresses[j].address);
        }
      });
    }
    async function sendMessage(host, port, lookup, signal, request3) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let addresses;
      if (_net.default.isIP(host)) {
        addresses = [{
          address: host,
          family: _net.default.isIPv6(host) ? 6 : 4
        }];
      } else {
        addresses = await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          const domainInASCII = _nodeUrl.default.domainToASCII(host);
          lookup(domainInASCII === "" ? host : domainInASCII, {
            all: true
          }, (err, addresses2) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses2);
          });
        });
      }
      return await sendInParallel(addresses, port, request3, signal);
    }
  }
});

// node_modules/tedious/lib/errors/timeout-error.js
var require_timeout_error = __commonJS({
  "node_modules/tedious/lib/errors/timeout-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var TimeoutError = class extends Error {
      constructor() {
        super("The operation was aborted due to timeout");
        this.code = "TIMEOUT_ERR";
        this.name = "TimeoutError";
      }
    };
    exports2.default = TimeoutError;
  }
});

// node_modules/tedious/lib/utils/with-timeout.js
var require_with_timeout = __commonJS({
  "node_modules/tedious/lib/utils/with-timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.withTimeout = withTimeout;
    var _timeoutError = _interopRequireDefault(require_timeout_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function withTimeout(timeout, func, signal) {
      const timeoutController = new AbortController();
      const abortCurrentAttempt = () => {
        timeoutController.abort();
      };
      const timer = setTimeout(abortCurrentAttempt, timeout);
      signal?.addEventListener("abort", abortCurrentAttempt, {
        once: true
      });
      try {
        return await func(timeoutController.signal);
      } catch (err) {
        if (err instanceof Error && err.name === "AbortError" && !(signal && signal.aborted)) {
          throw new _timeoutError.default();
        }
        throw err;
      } finally {
        signal?.removeEventListener("abort", abortCurrentAttempt);
        clearTimeout(timer);
      }
    }
  }
});

// node_modules/tedious/lib/instance-lookup.js
var require_instance_lookup = __commonJS({
  "node_modules/tedious/lib/instance-lookup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.instanceLookup = instanceLookup;
    exports2.parseBrowserResponse = parseBrowserResponse;
    var _dns = _interopRequireDefault(require("dns"));
    var _abortError = _interopRequireDefault(require_abort_error());
    var _sender = require_sender();
    var _withTimeout = require_with_timeout();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SQL_SERVER_BROWSER_PORT = 1434;
    var TIMEOUT = 2 * 1e3;
    var RETRIES = 3;
    var MYSTERY_HEADER_LENGTH = 3;
    async function instanceLookup(options) {
      const server = options.server;
      if (typeof server !== "string") {
        throw new TypeError('Invalid arguments: "server" must be a string');
      }
      const instanceName = options.instanceName;
      if (typeof instanceName !== "string") {
        throw new TypeError('Invalid arguments: "instanceName" must be a string');
      }
      const timeout = options.timeout === void 0 ? TIMEOUT : options.timeout;
      if (typeof timeout !== "number") {
        throw new TypeError('Invalid arguments: "timeout" must be a number');
      }
      const retries = options.retries === void 0 ? RETRIES : options.retries;
      if (typeof retries !== "number") {
        throw new TypeError('Invalid arguments: "retries" must be a number');
      }
      if (options.lookup !== void 0 && typeof options.lookup !== "function") {
        throw new TypeError('Invalid arguments: "lookup" must be a function');
      }
      const lookup = options.lookup ?? _dns.default.lookup;
      if (options.port !== void 0 && typeof options.port !== "number") {
        throw new TypeError('Invalid arguments: "port" must be a number');
      }
      const port = options.port ?? SQL_SERVER_BROWSER_PORT;
      const signal = options.signal;
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let response;
      for (let i = 0; i <= retries; i++) {
        try {
          response = await (0, _withTimeout.withTimeout)(timeout, async (signal2) => {
            const request3 = Buffer.from([2]);
            return await (0, _sender.sendMessage)(options.server, port, lookup, signal2, request3);
          }, signal);
        } catch (err) {
          if (!signal.aborted && err instanceof Error && err.name === "TimeoutError") {
            continue;
          }
          throw err;
        }
      }
      if (!response) {
        throw new Error("Failed to get response from SQL Server Browser on " + server);
      }
      const message = response.toString("ascii", MYSTERY_HEADER_LENGTH);
      const foundPort = parseBrowserResponse(message, instanceName);
      if (!foundPort) {
        throw new Error("Port for " + instanceName + " not found in " + options.server);
      }
      return foundPort;
    }
    function parseBrowserResponse(response, instanceName) {
      let getPort;
      const instances = response.split(";;");
      for (let i = 0, len = instances.length; i < len; i++) {
        const instance = instances[i];
        const parts = instance.split(";");
        for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {
          const name3 = parts[p];
          const value = parts[p + 1];
          if (name3 === "tcp" && getPort) {
            const port = parseInt(value, 10);
            return port;
          }
          if (name3 === "InstanceName") {
            if (value.toUpperCase() === instanceName.toUpperCase()) {
              getPort = true;
            } else {
              getPort = false;
            }
          }
        }
      }
    }
  }
});

// node_modules/tedious/lib/transient-error-lookup.js
var require_transient_error_lookup = __commonJS({
  "node_modules/tedious/lib/transient-error-lookup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TransientErrorLookup = void 0;
    var TransientErrorLookup = class {
      isTransientError(error) {
        const transientErrors = [4060, 10928, 10929, 40197, 40501, 40613];
        return transientErrors.indexOf(error) !== -1;
      }
    };
    exports2.TransientErrorLookup = TransientErrorLookup;
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports2) {
    "use strict";
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/tedious/lib/packet.js
var require_packet = __commonJS({
  "node_modules/tedious/lib/packet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TYPE = exports2.Packet = exports2.OFFSET = exports2.HEADER_LENGTH = void 0;
    exports2.isPacketComplete = isPacketComplete;
    exports2.packetLength = packetLength;
    var _sprintfJs = require_sprintf();
    var HEADER_LENGTH = exports2.HEADER_LENGTH = 8;
    var TYPE = exports2.TYPE = {
      SQL_BATCH: 1,
      RPC_REQUEST: 3,
      TABULAR_RESULT: 4,
      ATTENTION: 6,
      BULK_LOAD: 7,
      TRANSACTION_MANAGER: 14,
      LOGIN7: 16,
      NTLMAUTH_PKT: 17,
      PRELOGIN: 18,
      FEDAUTH_TOKEN: 8
    };
    var typeByValue = {};
    for (const name3 in TYPE) {
      typeByValue[TYPE[name3]] = name3;
    }
    var STATUS = {
      NORMAL: 0,
      EOM: 1,
      IGNORE: 2,
      RESETCONNECTION: 8,
      RESETCONNECTIONSKIPTRAN: 16
    };
    var OFFSET = exports2.OFFSET = {
      Type: 0,
      Status: 1,
      Length: 2,
      SPID: 4,
      PacketID: 6,
      Window: 7
    };
    var DEFAULT_SPID = 0;
    var DEFAULT_PACKETID = 1;
    var DEFAULT_WINDOW = 0;
    var NL = "\n";
    var Packet = class {
      constructor(typeOrBuffer) {
        if (typeOrBuffer instanceof Buffer) {
          this.buffer = typeOrBuffer;
        } else {
          const type2 = typeOrBuffer;
          this.buffer = Buffer.alloc(HEADER_LENGTH, 0);
          this.buffer.writeUInt8(type2, OFFSET.Type);
          this.buffer.writeUInt8(STATUS.NORMAL, OFFSET.Status);
          this.buffer.writeUInt16BE(DEFAULT_SPID, OFFSET.SPID);
          this.buffer.writeUInt8(DEFAULT_PACKETID, OFFSET.PacketID);
          this.buffer.writeUInt8(DEFAULT_WINDOW, OFFSET.Window);
          this.setLength();
        }
      }
      setLength() {
        this.buffer.writeUInt16BE(this.buffer.length, OFFSET.Length);
      }
      length() {
        return this.buffer.readUInt16BE(OFFSET.Length);
      }
      resetConnection(reset) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (reset) {
          status |= STATUS.RESETCONNECTION;
        } else {
          status &= 255 - STATUS.RESETCONNECTION;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      last(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (arguments.length > 0) {
          if (last) {
            status |= STATUS.EOM;
          } else {
            status &= 255 - STATUS.EOM;
          }
          this.buffer.writeUInt8(status, OFFSET.Status);
        }
        return this.isLast();
      }
      ignore(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (last) {
          status |= STATUS.IGNORE;
        } else {
          status &= 255 - STATUS.IGNORE;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      isLast() {
        return !!(this.buffer.readUInt8(OFFSET.Status) & STATUS.EOM);
      }
      packetId(packetId) {
        if (packetId) {
          this.buffer.writeUInt8(packetId % 256, OFFSET.PacketID);
        }
        return this.buffer.readUInt8(OFFSET.PacketID);
      }
      addData(data) {
        this.buffer = Buffer.concat([this.buffer, data]);
        this.setLength();
        return this;
      }
      data() {
        return this.buffer.slice(HEADER_LENGTH);
      }
      type() {
        return this.buffer.readUInt8(OFFSET.Type);
      }
      statusAsString() {
        const status = this.buffer.readUInt8(OFFSET.Status);
        const statuses = [];
        for (const name3 in STATUS) {
          const value = STATUS[name3];
          if (status & value) {
            statuses.push(name3);
          } else {
            statuses.push(void 0);
          }
        }
        return statuses.join(" ").trim();
      }
      headerToString(indent = "") {
        const text = (0, _sprintfJs.sprintf)("type:0x%02X(%s), status:0x%02X(%s), length:0x%04X, spid:0x%04X, packetId:0x%02X, window:0x%02X", this.buffer.readUInt8(OFFSET.Type), typeByValue[this.buffer.readUInt8(OFFSET.Type)], this.buffer.readUInt8(OFFSET.Status), this.statusAsString(), this.buffer.readUInt16BE(OFFSET.Length), this.buffer.readUInt16BE(OFFSET.SPID), this.buffer.readUInt8(OFFSET.PacketID), this.buffer.readUInt8(OFFSET.Window));
        return indent + text;
      }
      dataToString(indent = "") {
        const BYTES_PER_GROUP = 4;
        const CHARS_PER_GROUP = 8;
        const BYTES_PER_LINE = 32;
        const data = this.data();
        let dataDump = "";
        let chars = "";
        for (let offset = 0; offset < data.length; offset++) {
          if (offset % BYTES_PER_LINE === 0) {
            dataDump += indent;
            dataDump += (0, _sprintfJs.sprintf)("%04X  ", offset);
          }
          if (data[offset] < 32 || data[offset] > 126) {
            chars += ".";
            if ((offset + 1) % CHARS_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
              chars += " ";
            }
          } else {
            chars += String.fromCharCode(data[offset]);
          }
          if (data[offset] != null) {
            dataDump += (0, _sprintfJs.sprintf)("%02X", data[offset]);
          }
          if ((offset + 1) % BYTES_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
            dataDump += " ";
          }
          if ((offset + 1) % BYTES_PER_LINE === 0) {
            dataDump += "  " + chars;
            chars = "";
            if (offset < data.length - 1) {
              dataDump += NL;
            }
          }
        }
        if (chars.length) {
          dataDump += "  " + chars;
        }
        return dataDump;
      }
      toString(indent = "") {
        return this.headerToString(indent) + "\n" + this.dataToString(indent + indent);
      }
      payloadString() {
        return "";
      }
    };
    exports2.Packet = Packet;
    function isPacketComplete(potentialPacketBuffer) {
      if (potentialPacketBuffer.length < HEADER_LENGTH) {
        return false;
      } else {
        return potentialPacketBuffer.length >= potentialPacketBuffer.readUInt16BE(OFFSET.Length);
      }
    }
    function packetLength(potentialPacketBuffer) {
      return potentialPacketBuffer.readUInt16BE(OFFSET.Length);
    }
  }
});

// node_modules/tedious/lib/prelogin-payload.js
var require_prelogin_payload = __commonJS({
  "node_modules/tedious/lib/prelogin-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _sprintfJs = require_sprintf();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var optionBufferSize = 20;
    var TOKEN = {
      VERSION: 0,
      ENCRYPTION: 1,
      INSTOPT: 2,
      THREADID: 3,
      MARS: 4,
      FEDAUTHREQUIRED: 6,
      TERMINATOR: 255
    };
    var ENCRYPT = {
      OFF: 0,
      ON: 1,
      NOT_SUP: 2,
      REQ: 3
    };
    var encryptByValue = {};
    for (const name3 in ENCRYPT) {
      const value = ENCRYPT[name3];
      encryptByValue[value] = name3;
    }
    var MARS = {
      OFF: 0,
      ON: 1
    };
    var marsByValue = {};
    for (const name3 in MARS) {
      const value = MARS[name3];
      marsByValue[value] = name3;
    }
    var PreloginPayload = class {
      constructor(bufferOrOptions = {
        encrypt: false,
        version: {
          major: 0,
          minor: 0,
          build: 0,
          subbuild: 0
        }
      }) {
        if (bufferOrOptions instanceof Buffer) {
          this.data = bufferOrOptions;
          this.options = {
            encrypt: false,
            version: {
              major: 0,
              minor: 0,
              build: 0,
              subbuild: 0
            }
          };
        } else {
          this.options = bufferOrOptions;
          this.createOptions();
        }
        this.extractOptions();
      }
      createOptions() {
        const options = [this.createVersionOption(), this.createEncryptionOption(), this.createInstanceOption(), this.createThreadIdOption(), this.createMarsOption(), this.createFedAuthOption()];
        let length = 0;
        for (let i = 0, len = options.length; i < len; i++) {
          const option = options[i];
          length += 5 + option.data.length;
        }
        length++;
        this.data = Buffer.alloc(length, 0);
        let optionOffset = 0;
        let optionDataOffset = 5 * options.length + 1;
        for (let j = 0, len = options.length; j < len; j++) {
          const option = options[j];
          this.data.writeUInt8(option.token, optionOffset + 0);
          this.data.writeUInt16BE(optionDataOffset, optionOffset + 1);
          this.data.writeUInt16BE(option.data.length, optionOffset + 3);
          optionOffset += 5;
          option.data.copy(this.data, optionDataOffset);
          optionDataOffset += option.data.length;
        }
        this.data.writeUInt8(TOKEN.TERMINATOR, optionOffset);
      }
      createVersionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(this.options.version.major);
        buffer.writeUInt8(this.options.version.minor);
        buffer.writeUInt16BE(this.options.version.build);
        buffer.writeUInt16BE(this.options.version.subbuild);
        return {
          token: TOKEN.VERSION,
          data: buffer.data
        };
      }
      createEncryptionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        if (this.options.encrypt) {
          buffer.writeUInt8(ENCRYPT.ON);
        } else {
          buffer.writeUInt8(ENCRYPT.NOT_SUP);
        }
        return {
          token: TOKEN.ENCRYPTION,
          data: buffer.data
        };
      }
      createInstanceOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(0);
        return {
          token: TOKEN.INSTOPT,
          data: buffer.data
        };
      }
      createThreadIdOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt32BE(0);
        return {
          token: TOKEN.THREADID,
          data: buffer.data
        };
      }
      createMarsOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(MARS.OFF);
        return {
          token: TOKEN.MARS,
          data: buffer.data
        };
      }
      createFedAuthOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(1);
        return {
          token: TOKEN.FEDAUTHREQUIRED,
          data: buffer.data
        };
      }
      extractOptions() {
        let offset = 0;
        while (this.data[offset] !== TOKEN.TERMINATOR) {
          let dataOffset = this.data.readUInt16BE(offset + 1);
          const dataLength = this.data.readUInt16BE(offset + 3);
          switch (this.data[offset]) {
            case TOKEN.VERSION:
              this.extractVersion(dataOffset);
              break;
            case TOKEN.ENCRYPTION:
              this.extractEncryption(dataOffset);
              break;
            case TOKEN.INSTOPT:
              this.extractInstance(dataOffset);
              break;
            case TOKEN.THREADID:
              if (dataLength > 0) {
                this.extractThreadId(dataOffset);
              }
              break;
            case TOKEN.MARS:
              this.extractMars(dataOffset);
              break;
            case TOKEN.FEDAUTHREQUIRED:
              this.extractFedAuth(dataOffset);
              break;
          }
          offset += 5;
          dataOffset += dataLength;
        }
      }
      extractVersion(offset) {
        this.version = {
          major: this.data.readUInt8(offset + 0),
          minor: this.data.readUInt8(offset + 1),
          build: this.data.readUInt16BE(offset + 2),
          subbuild: this.data.readUInt16BE(offset + 4)
        };
      }
      extractEncryption(offset) {
        this.encryption = this.data.readUInt8(offset);
        this.encryptionString = encryptByValue[this.encryption];
      }
      extractInstance(offset) {
        this.instance = this.data.readUInt8(offset);
      }
      extractThreadId(offset) {
        this.threadId = this.data.readUInt32BE(offset);
      }
      extractMars(offset) {
        this.mars = this.data.readUInt8(offset);
        this.marsString = marsByValue[this.mars];
      }
      extractFedAuth(offset) {
        this.fedAuthRequired = this.data.readUInt8(offset);
      }
      toString(indent = "") {
        return indent + "PreLogin - " + (0, _sprintfJs.sprintf)("version:%d.%d.%d.%d, encryption:0x%02X(%s), instopt:0x%02X, threadId:0x%08X, mars:0x%02X(%s)", this.version.major, this.version.minor, this.version.build, this.version.subbuild, this.encryption ? this.encryption : 0, this.encryptionString ? this.encryptionString : "", this.instance ? this.instance : 0, this.threadId ? this.threadId : 0, this.mars ? this.mars : 0, this.marsString ? this.marsString : "");
      }
    };
    var _default = exports2.default = PreloginPayload;
    module2.exports = PreloginPayload;
  }
});

// node_modules/tedious/lib/tds-versions.js
var require_tds_versions = __commonJS({
  "node_modules/tedious/lib/tds-versions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.versionsByValue = exports2.versions = void 0;
    var versions2 = exports2.versions = {
      "7_1": 1895825409,
      "7_2": 1913192450,
      "7_3_A": 1930035203,
      "7_3_B": 1930100739,
      "7_4": 1946157060,
      "8_0": 134217728
    };
    var versionsByValue = exports2.versionsByValue = {};
    for (const name3 in versions2) {
      versionsByValue[versions2[name3]] = name3;
    }
  }
});

// node_modules/tedious/lib/login7-payload.js
var require_login7_payload = __commonJS({
  "node_modules/tedious/lib/login7-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _sprintfJs = require_sprintf();
    var _tdsVersions = require_tds_versions();
    var FLAGS_1 = {
      ENDIAN_LITTLE: 0,
      ENDIAN_BIG: 1,
      CHARSET_ASCII: 0,
      CHARSET_EBCDIC: 2,
      FLOAT_IEEE_754: 0,
      FLOAT_VAX: 4,
      FLOAT_ND5000: 8,
      BCP_DUMPLOAD_ON: 0,
      BCP_DUMPLOAD_OFF: 16,
      USE_DB_ON: 0,
      USE_DB_OFF: 32,
      INIT_DB_WARN: 0,
      INIT_DB_FATAL: 64,
      SET_LANG_WARN_OFF: 0,
      SET_LANG_WARN_ON: 128
    };
    var FLAGS_2 = {
      INIT_LANG_WARN: 0,
      INIT_LANG_FATAL: 1,
      ODBC_OFF: 0,
      ODBC_ON: 2,
      F_TRAN_BOUNDARY: 4,
      F_CACHE_CONNECT: 8,
      USER_NORMAL: 0,
      USER_SERVER: 16,
      USER_REMUSER: 32,
      USER_SQLREPL: 64,
      INTEGRATED_SECURITY_OFF: 0,
      INTEGRATED_SECURITY_ON: 128
    };
    var TYPE_FLAGS = {
      SQL_DFLT: 0,
      SQL_TSQL: 8,
      OLEDB_OFF: 0,
      OLEDB_ON: 16,
      READ_WRITE_INTENT: 0,
      READ_ONLY_INTENT: 32
    };
    var FLAGS_3 = {
      CHANGE_PASSWORD_NO: 0,
      CHANGE_PASSWORD_YES: 1,
      BINARY_XML: 2,
      SPAWN_USER_INSTANCE: 4,
      UNKNOWN_COLLATION_HANDLING: 8,
      EXTENSION_USED: 16
    };
    var FEDAUTH_OPTIONS = {
      FEATURE_ID: 2,
      LIBRARY_SECURITYTOKEN: 1,
      LIBRARY_ADAL: 2,
      FEDAUTH_YES_ECHO: 1,
      FEDAUTH_NO_ECHO: 0,
      ADAL_WORKFLOW_USER_PASS: 1,
      ADAL_WORKFLOW_INTEGRATED: 2
    };
    var FEATURE_EXT_TERMINATOR = 255;
    var Login7Payload = class {
      constructor({
        tdsVersion,
        packetSize,
        clientProgVer,
        clientPid,
        connectionId,
        clientTimeZone,
        clientLcid
      }) {
        this.tdsVersion = tdsVersion;
        this.packetSize = packetSize;
        this.clientProgVer = clientProgVer;
        this.clientPid = clientPid;
        this.connectionId = connectionId;
        this.clientTimeZone = clientTimeZone;
        this.clientLcid = clientLcid;
        this.readOnlyIntent = false;
        this.initDbFatal = false;
        this.fedAuth = void 0;
        this.userName = void 0;
        this.password = void 0;
        this.serverName = void 0;
        this.appName = void 0;
        this.hostname = void 0;
        this.libraryName = void 0;
        this.language = void 0;
        this.database = void 0;
        this.clientId = void 0;
        this.sspi = void 0;
        this.attachDbFile = void 0;
        this.changePassword = void 0;
      }
      toBuffer() {
        const fixedData = Buffer.alloc(94);
        const buffers = [fixedData];
        let offset = 0;
        let dataOffset = fixedData.length;
        offset = fixedData.writeUInt32LE(0, offset);
        offset = fixedData.writeUInt32LE(this.tdsVersion, offset);
        offset = fixedData.writeUInt32LE(this.packetSize, offset);
        offset = fixedData.writeUInt32LE(this.clientProgVer, offset);
        offset = fixedData.writeUInt32LE(this.clientPid, offset);
        offset = fixedData.writeUInt32LE(this.connectionId, offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags1(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags2(), offset);
        offset = fixedData.writeUInt8(this.buildTypeFlags(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags3(), offset);
        offset = fixedData.writeInt32LE(this.clientTimeZone, offset);
        offset = fixedData.writeUInt32LE(this.clientLcid, offset);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.hostname) {
          const buffer = Buffer.from(this.hostname, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(dataOffset, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.userName) {
          const buffer = Buffer.from(this.userName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.password) {
          const buffer = Buffer.from(this.password, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(this.scramblePassword(buffer));
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.appName) {
          const buffer = Buffer.from(this.appName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.serverName) {
          const buffer = Buffer.from(this.serverName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        const extensions = this.buildFeatureExt();
        offset = fixedData.writeUInt16LE(4, offset);
        const extensionOffset = Buffer.alloc(4);
        extensionOffset.writeUInt32LE(dataOffset += 4, 0);
        dataOffset += extensions.length;
        buffers.push(extensionOffset, extensions);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.libraryName) {
          const buffer = Buffer.from(this.libraryName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.language) {
          const buffer = Buffer.from(this.language, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.database) {
          const buffer = Buffer.from(this.database, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.clientId) {
          this.clientId.copy(fixedData, offset, 0, 6);
        }
        offset += 6;
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.sspi) {
          if (this.sspi.length > 65535) {
            offset = fixedData.writeUInt16LE(65535, offset);
          } else {
            offset = fixedData.writeUInt16LE(this.sspi.length, offset);
          }
          buffers.push(this.sspi);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.attachDbFile) {
          const buffer = Buffer.from(this.attachDbFile, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.changePassword) {
          const buffer = Buffer.from(this.changePassword, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.sspi && this.sspi.length > 65535) {
          fixedData.writeUInt32LE(this.sspi.length, offset);
        } else {
          fixedData.writeUInt32LE(0, offset);
        }
        const data = Buffer.concat(buffers);
        data.writeUInt32LE(data.length, 0);
        return data;
      }
      buildOptionFlags1() {
        let flags1 = FLAGS_1.ENDIAN_LITTLE | FLAGS_1.CHARSET_ASCII | FLAGS_1.FLOAT_IEEE_754 | FLAGS_1.BCP_DUMPLOAD_OFF | FLAGS_1.USE_DB_OFF | FLAGS_1.SET_LANG_WARN_ON;
        if (this.initDbFatal) {
          flags1 |= FLAGS_1.INIT_DB_FATAL;
        } else {
          flags1 |= FLAGS_1.INIT_DB_WARN;
        }
        return flags1;
      }
      buildFeatureExt() {
        const buffers = [];
        const fedAuth = this.fedAuth;
        if (fedAuth) {
          switch (fedAuth.type) {
            case "ADAL":
              const buffer = Buffer.alloc(7);
              buffer.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, 0);
              buffer.writeUInt32LE(2, 1);
              buffer.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_ADAL << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), 5);
              buffer.writeUInt8(fedAuth.workflow === "integrated" ? 2 : FEDAUTH_OPTIONS.ADAL_WORKFLOW_USER_PASS, 6);
              buffers.push(buffer);
              break;
            case "SECURITYTOKEN":
              const token = Buffer.from(fedAuth.fedAuthToken, "ucs2");
              const buf = Buffer.alloc(10);
              let offset = 0;
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, offset);
              offset = buf.writeUInt32LE(token.length + 4 + 1, offset);
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_SECURITYTOKEN << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), offset);
              buf.writeInt32LE(token.length, offset);
              buffers.push(buf);
              buffers.push(token);
              break;
          }
        }
        if (this.tdsVersion >= _tdsVersions.versions["7_4"]) {
          const UTF8_SUPPORT_FEATURE_ID = 10;
          const UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8 = 1;
          const buf = Buffer.alloc(6);
          buf.writeUInt8(UTF8_SUPPORT_FEATURE_ID, 0);
          buf.writeUInt32LE(1, 1);
          buf.writeUInt8(UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8, 5);
          buffers.push(buf);
        }
        buffers.push(Buffer.from([FEATURE_EXT_TERMINATOR]));
        return Buffer.concat(buffers);
      }
      buildOptionFlags2() {
        let flags2 = FLAGS_2.INIT_LANG_WARN | FLAGS_2.ODBC_OFF | FLAGS_2.USER_NORMAL;
        if (this.sspi) {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_ON;
        } else {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_OFF;
        }
        return flags2;
      }
      buildTypeFlags() {
        let typeFlags = TYPE_FLAGS.SQL_DFLT | TYPE_FLAGS.OLEDB_OFF;
        if (this.readOnlyIntent) {
          typeFlags |= TYPE_FLAGS.READ_ONLY_INTENT;
        } else {
          typeFlags |= TYPE_FLAGS.READ_WRITE_INTENT;
        }
        return typeFlags;
      }
      buildOptionFlags3() {
        return FLAGS_3.CHANGE_PASSWORD_NO | FLAGS_3.UNKNOWN_COLLATION_HANDLING | FLAGS_3.EXTENSION_USED;
      }
      scramblePassword(password) {
        for (let b = 0, len = password.length; b < len; b++) {
          let byte = password[b];
          const lowNibble = byte & 15;
          const highNibble = byte >> 4;
          byte = lowNibble << 4 | highNibble;
          byte = byte ^ 165;
          password[b] = byte;
        }
        return password;
      }
      toString(indent = "") {
        return indent + "Login7 - " + (0, _sprintfJs.sprintf)("TDS:0x%08X, PacketSize:0x%08X, ClientProgVer:0x%08X, ClientPID:0x%08X, ConnectionID:0x%08X", this.tdsVersion, this.packetSize, this.clientProgVer, this.clientPid, this.connectionId) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Flags1:0x%02X, Flags2:0x%02X, TypeFlags:0x%02X, Flags3:0x%02X, ClientTimezone:%d, ClientLCID:0x%08X", this.buildOptionFlags1(), this.buildOptionFlags2(), this.buildTypeFlags(), this.buildOptionFlags3(), this.clientTimeZone, this.clientLcid) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Hostname:'%s', Username:'%s', Password:'%s', AppName:'%s', ServerName:'%s', LibraryName:'%s'", this.hostname, this.userName, this.password, this.appName, this.serverName, this.libraryName) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Language:'%s', Database:'%s', SSPI:'%s', AttachDbFile:'%s', ChangePassword:'%s'", this.language, this.database, this.sspi, this.attachDbFile, this.changePassword);
      }
    };
    var _default = exports2.default = Login7Payload;
    module2.exports = Login7Payload;
  }
});

// node_modules/js-md4/src/md4.js
var require_md4 = __commonJS({
  "node_modules/js-md4/src/md4.js"(exports2, module2) {
    "use strict";
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.JS_MD4_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      }
      var COMMON_JS = !root.JS_MD4_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer"];
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md4(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md4();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type2 = OUTPUT_TYPES[i];
          method[type2] = createOutputMethod(type2);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto4 = require("crypto");
        var Buffer2 = require("buffer").Buffer;
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto4.createHash("md4").update(message, "utf8").digest("hex");
          } else if (ARRAY_BUFFER && message instanceof ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (message.length === void 0) {
            return method(message);
          }
          return crypto4.createHash("md4").update(new Buffer2(message)).digest("hex");
        };
        return nodeMethod;
      };
      function Md4(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md4.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString = typeof message !== "string";
        if (notString && ARRAY_BUFFER && message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  buffer82[i++] = code;
                } else if (code < 2048) {
                  buffer82[i++] = 192 | code >> 6;
                  buffer82[i++] = 128 | code & 63;
                } else if (code < 55296 || code >= 57344) {
                  buffer82[i++] = 224 | code >> 12;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code >> 18;
                  buffer82[i++] = 128 | code >> 12 & 63;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                }
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        return this;
      };
      Md4.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        this.hash();
      };
      Md4.prototype.hash = function() {
        var a, b, c, d, ab, bc, cd, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 1;
          a = a << 3 | a >>> 29;
          d = (a & 4023233417 | ~a & 2562383102) + blocks2[1] + 271733878;
          d = d << 7 | d >>> 25;
          c = (d & a | ~d & 4023233417) + blocks2[2] - 1732584194;
          c = c << 11 | c >>> 21;
          b = (c & d | ~c & a) + blocks2[3] - 271733879;
          b = b << 19 | b >>> 13;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (b & c | ~b & d) + blocks2[0];
          a = a << 3 | a >>> 29;
          d += (a & b | ~a & c) + blocks2[1];
          d = d << 7 | d >>> 25;
          c += (d & a | ~d & b) + blocks2[2];
          c = c << 11 | c >>> 21;
          b += (c & d | ~c & a) + blocks2[3];
          b = b << 19 | b >>> 13;
        }
        a += (b & c | ~b & d) + blocks2[4];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[5];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[6];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[7];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[8];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[9];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[10];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[11];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[12];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[13];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[14];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[15];
        b = b << 19 | b >>> 13;
        bc = b & c;
        a += (bc | b & d | c & d) + blocks2[0] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[4] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[8] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[12] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[1] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[5] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[9] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[13] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[2] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[6] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[10] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[14] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[3] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[7] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[11] + 1518500249;
        c = c << 9 | c >>> 23;
        b += (c & d | c & a | da) + blocks2[15] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[0] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[8] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[4] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[12] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[2] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[10] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[6] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[14] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[9] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[5] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[13] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[3] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[11] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[15] + 1859775393;
        b = b << 15 | b >>> 17;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md4.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      };
      Md4.prototype.toString = Md4.prototype.hex;
      Md4.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >> 8 & 255,
          h0 >> 16 & 255,
          h0 >> 24 & 255,
          h1 & 255,
          h1 >> 8 & 255,
          h1 >> 16 & 255,
          h1 >> 24 & 255,
          h2 & 255,
          h2 >> 8 & 255,
          h2 >> 16 & 255,
          h2 >> 24 & 255,
          h3 & 255,
          h3 >> 8 & 255,
          h3 >> 16 & 255,
          h3 >> 24 & 255
        ];
      };
      Md4.prototype.array = Md4.prototype.digest;
      Md4.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md4.prototype.buffer = Md4.prototype.arrayBuffer;
      var exports3 = createMethod();
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root.md4 = exports3;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/tedious/lib/ntlm-payload.js
var require_ntlm_payload = __commonJS({
  "node_modules/tedious/lib/ntlm-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var crypto4 = _interopRequireWildcard(require("crypto"));
    var _jsMd = _interopRequireDefault(require_md4());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NTLMResponsePayload = class {
      constructor(loginData) {
        this.data = this.createResponse(loginData);
      }
      toString(indent = "") {
        return indent + "NTLM Auth";
      }
      createResponse(challenge) {
        const client_nonce = this.createClientNonce();
        const lmv2len = 24;
        const ntlmv2len = 16;
        const domain = challenge.domain;
        const username = challenge.userName;
        const password = challenge.password;
        const ntlmData = challenge.ntlmpacket;
        const server_data = ntlmData.target;
        const server_nonce = ntlmData.nonce;
        const bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;
        const data = new _writableTrackingBuffer.default(bufferLength);
        data.position = 0;
        data.writeString("NTLMSSP\0", "utf8");
        data.writeUInt32LE(3);
        const baseIdx = 64;
        const dnIdx = baseIdx;
        const unIdx = dnIdx + domain.length * 2;
        const l2Idx = unIdx + username.length * 2;
        const ntIdx = l2Idx + lmv2len;
        data.writeUInt16LE(lmv2len);
        data.writeUInt16LE(lmv2len);
        data.writeUInt32LE(l2Idx);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt32LE(ntIdx);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt32LE(dnIdx);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt32LE(unIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(33281);
        data.writeUInt16LE(8);
        data.writeString(domain, "ucs2");
        data.writeString(username, "ucs2");
        const lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);
        data.copyFrom(lmv2Data);
        const genTime = (/* @__PURE__ */ new Date()).getTime();
        const ntlmDataBuffer = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);
        data.copyFrom(ntlmDataBuffer);
        data.writeUInt32LE(257);
        data.writeUInt32LE(0);
        const timestamp = this.createTimestamp(genTime);
        data.copyFrom(timestamp);
        data.copyFrom(client_nonce);
        data.writeUInt32LE(0);
        data.copyFrom(server_data);
        data.writeUInt32LE(0);
        return data.data;
      }
      createClientNonce() {
        const client_nonce = Buffer.alloc(8, 0);
        let nidx = 0;
        while (nidx < 8) {
          client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);
          nidx++;
        }
        return client_nonce;
      }
      ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {
        const timestamp = this.createTimestamp(mytime);
        const hash = this.ntv2Hash(domain, user, password);
        const dataLength = 40 + targetInfo.length;
        const data = Buffer.alloc(dataLength, 0);
        serverNonce.copy(data, 0, 0, 8);
        data.writeUInt32LE(257, 8);
        data.writeUInt32LE(0, 12);
        timestamp.copy(data, 16, 0, 8);
        clientNonce.copy(data, 24, 0, 8);
        data.writeUInt32LE(0, 32);
        targetInfo.copy(data, 36, 0, targetInfo.length);
        data.writeUInt32LE(0, 36 + targetInfo.length);
        return this.hmacMD5(data, hash);
      }
      createTimestamp(time) {
        const tenthsOfAMicrosecond = (BigInt(time) + BigInt(11644473600)) * BigInt(1e7);
        const lo = Number(tenthsOfAMicrosecond & BigInt(4294967295));
        const hi = Number(tenthsOfAMicrosecond >> BigInt(32) & BigInt(4294967295));
        const result = Buffer.alloc(8);
        result.writeUInt32LE(lo, 0);
        result.writeUInt32LE(hi, 4);
        return result;
      }
      lmv2Response(domain, user, password, serverNonce, clientNonce) {
        const hash = this.ntv2Hash(domain, user, password);
        const data = Buffer.alloc(serverNonce.length + clientNonce.length, 0);
        serverNonce.copy(data);
        clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);
        const newhash = this.hmacMD5(data, hash);
        const response = Buffer.alloc(newhash.length + clientNonce.length, 0);
        newhash.copy(response);
        clientNonce.copy(response, newhash.length, 0, clientNonce.length);
        return response;
      }
      ntv2Hash(domain, user, password) {
        const hash = this.ntHash(password);
        const identity = Buffer.from(user.toUpperCase() + domain.toUpperCase(), "ucs2");
        return this.hmacMD5(identity, hash);
      }
      ntHash(text) {
        const unicodeString = Buffer.from(text, "ucs2");
        return Buffer.from(_jsMd.default.arrayBuffer(unicodeString));
      }
      hmacMD5(data, key) {
        return crypto4.createHmac("MD5", key).update(data).digest();
      }
    };
    var _default = exports2.default = NTLMResponsePayload;
    module2.exports = NTLMResponsePayload;
  }
});

// node_modules/tedious/lib/errors.js
var require_errors = __commonJS({
  "node_modules/tedious/lib/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RequestError = exports2.InputError = exports2.ConnectionError = void 0;
    var ConnectionError = class extends Error {
      constructor(message, code, options) {
        super(message, options);
        this.code = code;
      }
    };
    exports2.ConnectionError = ConnectionError;
    var RequestError = class extends Error {
      constructor(message, code, options) {
        super(message, options);
        this.code = code;
      }
    };
    exports2.RequestError = RequestError;
    var InputError = class extends TypeError {
    };
    exports2.InputError = InputError;
  }
});

// node_modules/tedious/lib/always-encrypted/types.js
var require_types = __commonJS({
  "node_modules/tedious/lib/always-encrypted/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SQLServerStatementColumnEncryptionSetting = exports2.SQLServerEncryptionType = exports2.DescribeParameterEncryptionResultSet2 = exports2.DescribeParameterEncryptionResultSet1 = void 0;
    var SQLServerEncryptionType = exports2.SQLServerEncryptionType = /* @__PURE__ */ function(SQLServerEncryptionType2) {
      SQLServerEncryptionType2[SQLServerEncryptionType2["Deterministic"] = 1] = "Deterministic";
      SQLServerEncryptionType2[SQLServerEncryptionType2["Randomized"] = 2] = "Randomized";
      SQLServerEncryptionType2[SQLServerEncryptionType2["PlainText"] = 0] = "PlainText";
      return SQLServerEncryptionType2;
    }({});
    var DescribeParameterEncryptionResultSet1 = exports2.DescribeParameterEncryptionResultSet1 = /* @__PURE__ */ function(DescribeParameterEncryptionResultSet12) {
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyOrdinal"] = 0] = "KeyOrdinal";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["DbId"] = 1] = "DbId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyId"] = 2] = "KeyId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyVersion"] = 3] = "KeyVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyMdVersion"] = 4] = "KeyMdVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["EncryptedKey"] = 5] = "EncryptedKey";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["ProviderName"] = 6] = "ProviderName";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyPath"] = 7] = "KeyPath";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyEncryptionAlgorithm"] = 8] = "KeyEncryptionAlgorithm";
      return DescribeParameterEncryptionResultSet12;
    }({});
    var DescribeParameterEncryptionResultSet2 = exports2.DescribeParameterEncryptionResultSet2 = /* @__PURE__ */ function(DescribeParameterEncryptionResultSet22) {
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterOrdinal"] = 0] = "ParameterOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterName"] = 1] = "ParameterName";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionAlgorithm"] = 2] = "ColumnEncryptionAlgorithm";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncrytionType"] = 3] = "ColumnEncrytionType";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionKeyOrdinal"] = 4] = "ColumnEncryptionKeyOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["NormalizationRuleVersion"] = 5] = "NormalizationRuleVersion";
      return DescribeParameterEncryptionResultSet22;
    }({});
    var SQLServerStatementColumnEncryptionSetting = exports2.SQLServerStatementColumnEncryptionSetting = /* @__PURE__ */ function(SQLServerStatementColumnEncryptionSetting2) {
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["UseConnectionSetting"] = 0] = "UseConnectionSetting";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Enabled"] = 1] = "Enabled";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["ResultSetOnly"] = 2] = "ResultSetOnly";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Disabled"] = 3] = "Disabled";
      return SQLServerStatementColumnEncryptionSetting2;
    }({});
  }
});

// node_modules/tedious/lib/request.js
var require_request2 = __commonJS({
  "node_modules/tedious/lib/request.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _events = require("events");
    var _errors = require_errors();
    var _types = require_types();
    var Request = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * This event, describing result set columns, will be emitted before row
       * events are emitted. This event may be emitted multiple times when more
       * than one recordset is produced by the statement.
       *
       * An array like object, where the columns can be accessed either by index
       * or name. Columns with a name that is an integer are not accessible by name,
       * as it would be interpreted as an array index.
       */
      /**
       * The request has been prepared and can be used in subsequent calls to execute and unprepare.
       */
      /**
       * The request encountered an error and has not been prepared.
       */
      /**
       * A row resulting from execution of the SQL statement.
       */
      /**
       * All rows from a result set have been provided (through `row` events).
       *
       * This token is used to indicate the completion of a SQL statement.
       * As multiple SQL statements can be sent to the server in a single SQL batch, multiple `done` can be generated.
       * An `done` event is emitted for each SQL statement in the SQL batch except variable declarations.
       * For execution of SQL statements within stored procedures, `doneProc` and `doneInProc` events are used in place of `done`.
       *
       * If you are using [[Connection.execSql]] then SQL server may treat the multiple calls with the same query as a stored procedure.
       * When this occurs, the `doneProc` and `doneInProc` events may be emitted instead. You must handle both events to ensure complete coverage.
       */
      /**
       * `request.on('doneInProc', function (rowCount, more, rows) { });`
       *
       * Indicates the completion status of a SQL statement within a stored procedure. All rows from a statement
       * in a stored procedure have been provided (through `row` events).
       *
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * Indicates the completion status of a stored procedure. This is also generated for stored procedures
       * executed through SQL statements.\
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * A value for an output parameter (that was added to the request with [[addOutputParameter]]).
       * See also `Using Parameters`.
       */
      /**
       * This event gives the columns by which data is ordered, if `ORDER BY` clause is executed in SQL Server.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * @param sqlTextOrProcedure
       *   The SQL statement to be executed
       *
       * @param callback
       *   The callback to execute once the request has been fully completed.
       */
      constructor(sqlTextOrProcedure, callback, options) {
        super();
        this.sqlTextOrProcedure = sqlTextOrProcedure;
        this.parameters = [];
        this.parametersByName = {};
        this.preparing = false;
        this.handle = void 0;
        this.canceled = false;
        this.paused = false;
        this.error = void 0;
        this.connection = void 0;
        this.timeout = void 0;
        this.userCallback = callback;
        this.statementColumnEncryptionSetting = options && options.statementColumnEncryptionSetting || _types.SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;
        this.cryptoMetadataLoaded = false;
        this.callback = function(err, rowCount, rows) {
          if (this.preparing) {
            this.preparing = false;
            if (err) {
              this.emit("error", err);
            } else {
              this.emit("prepared");
            }
          } else {
            this.userCallback(err, rowCount, rows);
            this.emit("requestCompleted");
          }
        };
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects. The name should not start with `@`.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types.
       *
       * @param options
       *   Additional type options. Optional.
       */
      // TODO: `type` must be a valid TDS value type
      addParameter(name3, type2, value, options) {
        const {
          output = false,
          length,
          precision,
          scale
        } = options ?? {};
        const parameter = {
          type: type2,
          name: name3,
          value,
          output,
          length,
          precision,
          scale
        };
        this.parameters.push(parameter);
        this.parametersByName[name3] = parameter;
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types
       *
       * @param options
       *   Additional type options. Optional.
       */
      addOutputParameter(name3, type2, value, options) {
        this.addParameter(name3, type2, value, {
          ...options,
          output: true
        });
      }
      /**
       * @private
       */
      makeParamsParameter(parameters) {
        let paramsParameter = "";
        for (let i = 0, len = parameters.length; i < len; i++) {
          const parameter = parameters[i];
          if (paramsParameter.length > 0) {
            paramsParameter += ", ";
          }
          paramsParameter += "@" + parameter.name + " ";
          paramsParameter += parameter.type.declaration(parameter);
          if (parameter.output) {
            paramsParameter += " OUTPUT";
          }
        }
        return paramsParameter;
      }
      /**
       * @private
       */
      validateParameters(collation) {
        for (let i = 0, len = this.parameters.length; i < len; i++) {
          const parameter = this.parameters[i];
          try {
            parameter.value = parameter.type.validate(parameter.value, collation);
          } catch (error) {
            throw new _errors.RequestError("Validation failed for parameter '" + parameter.name + "'. " + error.message, "EPARAM", {
              cause: error
            });
          }
        }
      }
      /**
       * Temporarily suspends the flow of data from the database. No more `row` events will be emitted until [[resume] is called.
       * If this request is already in a paused state, calling [[pause]] has no effect.
       */
      pause() {
        if (this.paused) {
          return;
        }
        this.emit("pause");
        this.paused = true;
      }
      /**
       * Resumes the flow of data from the database.
       * If this request is not in a paused state, calling [[resume]] has no effect.
       */
      resume() {
        if (!this.paused) {
          return;
        }
        this.paused = false;
        this.emit("resume");
      }
      /**
       * Cancels a request while waiting for a server response.
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
      /**
       * Sets a timeout for this request.
       *
       * @param timeout
       *   The number of milliseconds before the request is considered failed,
       *   or `0` for no timeout. When no timeout is set for the request,
       *   the [[ConnectionOptions.requestTimeout]] of the [[Connection]] is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
    };
    var _default = exports2.default = Request;
    module2.exports = Request;
  }
});

// node_modules/tedious/lib/all-headers.js
var require_all_headers = __commonJS({
  "node_modules/tedious/lib/all-headers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.writeToTrackingBuffer = writeToTrackingBuffer;
    var TYPE = {
      QUERY_NOTIFICATIONS: 1,
      TXN_DESCRIPTOR: 2,
      TRACE_ACTIVITY: 3
    };
    var TXNDESCRIPTOR_HEADER_DATA_LEN = 4 + 8;
    var TXNDESCRIPTOR_HEADER_LEN = 4 + 2 + TXNDESCRIPTOR_HEADER_DATA_LEN;
    function writeToTrackingBuffer(buffer, txnDescriptor, outstandingRequestCount) {
      buffer.writeUInt32LE(0);
      buffer.writeUInt32LE(TXNDESCRIPTOR_HEADER_LEN);
      buffer.writeUInt16LE(TYPE.TXN_DESCRIPTOR);
      buffer.writeBuffer(txnDescriptor);
      buffer.writeUInt32LE(outstandingRequestCount);
      const data = buffer.data;
      data.writeUInt32LE(data.length, 0);
      return buffer;
    }
  }
});

// node_modules/tedious/lib/rpcrequest-payload.js
var require_rpcrequest_payload = __commonJS({
  "node_modules/tedious/lib/rpcrequest-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var STATUS = {
      BY_REF_VALUE: 1,
      DEFAULT_VALUE: 2
    };
    var RpcRequestPayload = class {
      constructor(procedure, parameters, txnDescriptor, options, collation) {
        this.procedure = procedure;
        this.parameters = parameters;
        this.options = options;
        this.txnDescriptor = txnDescriptor;
        this.collation = collation;
      }
      [Symbol.iterator]() {
        return this.generateData();
      }
      *generateData() {
        const buffer = new _writableTrackingBuffer.default(500);
        if (this.options.tdsVersion >= "7_2") {
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
        }
        if (typeof this.procedure === "string") {
          buffer.writeUsVarchar(this.procedure);
        } else {
          buffer.writeUShort(65535);
          buffer.writeUShort(this.procedure);
        }
        const optionFlags = 0;
        buffer.writeUInt16LE(optionFlags);
        yield buffer.data;
        const parametersLength = this.parameters.length;
        for (let i = 0; i < parametersLength; i++) {
          yield* this.generateParameterData(this.parameters[i]);
        }
      }
      toString(indent = "") {
        return indent + ("RPC Request - " + this.procedure);
      }
      *generateParameterData(parameter) {
        const buffer = new _writableTrackingBuffer.default(1 + 2 + Buffer.byteLength(parameter.name, "ucs-2") + 1);
        if (parameter.name) {
          buffer.writeBVarchar("@" + parameter.name);
        } else {
          buffer.writeBVarchar("");
        }
        let statusFlags = 0;
        if (parameter.output) {
          statusFlags |= STATUS.BY_REF_VALUE;
        }
        buffer.writeUInt8(statusFlags);
        yield buffer.data;
        const param = {
          value: parameter.value
        };
        const type2 = parameter.type;
        if ((type2.id & 48) === 32) {
          if (parameter.length) {
            param.length = parameter.length;
          } else if (type2.resolveLength) {
            param.length = type2.resolveLength(parameter);
          }
        }
        if (parameter.precision) {
          param.precision = parameter.precision;
        } else if (type2.resolvePrecision) {
          param.precision = type2.resolvePrecision(parameter);
        }
        if (parameter.scale) {
          param.scale = parameter.scale;
        } else if (type2.resolveScale) {
          param.scale = type2.resolveScale(parameter);
        }
        if (this.collation) {
          param.collation = this.collation;
        }
        yield type2.generateTypeInfo(param, this.options);
        yield type2.generateParameterLength(param, this.options);
        try {
          yield* type2.generateParameterData(param, this.options);
        } catch (error) {
          throw new _errors.InputError(`Input parameter '${parameter.name}' could not be validated`, {
            cause: error
          });
        }
      }
    };
    var _default = exports2.default = RpcRequestPayload;
    module2.exports = RpcRequestPayload;
  }
});

// node_modules/tedious/lib/sqlbatch-payload.js
var require_sqlbatch_payload = __commonJS({
  "node_modules/tedious/lib/sqlbatch-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SqlBatchPayload = class {
      constructor(sqlText, txnDescriptor, options) {
        this.sqlText = sqlText;
        this.txnDescriptor = txnDescriptor;
        this.options = options;
      }
      *[Symbol.iterator]() {
        if (this.options.tdsVersion >= "7_2") {
          const buffer = new _writableTrackingBuffer.default(18, "ucs2");
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
          yield buffer.data;
        }
        yield Buffer.from(this.sqlText, "ucs2");
      }
      toString(indent = "") {
        return indent + ("SQL Batch - " + this.sqlText);
      }
    };
    var _default = exports2.default = SqlBatchPayload;
    module2.exports = SqlBatchPayload;
  }
});

// node_modules/native-duplexpair/index.js
var require_native_duplexpair = __commonJS({
  "node_modules/native-duplexpair/index.js"(exports2, module2) {
    "use strict";
    var Duplex = require("stream").Duplex;
    var kCallback = Symbol("Callback");
    var kOtherSide = Symbol("Other");
    var DuplexSocket = class extends Duplex {
      constructor(options) {
        super(options);
        this[kCallback] = null;
        this[kOtherSide] = null;
      }
      _read() {
        const callback = this[kCallback];
        if (callback) {
          this[kCallback] = null;
          callback();
        }
      }
      _write(chunk, encoding, callback) {
        this[kOtherSide][kCallback] = callback;
        this[kOtherSide].push(chunk);
      }
      _final(callback) {
        this[kOtherSide].on("end", callback);
        this[kOtherSide].push(null);
      }
    };
    var DuplexPair = class {
      constructor(options) {
        this.socket1 = new DuplexSocket(options);
        this.socket2 = new DuplexSocket(options);
        this.socket1[kOtherSide] = this.socket2;
        this.socket2[kOtherSide] = this.socket1;
      }
    };
    module2.exports = DuplexPair;
  }
});

// node_modules/tedious/lib/message.js
var require_message = __commonJS({
  "node_modules/tedious/lib/message.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _stream = require("stream");
    var Message = class extends _stream.PassThrough {
      constructor({
        type: type2,
        resetConnection = false
      }) {
        super();
        this.type = type2;
        this.resetConnection = resetConnection;
        this.ignore = false;
      }
    };
    var _default = exports2.default = Message;
    module2.exports = Message;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/ours/primordials.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name3, prop) {
        return Object.defineProperty(self2, name3, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name3) {
        return Object.getOwnPropertyDescriptor(self2, name3);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap2 = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject2(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap2.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject2(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap2.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types[i] = arguments[i];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject2(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject2(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject2(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal2 = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal2.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal2(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController3 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal2(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController3.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController3.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports2.AbortController = AbortController3;
    exports2.AbortSignal = AbortSignal2;
    exports2.default = AbortController3;
    module2.exports = AbortController3;
    module2.exports.AbortController = module2.exports["default"] = AbortController3;
    module2.exports.AbortSignal = AbortSignal2;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/ours/util.js"(exports2, module2) {
    "use strict";
    var bufferModule = require("buffer");
    var { kResistStopPropagation, SymbolDispose } = require_primordials();
    var AbortSignal2 = globalThis.AbortSignal || require_abort_controller().AbortSignal;
    var AbortController3 = globalThis.AbortController || require_abort_controller().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob2 = typeof Blob2 !== "undefined" ? function isBlob3(b) {
      return b instanceof Blob2;
    } : function isBlob3(b) {
      return false;
    };
    var validateAbortSignal = (signal, name3) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name3, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name3) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name3, "Function", value);
    };
    var AggregateError2 = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module2.exports = {
      AggregateError: AggregateError2,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type2]) {
          const replacement = args.shift();
          if (type2 === "f") {
            return replacement.toFixed(6);
          } else if (type2 === "j") {
            return JSON.stringify(replacement);
          } else if (type2 === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob: isBlob2,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require("events").addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal2.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController3();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/bl/node_modules/readable-stream/lib/ours/errors.js
var require_errors2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/ours/errors.js"(exports2, module2) {
    "use strict";
    var { format, inspect: inspect2, AggregateError: CustomAggregateError } = require_util();
    var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert2(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError2([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError3 = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name3, expected, actual) => {
        assert2(typeof name3 === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name3.endsWith(" argument")) {
          msg += `${name3} `;
        } else {
          msg += `"${name3}" ${name3.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert2(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert2(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect2(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect2(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name3, value, reason = "is invalid") => {
        let inspected = inspect2(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type2 = name3.includes(".") ? "property" : "argument";
        return `The ${type2} '${name3}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name3, value) => {
        var _value$constructor;
        const type2 = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name3}" function but got ${type2}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert2(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert2(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect2(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = {
      AbortError: AbortError3,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/validators.js"(exports2, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors2();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name3, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name3, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name3);
      return value;
    }
    var validateInteger = hideStackFrames((value, name3, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE2(name3, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name3, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name3, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name3, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name3, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name3) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE2(name3, "string", value);
    }
    function validateNumber(value, name3, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE2(name3, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name3,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name3, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name3, value, reason);
      }
    });
    function validateBoolean(value, name3) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE2(name3, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name3, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE2(name3, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name3) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE2(name3, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name3, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE2(name3, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name3, value, reason);
      }
    });
    function validateStringArray(value, name3) {
      validateArray(value, name3);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name3}[${i}]`);
      }
    }
    function validateBooleanArray(value, name3) {
      validateArray(value, name3);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name3}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name3) {
      validateArray(value, name3);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name3}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name3 = "signal") {
      validateString(signal, name3);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name3 = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE2(name3, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name3 = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name3, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name3) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE2(name3, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name3) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE2(name3, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name3) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE2(name3, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name3) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE2(name3, "undefined", value);
    });
    function validateUnion(value, name3, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE2(name3, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name3) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name3,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module2.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/index.js
var require_process = __commonJS({
  "node_modules/process/index.js"(exports2, module2) {
    "use strict";
    module2.exports = global.process;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils3 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/utils.js"(exports2, module2) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream2(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream2(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state3 = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state3 !== null && state3 !== void 0 && state3.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state3 = wState || rState;
      return !state3 && isServerResponse(stream) || !!(state3 && state3.autoDestroy && state3.emitClose && state3.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module2.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream: isReadableStream2,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var process4 = require_process();
    var { AbortError: AbortError3, codes } = require_errors2();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream: isReadableStream2,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils3();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream2(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process4.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process4.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process4.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process4.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process4.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError3(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process4.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError3(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process4.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process4.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var process4 = require_process();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError: AbortError3
    } = require_errors2();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils3();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy2(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process4.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process4.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process4.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process4.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process4.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process4.nextTick(onConstruct, err);
        });
      } catch (err) {
        process4.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process4.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError3();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process4.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process4.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module2.exports = {
      construct,
      destroyer,
      destroy: destroy2,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports2, module2) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require("events");
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports2, module2) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError: AbortError3, codes } = require_errors2();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils3();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name3) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE2(name3, "AbortSignal", signal);
      }
    };
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError3(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError3(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require("buffer");
    var { inspect: inspect2 } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
        return inspect2(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/state.js
var require_state3 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state3, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name3 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name3, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state3.objectMode);
    }
    module2.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    var process4 = require_process();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require("buffer");
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process4.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process4.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/readable.js"(exports2, module2) {
    "use strict";
    var process4 = require_process();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module2.exports = Readable2;
    Readable2.ReadableState = ReadableState;
    var { EventEmitter: EE } = require("events");
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require("buffer");
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state3();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError: AbortError3
    } = require_errors2();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require("string_decoder");
    var from = require_from();
    ObjectSetPrototypeOf(Readable2.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable2, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value)
            this.state |= bit;
          else
            this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2))
        return new Readable2(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError3();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state3 = stream._readableState;
      let err;
      if ((state3.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state3.defaultEncoding;
          if (state3.encoding !== encoding) {
            if (addToFront && state3.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state3.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state3.state &= ~kReading;
        onEofChunk(stream, state3);
      } else if ((state3.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state3.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state3.destroyed || state3.errored)
            return false;
          else
            addChunk(stream, state3, chunk, true);
        } else if (state3.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state3.destroyed || state3.errored) {
          return false;
        } else {
          state3.state &= ~kReading;
          if (state3.decoder && !encoding) {
            chunk = state3.decoder.write(chunk);
            if (state3.objectMode || chunk.length !== 0)
              addChunk(stream, state3, chunk, false);
            else
              maybeReadMore(stream, state3);
          } else {
            addChunk(stream, state3, chunk, false);
          }
        }
      } else if (!addToFront) {
        state3.state &= ~kReading;
        maybeReadMore(stream, state3);
      }
      return !state3.ended && (state3.length < state3.highWaterMark || state3.length === 0);
    }
    function addChunk(stream, state3, chunk, addToFront) {
      if (state3.flowing && state3.length === 0 && !state3.sync && stream.listenerCount("data") > 0) {
        if ((state3.state & kMultiAwaitDrain) !== 0) {
          state3.awaitDrainWriters.clear();
        } else {
          state3.awaitDrainWriters = null;
        }
        state3.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state3.length += state3.objectMode ? 1 : chunk.length;
        if (addToFront)
          state3.buffer.unshift(chunk);
        else
          state3.buffer.push(chunk);
        if ((state3.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state3);
    }
    Readable2.prototype.isPaused = function() {
      const state3 = this._readableState;
      return state3[kPaused] === true || state3.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state3) {
      if (n <= 0 || state3.length === 0 && state3.ended)
        return 0;
      if ((state3.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n)) {
        if (state3.flowing && state3.length)
          return state3.buffer.first().length;
        return state3.length;
      }
      if (n <= state3.length)
        return n;
      return state3.ended ? state3.length : 0;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state3 = this._readableState;
      const nOrig = n;
      if (n > state3.highWaterMark)
        state3.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state3.state &= ~kEmittedReadable;
      if (n === 0 && state3.needReadable && ((state3.highWaterMark !== 0 ? state3.length >= state3.highWaterMark : state3.length > 0) || state3.ended)) {
        debug("read: emitReadable", state3.length, state3.ended);
        if (state3.length === 0 && state3.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state3);
      if (n === 0 && state3.ended) {
        if (state3.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state3.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state3.length === 0 || state3.length - n < state3.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state3.ended || state3.reading || state3.destroyed || state3.errored || !state3.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state3.state |= kReading | kSync;
        if (state3.length === 0)
          state3.state |= kNeedReadable;
        try {
          this._read(state3.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state3.state &= ~kSync;
        if (!state3.reading)
          n = howMuchToRead(nOrig, state3);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state3);
      else
        ret = null;
      if (ret === null) {
        state3.needReadable = state3.length <= state3.highWaterMark;
        n = 0;
      } else {
        state3.length -= n;
        if (state3.multiAwaitDrain) {
          state3.awaitDrainWriters.clear();
        } else {
          state3.awaitDrainWriters = null;
        }
      }
      if (state3.length === 0) {
        if (!state3.ended)
          state3.needReadable = true;
        if (nOrig !== n && state3.ended)
          endReadable(this);
      }
      if (ret !== null && !state3.errorEmitted && !state3.closeEmitted) {
        state3.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state3) {
      debug("onEofChunk");
      if (state3.ended)
        return;
      if (state3.decoder) {
        const chunk = state3.decoder.end();
        if (chunk && chunk.length) {
          state3.buffer.push(chunk);
          state3.length += state3.objectMode ? 1 : chunk.length;
        }
      }
      state3.ended = true;
      if (state3.sync) {
        emitReadable(stream);
      } else {
        state3.needReadable = false;
        state3.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state3 = stream._readableState;
      debug("emitReadable", state3.needReadable, state3.emittedReadable);
      state3.needReadable = false;
      if (!state3.emittedReadable) {
        debug("emitReadable", state3.flowing);
        state3.emittedReadable = true;
        process4.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state3 = stream._readableState;
      debug("emitReadable_", state3.destroyed, state3.length, state3.ended);
      if (!state3.destroyed && !state3.errored && (state3.length || state3.ended)) {
        stream.emit("readable");
        state3.emittedReadable = false;
      }
      state3.needReadable = !state3.flowing && !state3.ended && state3.length <= state3.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state3) {
      if (!state3.readingMore && state3.constructed) {
        state3.readingMore = true;
        process4.nextTick(maybeReadMore_, stream, state3);
      }
    }
    function maybeReadMore_(stream, state3) {
      while (!state3.reading && !state3.ended && (state3.length < state3.highWaterMark || state3.flowing && state3.length === 0)) {
        const len = state3.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state3.length)
          break;
      }
      state3.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state3 = this._readableState;
      if (state3.pipes.length === 1) {
        if (!state3.multiAwaitDrain) {
          state3.multiAwaitDrain = true;
          state3.awaitDrainWriters = new SafeSet(state3.awaitDrainWriters ? [state3.awaitDrainWriters] : []);
        }
      }
      state3.pipes.push(dest);
      debug("pipe count=%d opts=%j", state3.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process4.stdout && dest !== process4.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state3.endEmitted)
        process4.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state3.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state3.pipes.length === 1 && state3.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state3.awaitDrainWriters = dest;
            state3.multiAwaitDrain = false;
          } else if (state3.pipes.length > 1 && state3.pipes.includes(dest)) {
            debug("false write response, pause", state3.awaitDrainWriters.size);
            state3.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state3.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state3 = src._readableState;
        if (state3.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state3.awaitDrainWriters = null;
        } else if (state3.multiAwaitDrain) {
          debug("pipeOnDrain", state3.awaitDrainWriters.size);
          state3.awaitDrainWriters.delete(dest);
        }
        if ((!state3.awaitDrainWriters || state3.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state3 = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state3.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state3.pipes;
        state3.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state3.pipes, dest);
      if (index === -1)
        return this;
      state3.pipes.splice(index, 1);
      if (state3.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state3 = this._readableState;
      if (ev === "data") {
        state3.readableListening = this.listenerCount("readable") > 0;
        if (state3.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state3.endEmitted && !state3.readableListening) {
          state3.readableListening = state3.needReadable = true;
          state3.flowing = false;
          state3.emittedReadable = false;
          debug("on readable", state3.length, state3.reading);
          if (state3.length) {
            emitReadable(this);
          } else if (!state3.reading) {
            process4.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process4.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process4.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state3 = self2._readableState;
      state3.readableListening = self2.listenerCount("readable") > 0;
      if (state3.resumeScheduled && state3[kPaused] === false) {
        state3.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state3.readableListening) {
        state3.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state3 = this._readableState;
      if (!state3.flowing) {
        debug("resume");
        state3.flowing = !state3.readableListening;
        resume(this, state3);
      }
      state3[kPaused] = false;
      return this;
    };
    function resume(stream, state3) {
      if (!state3.resumeScheduled) {
        state3.resumeScheduled = true;
        process4.nextTick(resume_, stream, state3);
      }
    }
    function resume_(stream, state3) {
      debug("resume", state3.reading);
      if (!state3.reading) {
        stream.read(0);
      }
      state3.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state3.flowing && !state3.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state3 = stream._readableState;
      debug("flow", state3.flowing);
      while (state3.flowing && stream.read() !== null)
        ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state3) {
          if (this._readableState) {
            this._readableState.flowing = state3;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state3) {
      if (state3.length === 0)
        return null;
      let ret;
      if (state3.objectMode)
        ret = state3.buffer.shift();
      else if (!n || n >= state3.length) {
        if (state3.decoder)
          ret = state3.buffer.join("");
        else if (state3.buffer.length === 1)
          ret = state3.buffer.first();
        else
          ret = state3.buffer.concat(state3.length);
        state3.buffer.clear();
      } else {
        ret = state3.buffer.consume(n, state3.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state3 = stream._readableState;
      debug("endReadable", state3.endEmitted);
      if (!state3.endEmitted) {
        state3.ended = true;
        process4.nextTick(endReadableNT, state3, stream);
      }
    }
    function endReadableNT(state3, stream) {
      debug("endReadableNT", state3.endEmitted, state3.length);
      if (!state3.errored && !state3.closeEmitted && !state3.endEmitted && state3.length === 0) {
        state3.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process4.nextTick(endWritableNT, stream);
        } else if (state3.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/writable.js"(exports2, module2) {
    "use strict";
    var process4 = require_process();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require("events");
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require("buffer");
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state3();
    var {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors2().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state3) {
      state3.buffered = [];
      state3.bufferedIndex = 0;
      state3.allBuffers = true;
      state3.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state3 = this._writableState;
        if (!state3.writing) {
          clearBuffer(this, state3);
        }
        finishMaybe(this, state3);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state3 = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state3.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state3.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state3.objectMode) {
        if (typeof chunk === "string") {
          if (state3.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state3.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state3.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process4.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state3.pendingcb++;
      return writeOrBuffer(stream, state3, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state3 = this._writableState;
      if (state3.corked) {
        state3.corked--;
        if (!state3.writing)
          clearBuffer(this, state3);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state3, chunk, encoding, callback) {
      const len = state3.objectMode ? 1 : chunk.length;
      state3.length += len;
      const ret = state3.length < state3.highWaterMark;
      if (!ret)
        state3.needDrain = true;
      if (state3.writing || state3.corked || state3.errored || !state3.constructed) {
        state3.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state3.allBuffers && encoding !== "buffer") {
          state3.allBuffers = false;
        }
        if (state3.allNoop && callback !== nop) {
          state3.allNoop = false;
        }
      } else {
        state3.writelen = len;
        state3.writecb = callback;
        state3.writing = true;
        state3.sync = true;
        stream._write(chunk, encoding, state3.onwrite);
        state3.sync = false;
      }
      return ret && !state3.errored && !state3.destroyed;
    }
    function doWrite(stream, state3, writev, len, chunk, encoding, cb) {
      state3.writelen = len;
      state3.writecb = cb;
      state3.writing = true;
      state3.sync = true;
      if (state3.destroyed)
        state3.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state3.onwrite);
      else
        stream._write(chunk, encoding, state3.onwrite);
      state3.sync = false;
    }
    function onwriteError(stream, state3, er, cb) {
      --state3.pendingcb;
      cb(er);
      errorBuffer(state3);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state3 = stream._writableState;
      const sync = state3.sync;
      const cb = state3.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state3.writing = false;
      state3.writecb = null;
      state3.length -= state3.writelen;
      state3.writelen = 0;
      if (er) {
        er.stack;
        if (!state3.errored) {
          state3.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process4.nextTick(onwriteError, stream, state3, er, cb);
        } else {
          onwriteError(stream, state3, er, cb);
        }
      } else {
        if (state3.buffered.length > state3.bufferedIndex) {
          clearBuffer(stream, state3);
        }
        if (sync) {
          if (state3.afterWriteTickInfo !== null && state3.afterWriteTickInfo.cb === cb) {
            state3.afterWriteTickInfo.count++;
          } else {
            state3.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state: state3
            };
            process4.nextTick(afterWriteTick, state3.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state3, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state: state3, count, cb }) {
      state3.afterWriteTickInfo = null;
      return afterWrite(stream, state3, count, cb);
    }
    function afterWrite(stream, state3, count, cb) {
      const needDrain = !state3.ending && !stream.destroyed && state3.length === 0 && state3.needDrain;
      if (needDrain) {
        state3.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state3.pendingcb--;
        cb();
      }
      if (state3.destroyed) {
        errorBuffer(state3);
      }
      finishMaybe(stream, state3);
    }
    function errorBuffer(state3) {
      if (state3.writing) {
        return;
      }
      for (let n = state3.bufferedIndex; n < state3.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state3.buffered[n];
        const len = state3.objectMode ? 1 : chunk.length;
        state3.length -= len;
        callback(
          (_state$errored = state3.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state3[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state3.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state3);
    }
    function clearBuffer(stream, state3) {
      if (state3.corked || state3.bufferProcessing || state3.destroyed || !state3.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state3;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state3.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state3.pendingcb -= bufferedLength - 1;
        const callback = state3.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state3.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state3.allBuffers;
        doWrite(stream, state3, true, state3.length, chunks, "", callback);
        resetBuffer(state3);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state3, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state3.writing);
        if (i === buffered.length) {
          resetBuffer(state3);
        } else if (i > 256) {
          buffered.splice(0, i);
          state3.bufferedIndex = 0;
        } else {
          state3.bufferedIndex = i;
        }
      }
      state3.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state3 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state3.corked) {
        state3.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state3.errored && !state3.ending) {
        state3.ending = true;
        finishMaybe(this, state3, true);
        state3.ended = true;
      } else if (state3.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state3.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state3.finished) {
          process4.nextTick(cb, err);
        } else {
          state3[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state3) {
      return state3.ending && !state3.destroyed && state3.constructed && state3.length === 0 && !state3.errored && state3.buffered.length === 0 && !state3.finished && !state3.writing && !state3.errorEmitted && !state3.closeEmitted;
    }
    function callFinal(stream, state3) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state3.pendingcb--;
        if (err) {
          const onfinishCallbacks = state3[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state3.sync);
        } else if (needFinish(state3)) {
          state3.prefinished = true;
          stream.emit("prefinish");
          state3.pendingcb++;
          process4.nextTick(finish, stream, state3);
        }
      }
      state3.sync = true;
      state3.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state3.sync = false;
    }
    function prefinish(stream, state3) {
      if (!state3.prefinished && !state3.finalCalled) {
        if (typeof stream._final === "function" && !state3.destroyed) {
          state3.finalCalled = true;
          callFinal(stream, state3);
        } else {
          state3.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state3, sync) {
      if (needFinish(state3)) {
        prefinish(stream, state3);
        if (state3.pendingcb === 0) {
          if (sync) {
            state3.pendingcb++;
            process4.nextTick(
              (stream2, state4) => {
                if (needFinish(state4)) {
                  finish(stream2, state4);
                } else {
                  state4.pendingcb--;
                }
              },
              stream,
              state3
            );
          } else if (needFinish(state3)) {
            state3.pendingcb++;
            finish(stream, state3);
          }
        }
      }
    }
    function finish(stream, state3) {
      state3.pendingcb--;
      state3.finished = true;
      const onfinishCallbacks = state3[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state3.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy2 = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state3 = this._writableState;
      if (!state3.destroyed && (state3.bufferedIndex < state3.buffered.length || state3[kOnFinished].length)) {
        process4.nextTick(errorBuffer, state3);
      }
      destroy2.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports2, module2) {
    "use strict";
    var process4 = require_process();
    var bufferModule = require("buffer");
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream: isReadableStream2,
      isWritableStream
    } = require_utils3();
    var eos = require_end_of_stream();
    var {
      AbortError: AbortError3,
      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
    } = require_errors2();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable2 = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob2 = typeof Blob2 !== "undefined" ? function isBlob3(b) {
      return b instanceof Blob2;
    } : function isBlob3(b) {
      return false;
    };
    var AbortController3 = globalThis.AbortController || require_abort_controller().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module2.exports = function duplexify(body, name3) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream2(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy: destroy2 } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy: destroy2
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process4.nextTick(cb, null);
                } catch (err) {
                  process4.nextTick(cb, err);
                }
              });
            },
            destroy: destroy2
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name3, value);
      }
      if (isBlob2(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream2(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE2(
        name3,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController3();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process4.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError3(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError3();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports2, module2) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module2.exports = Duplex;
    var Readable2 = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex, Readable2);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/transform.js"(exports2, module2) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform2;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state3();
    ObjectSetPrototypeOf(Transform2.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform2, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform2.prototype._final = final;
    Transform2.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform2.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform2.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports2, module2) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform2 = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform2.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var process4 = require_process();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError: AbortError3
    } = require_errors2();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream: isReadableStream2,
      isReadableFinished
    } = require_utils3();
    var AbortController3 = globalThis.AbortController || require_abort_controller().AbortController;
    var PassThrough;
    var Readable2;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable2(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = require_readable();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController3();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError3());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process4.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy: destroy2, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy2);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable2((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable2(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process4.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process4.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream2(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy: destroy2, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy2);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream2(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable2(ret), stream, finish, {
              end
            });
          } else if (isReadableStream2(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process4.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process4.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module2.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/compose.js"(exports2, module2) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream: isReadableStream2
    } = require_utils3();
    var {
      AbortError: AbortError3,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors2();
    var eos = require_end_of_stream();
    module2.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream2(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream2(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError3();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/operators.js"(exports2, module2) {
    "use strict";
    var AbortController3 = globalThis.AbortController || require_abort_controller().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError: AbortError3
    } = require_errors2();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils3();
    var { deprecate } = require_util();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map2() {
        const signal = require_util().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError3();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError3();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError3({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError3(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController3();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError3();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError3(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError3();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError3();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError3();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError3();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module2.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/stream/promises.js"(exports2, module2) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils3();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module2.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors2();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state3();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils3();
    var Stream = module2.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/ours/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    if (Stream && process.env.READABLE_STREAM === "disable") {
      const promises = Stream.promises;
      module2.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = Stream._isUint8Array;
      module2.exports.isDisturbed = Stream.isDisturbed;
      module2.exports.isErrored = Stream.isErrored;
      module2.exports.isReadable = Stream.isReadable;
      module2.exports.Readable = Stream.Readable;
      module2.exports.Writable = Stream.Writable;
      module2.exports.Duplex = Stream.Duplex;
      module2.exports.Transform = Stream.Transform;
      module2.exports.PassThrough = Stream.PassThrough;
      module2.exports.addAbortSignal = Stream.addAbortSignal;
      module2.exports.finished = Stream.finished;
      module2.exports.destroy = Stream.destroy;
      module2.exports.pipeline = Stream.pipeline;
      module2.exports.compose = Stream.compose;
      Object.defineProperty(Stream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = Stream.Stream;
    } else {
      const CustomStream = require_stream();
      const promises = require_promises();
      const originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable;
      module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = CustomStream._isUint8Array;
      module2.exports.isDisturbed = CustomStream.isDisturbed;
      module2.exports.isErrored = CustomStream.isErrored;
      module2.exports.isReadable = CustomStream.isReadable;
      module2.exports.Readable = CustomStream.Readable;
      module2.exports.Writable = CustomStream.Writable;
      module2.exports.Duplex = CustomStream.Duplex;
      module2.exports.Transform = CustomStream.Transform;
      module2.exports.PassThrough = CustomStream.PassThrough;
      module2.exports.addAbortSignal = CustomStream.addAbortSignal;
      module2.exports.finished = CustomStream.finished;
      module2.exports.destroy = CustomStream.destroy;
      module2.exports.destroy = originalDestroy;
      module2.exports.pipeline = CustomStream.pipeline;
      module2.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    "use strict";
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    "use strict";
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init2(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readBigInt64BE: 8,
        readBigInt64LE: 8,
        readBigUInt64BE: 8,
        readBigUInt64LE: 8,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_ours().Duplex;
    var inherits = require_inherits();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});

// node_modules/tedious/lib/incoming-message-stream.js
var require_incoming_message_stream = __commonJS({
  "node_modules/tedious/lib/incoming-message-stream.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = require("stream");
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IncomingMessageStream = class extends _stream.Transform {
      constructor(debug) {
        super({
          readableObjectMode: true
        });
        this.debug = debug;
        this.currentMessage = void 0;
        this.bl = new _bl.default();
      }
      pause() {
        super.pause();
        if (this.currentMessage) {
          this.currentMessage.pause();
        }
        return this;
      }
      resume() {
        super.resume();
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
        return this;
      }
      processBufferedData(callback) {
        while (this.bl.length >= _packet.HEADER_LENGTH) {
          const length = this.bl.readUInt16BE(2);
          if (length < _packet.HEADER_LENGTH) {
            return callback(new _errors.ConnectionError("Unable to process incoming packet"));
          }
          if (this.bl.length >= length) {
            const data = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(data);
            this.debug.packet("Received", packet);
            this.debug.data(packet);
            let message = this.currentMessage;
            if (message === void 0) {
              this.currentMessage = message = new _message.default({
                type: packet.type(),
                resetConnection: false
              });
              this.push(message);
            }
            if (packet.isLast()) {
              message.once("end", () => {
                this.currentMessage = void 0;
                this.processBufferedData(callback);
              });
              message.end(packet.data());
              return;
            } else if (!message.write(packet.data())) {
              message.once("drain", () => {
                this.processBufferedData(callback);
              });
              return;
            }
          } else {
            break;
          }
        }
        callback();
      }
      _transform(chunk, _encoding, callback) {
        this.bl.append(chunk);
        this.processBufferedData(callback);
      }
    };
    var _default = exports2.default = IncomingMessageStream;
    module2.exports = IncomingMessageStream;
  }
});

// node_modules/tedious/lib/outgoing-message-stream.js
var require_outgoing_message_stream = __commonJS({
  "node_modules/tedious/lib/outgoing-message-stream.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = require("stream");
    var _packet = require_packet();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OutgoingMessageStream = class extends _stream.Duplex {
      constructor(debug, {
        packetSize
      }) {
        super({
          writableObjectMode: true
        });
        this.packetSize = packetSize;
        this.debug = debug;
        this.bl = new _bl.default();
        this.on("finish", () => {
          this.push(null);
        });
      }
      _write(message, _encoding, callback) {
        const length = this.packetSize - _packet.HEADER_LENGTH;
        let packetNumber = 0;
        this.currentMessage = message;
        this.currentMessage.on("data", (data) => {
          if (message.ignore) {
            return;
          }
          this.bl.append(data);
          while (this.bl.length > length) {
            const data2 = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(message.type);
            packet.packetId(packetNumber += 1);
            packet.resetConnection(message.resetConnection);
            packet.addData(data2);
            this.debug.packet("Sent", packet);
            this.debug.data(packet);
            if (this.push(packet.buffer) === false) {
              message.pause();
            }
          }
        });
        this.currentMessage.on("end", () => {
          const data = this.bl.slice();
          this.bl.consume(data.length);
          const packet = new _packet.Packet(message.type);
          packet.packetId(packetNumber += 1);
          packet.resetConnection(message.resetConnection);
          packet.last(true);
          packet.ignore(message.ignore);
          packet.addData(data);
          this.debug.packet("Sent", packet);
          this.debug.data(packet);
          this.push(packet.buffer);
          this.currentMessage = void 0;
          callback();
        });
      }
      _read(_size) {
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
      }
    };
    var _default = exports2.default = OutgoingMessageStream;
    module2.exports = OutgoingMessageStream;
  }
});

// node_modules/tedious/lib/message-io.js
var require_message_io = __commonJS({
  "node_modules/tedious/lib/message-io.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _nativeDuplexpair = _interopRequireDefault(require_native_duplexpair());
    var tls = _interopRequireWildcard(require("tls"));
    var _events = require("events");
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _incomingMessageStream = _interopRequireDefault(require_incoming_message_stream());
    var _outgoingMessageStream = _interopRequireDefault(require_outgoing_message_stream());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MessageIO = class extends _events.EventEmitter {
      constructor(socket, packetSize, debug) {
        super();
        this.socket = socket;
        this.debug = debug;
        this.tlsNegotiationComplete = false;
        this.incomingMessageStream = new _incomingMessageStream.default(this.debug);
        this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();
        this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {
          packetSize
        });
        this.socket.pipe(this.incomingMessageStream);
        this.outgoingMessageStream.pipe(this.socket);
      }
      packetSize(...args) {
        if (args.length > 0) {
          const packetSize = args[0];
          this.debug.log("Packet size changed from " + this.outgoingMessageStream.packetSize + " to " + packetSize);
          this.outgoingMessageStream.packetSize = packetSize;
        }
        if (this.securePair) {
          this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
        }
        return this.outgoingMessageStream.packetSize;
      }
      // Negotiate TLS encryption.
      startTls(credentialsDetails, hostname, trustServerCertificate) {
        if (!credentialsDetails.maxVersion || !["TLSv1.2", "TLSv1.1", "TLSv1"].includes(credentialsDetails.maxVersion)) {
          credentialsDetails.maxVersion = "TLSv1.2";
        }
        const secureContext = tls.createSecureContext(credentialsDetails);
        return new Promise((resolve, reject) => {
          const duplexpair = new _nativeDuplexpair.default();
          const securePair = this.securePair = {
            cleartext: tls.connect({
              socket: duplexpair.socket1,
              servername: hostname,
              secureContext,
              rejectUnauthorized: !trustServerCertificate
            }),
            encrypted: duplexpair.socket2
          };
          const onSecureConnect = () => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.once("error", (err) => {
              this.socket.destroy(err);
            });
            const cipher = securePair.cleartext.getCipher();
            if (cipher) {
              this.debug.log("TLS negotiated (" + cipher.name + ", " + cipher.version + ")");
            }
            this.emit("secure", securePair.cleartext);
            securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
            this.outgoingMessageStream.unpipe(this.socket);
            this.socket.unpipe(this.incomingMessageStream);
            this.socket.pipe(securePair.encrypted);
            securePair.encrypted.pipe(this.socket);
            securePair.cleartext.pipe(this.incomingMessageStream);
            this.outgoingMessageStream.pipe(securePair.cleartext);
            this.tlsNegotiationComplete = true;
            resolve();
          };
          const onError = (err) => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.destroy();
            securePair.encrypted.destroy();
            reject(err);
          };
          const onReadable = () => {
            const message = new _message.default({
              type: _packet.TYPE.PRELOGIN,
              resetConnection: false
            });
            let chunk;
            while (chunk = securePair.encrypted.read()) {
              message.write(chunk);
            }
            this.outgoingMessageStream.write(message);
            message.end();
            this.readMessage().then(async (response) => {
              securePair.encrypted.once("readable", onReadable);
              for await (const data of response) {
                securePair.encrypted.write(data);
              }
            }).catch(onError);
          };
          securePair.cleartext.once("error", onError);
          securePair.cleartext.once("secureConnect", onSecureConnect);
          securePair.encrypted.once("readable", onReadable);
        });
      }
      // TODO listen for 'drain' event when socket.write returns false.
      // TODO implement incomplete request cancelation (2.2.1.6)
      sendMessage(packetType, data, resetConnection) {
        const message = new _message.default({
          type: packetType,
          resetConnection
        });
        message.end(data);
        this.outgoingMessageStream.write(message);
        return message;
      }
      /**
       * Read the next incoming message from the socket.
       */
      async readMessage() {
        const result = await this.incomingMessageIterator.next();
        if (result.done) {
          throw new Error("unexpected end of message stream");
        }
        return result.value;
      }
    };
    var _default = exports2.default = MessageIO;
    module2.exports = MessageIO;
  }
});

// node_modules/tedious/lib/collation.js
var require_collation = __commonJS({
  "node_modules/tedious/lib/collation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.codepageBySortId = exports2.codepageByLanguageId = exports2.Flags = exports2.Collation = void 0;
    var codepageByLanguageId = exports2.codepageByLanguageId = {
      // Arabic_*
      [1025]: "CP1256",
      // Chinese_Taiwan_Stroke_*
      // Chinese_Traditional_Stroke_Count_*
      // Chinese_Taiwan_Bopomofo_*
      // Chinese_Traditional_Bopomofo_*
      [1028]: "CP950",
      // Czech_*
      [1029]: "CP1250",
      // Danish_Greenlandic_*
      // Danish_Norwegian_*
      [1030]: "CP1252",
      // Greek_*
      [1032]: "CP1253",
      // Latin1_General_*
      [1033]: "CP1252",
      // Traditional_Spanish_*
      [1034]: "CP1252",
      // Finnish_Swedish_*
      [1035]: "CP1252",
      // French_*
      [1036]: "CP1252",
      // Hebrew_*
      [1037]: "CP1255",
      // Hungarian_*
      // Hungarian_Technical_*
      [1038]: "CP1250",
      // Icelandic_*
      [1039]: "CP1252",
      // Japanese_*
      // Japanese_XJIS_*
      // Japanese_Unicode_*
      // Japanese_Bushu_Kakusu_*
      [1041]: "CP932",
      // Korean_*
      // Korean_Wansung_*
      [1042]: "CP949",
      // Norwegian_*
      [1044]: "CP1252",
      // Polish_*
      [1045]: "CP1250",
      // Romansh_*
      [1047]: "CP1252",
      // Romanian_*
      [1048]: "CP1250",
      // Cyrillic_*
      [1049]: "CP1251",
      // Croatian_*
      [1050]: "CP1250",
      // Slovak_*
      [1051]: "CP1250",
      // Albanian_*
      [1052]: "CP1250",
      // Thai_*
      [1054]: "CP874",
      // Turkish_*
      [1055]: "CP1254",
      // Urdu_*
      [1056]: "CP1256",
      // Ukrainian_*
      [1058]: "CP1251",
      // Slovenian_*
      [1060]: "CP1250",
      // Estonian_*
      [1061]: "CP1257",
      // Latvian_*
      [1062]: "CP1257",
      // Lithuanian_*
      [1063]: "CP1257",
      // Persian_*
      [1065]: "CP1256",
      // Vietnamese_*
      [1066]: "CP1258",
      // Azeri_Latin_*
      [1068]: "CP1254",
      // Upper_Sorbian_*
      [1070]: "CP1252",
      // Macedonian_FYROM_*
      [1071]: "CP1251",
      // Sami_Norway_*
      [1083]: "CP1252",
      // Kazakh_*
      [1087]: "CP1251",
      // Turkmen_*
      [1090]: "CP1250",
      // Uzbek_Latin_*
      [1091]: "CP1254",
      // Tatar_*
      [1092]: "CP1251",
      // Welsh_*
      [1106]: "CP1252",
      // Frisian_*
      [1122]: "CP1252",
      // Bashkir_*
      [1133]: "CP1251",
      // Mapudungan_*
      [1146]: "CP1252",
      // Mohawk_*
      [1148]: "CP1252",
      // Breton_*
      [1150]: "CP1252",
      // Uighur_*
      [1152]: "CP1256",
      // Corsican_*
      [1155]: "CP1252",
      // Yakut_*
      [1157]: "CP1251",
      // Dari_*
      [1164]: "CP1256",
      // Chinese_PRC_*
      // Chinese_Simplified_Pinyin_*
      // Chinese_PRC_Stroke_*
      // Chinese_Simplified_Stroke_Order_*
      [2052]: "CP936",
      // Serbian_Latin_*
      [2074]: "CP1250",
      // Azeri_Cyrillic_*
      [2092]: "CP1251",
      // Sami_Sweden_Finland_*
      [2107]: "CP1252",
      // Tamazight_*
      [2143]: "CP1252",
      // Chinese_Hong_Kong_Stroke_*
      [3076]: "CP950",
      // Modern_Spanish_*
      [3082]: "CP1252",
      // Serbian_Cyrillic_*
      [3098]: "CP1251",
      // Chinese_Traditional_Pinyin_*
      // Chinese_Traditional_Stroke_Order_*
      [5124]: "CP950",
      // Bosnian_Latin_*
      [5146]: "CP1250",
      // Bosnian_Cyrillic_*
      [8218]: "CP1251",
      // German
      // German_PhoneBook_*
      [1031]: "CP1252",
      // Georgian_Modern_Sort_*
      [1079]: "CP1252"
    };
    var codepageBySortId = exports2.codepageBySortId = {
      [30]: "CP437",
      // SQL_Latin1_General_CP437_BIN
      [31]: "CP437",
      // SQL_Latin1_General_CP437_CS_AS
      [32]: "CP437",
      // SQL_Latin1_General_CP437_CI_AS
      [33]: "CP437",
      // SQL_Latin1_General_Pref_CP437_CI_AS
      [34]: "CP437",
      // SQL_Latin1_General_CP437_CI_AI
      [40]: "CP850",
      // SQL_Latin1_General_CP850_BIN
      [41]: "CP850",
      // SQL_Latin1_General_CP850_CS_AS
      [42]: "CP850",
      // SQL_Latin1_General_CP850_CI_AS
      [43]: "CP850",
      // SQL_Latin1_General_Pref_CP850_CI_AS
      [44]: "CP850",
      // SQL_Latin1_General_CP850_CI_AI
      [49]: "CP850",
      // SQL_1xCompat_CP850_CI_AS
      [51]: "CP1252",
      // SQL_Latin1_General_Cp1_CS_AS_KI_WI
      [52]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AS_KI_WI
      [53]: "CP1252",
      // SQL_Latin1_General_Pref_Cp1_CI_AS_KI_WI
      [54]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AI_KI_WI
      [55]: "CP850",
      // SQL_AltDiction_CP850_CS_AS
      [56]: "CP850",
      // SQL_AltDiction_Pref_CP850_CI_AS
      [57]: "CP850",
      // SQL_AltDiction_CP850_CI_AI
      [58]: "CP850",
      // SQL_Scandinavian_Pref_CP850_CI_AS
      [59]: "CP850",
      // SQL_Scandinavian_CP850_CS_AS
      [60]: "CP850",
      // SQL_Scandinavian_CP850_CI_AS
      [61]: "CP850",
      // SQL_AltDiction_CP850_CI_AS
      [80]: "CP1250",
      // SQL_Latin1_General_1250_BIN
      [81]: "CP1250",
      // SQL_Latin1_General_CP1250_CS_AS
      [82]: "CP1250",
      // SQL_Latin1_General_Cp1250_CI_AS_KI_WI
      [83]: "CP1250",
      // SQL_Czech_Cp1250_CS_AS_KI_WI
      [84]: "CP1250",
      // SQL_Czech_Cp1250_CI_AS_KI_WI
      [85]: "CP1250",
      // SQL_Hungarian_Cp1250_CS_AS_KI_WI
      [86]: "CP1250",
      // SQL_Hungarian_Cp1250_CI_AS_KI_WI
      [87]: "CP1250",
      // SQL_Polish_Cp1250_CS_AS_KI_WI
      [88]: "CP1250",
      // SQL_Polish_Cp1250_CI_AS_KI_WI
      [89]: "CP1250",
      // SQL_Romanian_Cp1250_CS_AS_KI_WI
      [90]: "CP1250",
      // SQL_Romanian_Cp1250_CI_AS_KI_WI
      [91]: "CP1250",
      // SQL_Croatian_Cp1250_CS_AS_KI_WI
      [92]: "CP1250",
      // SQL_Croatian_Cp1250_CI_AS_KI_WI
      [93]: "CP1250",
      // SQL_Slovak_Cp1250_CS_AS_KI_WI
      [94]: "CP1250",
      // SQL_Slovak_Cp1250_CI_AS_KI_WI
      [95]: "CP1250",
      // SQL_Slovenian_Cp1250_CS_AS_KI_WI
      [96]: "CP1250",
      // SQL_Slovenian_Cp1250_CI_AS_KI_WI
      [104]: "CP1251",
      // SQL_Latin1_General_1251_BIN
      [105]: "CP1251",
      // SQL_Latin1_General_CP1251_CS_AS
      [106]: "CP1251",
      // SQL_Latin1_General_CP1251_CI_AS
      [107]: "CP1251",
      // SQL_Ukrainian_Cp1251_CS_AS_KI_WI
      [108]: "CP1251",
      // SQL_Ukrainian_Cp1251_CI_AS_KI_WI
      [112]: "CP1253",
      // SQL_Latin1_General_1253_BIN
      [113]: "CP1253",
      // SQL_Latin1_General_CP1253_CS_AS
      [114]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AS
      [120]: "CP1253",
      // SQL_MixDiction_CP1253_CS_AS
      [121]: "CP1253",
      // SQL_AltDiction_CP1253_CS_AS
      [122]: "CP1253",
      // SQL_AltDiction2_CP1253_CS_AS
      [124]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AI
      [128]: "CP1254",
      // SQL_Latin1_General_1254_BIN
      [129]: "CP1254",
      // SQL_Latin1_General_Cp1254_CS_AS_KI_WI
      [130]: "CP1254",
      // SQL_Latin1_General_Cp1254_CI_AS_KI_WI
      [136]: "CP1255",
      // SQL_Latin1_General_1255_BIN
      [137]: "CP1255",
      // SQL_Latin1_General_CP1255_CS_AS
      [138]: "CP1255",
      // SQL_Latin1_General_CP1255_CI_AS
      [144]: "CP1256",
      // SQL_Latin1_General_1256_BIN
      [145]: "CP1256",
      // SQL_Latin1_General_CP1256_CS_AS
      [146]: "CP1256",
      // SQL_Latin1_General_CP1256_CI_AS
      [152]: "CP1257",
      // SQL_Latin1_General_1257_BIN
      [153]: "CP1257",
      // SQL_Latin1_General_CP1257_CS_AS
      [154]: "CP1257",
      // SQL_Latin1_General_CP1257_CI_AS
      [155]: "CP1257",
      // SQL_Estonian_Cp1257_CS_AS_KI_WI
      [156]: "CP1257",
      // SQL_Estonian_Cp1257_CI_AS_KI_WI
      [157]: "CP1257",
      // SQL_Latvian_Cp1257_CS_AS_KI_WI
      [158]: "CP1257",
      // SQL_Latvian_Cp1257_CI_AS_KI_WI
      [159]: "CP1257",
      // SQL_Lithuanian_Cp1257_CS_AS_KI_WI
      [160]: "CP1257",
      // SQL_Lithuanian_Cp1257_CI_AS_KI_WI
      [183]: "CP1252",
      // SQL_Danish_Pref_Cp1_CI_AS_KI_WI
      [184]: "CP1252",
      // SQL_SwedishPhone_Pref_Cp1_CI_AS_KI_WI
      [185]: "CP1252",
      // SQL_SwedishStd_Pref_Cp1_CI_AS_KI_WI
      [186]: "CP1252"
      // SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
    };
    var Flags = exports2.Flags = {
      IGNORE_CASE: 1 << 0,
      IGNORE_ACCENT: 1 << 1,
      IGNORE_KANA: 1 << 2,
      IGNORE_WIDTH: 1 << 3,
      BINARY: 1 << 4,
      BINARY2: 1 << 5,
      UTF8: 1 << 6
    };
    var Collation = class {
      static fromBuffer(buffer, offset = 0) {
        let lcid = (buffer[offset + 2] & 15) << 16;
        lcid |= buffer[offset + 1] << 8;
        lcid |= buffer[offset + 0];
        let flags = (buffer[offset + 3] & 15) << 4;
        flags |= (buffer[offset + 2] & 240) >>> 4;
        const version3 = (buffer[offset + 3] & 240) >>> 4;
        const sortId = buffer[offset + 4];
        return new this(lcid, flags, version3, sortId);
      }
      constructor(lcid, flags, version3, sortId) {
        this.buffer = void 0;
        this.lcid = lcid;
        this.flags = flags;
        this.version = version3;
        this.sortId = sortId;
        if (this.flags & Flags.UTF8) {
          this.codepage = "utf-8";
        } else if (this.sortId) {
          this.codepage = codepageBySortId[this.sortId];
        } else {
          const languageId = this.lcid & 65535;
          this.codepage = codepageByLanguageId[languageId];
        }
      }
      toBuffer() {
        if (this.buffer) {
          return this.buffer;
        }
        this.buffer = Buffer.alloc(5);
        this.buffer[0] = this.lcid & 255;
        this.buffer[1] = this.lcid >>> 8 & 255;
        this.buffer[2] = this.lcid >>> 16 & 15 | (this.flags & 15) << 4;
        this.buffer[3] = (this.flags & 240) >>> 4 | (this.version & 15) << 4;
        this.buffer[4] = this.sortId & 255;
        return this.buffer;
      }
    };
    exports2.Collation = Collation;
  }
});

// node_modules/tedious/lib/data-types/null.js
var require_null = __commonJS({
  "node_modules/tedious/lib/data-types/null.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Null = {
      id: 31,
      type: "NULL",
      name: "Null",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = Null;
    module2.exports = Null;
  }
});

// node_modules/tedious/lib/data-types/intn.js
var require_intn = __commonJS({
  "node_modules/tedious/lib/data-types/intn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var IntN = {
      id: 38,
      type: "INTN",
      name: "IntN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = IntN;
    module2.exports = IntN;
  }
});

// node_modules/tedious/lib/data-types/tinyint.js
var require_tinyint = __commonJS({
  "node_modules/tedious/lib/data-types/tinyint.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var TinyInt = {
      id: 48,
      type: "INT1",
      name: "TinyInt",
      declaration: function() {
        return "tinyint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(1);
        buffer.writeUInt8(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < 0 || value > 255) {
          throw new TypeError("Value must be between 0 and 255, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports2.default = TinyInt;
    module2.exports = TinyInt;
  }
});

// node_modules/tedious/lib/data-types/bitn.js
var require_bitn = __commonJS({
  "node_modules/tedious/lib/data-types/bitn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var BitN = {
      id: 104,
      type: "BITN",
      name: "BitN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      *generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = BitN;
    module2.exports = BitN;
  }
});

// node_modules/tedious/lib/data-types/bit.js
var require_bit = __commonJS({
  "node_modules/tedious/lib/data-types/bit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _bitn = _interopRequireDefault(require_bitn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var Bit = {
      id: 50,
      type: "BIT",
      name: "Bit",
      declaration: function() {
        return "bit";
      },
      generateTypeInfo() {
        return Buffer.from([_bitn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value ? Buffer.from([1]) : Buffer.from([0]);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (value) {
          return true;
        } else {
          return false;
        }
      }
    };
    var _default = exports2.default = Bit;
    module2.exports = Bit;
  }
});

// node_modules/tedious/lib/data-types/smallint.js
var require_smallint = __commonJS({
  "node_modules/tedious/lib/data-types/smallint.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([2]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallInt = {
      id: 52,
      type: "INT2",
      name: "SmallInt",
      declaration: function() {
        return "smallint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 2]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeInt16LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -32768 || value > 32767) {
          throw new TypeError("Value must be between -32768 and 32767, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports2.default = SmallInt;
    module2.exports = SmallInt;
  }
});

// node_modules/tedious/lib/data-types/int.js
var require_int = __commonJS({
  "node_modules/tedious/lib/data-types/int.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Int = {
      id: 56,
      type: "INT4",
      name: "Int",
      declaration: function() {
        return "int";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -2147483648 || value > 2147483647) {
          throw new TypeError("Value must be between -2147483648 and 2147483647, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports2.default = Int;
    module2.exports = Int;
  }
});

// node_modules/tedious/lib/data-types/datetimen.js
var require_datetimen = __commonJS({
  "node_modules/tedious/lib/data-types/datetimen.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var DateTimeN = {
      id: 111,
      type: "DATETIMN",
      name: "DateTimeN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = DateTimeN;
    module2.exports = DateTimeN;
  }
});

// node_modules/tedious/lib/data-types/smalldatetime.js
var require_smalldatetime = __commonJS({
  "node_modules/tedious/lib/data-types/smalldatetime.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = new Date(1900, 0, 1);
    var UTC_EPOCH_DATE = new Date(Date.UTC(1900, 0, 1));
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallDateTime = {
      id: 58,
      type: "DATETIM4",
      name: "SmallDateTime",
      declaration: function() {
        return "smalldatetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        let days, dstDiff, minutes;
        if (options.useUTC) {
          days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getUTCHours() * 60 + parameter.value.getUTCMinutes();
        } else {
          dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1e3;
          days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getHours() * 60 + parameter.value.getMinutes();
        }
        buffer.writeUInt16LE(days, 0);
        buffer.writeUInt16LE(minutes, 2);
        yield buffer;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year, month, date;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
          month = value.getUTCMonth();
          date = value.getUTCDate();
        } else {
          year = value.getFullYear();
          month = value.getMonth();
          date = value.getDate();
        }
        if (year < 1900 || year > 2079) {
          throw new TypeError("Out of range.");
        }
        if (year === 2079) {
          if (month > 5 || month === 5 && date > 6) {
            throw new TypeError("Out of range.");
          }
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = SmallDateTime;
    module2.exports = SmallDateTime;
  }
});

// node_modules/tedious/lib/data-types/floatn.js
var require_floatn = __commonJS({
  "node_modules/tedious/lib/data-types/floatn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var FloatN = {
      id: 109,
      type: "FLTN",
      name: "FloatN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = FloatN;
    module2.exports = FloatN;
  }
});

// node_modules/tedious/lib/data-types/real.js
var require_real = __commonJS({
  "node_modules/tedious/lib/data-types/real.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Real = {
      id: 59,
      type: "FLT4",
      name: "Real",
      declaration: function() {
        return "real";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeFloatLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports2.default = Real;
    module2.exports = Real;
  }
});

// node_modules/tedious/lib/data-types/moneyn.js
var require_moneyn = __commonJS({
  "node_modules/tedious/lib/data-types/moneyn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var MoneyN = {
      id: 110,
      type: "MONEYN",
      name: "MoneyN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = MoneyN;
    module2.exports = MoneyN;
  }
});

// node_modules/tedious/lib/data-types/money.js
var require_money = __commonJS({
  "node_modules/tedious/lib/data-types/money.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var Money = {
      id: 60,
      type: "MONEY",
      name: "Money",
      declaration: function() {
        return "money";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value * 1e4;
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32), 0);
        buffer.writeInt32LE(value & -1, 4);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -9223372036854776e-1 || value > 9223372036854776e-1) {
          throw new TypeError("Value must be between -922337203685477.5808 and 922337203685477.5807, inclusive.");
        }
        return value;
      }
    };
    var _default = exports2.default = Money;
    module2.exports = Money;
  }
});

// node_modules/@js-joda/core/dist/js-joda.esm.js
var js_joda_esm_exports = {};
__export(js_joda_esm_exports, {
  ArithmeticException: () => ArithmeticException,
  ChronoField: () => ChronoField,
  ChronoLocalDate: () => ChronoLocalDate,
  ChronoLocalDateTime: () => ChronoLocalDateTime,
  ChronoUnit: () => ChronoUnit,
  ChronoZonedDateTime: () => ChronoZonedDateTime,
  Clock: () => Clock,
  DateTimeException: () => DateTimeException,
  DateTimeFormatter: () => DateTimeFormatter,
  DateTimeFormatterBuilder: () => DateTimeFormatterBuilder,
  DateTimeParseException: () => DateTimeParseException,
  DayOfWeek: () => DayOfWeek,
  DecimalStyle: () => DecimalStyle,
  Duration: () => Duration,
  IllegalArgumentException: () => IllegalArgumentException,
  IllegalStateException: () => IllegalStateException,
  Instant: () => Instant,
  IsoChronology: () => IsoChronology,
  IsoFields: () => IsoFields,
  LocalDate: () => LocalDate,
  LocalDateTime: () => LocalDateTime,
  LocalTime: () => LocalTime,
  Month: () => Month,
  MonthDay: () => MonthDay,
  NullPointerException: () => NullPointerException,
  OffsetDateTime: () => OffsetDateTime,
  OffsetTime: () => OffsetTime,
  ParsePosition: () => ParsePosition,
  Period: () => Period,
  ResolverStyle: () => ResolverStyle,
  SignStyle: () => SignStyle,
  Temporal: () => Temporal,
  TemporalAccessor: () => TemporalAccessor,
  TemporalAdjuster: () => TemporalAdjuster,
  TemporalAdjusters: () => TemporalAdjusters,
  TemporalAmount: () => TemporalAmount,
  TemporalField: () => TemporalField,
  TemporalQueries: () => TemporalQueries,
  TemporalQuery: () => TemporalQuery,
  TemporalUnit: () => TemporalUnit,
  TextStyle: () => TextStyle,
  UnsupportedTemporalTypeException: () => UnsupportedTemporalTypeException,
  ValueRange: () => ValueRange,
  Year: () => Year,
  YearConstants: () => YearConstants,
  YearMonth: () => YearMonth,
  ZoneId: () => ZoneId,
  ZoneOffset: () => ZoneOffset,
  ZoneOffsetTransition: () => ZoneOffsetTransition,
  ZoneRegion: () => ZoneRegion,
  ZoneRules: () => ZoneRules,
  ZoneRulesProvider: () => ZoneRulesProvider,
  ZonedDateTime: () => ZonedDateTime,
  _: () => _,
  convert: () => convert,
  nativeJs: () => nativeJs,
  use: () => use
});
function createErrorType(name3, init2, superErrorClass) {
  if (superErrorClass === void 0) {
    superErrorClass = Error;
  }
  function JsJodaException(message) {
    if (!Error.captureStackTrace) {
      this.stack = new Error().stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
    this.message = message;
    init2 && init2.apply(this, arguments);
    this.toString = function() {
      return this.name + ": " + this.message;
    };
  }
  JsJodaException.prototype = Object.create(superErrorClass.prototype);
  JsJodaException.prototype.name = name3;
  JsJodaException.prototype.constructor = JsJodaException;
  return JsJodaException;
}
function messageWithCause(message, cause) {
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
}
function messageForDateTimeParseException(message, text, index, cause) {
  if (text === void 0) {
    text = "";
  }
  if (index === void 0) {
    index = 0;
  }
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  msg += ": " + text + ", at index: " + index;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
  this.parsedString = function() {
    return text;
  };
  this.errorIndex = function() {
    return index;
  };
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function assert(assertion, msg, error) {
  if (!assertion) {
    if (error) {
      throw new error(msg);
    } else {
      throw new Error(msg);
    }
  }
}
function requireNonNull(value, parameterName) {
  if (value == null) {
    throw new NullPointerException(parameterName + " must not be null");
  }
  return value;
}
function requireInstance(value, _class, parameterName) {
  if (!(value instanceof _class)) {
    throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ""));
  }
  return value;
}
function abstractMethodFail(methodName) {
  throw new TypeError('abstract method "' + methodName + '" is not implemented');
}
function _init$n() {
  Duration.ZERO = new Duration(0, 0);
}
function _init$m() {
  YearConstants.MIN_VALUE = -999999;
  YearConstants.MAX_VALUE = 999999;
}
function _init$l() {
  ChronoUnit.NANOS = new ChronoUnit("Nanos", Duration.ofNanos(1));
  ChronoUnit.MICROS = new ChronoUnit("Micros", Duration.ofNanos(1e3));
  ChronoUnit.MILLIS = new ChronoUnit("Millis", Duration.ofNanos(1e6));
  ChronoUnit.SECONDS = new ChronoUnit("Seconds", Duration.ofSeconds(1));
  ChronoUnit.MINUTES = new ChronoUnit("Minutes", Duration.ofSeconds(60));
  ChronoUnit.HOURS = new ChronoUnit("Hours", Duration.ofSeconds(3600));
  ChronoUnit.HALF_DAYS = new ChronoUnit("HalfDays", Duration.ofSeconds(43200));
  ChronoUnit.DAYS = new ChronoUnit("Days", Duration.ofSeconds(86400));
  ChronoUnit.WEEKS = new ChronoUnit("Weeks", Duration.ofSeconds(7 * 86400));
  ChronoUnit.MONTHS = new ChronoUnit("Months", Duration.ofSeconds(31556952 / 12));
  ChronoUnit.YEARS = new ChronoUnit("Years", Duration.ofSeconds(31556952));
  ChronoUnit.DECADES = new ChronoUnit("Decades", Duration.ofSeconds(31556952 * 10));
  ChronoUnit.CENTURIES = new ChronoUnit("Centuries", Duration.ofSeconds(31556952 * 100));
  ChronoUnit.MILLENNIA = new ChronoUnit("Millennia", Duration.ofSeconds(31556952 * 1e3));
  ChronoUnit.ERAS = new ChronoUnit("Eras", Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
  ChronoUnit.FOREVER = new ChronoUnit("Forever", Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
}
function _init$k() {
  ChronoField.NANO_OF_SECOND = new ChronoField("NanoOfSecond", ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
  ChronoField.NANO_OF_DAY = new ChronoField("NanoOfDay", ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e9 - 1));
  ChronoField.MICRO_OF_SECOND = new ChronoField("MicroOfSecond", ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
  ChronoField.MICRO_OF_DAY = new ChronoField("MicroOfDay", ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e6 - 1));
  ChronoField.MILLI_OF_SECOND = new ChronoField("MilliOfSecond", ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
  ChronoField.MILLI_OF_DAY = new ChronoField("MilliOfDay", ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e3 - 1));
  ChronoField.SECOND_OF_MINUTE = new ChronoField("SecondOfMinute", ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
  ChronoField.SECOND_OF_DAY = new ChronoField("SecondOfDay", ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
  ChronoField.MINUTE_OF_HOUR = new ChronoField("MinuteOfHour", ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
  ChronoField.MINUTE_OF_DAY = new ChronoField("MinuteOfDay", ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
  ChronoField.HOUR_OF_AMPM = new ChronoField("HourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField("ClockHourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
  ChronoField.HOUR_OF_DAY = new ChronoField("HourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField("ClockHourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
  ChronoField.AMPM_OF_DAY = new ChronoField("AmPmOfDay", ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
  ChronoField.DAY_OF_WEEK = new ChronoField("DayOfWeek", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField("AlignedDayOfWeekInMonth", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField("AlignedDayOfWeekInYear", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.DAY_OF_MONTH = new ChronoField("DayOfMonth", ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), "day");
  ChronoField.DAY_OF_YEAR = new ChronoField("DayOfYear", ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
  ChronoField.EPOCH_DAY = new ChronoField("EpochDay", ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));
  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField("AlignedWeekOfMonth", ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField("AlignedWeekOfYear", ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
  ChronoField.MONTH_OF_YEAR = new ChronoField("MonthOfYear", ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), "month");
  ChronoField.PROLEPTIC_MONTH = new ChronoField("ProlepticMonth", ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
  ChronoField.YEAR_OF_ERA = new ChronoField("YearOfEra", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
  ChronoField.YEAR = new ChronoField("Year", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), "year");
  ChronoField.ERA = new ChronoField("Era", ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
  ChronoField.INSTANT_SECONDS = new ChronoField("InstantSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
  ChronoField.OFFSET_SECONDS = new ChronoField("OffsetSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
}
function createTemporalQuery(name3, queryFromFunction) {
  var ExtendedTemporalQuery = function(_TemporalQuery) {
    _inheritsLoose(ExtendedTemporalQuery2, _TemporalQuery);
    function ExtendedTemporalQuery2() {
      return _TemporalQuery.apply(this, arguments) || this;
    }
    return ExtendedTemporalQuery2;
  }(TemporalQuery);
  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
  return new ExtendedTemporalQuery(name3);
}
function _init$j() {
  DayOfWeek.MONDAY = new DayOfWeek(0, "MONDAY");
  DayOfWeek.TUESDAY = new DayOfWeek(1, "TUESDAY");
  DayOfWeek.WEDNESDAY = new DayOfWeek(2, "WEDNESDAY");
  DayOfWeek.THURSDAY = new DayOfWeek(3, "THURSDAY");
  DayOfWeek.FRIDAY = new DayOfWeek(4, "FRIDAY");
  DayOfWeek.SATURDAY = new DayOfWeek(5, "SATURDAY");
  DayOfWeek.SUNDAY = new DayOfWeek(6, "SUNDAY");
  DayOfWeek.FROM = createTemporalQuery("DayOfWeek.FROM", function(temporal) {
    return DayOfWeek.from(temporal);
  });
  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
}
function _init$i() {
  Month.JANUARY = new Month(1, "JANUARY");
  Month.FEBRUARY = new Month(2, "FEBRUARY");
  Month.MARCH = new Month(3, "MARCH");
  Month.APRIL = new Month(4, "APRIL");
  Month.MAY = new Month(5, "MAY");
  Month.JUNE = new Month(6, "JUNE");
  Month.JULY = new Month(7, "JULY");
  Month.AUGUST = new Month(8, "AUGUST");
  Month.SEPTEMBER = new Month(9, "SEPTEMBER");
  Month.OCTOBER = new Month(10, "OCTOBER");
  Month.NOVEMBER = new Month(11, "NOVEMBER");
  Month.DECEMBER = new Month(12, "DECEMBER");
  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
}
function _init$h() {
  Period.ofDays(0);
}
function _init$g() {
  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
}
function _init$f() {
  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEARS = new Unit("WeekBasedYears", Duration.ofSeconds(31556952));
  QUARTER_YEARS = new Unit("QuarterYears", Duration.ofSeconds(31556952 / 4));
  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
  IsoFields.QUARTER_YEARS = QUARTER_YEARS;
  LocalDate.prototype.isoWeekOfWeekyear = function() {
    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
  };
  LocalDate.prototype.isoWeekyear = function() {
    return this.get(IsoFields.WEEK_BASED_YEAR);
  };
}
function _init$e() {
  ReducedPrinterParser.BASE_DATE = LocalDate.of(2e3, 1, 1);
  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
  DateTimeFormatterBuilder.SettingsParser = SettingsParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}
function _init$d() {
  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral("[").parseCaseSensitive().appendZoneId().appendLiteral("]").toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-W").appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral("-").appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery("PARSED_EXCESS_DAYS", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.excessDays;
    } else {
      return Period.ZERO;
    }
  });
  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery("PARSED_LEAP_SECOND", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.leapSecond;
    } else {
      return false;
    }
  });
}
function _init$c() {
  PARSER$2 = new DateTimeFormatterBuilder().appendLiteral("--").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
  MonthDay.FROM = createTemporalQuery("MonthDay.FROM", function(temporal) {
    return MonthDay.from(temporal);
  });
}
function _init$b() {
  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
  YearMonth.FROM = createTemporalQuery("YearMonth.FROM", function(temporal) {
    return YearMonth.from(temporal);
  });
}
function _init$a() {
  Year.MIN_VALUE = YearConstants.MIN_VALUE;
  Year.MAX_VALUE = YearConstants.MAX_VALUE;
  PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
  Year.FROM = createTemporalQuery("Year.FROM", function(temporal) {
    return Year.from(temporal);
  });
}
function _init$9() {
  IsoChronology.INSTANCE = new IsoChronology("IsoChronology");
}
function _init$8() {
  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
  OffsetTime.FROM = createTemporalQuery("OffsetTime.FROM", function(temporal) {
    return OffsetTime.from(temporal);
  });
}
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function _init$7() {
  ZonedDateTime.FROM = createTemporalQuery("ZonedDateTime.FROM", function(temporal) {
    return ZonedDateTime.from(temporal);
  });
}
function _init$6() {
  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
  OffsetDateTime.FROM = createTemporalQuery("OffsetDateTime.FROM", function(temporal) {
    return OffsetDateTime.from(temporal);
  });
}
function _init$5() {
  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
  LocalDate.FROM = createTemporalQuery("LocalDate.FROM", function(temporal) {
    return LocalDate.from(temporal);
  });
}
function _init$4() {
  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
  LocalDateTime.FROM = createTemporalQuery("LocalDateTime.FROM", function(temporal) {
    return LocalDateTime.from(temporal);
  });
}
function _init$3() {
  LocalTime.HOURS = [];
  for (var hour = 0; hour < 24; hour++) {
    LocalTime.of(hour, 0, 0, 0);
  }
  LocalTime.MIN = LocalTime.HOURS[0];
  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
  LocalTime.MIDNIGHT = LocalTime.HOURS[0];
  LocalTime.NOON = LocalTime.HOURS[12];
  LocalTime.FROM = createTemporalQuery("LocalTime.FROM", function(temporal) {
    return LocalTime.from(temporal);
  });
}
function _init$2() {
  Instant.MIN_SECONDS = -31619119219200;
  Instant.MAX_SECONDS = 31494816403199;
  Instant.EPOCH = new Instant(0, 0);
  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
  Instant.FROM = createTemporalQuery("Instant.FROM", function(temporal) {
    return Instant.from(temporal);
  });
}
function _init$1() {
  TemporalQueries.ZONE_ID = createTemporalQuery("ZONE_ID", function(temporal) {
    return temporal.query(TemporalQueries.ZONE_ID);
  });
  TemporalQueries.CHRONO = createTemporalQuery("CHRONO", function(temporal) {
    return temporal.query(TemporalQueries.CHRONO);
  });
  TemporalQueries.PRECISION = createTemporalQuery("PRECISION", function(temporal) {
    return temporal.query(TemporalQueries.PRECISION);
  });
  TemporalQueries.OFFSET = createTemporalQuery("OFFSET", function(temporal) {
    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
    }
    return null;
  });
  TemporalQueries.ZONE = createTemporalQuery("ZONE", function(temporal) {
    var zone = temporal.query(TemporalQueries.ZONE_ID);
    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
  });
  TemporalQueries.LOCAL_DATE = createTemporalQuery("LOCAL_DATE", function(temporal) {
    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
    }
    return null;
  });
  TemporalQueries.LOCAL_TIME = createTemporalQuery("LOCAL_TIME", function(temporal) {
    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
    }
    return null;
  });
}
function _init() {
  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
  ZoneId.systemDefault = ZoneIdFactory.systemDefault;
  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
  ZoneId.of = ZoneIdFactory.of;
  ZoneId.ofOffset = ZoneIdFactory.ofOffset;
  ZoneId.from = ZoneIdFactory.from;
  ZoneOffset.from = ZoneIdFactory.from;
  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
}
function init() {
  if (isInit) {
    return;
  }
  isInit = true;
  _init$m();
  _init$n();
  _init$l();
  _init$k();
  _init$3();
  _init$f();
  _init$1();
  _init$j();
  _init$2();
  _init$5();
  _init$4();
  _init$a();
  _init$i();
  _init$b();
  _init$c();
  _init$h();
  _init$g();
  _init$7();
  _init();
  _init$9();
  _init$d();
  _init$e();
  _init$6();
  _init$8();
}
function convert(temporal, zone) {
  return new ToNativeJsConverter(temporal, zone);
}
function nativeJs(date, zone) {
  if (zone === void 0) {
    zone = ZoneId.systemDefault();
  }
  requireNonNull(date, "date");
  requireNonNull(zone, "zone");
  if (date instanceof Date) {
    return Instant.ofEpochMilli(date.getTime()).atZone(zone);
  } else if (typeof date.toDate === "function" && date.toDate() instanceof Date) {
    return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);
  }
  throw new IllegalArgumentException("date must be a javascript Date or a moment instance");
}
function bindUse(jsJoda) {
  var used = [];
  return function use2(fn) {
    if (!~used.indexOf(fn)) {
      fn(jsJoda);
      used.push(fn);
    }
    return jsJoda;
  };
}
var DateTimeException, DateTimeParseException, UnsupportedTemporalTypeException, ArithmeticException, IllegalArgumentException, IllegalStateException, NullPointerException, assert$1, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER, MathUtil, Enum, TemporalAmount, TemporalUnit, Duration, YearConstants, ChronoUnit, TemporalField, ValueRange, ChronoField, TemporalQueries, TemporalAccessor, TemporalQuery, DayOfWeek, ENUMS, Month, MONTHS, PATTERN, Period, ParsePosition, EnumMap, ResolverStyle, Temporal, ChronoLocalDate, StringUtil, ZoneId, ZoneRules, Fixed, SECONDS_CACHE, ID_CACHE, ZoneOffset, DateTimeBuilder, DateTimeParseContext, Parsed, DateTimePrintContext, IsoFields, QUARTER_DAYS, Field, DAY_OF_QUARTER_FIELD, QUARTER_OF_YEAR_FIELD, WEEK_OF_WEEK_BASED_YEAR_FIELD, WEEK_BASED_YEAR_FIELD, Unit, DAY_OF_QUARTER, QUARTER_OF_YEAR, WEEK_OF_WEEK_BASED_YEAR, WEEK_BASED_YEAR, WEEK_BASED_YEARS, QUARTER_YEARS, DecimalStyle, SignStyle, TextStyle, CharLiteralPrinterParser, CompositePrinterParser, FractionPrinterParser, MAX_WIDTH$1, EXCEED_POINTS, NumberPrinterParser, ReducedPrinterParser, PATTERNS, OffsetIdPrinterParser, PadPrinterParserDecorator, SettingsParser, StringLiteralPrinterParser, ZoneRulesProvider, ZoneRegion, ZoneIdPrinterParser, ZoneIdTree, ZoneIdTreeMap, zoneIdTree, MAX_WIDTH, DateTimeFormatterBuilder, SECONDS_PER_10000_YEARS, SECONDS_0000_TO_1970, InstantPrinterParser, DefaultingParser, StringBuilder, DateTimeFormatter, MonthDay, PARSER$2, YearMonth, PARSER$1, Year, PARSER, TemporalAdjuster, TemporalAdjusters, Impl, DayOfWeekInMonth, RelativeDayOfWeek, IsoChronology, OffsetTime, ChronoZonedDateTime, ZonedDateTime, OffsetDateTime, DAYS_PER_CYCLE, DAYS_0000_TO_1970, LocalDate, ChronoLocalDateTime, LocalDateTime, LocalTime, NANOS_PER_MILLI, Instant, Clock, SystemClock, FixedClock, OffsetClock, ZoneOffsetTransition, SystemDefaultZoneRules, SystemDefaultZoneId, ZoneIdFactory, SYSTEM_DEFAULT_ZONE_ID_INSTANCE, isInit, ToNativeJsConverter, _, jsJodaExports, use;
var init_js_joda_esm = __esm({
  "node_modules/@js-joda/core/dist/js-joda.esm.js"() {
    "use strict";
    DateTimeException = createErrorType("DateTimeException", messageWithCause);
    DateTimeParseException = createErrorType("DateTimeParseException", messageForDateTimeParseException);
    UnsupportedTemporalTypeException = createErrorType("UnsupportedTemporalTypeException", null, DateTimeException);
    ArithmeticException = createErrorType("ArithmeticException");
    IllegalArgumentException = createErrorType("IllegalArgumentException");
    IllegalStateException = createErrorType("IllegalStateException");
    NullPointerException = createErrorType("NullPointerException");
    assert$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      assert,
      requireNonNull,
      requireInstance,
      abstractMethodFail
    });
    MAX_SAFE_INTEGER = 9007199254740991;
    MIN_SAFE_INTEGER = -9007199254740991;
    MathUtil = function() {
      function MathUtil2() {
      }
      MathUtil2.intDiv = function intDiv(x, y) {
        var r = x / y;
        r = MathUtil2.roundDown(r);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.intMod = function intMod(x, y) {
        var r = x - MathUtil2.intDiv(x, y) * y;
        r = MathUtil2.roundDown(r);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.roundDown = function roundDown(r) {
        if (r < 0) {
          return Math.ceil(r);
        } else {
          return Math.floor(r);
        }
      };
      MathUtil2.floorDiv = function floorDiv(x, y) {
        var r = Math.floor(x / y);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.floorMod = function floorMod(x, y) {
        var r = x - MathUtil2.floorDiv(x, y) * y;
        return MathUtil2.safeZero(r);
      };
      MathUtil2.safeAdd = function safeAdd(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 0) {
          return MathUtil2.safeZero(y);
        }
        if (y === 0) {
          return MathUtil2.safeZero(x);
        }
        var r = MathUtil2.safeToInt(x + y);
        if (r === x || r === y) {
          throw new ArithmeticException("Invalid addition beyond MAX_SAFE_INTEGER!");
        }
        return r;
      };
      MathUtil2.safeSubtract = function safeSubtract(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 0 && y === 0) {
          return 0;
        } else if (x === 0) {
          return MathUtil2.safeZero(-1 * y);
        } else if (y === 0) {
          return MathUtil2.safeZero(x);
        }
        return MathUtil2.safeToInt(x - y);
      };
      MathUtil2.safeMultiply = function safeMultiply(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 1) {
          return MathUtil2.safeZero(y);
        }
        if (y === 1) {
          return MathUtil2.safeZero(x);
        }
        if (x === 0 || y === 0) {
          return 0;
        }
        var r = MathUtil2.safeToInt(x * y);
        if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
          throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
        }
        return r;
      };
      MathUtil2.parseInt = function(_parseInt) {
        function parseInt2(_x) {
          return _parseInt.apply(this, arguments);
        }
        parseInt2.toString = function() {
          return _parseInt.toString();
        };
        return parseInt2;
      }(function(value) {
        var r = parseInt(value);
        return MathUtil2.safeToInt(r);
      });
      MathUtil2.safeToInt = function safeToInt(value) {
        MathUtil2.verifyInt(value);
        return MathUtil2.safeZero(value);
      };
      MathUtil2.verifyInt = function verifyInt(value) {
        if (value == null) {
          throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
        }
        if (isNaN(value)) {
          throw new ArithmeticException("Invalid int value, using NaN as argument");
        }
        if (value % 1 !== 0) {
          throw new ArithmeticException("Invalid value: '" + value + "' is a float");
        }
        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
          throw new ArithmeticException("Calculation overflows an int: " + value);
        }
      };
      MathUtil2.safeZero = function safeZero(value) {
        return value === 0 ? 0 : +value;
      };
      MathUtil2.compareNumbers = function compareNumbers(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      };
      MathUtil2.smi = function smi(int) {
        return int >>> 1 & 1073741824 | int & 3221225471;
      };
      MathUtil2.hash = function hash(number) {
        if (number !== number || number === Infinity) {
          return 0;
        }
        var result = number;
        while (number > 4294967295) {
          number /= 4294967295;
          result ^= number;
        }
        return MathUtil2.smi(result);
      };
      MathUtil2.hashCode = function hashCode() {
        var result = 17;
        for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
          numbers[_key] = arguments[_key];
        }
        for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
          var n = _numbers[_i];
          result = (result << 5) - result + MathUtil2.hash(n);
        }
        return MathUtil2.hash(result);
      };
      return MathUtil2;
    }();
    MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;
    Enum = function() {
      function Enum2(name3) {
        this._name = name3;
      }
      var _proto = Enum2.prototype;
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Enum2;
    }();
    TemporalAmount = function() {
      function TemporalAmount2() {
      }
      var _proto = TemporalAmount2.prototype;
      _proto.get = function get(unit) {
        abstractMethodFail("get");
      };
      _proto.units = function units() {
        abstractMethodFail("units");
      };
      _proto.addTo = function addTo(temporal) {
        abstractMethodFail("addTo");
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        abstractMethodFail("subtractFrom");
      };
      return TemporalAmount2;
    }();
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
      TemporalAmount.prototype[Symbol.toPrimitive] = function(hint) {
        if (hint !== "number") {
          return this.toString();
        }
        throw new TypeError("A conversion from TemporalAmount to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
      };
    }
    TemporalUnit = function() {
      function TemporalUnit2() {
      }
      var _proto = TemporalUnit2.prototype;
      _proto.duration = function duration() {
        abstractMethodFail("duration");
      };
      _proto.isDurationEstimated = function isDurationEstimated() {
        abstractMethodFail("isDurationEstimated");
      };
      _proto.isDateBased = function isDateBased() {
        abstractMethodFail("isDateBased");
      };
      _proto.isTimeBased = function isTimeBased() {
        abstractMethodFail("isTimeBased");
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail("isSupportedBy");
      };
      _proto.addTo = function addTo(dateTime, periodToAdd) {
        abstractMethodFail("addTo");
      };
      _proto.between = function between(temporal1, temporal2) {
        abstractMethodFail("between");
      };
      return TemporalUnit2;
    }();
    Duration = function(_TemporalAmount) {
      _inheritsLoose(Duration2, _TemporalAmount);
      function Duration2(seconds, nanos) {
        var _this;
        _this = _TemporalAmount.call(this) || this;
        _this._seconds = MathUtil.safeToInt(seconds);
        _this._nanos = MathUtil.safeToInt(nanos);
        return _this;
      }
      Duration2.ofDays = function ofDays(days) {
        return Duration2._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
      };
      Duration2.ofHours = function ofHours(hours) {
        return Duration2._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
      };
      Duration2.ofMinutes = function ofMinutes(minutes) {
        return Duration2._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
      };
      Duration2.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        return Duration2._create(secs, nos);
      };
      Duration2.ofMillis = function ofMillis(millis) {
        var secs = MathUtil.intDiv(millis, 1e3);
        var mos = MathUtil.intMod(millis, 1e3);
        if (mos < 0) {
          mos += 1e3;
          secs--;
        }
        return Duration2._create(secs, mos * 1e6);
      };
      Duration2.ofNanos = function ofNanos(nanos) {
        var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
        if (nos < 0) {
          nos += LocalTime.NANOS_PER_SECOND;
          secs--;
        }
        return this._create(secs, nos);
      };
      Duration2.of = function of(amount, unit) {
        return Duration2.ZERO.plus(amount, unit);
      };
      Duration2.from = function from(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount);
        var duration = Duration2.ZERO;
        amount.units().forEach(function(unit) {
          duration = duration.plus(amount.get(unit), unit);
        });
        return duration;
      };
      Duration2.between = function between(startInclusive, endExclusive) {
        requireNonNull(startInclusive, "startInclusive");
        requireNonNull(endExclusive, "endExclusive");
        var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
        var nanos = 0;
        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
          try {
            var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
            nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
            if (secs > 0 && nanos < 0) {
              nanos += LocalTime.NANOS_PER_SECOND;
            } else if (secs < 0 && nanos > 0) {
              nanos -= LocalTime.NANOS_PER_SECOND;
            } else if (secs === 0 && nanos !== 0) {
              var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
              secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
            }
          } catch (e) {
          }
        }
        return this.ofSeconds(secs, nanos);
      };
      Duration2.parse = function parse2(text) {
        requireNonNull(text, "text");
        var PATTERN2 = new RegExp("([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?", "i");
        var matches = PATTERN2.exec(text);
        if (matches !== null) {
          if ("T" === matches[3] === false) {
            var negate = "-" === matches[1];
            var dayMatch = matches[2];
            var hourMatch = matches[4];
            var minuteMatch = matches[5];
            var secondMatch = matches[6];
            var fractionMatch = matches[7];
            if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
              var daysAsSecs = Duration2._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, "days");
              var hoursAsSecs = Duration2._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, "hours");
              var minsAsSecs = Duration2._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, "minutes");
              var seconds = Duration2._parseNumber(text, secondMatch, 1, "seconds");
              var negativeSecs = secondMatch != null && secondMatch.charAt(0) === "-";
              var nanos = Duration2._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);
              try {
                return Duration2._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
              } catch (ex) {
                throw new DateTimeParseException("Text cannot be parsed to a Duration: overflow", text, 0, ex);
              }
            }
          }
        }
        throw new DateTimeParseException("Text cannot be parsed to a Duration", text, 0);
      };
      Duration2._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
        if (parsed == null) {
          return 0;
        }
        try {
          if (parsed[0] === "+") {
            parsed = parsed.substring(1);
          }
          return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
        } catch (ex) {
          throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text, 0, ex);
        }
      };
      Duration2._parseFraction = function _parseFraction(text, parsed, negate) {
        if (parsed == null || parsed.length === 0) {
          return 0;
        }
        parsed = (parsed + "000000000").substring(0, 9);
        return parseFloat(parsed) * negate;
      };
      Duration2._create = function _create() {
        if (arguments.length <= 2) {
          return Duration2._createSecondsNanos(arguments[0], arguments[1]);
        } else {
          return Duration2._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
      };
      Duration2._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
        var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
        if (negate) {
          return Duration2.ofSeconds(seconds, nanos).negated();
        }
        return Duration2.ofSeconds(seconds, nanos);
      };
      Duration2._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
        if (seconds === void 0) {
          seconds = 0;
        }
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        if (seconds === 0 && nanoAdjustment === 0) {
          return Duration2.ZERO;
        }
        return new Duration2(seconds, nanoAdjustment);
      };
      var _proto = Duration2.prototype;
      _proto.get = function get(unit) {
        if (unit === ChronoUnit.SECONDS) {
          return this._seconds;
        } else if (unit === ChronoUnit.NANOS) {
          return this._nanos;
        } else {
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
      };
      _proto.units = function units() {
        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
      };
      _proto.isZero = function isZero() {
        return this._seconds === 0 && this._nanos === 0;
      };
      _proto.isNegative = function isNegative() {
        return this._seconds < 0;
      };
      _proto.seconds = function seconds() {
        return this._seconds;
      };
      _proto.nano = function nano() {
        return this._nanos;
      };
      _proto.withSeconds = function withSeconds(seconds) {
        return Duration2._create(seconds, this._nanos);
      };
      _proto.withNanos = function withNanos(nanoOfSecond) {
        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
        return Duration2._create(this._seconds, nanoOfSecond);
      };
      _proto.plusDuration = function plusDuration(duration) {
        requireNonNull(duration, "duration");
        return this.plus(duration.seconds(), duration.nano());
      };
      _proto.plus = function plus(durationOrNumber, unitOrNumber) {
        if (arguments.length === 1) {
          return this.plusDuration(durationOrNumber);
        } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
          return this.plusAmountUnit(durationOrNumber, unitOrNumber);
        } else {
          return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
        }
      };
      _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.DAYS) {
          return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
        }
        if (unit.isDurationEstimated()) {
          throw new UnsupportedTemporalTypeException("Unit must not have an estimated duration");
        }
        if (amountToAdd === 0) {
          return this;
        }
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1e6 * 1e3) * 1e3, MathUtil.intMod(amountToAdd, 1e6 * 1e3) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusMillis(amountToAdd);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
          }
          return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
        }
        var duration = unit.duration().multipliedBy(amountToAdd);
        return this.plusSecondsNanos(duration.seconds(), duration.nano());
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
      };
      _proto.plusHours = function plusHours(hoursToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
      };
      _proto.plusMinutes = function plusMinutes(minutesToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        return this.plusSecondsNanos(secondsToAdd, 0);
      };
      _proto.plusMillis = function plusMillis(millisToAdd) {
        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * 1e6);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        return this.plusSecondsNanos(0, nanosToAdd);
      };
      _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
        requireNonNull(secondsToAdd, "secondsToAdd");
        requireNonNull(nanosToAdd, "nanosToAdd");
        if (secondsToAdd === 0 && nanosToAdd === 0) {
          return this;
        }
        var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
        var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
        return Duration2.ofSeconds(epochSec, nanoAdjustment);
      };
      _proto.minus = function minus(durationOrNumber, unit) {
        if (arguments.length === 1) {
          return this.minusDuration(durationOrNumber);
        } else {
          return this.minusAmountUnit(durationOrNumber, unit);
        }
      };
      _proto.minusDuration = function minusDuration(duration) {
        requireNonNull(duration, "duration");
        var secsToSubtract = duration.seconds();
        var nanosToSubtract = duration.nano();
        if (secsToSubtract === MIN_SAFE_INTEGER) {
          return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
        }
        return this.plus(-secsToSubtract, -nanosToSubtract);
      };
      _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
      };
      _proto.minusHours = function minusHours(hoursToSubtract) {
        return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
      };
      _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
        return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
      };
      _proto.minusMillis = function minusMillis(millisToSubtract) {
        return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
      };
      _proto.multipliedBy = function multipliedBy(multiplicand) {
        if (multiplicand === 0) {
          return Duration2.ZERO;
        }
        if (multiplicand === 1) {
          return this;
        }
        var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
        var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
        return Duration2.ofSeconds(secs, nos);
      };
      _proto.dividedBy = function dividedBy(divisor) {
        if (divisor === 0) {
          throw new ArithmeticException("Cannot divide by zero");
        }
        if (divisor === 1) {
          return this;
        }
        var secs = MathUtil.intDiv(this._seconds, divisor);
        var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.intDiv(this._nanos, divisor);
        nos = secsMod + nos;
        return Duration2.ofSeconds(secs, nos);
      };
      _proto.negated = function negated() {
        return this.multipliedBy(-1);
      };
      _proto.abs = function abs() {
        return this.isNegative() ? this.negated() : this;
      };
      _proto.addTo = function addTo(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._seconds !== 0) {
          temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
        }
        if (this._nanos !== 0) {
          temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
        }
        return temporal;
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._seconds !== 0) {
          temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
        }
        if (this._nanos !== 0) {
          temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
        }
        return temporal;
      };
      _proto.toDays = function toDays() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
      };
      _proto.toHours = function toHours() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
      };
      _proto.toMinutes = function toMinutes() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
      };
      _proto.toMillis = function toMillis() {
        var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1e3));
        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1e6));
        return millis;
      };
      _proto.toNanos = function toNanos() {
        var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
        return totalNanos;
      };
      _proto.compareTo = function compareTo(otherDuration) {
        requireNonNull(otherDuration, "otherDuration");
        requireInstance(otherDuration, Duration2, "otherDuration");
        var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
        if (cmp !== 0) {
          return cmp;
        }
        return this._nanos - otherDuration.nano();
      };
      _proto.equals = function equals(otherDuration) {
        if (this === otherDuration) {
          return true;
        }
        if (otherDuration instanceof Duration2) {
          return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
        }
        return false;
      };
      _proto.toString = function toString() {
        if (this === Duration2.ZERO) {
          return "PT0S";
        }
        var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
        var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
        var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
        var rval = "PT";
        if (hours !== 0) {
          rval += hours + "H";
        }
        if (minutes !== 0) {
          rval += minutes + "M";
        }
        if (secs === 0 && this._nanos === 0 && rval.length > 2) {
          return rval;
        }
        if (secs < 0 && this._nanos > 0) {
          if (secs === -1) {
            rval += "-0";
          } else {
            rval += secs + 1;
          }
        } else {
          rval += secs;
        }
        if (this._nanos > 0) {
          rval += ".";
          var nanoString;
          if (secs < 0) {
            nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
          } else {
            nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
          }
          nanoString = nanoString.slice(1, nanoString.length);
          rval += nanoString;
          while (rval.charAt(rval.length - 1) === "0") {
            rval = rval.slice(0, rval.length - 1);
          }
        }
        rval += "S";
        return rval;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Duration2;
    }(TemporalAmount);
    YearConstants = function YearConstants2() {
    };
    ChronoUnit = function(_TemporalUnit) {
      _inheritsLoose(ChronoUnit2, _TemporalUnit);
      function ChronoUnit2(name3, estimatedDuration) {
        var _this;
        _this = _TemporalUnit.call(this) || this;
        _this._name = name3;
        _this._duration = estimatedDuration;
        return _this;
      }
      var _proto = ChronoUnit2.prototype;
      _proto.duration = function duration() {
        return this._duration;
      };
      _proto.isDurationEstimated = function isDurationEstimated() {
        return this.isDateBased() || this === ChronoUnit2.FOREVER;
      };
      _proto.isDateBased = function isDateBased() {
        return this.compareTo(ChronoUnit2.DAYS) >= 0 && this !== ChronoUnit2.FOREVER;
      };
      _proto.isTimeBased = function isTimeBased() {
        return this.compareTo(ChronoUnit2.DAYS) < 0;
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        if (this === ChronoUnit2.FOREVER) {
          return false;
        }
        try {
          temporal.plus(1, this);
          return true;
        } catch (e) {
          try {
            temporal.plus(-1, this);
            return true;
          } catch (e2) {
            return false;
          }
        }
      };
      _proto.addTo = function addTo(temporal, amount) {
        return temporal.plus(amount, this);
      };
      _proto.between = function between(temporal1, temporal2) {
        return temporal1.until(temporal2, this);
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.compareTo = function compareTo(other) {
        return this.duration().compareTo(other.duration());
      };
      return ChronoUnit2;
    }(TemporalUnit);
    TemporalField = function() {
      function TemporalField2() {
      }
      var _proto = TemporalField2.prototype;
      _proto.isDateBased = function isDateBased() {
        abstractMethodFail("isDateBased");
      };
      _proto.isTimeBased = function isTimeBased() {
        abstractMethodFail("isTimeBased");
      };
      _proto.baseUnit = function baseUnit() {
        abstractMethodFail("baseUnit");
      };
      _proto.rangeUnit = function rangeUnit() {
        abstractMethodFail("rangeUnit");
      };
      _proto.range = function range() {
        abstractMethodFail("range");
      };
      _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
        abstractMethodFail("rangeRefinedBy");
      };
      _proto.getFrom = function getFrom(temporal) {
        abstractMethodFail("getFrom");
      };
      _proto.adjustInto = function adjustInto(temporal, newValue) {
        abstractMethodFail("adjustInto");
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail("isSupportedBy");
      };
      _proto.displayName = function displayName() {
        abstractMethodFail("displayName");
      };
      _proto.equals = function equals(other) {
        abstractMethodFail("equals");
      };
      _proto.name = function name3() {
        abstractMethodFail("name");
      };
      return TemporalField2;
    }();
    ValueRange = function() {
      function ValueRange2(minSmallest, minLargest, maxSmallest, maxLargest) {
        assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
        assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
        assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
        this._minSmallest = minSmallest;
        this._minLargest = minLargest;
        this._maxLargest = maxLargest;
        this._maxSmallest = maxSmallest;
      }
      var _proto = ValueRange2.prototype;
      _proto.isFixed = function isFixed() {
        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
      };
      _proto.minimum = function minimum() {
        return this._minSmallest;
      };
      _proto.largestMinimum = function largestMinimum() {
        return this._minLargest;
      };
      _proto.maximum = function maximum() {
        return this._maxLargest;
      };
      _proto.smallestMaximum = function smallestMaximum() {
        return this._maxSmallest;
      };
      _proto.isValidValue = function isValidValue(value) {
        return this.minimum() <= value && value <= this.maximum();
      };
      _proto.checkValidValue = function checkValidValue(value, field) {
        var msg;
        if (!this.isValidValue(value)) {
          if (field != null) {
            msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
          } else {
            msg = "Invalid value (valid values " + this.toString() + "): " + value;
          }
          return assert(false, msg, DateTimeException);
        }
        return value;
      };
      _proto.checkValidIntValue = function checkValidIntValue(value, field) {
        if (this.isValidIntValue(value) === false) {
          throw new DateTimeException("Invalid int value for " + field + ": " + value);
        }
        return value;
      };
      _proto.isValidIntValue = function isValidIntValue(value) {
        return this.isIntValue() && this.isValidValue(value);
      };
      _proto.isIntValue = function isIntValue() {
        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
      };
      _proto.equals = function equals(other) {
        if (other === this) {
          return true;
        }
        if (other instanceof ValueRange2) {
          return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
      };
      _proto.toString = function toString() {
        var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : "");
        str += " - ";
        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : "");
        return str;
      };
      ValueRange2.of = function of() {
        if (arguments.length === 2) {
          return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[1]);
        } else if (arguments.length === 3) {
          return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[2]);
        } else if (arguments.length === 4) {
          return new ValueRange2(arguments[0], arguments[1], arguments[2], arguments[3]);
        } else {
          return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
        }
      };
      return ValueRange2;
    }();
    ChronoField = function(_TemporalField) {
      _inheritsLoose(ChronoField2, _TemporalField);
      ChronoField2.byName = function byName(fieldName) {
        for (var prop in ChronoField2) {
          if (ChronoField2[prop]) {
            if (ChronoField2[prop] instanceof ChronoField2 && ChronoField2[prop].name() === fieldName) {
              return ChronoField2[prop];
            }
          }
        }
      };
      function ChronoField2(name3, baseUnit, rangeUnit, range) {
        var _this;
        _this = _TemporalField.call(this) || this;
        _this._name = name3;
        _this._baseUnit = baseUnit;
        _this._rangeUnit = rangeUnit;
        _this._range = range;
        return _this;
      }
      var _proto = ChronoField2.prototype;
      _proto.name = function name3() {
        return this._name;
      };
      _proto.baseUnit = function baseUnit() {
        return this._baseUnit;
      };
      _proto.rangeUnit = function rangeUnit() {
        return this._rangeUnit;
      };
      _proto.range = function range() {
        return this._range;
      };
      _proto.displayName = function displayName() {
        return this.toString();
      };
      _proto.checkValidValue = function checkValidValue(value) {
        return this.range().checkValidValue(value, this);
      };
      _proto.checkValidIntValue = function checkValidIntValue(value) {
        return this.range().checkValidIntValue(value, this);
      };
      _proto.isDateBased = function isDateBased() {
        var dateBased = this === ChronoField2.DAY_OF_WEEK || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField2.DAY_OF_MONTH || this === ChronoField2.DAY_OF_YEAR || this === ChronoField2.EPOCH_DAY || this === ChronoField2.ALIGNED_WEEK_OF_MONTH || this === ChronoField2.ALIGNED_WEEK_OF_YEAR || this === ChronoField2.MONTH_OF_YEAR || this === ChronoField2.PROLEPTIC_MONTH || this === ChronoField2.YEAR_OF_ERA || this === ChronoField2.YEAR || this === ChronoField2.ERA;
        return dateBased;
      };
      _proto.isTimeBased = function isTimeBased() {
        var timeBased = this === ChronoField2.NANO_OF_SECOND || this === ChronoField2.NANO_OF_DAY || this === ChronoField2.MICRO_OF_SECOND || this === ChronoField2.MICRO_OF_DAY || this === ChronoField2.MILLI_OF_SECOND || this === ChronoField2.MILLI_OF_DAY || this === ChronoField2.SECOND_OF_MINUTE || this === ChronoField2.SECOND_OF_DAY || this === ChronoField2.MINUTE_OF_HOUR || this === ChronoField2.MINUTE_OF_DAY || this === ChronoField2.HOUR_OF_AMPM || this === ChronoField2.CLOCK_HOUR_OF_AMPM || this === ChronoField2.HOUR_OF_DAY || this === ChronoField2.CLOCK_HOUR_OF_DAY || this === ChronoField2.AMPM_OF_DAY;
        return timeBased;
      };
      _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return temporal.range(this);
      };
      _proto.getFrom = function getFrom(temporal) {
        return temporal.getLong(this);
      };
      _proto.toString = function toString() {
        return this.name();
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.adjustInto = function adjustInto(temporal, newValue) {
        return temporal.with(this, newValue);
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(this);
      };
      return ChronoField2;
    }(TemporalField);
    TemporalQueries = function() {
      function TemporalQueries2() {
      }
      TemporalQueries2.zoneId = function zoneId() {
        return TemporalQueries2.ZONE_ID;
      };
      TemporalQueries2.chronology = function chronology() {
        return TemporalQueries2.CHRONO;
      };
      TemporalQueries2.precision = function precision() {
        return TemporalQueries2.PRECISION;
      };
      TemporalQueries2.zone = function zone() {
        return TemporalQueries2.ZONE;
      };
      TemporalQueries2.offset = function offset() {
        return TemporalQueries2.OFFSET;
      };
      TemporalQueries2.localDate = function localDate() {
        return TemporalQueries2.LOCAL_DATE;
      };
      TemporalQueries2.localTime = function localTime() {
        return TemporalQueries2.LOCAL_TIME;
      };
      return TemporalQueries2;
    }();
    TemporalAccessor = function() {
      function TemporalAccessor2() {
      }
      var _proto = TemporalAccessor2.prototype;
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        abstractMethodFail("getLong");
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (this.isSupported(field)) {
            return field.range();
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.isSupported = function isSupported(field) {
        abstractMethodFail("isSupported");
      };
      return TemporalAccessor2;
    }();
    TemporalQuery = function(_Enum) {
      _inheritsLoose(TemporalQuery2, _Enum);
      function TemporalQuery2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = TemporalQuery2.prototype;
      _proto.queryFrom = function queryFrom(temporal) {
        abstractMethodFail("queryFrom");
      };
      return TemporalQuery2;
    }(Enum);
    DayOfWeek = function(_TemporalAccessor) {
      _inheritsLoose(DayOfWeek2, _TemporalAccessor);
      function DayOfWeek2(ordinal, name3) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._ordinal = ordinal;
        _this._name = name3;
        return _this;
      }
      var _proto = DayOfWeek2.prototype;
      _proto.ordinal = function ordinal() {
        return this._ordinal;
      };
      _proto.name = function name3() {
        return this._name;
      };
      DayOfWeek2.values = function values() {
        return ENUMS.slice();
      };
      DayOfWeek2.valueOf = function valueOf(name3) {
        var ordinal = 0;
        for (ordinal; ordinal < ENUMS.length; ordinal++) {
          if (ENUMS[ordinal].name() === name3) {
            break;
          }
        }
        return DayOfWeek2.of(ordinal + 1);
      };
      DayOfWeek2.of = function of(dayOfWeek) {
        if (dayOfWeek < 1 || dayOfWeek > 7) {
          throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
        }
        return ENUMS[dayOfWeek - 1];
      };
      DayOfWeek2.from = function from(temporal) {
        assert(temporal != null, "temporal", NullPointerException);
        if (temporal instanceof DayOfWeek2) {
          return temporal;
        }
        try {
          return DayOfWeek2.of(temporal.get(ChronoField.DAY_OF_WEEK));
        } catch (ex) {
          if (ex instanceof DateTimeException) {
            throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""), ex);
          } else {
            throw ex;
          }
        }
      };
      _proto.value = function value() {
        return this._ordinal + 1;
      };
      _proto.displayName = function displayName(style, locale) {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
      };
      _proto.isSupported = function isSupported(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.DAY_OF_WEEK;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return field.range();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return this.value();
        }
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return this.value();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.plus = function plus(days) {
        var amount = MathUtil.floorMod(days, 7);
        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
      };
      _proto.minus = function minus(days) {
        return this.plus(-1 * MathUtil.floorMod(days, 7));
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.DAYS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        assert(_query != null, "query", NullPointerException);
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, DayOfWeek2, "other");
        return this._ordinal - other._ordinal;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return DayOfWeek2;
    }(TemporalAccessor);
    Month = function(_TemporalAccessor) {
      _inheritsLoose(Month2, _TemporalAccessor);
      function Month2(value, name3) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._value = MathUtil.safeToInt(value);
        _this._name = name3;
        return _this;
      }
      var _proto = Month2.prototype;
      _proto.value = function value() {
        return this._value;
      };
      _proto.ordinal = function ordinal() {
        return this._value - 1;
      };
      _proto.name = function name3() {
        return this._name;
      };
      _proto.displayName = function displayName(style, locale) {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
      };
      _proto.isSupported = function isSupported(field) {
        if (null === field) {
          return false;
        }
        if (field instanceof ChronoField) {
          return field === ChronoField.MONTH_OF_YEAR;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.get = function get(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return this.value();
        }
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return this.value();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.plus = function plus(months) {
        var amount = MathUtil.intMod(months, 12) + 12;
        var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
        return Month2.of(newMonthVal);
      };
      _proto.minus = function minus(months) {
        return this.plus(-1 * MathUtil.intMod(months, 12));
      };
      _proto.length = function length(leapYear) {
        switch (this) {
          case Month2.FEBRUARY:
            return leapYear ? 29 : 28;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.minLength = function minLength() {
        switch (this) {
          case Month2.FEBRUARY:
            return 28;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.maxLength = function maxLength() {
        switch (this) {
          case Month2.FEBRUARY:
            return 29;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
        var leap = leapYear ? 1 : 0;
        switch (this) {
          case Month2.JANUARY:
            return 1;
          case Month2.FEBRUARY:
            return 32;
          case Month2.MARCH:
            return 60 + leap;
          case Month2.APRIL:
            return 91 + leap;
          case Month2.MAY:
            return 121 + leap;
          case Month2.JUNE:
            return 152 + leap;
          case Month2.JULY:
            return 182 + leap;
          case Month2.AUGUST:
            return 213 + leap;
          case Month2.SEPTEMBER:
            return 244 + leap;
          case Month2.OCTOBER:
            return 274 + leap;
          case Month2.NOVEMBER:
            return 305 + leap;
          case Month2.DECEMBER:
          default:
            return 335 + leap;
        }
      };
      _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
        switch (this) {
          case Month2.JANUARY:
          case Month2.FEBRUARY:
          case Month2.MARCH:
            return Month2.JANUARY;
          case Month2.APRIL:
          case Month2.MAY:
          case Month2.JUNE:
            return Month2.APRIL;
          case Month2.JULY:
          case Month2.AUGUST:
          case Month2.SEPTEMBER:
            return Month2.JULY;
          case Month2.OCTOBER:
          case Month2.NOVEMBER:
          case Month2.DECEMBER:
          default:
            return Month2.OCTOBER;
        }
      };
      _proto.query = function query(_query) {
        assert(_query != null, "query() parameter must not be null", DateTimeException);
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.MONTHS;
        }
        return _TemporalAccessor.prototype.query.call(this, _query);
      };
      _proto.toString = function toString() {
        switch (this) {
          case Month2.JANUARY:
            return "JANUARY";
          case Month2.FEBRUARY:
            return "FEBRUARY";
          case Month2.MARCH:
            return "MARCH";
          case Month2.APRIL:
            return "APRIL";
          case Month2.MAY:
            return "MAY";
          case Month2.JUNE:
            return "JUNE";
          case Month2.JULY:
            return "JULY";
          case Month2.AUGUST:
            return "AUGUST";
          case Month2.SEPTEMBER:
            return "SEPTEMBER";
          case Month2.OCTOBER:
            return "OCTOBER";
          case Month2.NOVEMBER:
            return "NOVEMBER";
          case Month2.DECEMBER:
            return "DECEMBER";
          default:
            return "unknown Month, value: " + this.value();
        }
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, Month2, "other");
        return this._value - other._value;
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      Month2.valueOf = function valueOf(name3) {
        var ordinal = 0;
        for (ordinal; ordinal < MONTHS.length; ordinal++) {
          if (MONTHS[ordinal].name() === name3) {
            break;
          }
        }
        return Month2.of(ordinal + 1);
      };
      Month2.values = function values() {
        return MONTHS.slice();
      };
      Month2.of = function of(month) {
        if (month < 1 || month > 12) {
          assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
        }
        return MONTHS[month - 1];
      };
      Month2.from = function from(temporal) {
        if (temporal instanceof Month2) {
          return temporal;
        }
        try {
          return Month2.of(temporal.get(ChronoField.MONTH_OF_YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""), ex);
        }
      };
      return Month2;
    }(TemporalAccessor);
    PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
    Period = function(_TemporalAmount) {
      _inheritsLoose(Period2, _TemporalAmount);
      function Period2(years, months, days) {
        var _this;
        _this = _TemporalAmount.call(this) || this;
        var _years = MathUtil.safeToInt(years);
        var _months = MathUtil.safeToInt(months);
        var _days = MathUtil.safeToInt(days);
        if (_years === 0 && _months === 0 && _days === 0) {
          if (!Period2.ZERO) {
            _this._years = _years;
            _this._months = _months;
            _this._days = _days;
            Period2.ZERO = _assertThisInitialized(_this);
          }
          return Period2.ZERO || _assertThisInitialized(_this);
        }
        _this._years = _years;
        _this._months = _months;
        _this._days = _days;
        return _this;
      }
      Period2.ofYears = function ofYears(years) {
        return Period2.create(years, 0, 0);
      };
      Period2.ofMonths = function ofMonths(months) {
        return Period2.create(0, months, 0);
      };
      Period2.ofWeeks = function ofWeeks(weeks) {
        return Period2.create(0, 0, MathUtil.safeMultiply(weeks, 7));
      };
      Period2.ofDays = function ofDays(days) {
        return Period2.create(0, 0, days);
      };
      Period2.of = function of(years, months, days) {
        return Period2.create(years, months, days);
      };
      Period2.from = function from(amount) {
        if (amount instanceof Period2) {
          return amount;
        }
        requireNonNull(amount, "amount");
        var years = 0;
        var months = 0;
        var days = 0;
        var units = amount.units();
        for (var i = 0; i < units.length; i++) {
          var unit = units[i];
          var unitAmount = amount.get(unit);
          if (unit === ChronoUnit.YEARS) {
            years = MathUtil.safeToInt(unitAmount);
          } else if (unit === ChronoUnit.MONTHS) {
            months = MathUtil.safeToInt(unitAmount);
          } else if (unit === ChronoUnit.DAYS) {
            days = MathUtil.safeToInt(unitAmount);
          } else {
            throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
          }
        }
        return Period2.create(years, months, days);
      };
      Period2.between = function between(startDate, endDate) {
        requireNonNull(startDate, "startDate");
        requireNonNull(endDate, "endDate");
        requireInstance(startDate, LocalDate, "startDate");
        requireInstance(endDate, LocalDate, "endDate");
        return startDate.until(endDate);
      };
      Period2.parse = function parse2(text) {
        requireNonNull(text, "text");
        try {
          return Period2._parse(text);
        } catch (ex) {
          if (ex instanceof ArithmeticException) {
            throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0, ex);
          } else {
            throw ex;
          }
        }
      };
      Period2._parse = function _parse(text) {
        var matches = PATTERN.exec(text);
        if (matches != null) {
          var negate = "-" === matches[1] ? -1 : 1;
          var yearMatch = matches[2];
          var monthMatch = matches[3];
          var weekMatch = matches[4];
          var dayMatch = matches[5];
          if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
            var years = Period2._parseNumber(text, yearMatch, negate);
            var months = Period2._parseNumber(text, monthMatch, negate);
            var weeks = Period2._parseNumber(text, weekMatch, negate);
            var days = Period2._parseNumber(text, dayMatch, negate);
            days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
            return Period2.create(years, months, days);
          }
        }
        throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0);
      };
      Period2._parseNumber = function _parseNumber(text, str, negate) {
        if (str == null) {
          return 0;
        }
        var val = MathUtil.parseInt(str);
        return MathUtil.safeMultiply(val, negate);
      };
      Period2.create = function create(years, months, days) {
        return new Period2(years, months, days);
      };
      var _proto = Period2.prototype;
      _proto.units = function units() {
        return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
      };
      _proto.chronology = function chronology() {
        return IsoChronology.INSTANCE;
      };
      _proto.get = function get(unit) {
        if (unit === ChronoUnit.YEARS) {
          return this._years;
        }
        if (unit === ChronoUnit.MONTHS) {
          return this._months;
        }
        if (unit === ChronoUnit.DAYS) {
          return this._days;
        }
        throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
      };
      _proto.isZero = function isZero() {
        return this === Period2.ZERO;
      };
      _proto.isNegative = function isNegative() {
        return this._years < 0 || this._months < 0 || this._days < 0;
      };
      _proto.years = function years() {
        return this._years;
      };
      _proto.months = function months() {
        return this._months;
      };
      _proto.days = function days() {
        return this._days;
      };
      _proto.withYears = function withYears(years) {
        if (years === this._years) {
          return this;
        }
        return Period2.create(years, this._months, this._days);
      };
      _proto.withMonths = function withMonths(months) {
        if (months === this._months) {
          return this;
        }
        return Period2.create(this._years, months, this._days);
      };
      _proto.withDays = function withDays(days) {
        if (days === this._days) {
          return this;
        }
        return Period2.create(this._years, this._months, days);
      };
      _proto.plus = function plus(amountToAdd) {
        var amount = Period2.from(amountToAdd);
        return Period2.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        return Period2.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        return Period2.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        if (daysToAdd === 0) {
          return this;
        }
        return Period2.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
      };
      _proto.minus = function minus(amountToSubtract) {
        var amount = Period2.from(amountToSubtract);
        return Period2.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return this.plusYears(-1 * yearsToSubtract);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return this.plusMonths(-1 * monthsToSubtract);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return this.plusDays(-1 * daysToSubtract);
      };
      _proto.multipliedBy = function multipliedBy(scalar) {
        if (this === Period2.ZERO || scalar === 1) {
          return this;
        }
        return Period2.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
      };
      _proto.negated = function negated() {
        return this.multipliedBy(-1);
      };
      _proto.normalized = function normalized() {
        var totalMonths = this.toTotalMonths();
        var splitYears = MathUtil.intDiv(totalMonths, 12);
        var splitMonths = MathUtil.intMod(totalMonths, 12);
        if (splitYears === this._years && splitMonths === this._months) {
          return this;
        }
        return Period2.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
      };
      _proto.toTotalMonths = function toTotalMonths() {
        return this._years * 12 + this._months;
      };
      _proto.addTo = function addTo(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._years !== 0) {
          if (this._months !== 0) {
            temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
          } else {
            temporal = temporal.plus(this._years, ChronoUnit.YEARS);
          }
        } else if (this._months !== 0) {
          temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
        }
        if (this._days !== 0) {
          temporal = temporal.plus(this._days, ChronoUnit.DAYS);
        }
        return temporal;
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._years !== 0) {
          if (this._months !== 0) {
            temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
          } else {
            temporal = temporal.minus(this._years, ChronoUnit.YEARS);
          }
        } else if (this._months !== 0) {
          temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
        }
        if (this._days !== 0) {
          temporal = temporal.minus(this._days, ChronoUnit.DAYS);
        }
        return temporal;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof Period2) {
          var other = obj;
          return this._years === other._years && this._months === other._months && this._days === other._days;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._years, this._months, this._days);
      };
      _proto.toString = function toString() {
        if (this === Period2.ZERO) {
          return "P0D";
        } else {
          var buf = "P";
          if (this._years !== 0) {
            buf += this._years + "Y";
          }
          if (this._months !== 0) {
            buf += this._months + "M";
          }
          if (this._days !== 0) {
            buf += this._days + "D";
          }
          return buf;
        }
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Period2;
    }(TemporalAmount);
    ParsePosition = function() {
      function ParsePosition2(index) {
        this._index = index;
        this._errorIndex = -1;
      }
      var _proto = ParsePosition2.prototype;
      _proto.getIndex = function getIndex() {
        return this._index;
      };
      _proto.setIndex = function setIndex(index) {
        this._index = index;
      };
      _proto.getErrorIndex = function getErrorIndex() {
        return this._errorIndex;
      };
      _proto.setErrorIndex = function setErrorIndex(errorIndex) {
        this._errorIndex = errorIndex;
      };
      return ParsePosition2;
    }();
    EnumMap = function() {
      function EnumMap2() {
        this._map = {};
      }
      var _proto = EnumMap2.prototype;
      _proto.putAll = function putAll(otherMap) {
        for (var key in otherMap._map) {
          this._map[key] = otherMap._map[key];
        }
        return this;
      };
      _proto.containsKey = function containsKey(key) {
        return this._map.hasOwnProperty(key.name()) && this.get(key) !== void 0;
      };
      _proto.get = function get(key) {
        return this._map[key.name()];
      };
      _proto.put = function put(key, val) {
        return this.set(key, val);
      };
      _proto.set = function set(key, val) {
        this._map[key.name()] = val;
        return this;
      };
      _proto.retainAll = function retainAll(keyList) {
        var map = {};
        for (var i = 0; i < keyList.length; i++) {
          var key = keyList[i].name();
          map[key] = this._map[key];
        }
        this._map = map;
        return this;
      };
      _proto.remove = function remove(key) {
        var keyName = key.name();
        var val = this._map[keyName];
        this._map[keyName] = void 0;
        return val;
      };
      _proto.keySet = function keySet() {
        return this._map;
      };
      _proto.clear = function clear() {
        this._map = {};
      };
      return EnumMap2;
    }();
    ResolverStyle = function(_Enum) {
      _inheritsLoose(ResolverStyle2, _Enum);
      function ResolverStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      return ResolverStyle2;
    }(Enum);
    ResolverStyle.STRICT = new ResolverStyle("STRICT");
    ResolverStyle.SMART = new ResolverStyle("SMART");
    ResolverStyle.LENIENT = new ResolverStyle("LENIENT");
    Temporal = function(_TemporalAccessor) {
      _inheritsLoose(Temporal2, _TemporalAccessor);
      function Temporal2() {
        return _TemporalAccessor.apply(this, arguments) || this;
      }
      var _proto = Temporal2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        abstractMethodFail("isSupported");
      };
      _proto.minus = function minus(amount, unit) {
        if (arguments.length < 2) {
          return this._minusAmount(amount);
        } else {
          return this._minusUnit(amount, unit);
        }
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount, "amount");
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        return this._plusUnit(-amountToSubtract, unit);
      };
      _proto.plus = function plus(amount, unit) {
        if (arguments.length < 2) {
          return this._plusAmount(amount);
        } else {
          return this._plusUnit(amount, unit);
        }
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount, "amount");
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        abstractMethodFail("_plusUnit");
      };
      _proto.until = function until(endTemporal, unit) {
        abstractMethodFail("until");
      };
      _proto.with = function _with(adjusterOrField, newValue) {
        if (arguments.length < 2) {
          return this._withAdjuster(adjusterOrField);
        } else {
          return this._withField(adjusterOrField, newValue);
        }
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        assert(typeof adjuster.adjustInto === "function", "adjuster must be a TemporalAdjuster", IllegalArgumentException);
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        abstractMethodFail("_withField");
      };
      return Temporal2;
    }(TemporalAccessor);
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
      Temporal.prototype[Symbol.toPrimitive] = function(hint) {
        if (hint !== "number") {
          return this.toString();
        }
        throw new TypeError("A conversion from Temporal to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
      };
    }
    ChronoLocalDate = function(_Temporal) {
      _inheritsLoose(ChronoLocalDate2, _Temporal);
      function ChronoLocalDate2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoLocalDate2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.DAYS;
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toEpochDay());
        } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      return ChronoLocalDate2;
    }(Temporal);
    StringUtil = function() {
      function StringUtil2() {
      }
      StringUtil2.startsWith = function startsWith(text, pattern) {
        return text.indexOf(pattern) === 0;
      };
      StringUtil2.hashCode = function hashCode(text) {
        var len = text.length;
        if (len === 0) {
          return 0;
        }
        var hash = 0;
        for (var i = 0; i < len; i++) {
          var chr = text.charCodeAt(i);
          hash = (hash << 5) - hash + chr;
          hash |= 0;
        }
        return MathUtil.smi(hash);
      };
      return StringUtil2;
    }();
    ZoneId = function() {
      function ZoneId2() {
      }
      ZoneId2.systemDefault = function systemDefault() {
        throw new DateTimeException("not supported operation");
      };
      ZoneId2.getAvailableZoneIds = function getAvailableZoneIds() {
        throw new DateTimeException("not supported operation");
      };
      ZoneId2.of = function of(zoneId) {
        throw new DateTimeException("not supported operation" + zoneId);
      };
      ZoneId2.ofOffset = function ofOffset(prefix, offset) {
        throw new DateTimeException("not supported operation" + prefix + offset);
      };
      ZoneId2.from = function from(temporal) {
        throw new DateTimeException("not supported operation" + temporal);
      };
      var _proto = ZoneId2.prototype;
      _proto.id = function id() {
        abstractMethodFail("ZoneId.id");
      };
      _proto.rules = function rules() {
        abstractMethodFail("ZoneId.rules");
      };
      _proto.normalized = function normalized() {
        var rules = this.rules();
        if (rules.isFixedOffset()) {
          return rules.offset(Instant.EPOCH);
        }
        return this;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ZoneId2) {
          return this.id() === other.id();
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return StringUtil.hashCode(this.id());
      };
      _proto.toString = function toString() {
        return this.id();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return ZoneId2;
    }();
    ZoneRules = function() {
      function ZoneRules2() {
      }
      ZoneRules2.of = function of(offset) {
        requireNonNull(offset, "offset");
        return new Fixed(offset);
      };
      var _proto = ZoneRules2.prototype;
      _proto.isFixedOffset = function isFixedOffset() {
        abstractMethodFail("ZoneRules.isFixedOffset");
      };
      _proto.offset = function offset(instantOrLocalDateTime) {
        if (instantOrLocalDateTime instanceof Instant) {
          return this.offsetOfInstant(instantOrLocalDateTime);
        } else {
          return this.offsetOfLocalDateTime(instantOrLocalDateTime);
        }
      };
      _proto.offsetOfInstant = function offsetOfInstant(instant) {
        abstractMethodFail("ZoneRules.offsetInstant");
      };
      _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
        abstractMethodFail("ZoneRules.offsetOfEpochMilli");
      };
      _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
        abstractMethodFail("ZoneRules.offsetLocalDateTime");
      };
      _proto.validOffsets = function validOffsets(localDateTime) {
        abstractMethodFail("ZoneRules.validOffsets");
      };
      _proto.transition = function transition(localDateTime) {
        abstractMethodFail("ZoneRules.transition");
      };
      _proto.standardOffset = function standardOffset(instant) {
        abstractMethodFail("ZoneRules.standardOffset");
      };
      _proto.daylightSavings = function daylightSavings(instant) {
        abstractMethodFail("ZoneRules.daylightSavings");
      };
      _proto.isDaylightSavings = function isDaylightSavings(instant) {
        abstractMethodFail("ZoneRules.isDaylightSavings");
      };
      _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
        abstractMethodFail("ZoneRules.isValidOffset");
      };
      _proto.nextTransition = function nextTransition(instant) {
        abstractMethodFail("ZoneRules.nextTransition");
      };
      _proto.previousTransition = function previousTransition(instant) {
        abstractMethodFail("ZoneRules.previousTransition");
      };
      _proto.transitions = function transitions() {
        abstractMethodFail("ZoneRules.transitions");
      };
      _proto.transitionRules = function transitionRules() {
        abstractMethodFail("ZoneRules.transitionRules");
      };
      _proto.toString = function toString() {
        abstractMethodFail("ZoneRules.toString");
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return ZoneRules2;
    }();
    Fixed = function(_ZoneRules) {
      _inheritsLoose(Fixed2, _ZoneRules);
      function Fixed2(offset) {
        var _this;
        _this = _ZoneRules.call(this) || this;
        _this._offset = offset;
        return _this;
      }
      var _proto2 = Fixed2.prototype;
      _proto2.isFixedOffset = function isFixedOffset() {
        return true;
      };
      _proto2.offsetOfInstant = function offsetOfInstant() {
        return this._offset;
      };
      _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
        return this._offset;
      };
      _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
        return this._offset;
      };
      _proto2.validOffsets = function validOffsets() {
        return [this._offset];
      };
      _proto2.transition = function transition() {
        return null;
      };
      _proto2.standardOffset = function standardOffset() {
        return this._offset;
      };
      _proto2.daylightSavings = function daylightSavings() {
        return Duration.ZERO;
      };
      _proto2.isDaylightSavings = function isDaylightSavings() {
        return false;
      };
      _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
        return this._offset.equals(offset);
      };
      _proto2.nextTransition = function nextTransition() {
        return null;
      };
      _proto2.previousTransition = function previousTransition() {
        return null;
      };
      _proto2.transitions = function transitions() {
        return [];
      };
      _proto2.transitionRules = function transitionRules() {
        return [];
      };
      _proto2.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Fixed2) {
          return this._offset.equals(other._offset);
        }
        return false;
      };
      _proto2.toString = function toString() {
        return "FixedRules:" + this._offset.toString();
      };
      return Fixed2;
    }(ZoneRules);
    SECONDS_CACHE = {};
    ID_CACHE = {};
    ZoneOffset = function(_ZoneId) {
      _inheritsLoose(ZoneOffset2, _ZoneId);
      function ZoneOffset2(totalSeconds) {
        var _this;
        _this = _ZoneId.call(this) || this;
        ZoneOffset2._validateTotalSeconds(totalSeconds);
        _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
        _this._rules = ZoneRules.of(_assertThisInitialized(_this));
        _this._id = ZoneOffset2._buildId(totalSeconds);
        return _this;
      }
      var _proto = ZoneOffset2.prototype;
      _proto.totalSeconds = function totalSeconds() {
        return this._totalSeconds;
      };
      _proto.id = function id() {
        return this._id;
      };
      ZoneOffset2._buildId = function _buildId(totalSeconds) {
        if (totalSeconds === 0) {
          return "Z";
        } else {
          var absTotalSeconds = Math.abs(totalSeconds);
          var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
          var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
          var buf = (totalSeconds < 0 ? "-" : "+") + (absHours < 10 ? "0" : "") + absHours + (absMinutes < 10 ? ":0" : ":") + absMinutes;
          var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
          if (absSeconds !== 0) {
            buf += (absSeconds < 10 ? ":0" : ":") + absSeconds;
          }
          return buf;
        }
      };
      ZoneOffset2._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
        if (Math.abs(totalSeconds) > ZoneOffset2.MAX_SECONDS) {
          throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
        }
      };
      ZoneOffset2._validate = function _validate(hours, minutes, seconds) {
        if (hours < -18 || hours > 18) {
          throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
        }
        if (hours > 0) {
          if (minutes < 0 || seconds < 0) {
            throw new DateTimeException("Zone offset minutes and seconds must be positive because hours is positive");
          }
        } else if (hours < 0) {
          if (minutes > 0 || seconds > 0) {
            throw new DateTimeException("Zone offset minutes and seconds must be negative because hours is negative");
          }
        } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
          throw new DateTimeException("Zone offset minutes and seconds must have the same sign");
        }
        if (Math.abs(minutes) > 59) {
          throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
        }
        if (Math.abs(seconds) > 59) {
          throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
        }
        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
          throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
        }
      };
      ZoneOffset2.of = function of(offsetId) {
        requireNonNull(offsetId, "offsetId");
        var offset = ID_CACHE[offsetId];
        if (offset != null) {
          return offset;
        }
        var hours, minutes, seconds;
        switch (offsetId.length) {
          case 2:
            offsetId = offsetId[0] + "0" + offsetId[1];
          case 3:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = 0;
            seconds = 0;
            break;
          case 5:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
            seconds = 0;
            break;
          case 6:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
            seconds = 0;
            break;
          case 7:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
            seconds = ZoneOffset2._parseNumber(offsetId, 5, false);
            break;
          case 9:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
            seconds = ZoneOffset2._parseNumber(offsetId, 7, true);
            break;
          default:
            throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
        }
        var first = offsetId[0];
        if (first !== "+" && first !== "-") {
          throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
        }
        if (first === "-") {
          return ZoneOffset2.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
        } else {
          return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, seconds);
        }
      };
      ZoneOffset2._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
        if (precededByColon && offsetId[pos - 1] !== ":") {
          throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
        }
        var ch1 = offsetId[pos];
        var ch2 = offsetId[pos + 1];
        if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
          throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
        }
        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
      };
      ZoneOffset2.ofHours = function ofHours(hours) {
        return ZoneOffset2.ofHoursMinutesSeconds(hours, 0, 0);
      };
      ZoneOffset2.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
        return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, 0);
      };
      ZoneOffset2.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
        ZoneOffset2._validate(hours, minutes, seconds);
        var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
        return ZoneOffset2.ofTotalSeconds(totalSeconds);
      };
      ZoneOffset2.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
        var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
        return ZoneOffset2.ofTotalSeconds(totalSeconds);
      };
      ZoneOffset2.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
          var totalSecs = totalSeconds;
          var result = SECONDS_CACHE[totalSecs];
          if (result == null) {
            result = new ZoneOffset2(totalSeconds);
            SECONDS_CACHE[totalSecs] = result;
            ID_CACHE[result.id()] = result;
          }
          return result;
        } else {
          return new ZoneOffset2(totalSeconds);
        }
      };
      _proto.rules = function rules() {
        return this._rules;
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.OFFSET_SECONDS) {
          return this._totalSeconds;
        } else if (field instanceof ChronoField) {
          throw new DateTimeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        return other._totalSeconds - this._totalSeconds;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof ZoneOffset2) {
          return this._totalSeconds === obj._totalSeconds;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._totalSeconds;
      };
      _proto.toString = function toString() {
        return this._id;
      };
      return ZoneOffset2;
    }(ZoneId);
    DateTimeBuilder = function(_TemporalAccessor) {
      _inheritsLoose(DateTimeBuilder2, _TemporalAccessor);
      DateTimeBuilder2.create = function create(field, value) {
        var dtb = new DateTimeBuilder2();
        dtb._addFieldValue(field, value);
        return dtb;
      };
      function DateTimeBuilder2() {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this.fieldValues = new EnumMap();
        _this.chrono = null;
        _this.zone = null;
        _this.date = null;
        _this.time = null;
        _this.leapSecond = false;
        _this.excessDays = null;
        return _this;
      }
      var _proto = DateTimeBuilder2.prototype;
      _proto.getFieldValue0 = function getFieldValue0(field) {
        return this.fieldValues.get(field);
      };
      _proto._addFieldValue = function _addFieldValue(field, value) {
        requireNonNull(field, "field");
        var old = this.getFieldValue0(field);
        if (old != null && old !== value) {
          throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
        }
        return this._putFieldValue0(field, value);
      };
      _proto._putFieldValue0 = function _putFieldValue0(field, value) {
        this.fieldValues.put(field, value);
        return this;
      };
      _proto.resolve = function resolve(resolverStyle, resolverFields) {
        if (resolverFields != null) {
          this.fieldValues.retainAll(resolverFields);
        }
        this._mergeDate(resolverStyle);
        this._mergeTime(resolverStyle);
        this._resolveTimeInferZeroes(resolverStyle);
        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
          this.date = this.date.plus(this.excessDays);
          this.excessDays = Period.ZERO;
        }
        this._resolveInstant();
        return this;
      };
      _proto._mergeDate = function _mergeDate(resolverStyle) {
        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
      };
      _proto._checkDate = function _checkDate(date) {
        if (date != null) {
          this._addObject(date);
          for (var fieldName in this.fieldValues.keySet()) {
            var field = ChronoField.byName(fieldName);
            if (field) {
              if (this.fieldValues.get(field) !== void 0) {
                if (field.isDateBased()) {
                  var val1 = void 0;
                  try {
                    val1 = date.getLong(field);
                  } catch (ex) {
                    if (ex instanceof DateTimeException) {
                      continue;
                    } else {
                      throw ex;
                    }
                  }
                  var val2 = this.fieldValues.get(field);
                  if (val1 !== val2) {
                    throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date);
                  }
                }
              }
            }
          }
        }
      };
      _proto._mergeTime = function _mergeTime(resolverStyle) {
        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
          var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (resolverStyle === ResolverStyle.SMART && ch === 0)
              ;
            else {
              ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
            }
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
        }
        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
          var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (resolverStyle === ResolverStyle.SMART && _ch === 0)
              ;
            else {
              ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
            }
          }
          this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
            ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
          }
          if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
            ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
          }
        }
        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
          var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
          var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
          this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
        }
        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
          var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.NANO_OF_DAY.checkValidValue(nod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1e9));
          this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1e9));
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
          var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MICRO_OF_DAY.checkValidValue(cod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1e6));
          this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1e6));
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
          var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MILLI_OF_DAY.checkValidValue(lod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1e3));
          this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1e3));
        }
        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
          var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.SECOND_OF_DAY.checkValidValue(sod);
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
          this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
          this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
        }
        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
          var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
          this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
            ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
          }
          if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
            ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
          }
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
          var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
          this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1e3 + MathUtil.intMod(cos, 1e3));
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
          var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1e3));
          this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
          var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1e6));
          this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
          var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
          this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1e3);
        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
          var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1e6);
        }
      };
      _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
        var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
        var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
        var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
        var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
        if (hod == null) {
          return;
        }
        if (moh == null && (som != null || nos != null)) {
          return;
        }
        if (moh != null && som == null && nos != null) {
          return;
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (hod != null) {
            if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
              hod = 0;
              this.excessDays = Period.ofDays(1);
            }
            var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
            if (moh != null) {
              var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
              if (som != null) {
                var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
                if (nos != null) {
                  var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
                  this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
                } else {
                  this._addObject(LocalTime.of(hodVal, mohVal, somVal));
                }
              } else {
                if (nos == null) {
                  this._addObject(LocalTime.of(hodVal, mohVal));
                }
              }
            } else {
              if (som == null && nos == null) {
                this._addObject(LocalTime.of(hodVal, 0));
              }
            }
          }
        } else {
          if (hod != null) {
            var _hodVal = hod;
            if (moh != null) {
              if (som != null) {
                if (nos == null) {
                  nos = 0;
                }
                var totalNanos = MathUtil.safeMultiply(_hodVal, 36e11);
                totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 6e10));
                totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1e9));
                totalNanos = MathUtil.safeAdd(totalNanos, nos);
                var excessDays = MathUtil.floorDiv(totalNanos, 864e11);
                var nod = MathUtil.floorMod(totalNanos, 864e11);
                this._addObject(LocalTime.ofNanoOfDay(nod));
                this.excessDays = Period.ofDays(excessDays);
              } else {
                var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
                totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
                var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
                var sod = MathUtil.floorMod(totalSecs, 86400);
                this._addObject(LocalTime.ofSecondOfDay(sod));
                this.excessDays = Period.ofDays(_excessDays);
              }
            } else {
              var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
              _hodVal = MathUtil.floorMod(_hodVal, 24);
              this._addObject(LocalTime.of(_hodVal, 0));
              this.excessDays = Period.ofDays(_excessDays2);
            }
          }
        }
        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
      };
      _proto._addObject = function _addObject(dateOrTime) {
        if (dateOrTime instanceof ChronoLocalDate) {
          this.date = dateOrTime;
        } else if (dateOrTime instanceof LocalTime) {
          this.time = dateOrTime;
        }
      };
      _proto._resolveInstant = function _resolveInstant() {
        if (this.date != null && this.time != null) {
          var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
          if (offsetSecs != null) {
            var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
            var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
            this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
          } else if (this.zone != null) {
            var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
            this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
          }
        }
      };
      _proto.build = function build(type2) {
        return type2.queryFrom(this);
      };
      _proto.isSupported = function isSupported(field) {
        if (field == null) {
          return false;
        }
        return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== void 0 || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        var value = this.getFieldValue0(field);
        if (value == null) {
          if (this.date != null && this.date.isSupported(field)) {
            return this.date.getLong(field);
          }
          if (this.time != null && this.time.isSupported(field)) {
            return this.time.getLong(field);
          }
          throw new DateTimeException("Field not found: " + field);
        }
        return value;
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId()) {
          return this.zone;
        } else if (_query === TemporalQueries.chronology()) {
          return this.chrono;
        } else if (_query === TemporalQueries.localDate()) {
          return this.date != null ? LocalDate.from(this.date) : null;
        } else if (_query === TemporalQueries.localTime()) {
          return this.time;
        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
          return _query.queryFrom(this);
        } else if (_query === TemporalQueries.precision()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      return DateTimeBuilder2;
    }(TemporalAccessor);
    DateTimeParseContext = function() {
      function DateTimeParseContext2() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof DateTimeParseContext2) {
            this._constructorSelf.apply(this, arguments);
            return;
          } else {
            this._constructorFormatter.apply(this, arguments);
          }
        } else {
          this._constructorParam.apply(this, arguments);
        }
        this._caseSensitive = true;
        this._strict = true;
        this._parsed = [new Parsed(this)];
      }
      var _proto = DateTimeParseContext2.prototype;
      _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
        this._locale = locale;
        this._symbols = symbols;
        this._overrideChronology = chronology;
      };
      _proto._constructorFormatter = function _constructorFormatter(formatter) {
        this._locale = formatter.locale();
        this._symbols = formatter.decimalStyle();
        this._overrideChronology = formatter.chronology();
      };
      _proto._constructorSelf = function _constructorSelf(other) {
        this._locale = other._locale;
        this._symbols = other._symbols;
        this._overrideChronology = other._overrideChronology;
        this._overrideZone = other._overrideZone;
        this._caseSensitive = other._caseSensitive;
        this._strict = other._strict;
        this._parsed = [new Parsed(this)];
      };
      _proto.copy = function copy() {
        return new DateTimeParseContext2(this);
      };
      _proto.symbols = function symbols() {
        return this._symbols;
      };
      _proto.isStrict = function isStrict() {
        return this._strict;
      };
      _proto.setStrict = function setStrict(strict) {
        this._strict = strict;
      };
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.setLocale = function setLocale(locale) {
        this._locale = locale;
      };
      _proto.startOptional = function startOptional() {
        this._parsed.push(this.currentParsed().copy());
      };
      _proto.endOptional = function endOptional(successful) {
        if (successful) {
          this._parsed.splice(this._parsed.length - 2, 1);
        } else {
          this._parsed.splice(this._parsed.length - 1, 1);
        }
      };
      _proto.isCaseSensitive = function isCaseSensitive() {
        return this._caseSensitive;
      };
      _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
        this._caseSensitive = caseSensitive;
      };
      _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
          return false;
        }
        if (!this.isCaseSensitive()) {
          cs1 = cs1.toLowerCase();
          cs2 = cs2.toLowerCase();
        }
        for (var i = 0; i < length; i++) {
          var ch1 = cs1[offset1 + i];
          var ch2 = cs2[offset2 + i];
          if (ch1 !== ch2) {
            return false;
          }
        }
        return true;
      };
      _proto.charEquals = function charEquals(ch1, ch2) {
        if (this.isCaseSensitive()) {
          return ch1 === ch2;
        }
        return this.charEqualsIgnoreCase(ch1, ch2);
      };
      _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
        return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
      };
      _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
        var currentParsedFieldValues = this.currentParsed().fieldValues;
        var old = currentParsedFieldValues.get(field);
        currentParsedFieldValues.set(field, value);
        return old != null && old !== value ? ~errorPos : successPos;
      };
      _proto.setParsedZone = function setParsedZone(zone) {
        requireNonNull(zone, "zone");
        this.currentParsed().zone = zone;
      };
      _proto.getParsed = function getParsed(field) {
        return this.currentParsed().fieldValues.get(field);
      };
      _proto.toParsed = function toParsed() {
        return this.currentParsed();
      };
      _proto.currentParsed = function currentParsed() {
        return this._parsed[this._parsed.length - 1];
      };
      _proto.setParsedLeapSecond = function setParsedLeapSecond() {
        this.currentParsed().leapSecond = true;
      };
      _proto.getEffectiveChronology = function getEffectiveChronology() {
        var chrono = this.currentParsed().chrono;
        if (chrono == null) {
          chrono = this._overrideChronology;
          if (chrono == null) {
            chrono = IsoChronology.INSTANCE;
          }
        }
        return chrono;
      };
      return DateTimeParseContext2;
    }();
    Parsed = function(_Temporal) {
      _inheritsLoose(Parsed2, _Temporal);
      function Parsed2(dateTimeParseContext) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this.chrono = null;
        _this.zone = null;
        _this.fieldValues = new EnumMap();
        _this.leapSecond = false;
        _this.dateTimeParseContext = dateTimeParseContext;
        return _this;
      }
      var _proto2 = Parsed2.prototype;
      _proto2.copy = function copy() {
        var cloned = new Parsed2();
        cloned.chrono = this.chrono;
        cloned.zone = this.zone;
        cloned.fieldValues.putAll(this.fieldValues);
        cloned.leapSecond = this.leapSecond;
        cloned.dateTimeParseContext = this.dateTimeParseContext;
        return cloned;
      };
      _proto2.toString = function toString() {
        return this.fieldValues + ", " + this.chrono + ", " + this.zone;
      };
      _proto2.isSupported = function isSupported(field) {
        return this.fieldValues.containsKey(field);
      };
      _proto2.get = function get(field) {
        var val = this.fieldValues.get(field);
        assert(val != null);
        return val;
      };
      _proto2.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chrono;
        }
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
          return this.zone;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto2.toBuilder = function toBuilder() {
        var builder = new DateTimeBuilder();
        builder.fieldValues.putAll(this.fieldValues);
        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();
        if (this.zone != null) {
          builder.zone = this.zone;
        } else {
          builder.zone = this.overrideZone;
        }
        builder.leapSecond = this.leapSecond;
        builder.excessDays = this.excessDays;
        return builder;
      };
      return Parsed2;
    }(Temporal);
    DateTimePrintContext = function() {
      function DateTimePrintContext2(temporal, localeOrFormatter, symbols) {
        if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
          this._temporal = DateTimePrintContext2.adjust(temporal, localeOrFormatter);
          this._locale = localeOrFormatter.locale();
          this._symbols = localeOrFormatter.decimalStyle();
        } else {
          this._temporal = temporal;
          this._locale = localeOrFormatter;
          this._symbols = symbols;
        }
        this._optional = 0;
      }
      DateTimePrintContext2.adjust = function adjust(temporal, formatter) {
        return temporal;
      };
      var _proto = DateTimePrintContext2.prototype;
      _proto.symbols = function symbols() {
        return this._symbols;
      };
      _proto.startOptional = function startOptional() {
        this._optional++;
      };
      _proto.endOptional = function endOptional() {
        this._optional--;
      };
      _proto.getValueQuery = function getValueQuery(query) {
        var result = this._temporal.query(query);
        if (result == null && this._optional === 0) {
          throw new DateTimeException("Unable to extract value: " + this._temporal);
        }
        return result;
      };
      _proto.getValue = function getValue(field) {
        try {
          return this._temporal.getLong(field);
        } catch (ex) {
          if (ex instanceof DateTimeException && this._optional > 0) {
            return null;
          }
          throw ex;
        }
      };
      _proto.temporal = function temporal() {
        return this._temporal;
      };
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.setDateTime = function setDateTime(temporal) {
        this._temporal = temporal;
      };
      _proto.setLocale = function setLocale(locale) {
        this._locale = locale;
      };
      return DateTimePrintContext2;
    }();
    IsoFields = {};
    QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];
    Field = function(_TemporalField) {
      _inheritsLoose(Field2, _TemporalField);
      function Field2() {
        return _TemporalField.apply(this, arguments) || this;
      }
      var _proto = Field2.prototype;
      _proto.isDateBased = function isDateBased() {
        return true;
      };
      _proto.isTimeBased = function isTimeBased() {
        return false;
      };
      _proto._isIso = function _isIso() {
        return true;
      };
      Field2._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
        var wby = Field2._getWeekBasedYear(date);
        return ValueRange.of(1, Field2._getWeekRangeByYear(wby));
      };
      Field2._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
        var date = LocalDate.of(wby, 1, 1);
        if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
          return 53;
        }
        return 52;
      };
      Field2._getWeek = function _getWeek(date) {
        var dow0 = date.dayOfWeek().ordinal();
        var doy0 = date.dayOfYear() - 1;
        var doyThu0 = doy0 + (3 - dow0);
        var alignedWeek = MathUtil.intDiv(doyThu0, 7);
        var firstThuDoy0 = doyThu0 - alignedWeek * 7;
        var firstMonDoy0 = firstThuDoy0 - 3;
        if (firstMonDoy0 < -3) {
          firstMonDoy0 += 7;
        }
        if (doy0 < firstMonDoy0) {
          return Field2._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
        }
        var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
        if (week === 53) {
          if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
            week = 1;
          }
        }
        return week;
      };
      Field2._getWeekBasedYear = function _getWeekBasedYear(date) {
        var year = date.year();
        var doy = date.dayOfYear();
        if (doy <= 3) {
          var dow = date.dayOfWeek().ordinal();
          if (doy - dow < -2) {
            year--;
          }
        } else if (doy >= 363) {
          var _dow = date.dayOfWeek().ordinal();
          doy = doy - 363 - (date.isLeapYear() ? 1 : 0);
          if (doy - _dow >= 0) {
            year++;
          }
        }
        return year;
      };
      _proto.displayName = function displayName() {
        return this.toString();
      };
      _proto.resolve = function resolve() {
        return null;
      };
      _proto.name = function name3() {
        return this.toString();
      };
      return Field2;
    }(TemporalField);
    DAY_OF_QUARTER_FIELD = function(_Field) {
      _inheritsLoose(DAY_OF_QUARTER_FIELD2, _Field);
      function DAY_OF_QUARTER_FIELD2() {
        return _Field.apply(this, arguments) || this;
      }
      var _proto2 = DAY_OF_QUARTER_FIELD2.prototype;
      _proto2.toString = function toString() {
        return "DayOfQuarter";
      };
      _proto2.baseUnit = function baseUnit() {
        return ChronoUnit.DAYS;
      };
      _proto2.rangeUnit = function rangeUnit() {
        return QUARTER_YEARS;
      };
      _proto2.range = function range() {
        return ValueRange.of(1, 90, 92);
      };
      _proto2.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
      };
      _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
        }
        var qoy = temporal.getLong(QUARTER_OF_YEAR);
        if (qoy === 1) {
          var year = temporal.getLong(ChronoField.YEAR);
          return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
        } else if (qoy === 2) {
          return ValueRange.of(1, 91);
        } else if (qoy === 3 || qoy === 4) {
          return ValueRange.of(1, 92);
        }
        return this.range();
      };
      _proto2.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
        }
        var doy = temporal.get(ChronoField.DAY_OF_YEAR);
        var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
        var year = temporal.getLong(ChronoField.YEAR);
        return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
      };
      _proto2.adjustInto = function adjustInto(temporal, newValue) {
        var curValue = this.getFrom(temporal);
        this.range().checkValidValue(newValue, this);
        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
      };
      _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
        var yearLong = fieldValues.get(ChronoField.YEAR);
        var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
        if (yearLong == null || qoyLong == null) {
          return null;
        }
        var y = ChronoField.YEAR.checkValidIntValue(yearLong);
        var doq = fieldValues.get(DAY_OF_QUARTER);
        var date;
        if (resolverStyle === ResolverStyle.LENIENT) {
          var qoy = qoyLong;
          date = LocalDate.of(y, 1, 1);
          date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
          date = date.plusDays(MathUtil.safeSubtract(doq, 1));
        } else {
          var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
          if (resolverStyle === ResolverStyle.STRICT) {
            var max = 92;
            if (_qoy === 1) {
              max = IsoChronology.isLeapYear(y) ? 91 : 90;
            } else if (_qoy === 2) {
              max = 91;
            }
            ValueRange.of(1, max).checkValidValue(doq, this);
          } else {
            this.range().checkValidValue(doq, this);
          }
          date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
        }
        fieldValues.remove(this);
        fieldValues.remove(ChronoField.YEAR);
        fieldValues.remove(QUARTER_OF_YEAR);
        return date;
      };
      return DAY_OF_QUARTER_FIELD2;
    }(Field);
    QUARTER_OF_YEAR_FIELD = function(_Field2) {
      _inheritsLoose(QUARTER_OF_YEAR_FIELD2, _Field2);
      function QUARTER_OF_YEAR_FIELD2() {
        return _Field2.apply(this, arguments) || this;
      }
      var _proto3 = QUARTER_OF_YEAR_FIELD2.prototype;
      _proto3.toString = function toString() {
        return "QuarterOfYear";
      };
      _proto3.baseUnit = function baseUnit() {
        return QUARTER_YEARS;
      };
      _proto3.rangeUnit = function rangeUnit() {
        return ChronoUnit.YEARS;
      };
      _proto3.range = function range() {
        return ValueRange.of(1, 4);
      };
      _proto3.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
      };
      _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return this.range();
      };
      _proto3.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: QuarterOfYear");
        }
        var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
        return MathUtil.intDiv(moy + 2, 3);
      };
      _proto3.adjustInto = function adjustInto(temporal, newValue) {
        var curValue = this.getFrom(temporal);
        this.range().checkValidValue(newValue, this);
        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
      };
      return QUARTER_OF_YEAR_FIELD2;
    }(Field);
    WEEK_OF_WEEK_BASED_YEAR_FIELD = function(_Field3) {
      _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD2, _Field3);
      function WEEK_OF_WEEK_BASED_YEAR_FIELD2() {
        return _Field3.apply(this, arguments) || this;
      }
      var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD2.prototype;
      _proto4.toString = function toString() {
        return "WeekOfWeekBasedYear";
      };
      _proto4.baseUnit = function baseUnit() {
        return ChronoUnit.WEEKS;
      };
      _proto4.rangeUnit = function rangeUnit() {
        return WEEK_BASED_YEARS;
      };
      _proto4.range = function range() {
        return ValueRange.of(1, 52, 53);
      };
      _proto4.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
      };
      _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
        }
        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
      };
      _proto4.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
        }
        return Field._getWeek(LocalDate.from(temporal));
      };
      _proto4.adjustInto = function adjustInto(temporal, newValue) {
        this.range().checkValidValue(newValue, this);
        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
      };
      _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
        var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
        var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
        if (wbyLong == null || dowLong == null) {
          return null;
        }
        var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
        var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
        var date;
        if (resolverStyle === ResolverStyle.LENIENT) {
          var dow = dowLong;
          var weeks = 0;
          if (dow > 7) {
            weeks = MathUtil.intDiv(dow - 1, 7);
            dow = MathUtil.intMod(dow - 1, 7) + 1;
          } else if (dow < 1) {
            weeks = MathUtil.intDiv(dow, 7) - 1;
            dow = MathUtil.intMod(dow, 7) + 7;
          }
          date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
        } else {
          var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
          if (resolverStyle === ResolverStyle.STRICT) {
            var temp = LocalDate.of(wby, 1, 4);
            var range = Field._getWeekRangeByLocalDate(temp);
            range.checkValidValue(wowby, this);
          } else {
            this.range().checkValidValue(wowby, this);
          }
          date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
        }
        fieldValues.remove(this);
        fieldValues.remove(WEEK_BASED_YEAR);
        fieldValues.remove(ChronoField.DAY_OF_WEEK);
        return date;
      };
      _proto4.displayName = function displayName() {
        return "Week";
      };
      return WEEK_OF_WEEK_BASED_YEAR_FIELD2;
    }(Field);
    WEEK_BASED_YEAR_FIELD = function(_Field4) {
      _inheritsLoose(WEEK_BASED_YEAR_FIELD2, _Field4);
      function WEEK_BASED_YEAR_FIELD2() {
        return _Field4.apply(this, arguments) || this;
      }
      var _proto5 = WEEK_BASED_YEAR_FIELD2.prototype;
      _proto5.toString = function toString() {
        return "WeekBasedYear";
      };
      _proto5.baseUnit = function baseUnit() {
        return WEEK_BASED_YEARS;
      };
      _proto5.rangeUnit = function rangeUnit() {
        return ChronoUnit.FOREVER;
      };
      _proto5.range = function range() {
        return ChronoField.YEAR.range();
      };
      _proto5.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
      };
      _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return ChronoField.YEAR.range();
      };
      _proto5.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
        }
        return Field._getWeekBasedYear(LocalDate.from(temporal));
      };
      _proto5.adjustInto = function adjustInto(temporal, newValue) {
        if (this.isSupportedBy(temporal) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
        }
        var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
        var date = LocalDate.from(temporal);
        var dow = date.get(ChronoField.DAY_OF_WEEK);
        var week = Field._getWeek(date);
        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
          week = 52;
        }
        var resolved = LocalDate.of(newWby, 1, 4);
        var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
        resolved = resolved.plusDays(days);
        return temporal.with(resolved);
      };
      return WEEK_BASED_YEAR_FIELD2;
    }(Field);
    Unit = function(_TemporalUnit) {
      _inheritsLoose(Unit2, _TemporalUnit);
      function Unit2(name3, estimatedDuration) {
        var _this;
        _this = _TemporalUnit.call(this) || this;
        _this._name = name3;
        _this._duration = estimatedDuration;
        return _this;
      }
      var _proto6 = Unit2.prototype;
      _proto6.duration = function duration() {
        return this._duration;
      };
      _proto6.isDurationEstimated = function isDurationEstimated() {
        return true;
      };
      _proto6.isDateBased = function isDateBased() {
        return true;
      };
      _proto6.isTimeBased = function isTimeBased() {
        return false;
      };
      _proto6.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY);
      };
      _proto6.addTo = function addTo(temporal, periodToAdd) {
        switch (this) {
          case WEEK_BASED_YEARS: {
            var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
            return temporal.with(WEEK_BASED_YEAR, added);
          }
          case QUARTER_YEARS:
            return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
          default:
            throw new IllegalStateException("Unreachable");
        }
      };
      _proto6.between = function between(temporal1, temporal2) {
        switch (this) {
          case WEEK_BASED_YEARS:
            return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
          case QUARTER_YEARS:
            return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
          default:
            throw new IllegalStateException("Unreachable");
        }
      };
      _proto6.toString = function toString() {
        return this._name;
      };
      return Unit2;
    }(TemporalUnit);
    DAY_OF_QUARTER = null;
    QUARTER_OF_YEAR = null;
    WEEK_OF_WEEK_BASED_YEAR = null;
    WEEK_BASED_YEAR = null;
    WEEK_BASED_YEARS = null;
    QUARTER_YEARS = null;
    DecimalStyle = function() {
      function DecimalStyle2(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
        this._zeroDigit = zeroChar;
        this._zeroDigitCharCode = zeroChar.charCodeAt(0);
        this._positiveSign = positiveSignChar;
        this._negativeSign = negativeSignChar;
        this._decimalSeparator = decimalPointChar;
      }
      var _proto = DecimalStyle2.prototype;
      _proto.positiveSign = function positiveSign() {
        return this._positiveSign;
      };
      _proto.withPositiveSign = function withPositiveSign(positiveSign) {
        if (positiveSign === this._positiveSign) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
      };
      _proto.negativeSign = function negativeSign() {
        return this._negativeSign;
      };
      _proto.withNegativeSign = function withNegativeSign(negativeSign) {
        if (negativeSign === this._negativeSign) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
      };
      _proto.zeroDigit = function zeroDigit() {
        return this._zeroDigit;
      };
      _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
        if (zeroDigit === this._zeroDigit) {
          return this;
        }
        return new DecimalStyle2(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
      };
      _proto.decimalSeparator = function decimalSeparator() {
        return this._decimalSeparator;
      };
      _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
        if (decimalSeparator === this._decimalSeparator) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
      };
      _proto.convertToDigit = function convertToDigit(char) {
        var val = char.charCodeAt(0) - this._zeroDigitCharCode;
        return val >= 0 && val <= 9 ? val : -1;
      };
      _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
        if (this._zeroDigit === "0") {
          return numericText;
        }
        var diff = this._zeroDigitCharCode - "0".charCodeAt(0);
        var convertedText = "";
        for (var i = 0; i < numericText.length; i++) {
          convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
        }
        return convertedText;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof DecimalStyle2) {
          return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
      };
      _proto.toString = function toString() {
        return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
      };
      DecimalStyle2.of = function of() {
        throw new Error("not yet supported");
      };
      DecimalStyle2.availableLocales = function availableLocales() {
        throw new Error("not yet supported");
      };
      return DecimalStyle2;
    }();
    DecimalStyle.STANDARD = new DecimalStyle("0", "+", "-", ".");
    SignStyle = function(_Enum) {
      _inheritsLoose(SignStyle2, _Enum);
      function SignStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = SignStyle2.prototype;
      _proto.parse = function parse2(positive, strict, fixedWidth) {
        switch (this) {
          case SignStyle2.NORMAL:
            return !positive || !strict;
          case SignStyle2.ALWAYS:
          case SignStyle2.EXCEEDS_PAD:
            return true;
          default:
            return !strict && !fixedWidth;
        }
      };
      return SignStyle2;
    }(Enum);
    SignStyle.NORMAL = new SignStyle("NORMAL");
    SignStyle.NEVER = new SignStyle("NEVER");
    SignStyle.ALWAYS = new SignStyle("ALWAYS");
    SignStyle.EXCEEDS_PAD = new SignStyle("EXCEEDS_PAD");
    SignStyle.NOT_NEGATIVE = new SignStyle("NOT_NEGATIVE");
    TextStyle = function(_Enum) {
      _inheritsLoose(TextStyle2, _Enum);
      function TextStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = TextStyle2.prototype;
      _proto.isStandalone = function isStandalone() {
        switch (this) {
          case TextStyle2.FULL_STANDALONE:
          case TextStyle2.SHORT_STANDALONE:
          case TextStyle2.NARROW_STANDALONE:
            return true;
          default:
            return false;
        }
      };
      _proto.asStandalone = function asStandalone() {
        switch (this) {
          case TextStyle2.FULL:
            return TextStyle2.FULL_STANDALONE;
          case TextStyle2.SHORT:
            return TextStyle2.SHORT_STANDALONE;
          case TextStyle2.NARROW:
            return TextStyle2.NARROW_STANDALONE;
          default:
            return this;
        }
      };
      _proto.asNormal = function asNormal() {
        switch (this) {
          case TextStyle2.FULL_STANDALONE:
            return TextStyle2.FULL;
          case TextStyle2.SHORT_STANDALONE:
            return TextStyle2.SHORT;
          case TextStyle2.NARROW_STANDALONE:
            return TextStyle2.NARROW;
          default:
            return this;
        }
      };
      return TextStyle2;
    }(Enum);
    TextStyle.FULL = new TextStyle("FULL");
    TextStyle.FULL_STANDALONE = new TextStyle("FULL_STANDALONE");
    TextStyle.SHORT = new TextStyle("SHORT");
    TextStyle.SHORT_STANDALONE = new TextStyle("SHORT_STANDALONE");
    TextStyle.NARROW = new TextStyle("NARROW");
    TextStyle.NARROW_STANDALONE = new TextStyle("NARROW_STANDALONE");
    CharLiteralPrinterParser = function() {
      function CharLiteralPrinterParser2(literal) {
        if (literal.length > 1) {
          throw new IllegalArgumentException('invalid literal, too long: "' + literal + '"');
        }
        this._literal = literal;
      }
      var _proto = CharLiteralPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        buf.append(this._literal);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position === length) {
          return ~position;
        }
        var ch = text.charAt(position);
        if (context.charEquals(this._literal, ch) === false) {
          return ~position;
        }
        return position + this._literal.length;
      };
      _proto.toString = function toString() {
        if (this._literal === "'") {
          return "''";
        }
        return "'" + this._literal + "'";
      };
      return CharLiteralPrinterParser2;
    }();
    CompositePrinterParser = function() {
      function CompositePrinterParser2(printerParsers, optional) {
        this._printerParsers = printerParsers;
        this._optional = optional;
      }
      var _proto = CompositePrinterParser2.prototype;
      _proto.withOptional = function withOptional(optional) {
        if (optional === this._optional) {
          return this;
        }
        return new CompositePrinterParser2(this._printerParsers, optional);
      };
      _proto.print = function print(context, buf) {
        var length = buf.length();
        if (this._optional) {
          context.startOptional();
        }
        try {
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            if (pp.print(context, buf) === false) {
              buf.setLength(length);
              return true;
            }
          }
        } finally {
          if (this._optional) {
            context.endOptional();
          }
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        if (this._optional) {
          context.startOptional();
          var pos = position;
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            pos = pp.parse(context, text, pos);
            if (pos < 0) {
              context.endOptional(false);
              return position;
            }
          }
          context.endOptional(true);
          return pos;
        } else {
          for (var _i = 0; _i < this._printerParsers.length; _i++) {
            var _pp = this._printerParsers[_i];
            position = _pp.parse(context, text, position);
            if (position < 0) {
              break;
            }
          }
          return position;
        }
      };
      _proto.toString = function toString() {
        var buf = "";
        if (this._printerParsers != null) {
          buf += this._optional ? "[" : "(";
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            buf += pp.toString();
          }
          buf += this._optional ? "]" : ")";
        }
        return buf;
      };
      return CompositePrinterParser2;
    }();
    FractionPrinterParser = function() {
      function FractionPrinterParser2(field, minWidth, maxWidth, decimalPoint) {
        requireNonNull(field, "field");
        if (field.range().isFixed() === false) {
          throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
        }
        if (minWidth < 0 || minWidth > 9) {
          throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
        }
        if (maxWidth < 1 || maxWidth > 9) {
          throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
        }
        if (maxWidth < minWidth) {
          throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
        }
        this.field = field;
        this.minWidth = minWidth;
        this.maxWidth = maxWidth;
        this.decimalPoint = decimalPoint;
      }
      var _proto = FractionPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        var value = context.getValue(this.field);
        if (value === null) {
          return false;
        }
        var symbols = context.symbols();
        if (value === 0) {
          if (this.minWidth > 0) {
            if (this.decimalPoint) {
              buf.append(symbols.decimalSeparator());
            }
            for (var i = 0; i < this.minWidth; i++) {
              buf.append(symbols.zeroDigit());
            }
          }
        } else {
          var fraction = this.convertToFraction(value, symbols.zeroDigit());
          var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
          fraction = fraction.substr(0, outputScale);
          if (fraction * 1 > 0) {
            while (fraction.length > this.minWidth && fraction[fraction.length - 1] === "0") {
              fraction = fraction.substr(0, fraction.length - 1);
            }
          }
          var str = fraction;
          str = symbols.convertNumberToI18N(str);
          if (this.decimalPoint) {
            buf.append(symbols.decimalSeparator());
          }
          buf.append(str);
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var effectiveMin = context.isStrict() ? this.minWidth : 0;
        var effectiveMax = context.isStrict() ? this.maxWidth : 9;
        var length = text.length;
        if (position === length) {
          return effectiveMin > 0 ? ~position : position;
        }
        if (this.decimalPoint) {
          if (text[position] !== context.symbols().decimalSeparator()) {
            return effectiveMin > 0 ? ~position : position;
          }
          position++;
        }
        var minEndPos = position + effectiveMin;
        if (minEndPos > length) {
          return ~position;
        }
        var maxEndPos = Math.min(position + effectiveMax, length);
        var total = 0;
        var pos = position;
        while (pos < maxEndPos) {
          var ch = text.charAt(pos++);
          var digit = context.symbols().convertToDigit(ch);
          if (digit < 0) {
            if (pos < minEndPos) {
              return ~position;
            }
            pos--;
            break;
          }
          total = total * 10 + digit;
        }
        var moveLeft = pos - position;
        var scale = Math.pow(10, moveLeft);
        var value = this.convertFromFraction(total, scale);
        return context.setParsedField(this.field, value, position, pos);
      };
      _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
        var range = this.field.range();
        range.checkValidValue(value, this.field);
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = value - _min;
        var _scaled = MathUtil.intDiv(_value * 1e9, _range);
        var fraction = "" + _scaled;
        while (fraction.length < 9) {
          fraction = zeroDigit + fraction;
        }
        return fraction;
      };
      _proto.convertFromFraction = function convertFromFraction(total, scale) {
        var range = this.field.range();
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = MathUtil.intDiv(total * _range, scale);
        return _value;
      };
      _proto.toString = function toString() {
        var decimal = this.decimalPoint ? ",DecimalPoint" : "";
        return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal + ")";
      };
      return FractionPrinterParser2;
    }();
    MAX_WIDTH$1 = 15;
    EXCEED_POINTS = [0, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
    NumberPrinterParser = function() {
      function NumberPrinterParser2(field, minWidth, maxWidth, signStyle, subsequentWidth) {
        if (subsequentWidth === void 0) {
          subsequentWidth = 0;
        }
        this._field = field;
        this._minWidth = minWidth;
        this._maxWidth = maxWidth;
        this._signStyle = signStyle;
        this._subsequentWidth = subsequentWidth;
      }
      var _proto = NumberPrinterParser2.prototype;
      _proto.field = function field() {
        return this._field;
      };
      _proto.minWidth = function minWidth() {
        return this._minWidth;
      };
      _proto.maxWidth = function maxWidth() {
        return this._maxWidth;
      };
      _proto.signStyle = function signStyle() {
        return this._signStyle;
      };
      _proto.withFixedWidth = function withFixedWidth() {
        if (this._subsequentWidth === -1) {
          return this;
        }
        return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
      };
      _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
        return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
      };
      _proto._isFixedWidth = function _isFixedWidth() {
        return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
      };
      _proto.print = function print(context, buf) {
        var contextValue = context.getValue(this._field);
        if (contextValue == null) {
          return false;
        }
        var value = this._getValue(context, contextValue);
        var symbols = context.symbols();
        var str = "" + Math.abs(value);
        if (str.length > this._maxWidth) {
          throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
        }
        str = symbols.convertNumberToI18N(str);
        if (value >= 0) {
          switch (this._signStyle) {
            case SignStyle.EXCEEDS_PAD:
              if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
                buf.append(symbols.positiveSign());
              }
              break;
            case SignStyle.ALWAYS:
              buf.append(symbols.positiveSign());
              break;
          }
        } else {
          switch (this._signStyle) {
            case SignStyle.NORMAL:
            case SignStyle.EXCEEDS_PAD:
            case SignStyle.ALWAYS:
              buf.append(symbols.negativeSign());
              break;
            case SignStyle.NOT_NEGATIVE:
              throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
          }
        }
        for (var i = 0; i < this._minWidth - str.length; i++) {
          buf.append(symbols.zeroDigit());
        }
        buf.append(str);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position === length) {
          return ~position;
        }
        assert(position >= 0 && position < length);
        var sign = text.charAt(position);
        var negative = false;
        var positive = false;
        if (sign === context.symbols().positiveSign()) {
          if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
            return ~position;
          }
          positive = true;
          position++;
        } else if (sign === context.symbols().negativeSign()) {
          if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
            return ~position;
          }
          negative = true;
          position++;
        } else {
          if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {
            return ~position;
          }
        }
        var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
        var minEndPos = position + effMinWidth;
        if (minEndPos > length) {
          return ~position;
        }
        var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
        var total = 0;
        var pos = position;
        for (var pass = 0; pass < 2; pass++) {
          var maxEndPos = Math.min(pos + effMaxWidth, length);
          while (pos < maxEndPos) {
            var ch = text.charAt(pos++);
            var digit = context.symbols().convertToDigit(ch);
            if (digit < 0) {
              pos--;
              if (pos < minEndPos) {
                return ~position;
              }
              break;
            }
            if (pos - position > MAX_WIDTH$1) {
              throw new ArithmeticException("number text exceeds length");
            } else {
              total = total * 10 + digit;
            }
          }
          if (this._subsequentWidth > 0 && pass === 0) {
            var parseLen = pos - position;
            effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
            pos = position;
            total = 0;
          } else {
            break;
          }
        }
        if (negative) {
          if (total === 0 && context.isStrict()) {
            return ~(position - 1);
          }
          if (total !== 0) {
            total = -total;
          }
        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {
          var _parseLen = pos - position;
          if (positive) {
            if (_parseLen <= this._minWidth) {
              return ~(position - 1);
            }
          } else {
            if (_parseLen > this._minWidth) {
              return ~position;
            }
          }
        }
        return this._setValue(context, total, position, pos);
      };
      _proto._getValue = function _getValue(context, value) {
        return value;
      };
      _proto._setValue = function _setValue(context, value, errorPos, successPos) {
        return context.setParsedField(this._field, value, errorPos, successPos);
      };
      _proto.toString = function toString() {
        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
          return "Value(" + this._field + ")";
        }
        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
          return "Value(" + this._field + "," + this._minWidth + ")";
        }
        return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
      };
      return NumberPrinterParser2;
    }();
    ReducedPrinterParser = function(_NumberPrinterParser) {
      _inheritsLoose(ReducedPrinterParser2, _NumberPrinterParser);
      function ReducedPrinterParser2(field, width, maxWidth, baseValue, baseDate) {
        var _this;
        _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;
        if (width < 1 || width > 10) {
          throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
        }
        if (maxWidth < 1 || maxWidth > 10) {
          throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
        }
        if (maxWidth < width) {
          throw new IllegalArgumentException("The maxWidth must be greater than the width");
        }
        if (baseDate === null) {
          if (field.range().isValidValue(baseValue) === false) {
            throw new IllegalArgumentException("The base value must be within the range of the field");
          }
          if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
            throw new DateTimeException("Unable to add printer-parser as the range exceeds the capacity of an int");
          }
        }
        _this._baseValue = baseValue;
        _this._baseDate = baseDate;
        return _this;
      }
      var _proto2 = ReducedPrinterParser2.prototype;
      _proto2._getValue = function _getValue(context, value) {
        var absValue = Math.abs(value);
        var baseValue = this._baseValue;
        if (this._baseDate !== null) {
          context.temporal();
          var chrono = IsoChronology.INSTANCE;
          baseValue = chrono.date(this._baseDate).get(this._field);
        }
        if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
          return absValue % EXCEED_POINTS[this._minWidth];
        }
        return absValue % EXCEED_POINTS[this._maxWidth];
      };
      _proto2._setValue = function _setValue(context, value, errorPos, successPos) {
        var baseValue = this._baseValue;
        if (this._baseDate != null) {
          var chrono = context.getEffectiveChronology();
          baseValue = chrono.date(this._baseDate).get(this._field);
        }
        var parseLen = successPos - errorPos;
        if (parseLen === this._minWidth && value >= 0) {
          var range = EXCEED_POINTS[this._minWidth];
          var lastPart = baseValue % range;
          var basePart = baseValue - lastPart;
          if (baseValue > 0) {
            value = basePart + value;
          } else {
            value = basePart - value;
          }
          if (value < baseValue) {
            value += range;
          }
        }
        return context.setParsedField(this._field, value, errorPos, successPos);
      };
      _proto2.withFixedWidth = function withFixedWidth() {
        if (this._subsequentWidth === -1) {
          return this;
        }
        return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);
      };
      _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
        return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
      };
      _proto2.isFixedWidth = function isFixedWidth(context) {
        if (context.isStrict() === false) {
          return false;
        }
        return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);
      };
      _proto2.toString = function toString() {
        return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
      };
      return ReducedPrinterParser2;
    }(NumberPrinterParser);
    PATTERNS = ["+HH", "+HHmm", "+HH:mm", "+HHMM", "+HH:MM", "+HHMMss", "+HH:MM:ss", "+HHMMSS", "+HH:MM:SS"];
    OffsetIdPrinterParser = function() {
      function OffsetIdPrinterParser2(noOffsetText, pattern) {
        requireNonNull(noOffsetText, "noOffsetText");
        requireNonNull(pattern, "pattern");
        this.noOffsetText = noOffsetText;
        this.type = this._checkPattern(pattern);
      }
      var _proto = OffsetIdPrinterParser2.prototype;
      _proto._checkPattern = function _checkPattern(pattern) {
        for (var i = 0; i < PATTERNS.length; i++) {
          if (PATTERNS[i] === pattern) {
            return i;
          }
        }
        throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
      };
      _proto.print = function print(context, buf) {
        var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);
        if (offsetSecs == null) {
          return false;
        }
        var totalSecs = MathUtil.safeToInt(offsetSecs);
        if (totalSecs === 0) {
          buf.append(this.noOffsetText);
        } else {
          var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
          var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
          var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
          var bufPos = buf.length();
          var output = absHours;
          buf.append(totalSecs < 0 ? "-" : "+").appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");
          if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
            buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
            output += absMinutes;
            if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
              buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
              output += absSeconds;
            }
          }
          if (output === 0) {
            buf.setLength(bufPos);
            buf.append(this.noOffsetText);
          }
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        var noOffsetLen = this.noOffsetText.length;
        if (noOffsetLen === 0) {
          if (position === length) {
            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
          }
        } else {
          if (position === length) {
            return ~position;
          }
          if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
          }
        }
        var sign = text[position];
        if (sign === "+" || sign === "-") {
          var negative = sign === "-" ? -1 : 1;
          var array = [0, 0, 0, 0];
          array[0] = position + 1;
          if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
            var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
            return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
          }
        }
        if (noOffsetLen === 0) {
          return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
        }
        return ~position;
      };
      _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
        if ((this.type + 3) / 2 < arrayIndex) {
          return false;
        }
        var pos = array[0];
        if (this.type % 2 === 0 && arrayIndex > 1) {
          if (pos + 1 > parseText.length || parseText[pos] !== ":") {
            return required;
          }
          pos++;
        }
        if (pos + 2 > parseText.length) {
          return required;
        }
        var ch1 = parseText[pos++];
        var ch2 = parseText[pos++];
        if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
          return required;
        }
        var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
        if (value < 0 || value > 59) {
          return required;
        }
        array[arrayIndex] = value;
        array[0] = pos;
        return false;
      };
      _proto.toString = function toString() {
        var converted = this.noOffsetText.replace("'", "''");
        return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
      };
      return OffsetIdPrinterParser2;
    }();
    OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser("Z", "+HH:MM:ss");
    OffsetIdPrinterParser.PATTERNS = PATTERNS;
    PadPrinterParserDecorator = function() {
      function PadPrinterParserDecorator2(printerParser, padWidth, padChar) {
        this._printerParser = printerParser;
        this._padWidth = padWidth;
        this._padChar = padChar;
      }
      var _proto = PadPrinterParserDecorator2.prototype;
      _proto.print = function print(context, buf) {
        var preLen = buf.length();
        if (this._printerParser.print(context, buf) === false) {
          return false;
        }
        var len = buf.length() - preLen;
        if (len > this._padWidth) {
          throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
        }
        for (var i = 0; i < this._padWidth - len; i++) {
          buf.insert(preLen, this._padChar);
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var strict = context.isStrict();
        var caseSensitive = context.isCaseSensitive();
        assert(!(position > text.length));
        assert(position >= 0);
        if (position === text.length) {
          return ~position;
        }
        var endPos = position + this._padWidth;
        if (endPos > text.length) {
          if (strict) {
            return ~position;
          }
          endPos = text.length;
        }
        var pos = position;
        while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
          pos++;
        }
        text = text.substring(0, endPos);
        var resultPos = this._printerParser.parse(context, text, pos);
        if (resultPos !== endPos && strict) {
          return ~(position + pos);
        }
        return resultPos;
      };
      _proto.toString = function toString() {
        return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === " " ? ")" : ",'" + this._padChar + "')");
      };
      return PadPrinterParserDecorator2;
    }();
    SettingsParser = function(_Enum) {
      _inheritsLoose(SettingsParser2, _Enum);
      function SettingsParser2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = SettingsParser2.prototype;
      _proto.print = function print() {
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        switch (this) {
          case SettingsParser2.SENSITIVE:
            context.setCaseSensitive(true);
            break;
          case SettingsParser2.INSENSITIVE:
            context.setCaseSensitive(false);
            break;
          case SettingsParser2.STRICT:
            context.setStrict(true);
            break;
          case SettingsParser2.LENIENT:
            context.setStrict(false);
            break;
        }
        return position;
      };
      _proto.toString = function toString() {
        switch (this) {
          case SettingsParser2.SENSITIVE:
            return "ParseCaseSensitive(true)";
          case SettingsParser2.INSENSITIVE:
            return "ParseCaseSensitive(false)";
          case SettingsParser2.STRICT:
            return "ParseStrict(true)";
          case SettingsParser2.LENIENT:
            return "ParseStrict(false)";
        }
      };
      return SettingsParser2;
    }(Enum);
    SettingsParser.SENSITIVE = new SettingsParser("SENSITIVE");
    SettingsParser.INSENSITIVE = new SettingsParser("INSENSITIVE");
    SettingsParser.STRICT = new SettingsParser("STRICT");
    SettingsParser.LENIENT = new SettingsParser("LENIENT");
    StringLiteralPrinterParser = function() {
      function StringLiteralPrinterParser2(literal) {
        this._literal = literal;
      }
      var _proto = StringLiteralPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        buf.append(this._literal);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        assert(!(position > length || position < 0));
        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
          return ~position;
        }
        return position + this._literal.length;
      };
      _proto.toString = function toString() {
        var converted = this._literal.replace("'", "''");
        return "'" + converted + "'";
      };
      return StringLiteralPrinterParser2;
    }();
    ZoneRulesProvider = function() {
      function ZoneRulesProvider2() {
      }
      ZoneRulesProvider2.getRules = function getRules(zoneId) {
        throw new DateTimeException("unsupported ZoneId:" + zoneId);
      };
      ZoneRulesProvider2.getAvailableZoneIds = function getAvailableZoneIds() {
        return [];
      };
      return ZoneRulesProvider2;
    }();
    ZoneRegion = function(_ZoneId) {
      _inheritsLoose(ZoneRegion2, _ZoneId);
      ZoneRegion2.ofId = function ofId(zoneId) {
        var rules = ZoneRulesProvider.getRules(zoneId);
        return new ZoneRegion2(zoneId, rules);
      };
      function ZoneRegion2(id, rules) {
        var _this;
        _this = _ZoneId.call(this) || this;
        _this._id = id;
        _this._rules = rules;
        return _this;
      }
      var _proto = ZoneRegion2.prototype;
      _proto.id = function id() {
        return this._id;
      };
      _proto.rules = function rules() {
        return this._rules;
      };
      return ZoneRegion2;
    }(ZoneId);
    ZoneIdPrinterParser = function() {
      function ZoneIdPrinterParser2(query, description) {
        this.query = query;
        this.description = description;
      }
      var _proto = ZoneIdPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        var zone = context.getValueQuery(this.query);
        if (zone == null) {
          return false;
        }
        buf.append(zone.id());
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position > length) {
          return ~position;
        }
        if (position === length) {
          return ~position;
        }
        var nextChar = text.charAt(position);
        if (nextChar === "+" || nextChar === "-") {
          var newContext = context.copy();
          var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
          if (endPos < 0) {
            return endPos;
          }
          var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
          var zone = ZoneOffset.ofTotalSeconds(offset);
          context.setParsedZone(zone);
          return endPos;
        } else if (length >= position + 2) {
          var nextNextChar = text.charAt(position + 1);
          if (context.charEquals(nextChar, "U") && context.charEquals(nextNextChar, "T")) {
            if (length >= position + 3 && context.charEquals(text.charAt(position + 2), "C")) {
              return this._parsePrefixedOffset(context, text, position, position + 3);
            }
            return this._parsePrefixedOffset(context, text, position, position + 2);
          } else if (context.charEquals(nextChar, "G") && length >= position + 3 && context.charEquals(nextNextChar, "M") && context.charEquals(text.charAt(position + 2), "T")) {
            return this._parsePrefixedOffset(context, text, position, position + 3);
          }
        }
        if (text.substr(position, 6) === "SYSTEM") {
          context.setParsedZone(ZoneId.systemDefault());
          return position + 6;
        }
        if (context.charEquals(nextChar, "Z")) {
          context.setParsedZone(ZoneOffset.UTC);
          return position + 1;
        }
        var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
        if (zoneIdTree.size !== availableZoneIds.length) {
          zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
        }
        var maxParseLength = length - position;
        var treeMap = zoneIdTree.treeMap;
        var parsedZoneId = null;
        var parseLength = 0;
        while (treeMap != null) {
          var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
          treeMap = treeMap.get(parsedSubZoneId);
          if (treeMap != null && treeMap.isLeaf) {
            parsedZoneId = parsedSubZoneId;
            parseLength = treeMap.length;
          }
        }
        if (parsedZoneId != null) {
          context.setParsedZone(ZoneRegion.ofId(parsedZoneId));
          return position + parseLength;
        }
        return ~position;
      };
      _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {
        var prefix = text.substring(prefixPos, position).toUpperCase();
        var newContext = context.copy();
        if (position < text.length && context.charEquals(text.charAt(position), "Z")) {
          context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
          return position;
        }
        var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
        if (endPos < 0) {
          context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
          return position;
        }
        var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        context.setParsedZone(ZoneId.ofOffset(prefix, offset));
        return endPos;
      };
      _proto.toString = function toString() {
        return this.description;
      };
      return ZoneIdPrinterParser2;
    }();
    ZoneIdTree = function() {
      ZoneIdTree2.createTreeMap = function createTreeMap(availableZoneIds) {
        var sortedZoneIds = availableZoneIds.sort(function(a, b) {
          return a.length - b.length;
        });
        var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
        for (var i = 0; i < sortedZoneIds.length; i++) {
          treeMap.add(sortedZoneIds[i]);
        }
        return new ZoneIdTree2(sortedZoneIds.length, treeMap);
      };
      function ZoneIdTree2(size, treeMap) {
        this.size = size;
        this.treeMap = treeMap;
      }
      return ZoneIdTree2;
    }();
    ZoneIdTreeMap = function() {
      function ZoneIdTreeMap2(length, isLeaf) {
        if (length === void 0) {
          length = 0;
        }
        if (isLeaf === void 0) {
          isLeaf = false;
        }
        this.length = length;
        this.isLeaf = isLeaf;
        this._treeMap = {};
      }
      var _proto2 = ZoneIdTreeMap2.prototype;
      _proto2.add = function add(zoneId) {
        var idLength = zoneId.length;
        if (idLength === this.length) {
          this._treeMap[zoneId] = new ZoneIdTreeMap2(idLength, true);
        } else if (idLength > this.length) {
          var subZoneId = zoneId.substr(0, this.length);
          var subTreeMap = this._treeMap[subZoneId];
          if (subTreeMap == null) {
            subTreeMap = new ZoneIdTreeMap2(idLength, false);
            this._treeMap[subZoneId] = subTreeMap;
          }
          subTreeMap.add(zoneId);
        }
      };
      _proto2.get = function get(zoneId) {
        return this._treeMap[zoneId];
      };
      return ZoneIdTreeMap2;
    }();
    zoneIdTree = new ZoneIdTree([]);
    MAX_WIDTH = 15;
    DateTimeFormatterBuilder = function() {
      function DateTimeFormatterBuilder2() {
        this._active = this;
        this._parent = null;
        this._printerParsers = [];
        this._optional = false;
        this._padNextWidth = 0;
        this._padNextChar = null;
        this._valueParserIndex = -1;
      }
      DateTimeFormatterBuilder2._of = function _of(parent, optional) {
        requireNonNull(parent, "parent");
        requireNonNull(optional, "optional");
        var dtFormatterBuilder = new DateTimeFormatterBuilder2();
        dtFormatterBuilder._parent = parent;
        dtFormatterBuilder._optional = optional;
        return dtFormatterBuilder;
      };
      var _proto = DateTimeFormatterBuilder2.prototype;
      _proto.parseCaseSensitive = function parseCaseSensitive() {
        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
        return this;
      };
      _proto.parseCaseInsensitive = function parseCaseInsensitive() {
        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
        return this;
      };
      _proto.parseStrict = function parseStrict() {
        this._appendInternalPrinterParser(SettingsParser.STRICT);
        return this;
      };
      _proto.parseLenient = function parseLenient() {
        this._appendInternalPrinterParser(SettingsParser.LENIENT);
        return this;
      };
      _proto.parseDefaulting = function parseDefaulting(field, value) {
        requireNonNull(field);
        this._appendInternal(new DefaultingParser(field, value));
        return this;
      };
      _proto.appendValue = function appendValue() {
        if (arguments.length === 1) {
          return this._appendValue1.apply(this, arguments);
        } else if (arguments.length === 2) {
          return this._appendValue2.apply(this, arguments);
        } else {
          return this._appendValue4.apply(this, arguments);
        }
      };
      _proto._appendValue1 = function _appendValue1(field) {
        requireNonNull(field);
        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
        return this;
      };
      _proto._appendValue2 = function _appendValue2(field, width) {
        requireNonNull(field);
        if (width < 1 || width > MAX_WIDTH) {
          throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
        }
        var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
        requireNonNull(field);
        requireNonNull(signStyle);
        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
          return this._appendValue2(field, maxWidth);
        }
        if (minWidth < 1 || minWidth > MAX_WIDTH) {
          throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
        }
        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
          throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
        }
        if (maxWidth < minWidth) {
          throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
        }
        var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto.appendValueReduced = function appendValueReduced() {
        if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
          return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
        } else {
          return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
        }
      };
      _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
        requireNonNull(field, "field");
        var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
        requireNonNull(field, "field");
        requireNonNull(baseDate, "baseDate");
        requireInstance(baseDate, ChronoLocalDate, "baseDate");
        var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
        assert(pp != null);
        if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
          var activeValueParser = this._active._valueParserIndex;
          var basePP = this._active._printerParsers[activeValueParser];
          if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
            basePP = basePP.withSubsequentWidth(pp.maxWidth());
            this._appendInternal(pp.withFixedWidth());
            this._active._valueParserIndex = activeValueParser;
          } else {
            basePP = basePP.withFixedWidth();
            this._active._valueParserIndex = this._appendInternal(pp);
          }
          this._active._printerParsers[activeValueParser] = basePP;
        } else {
          this._active._valueParserIndex = this._appendInternal(pp);
        }
        return this;
      };
      _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
        return this;
      };
      _proto.appendInstant = function appendInstant(fractionalDigits) {
        if (fractionalDigits === void 0) {
          fractionalDigits = -2;
        }
        if (fractionalDigits < -2 || fractionalDigits > 9) {
          throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
        }
        this._appendInternal(new InstantPrinterParser(fractionalDigits));
        return this;
      };
      _proto.appendOffsetId = function appendOffsetId() {
        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
        return this;
      };
      _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
        return this;
      };
      _proto.appendZoneId = function appendZoneId() {
        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), "ZoneId()"));
        return this;
      };
      _proto.appendPattern = function appendPattern(pattern) {
        requireNonNull(pattern, "pattern");
        this._parsePattern(pattern);
        return this;
      };
      _proto.appendZoneText = function appendZoneText() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendText = function appendText() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendLocalizedOffset = function appendLocalizedOffset() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendWeekField = function appendWeekField() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto._parsePattern = function _parsePattern(pattern) {
        var FIELD_MAP = {
          "G": ChronoField.ERA,
          "y": ChronoField.YEAR_OF_ERA,
          "u": ChronoField.YEAR,
          "Q": IsoFields.QUARTER_OF_YEAR,
          "q": IsoFields.QUARTER_OF_YEAR,
          "M": ChronoField.MONTH_OF_YEAR,
          "L": ChronoField.MONTH_OF_YEAR,
          "D": ChronoField.DAY_OF_YEAR,
          "d": ChronoField.DAY_OF_MONTH,
          "F": ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
          "E": ChronoField.DAY_OF_WEEK,
          "c": ChronoField.DAY_OF_WEEK,
          "e": ChronoField.DAY_OF_WEEK,
          "a": ChronoField.AMPM_OF_DAY,
          "H": ChronoField.HOUR_OF_DAY,
          "k": ChronoField.CLOCK_HOUR_OF_DAY,
          "K": ChronoField.HOUR_OF_AMPM,
          "h": ChronoField.CLOCK_HOUR_OF_AMPM,
          "m": ChronoField.MINUTE_OF_HOUR,
          "s": ChronoField.SECOND_OF_MINUTE,
          "S": ChronoField.NANO_OF_SECOND,
          "A": ChronoField.MILLI_OF_DAY,
          "n": ChronoField.NANO_OF_SECOND,
          "N": ChronoField.NANO_OF_DAY
        };
        for (var pos = 0; pos < pattern.length; pos++) {
          var cur = pattern.charAt(pos);
          if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
            var start = pos++;
            for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++)
              ;
            var count = pos - start;
            if (cur === "p") {
              var pad = 0;
              if (pos < pattern.length) {
                cur = pattern.charAt(pos);
                if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
                  pad = count;
                  start = pos++;
                  for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++)
                    ;
                  count = pos - start;
                }
              }
              if (pad === 0) {
                throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
              }
              this.padNext(pad);
            }
            var field = FIELD_MAP[cur];
            if (field != null) {
              this._parseField(cur, count, field);
            } else if (cur === "z") {
              if (count > 4) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              } else if (count === 4) {
                this.appendZoneText(TextStyle.FULL);
              } else {
                this.appendZoneText(TextStyle.SHORT);
              }
            } else if (cur === "V") {
              if (count !== 2) {
                throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
              }
              this.appendZoneId();
            } else if (cur === "Z") {
              if (count < 4) {
                this.appendOffset("+HHMM", "+0000");
              } else if (count === 4) {
                this.appendLocalizedOffset(TextStyle.FULL);
              } else if (count === 5) {
                this.appendOffset("+HH:MM:ss", "Z");
              } else {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
            } else if (cur === "O") {
              if (count === 1) {
                this.appendLocalizedOffset(TextStyle.SHORT);
              } else if (count === 4) {
                this.appendLocalizedOffset(TextStyle.FULL);
              } else {
                throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
              }
            } else if (cur === "X") {
              if (count > 5) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], "Z");
            } else if (cur === "x") {
              if (count > 5) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              var zero = count === 1 ? "+00" : count % 2 === 0 ? "+0000" : "+00:00";
              this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
            } else if (cur === "W") {
              if (count > 1) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendWeekField("W", count);
            } else if (cur === "w") {
              if (count > 2) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendWeekField("w", count);
            } else if (cur === "Y") {
              this.appendWeekField("Y", count);
            } else {
              throw new IllegalArgumentException("Unknown pattern letter: " + cur);
            }
            pos--;
          } else if (cur === "'") {
            var _start = pos++;
            for (; pos < pattern.length; pos++) {
              if (pattern.charAt(pos) === "'") {
                if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === "'") {
                  pos++;
                } else {
                  break;
                }
              }
            }
            if (pos >= pattern.length) {
              throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
            }
            var str = pattern.substring(_start + 1, pos);
            if (str.length === 0) {
              this.appendLiteral("'");
            } else {
              this.appendLiteral(str.replace("''", "'"));
            }
          } else if (cur === "[") {
            this.optionalStart();
          } else if (cur === "]") {
            if (this._active._parent === null) {
              throw new IllegalArgumentException("Pattern invalid as it contains ] without previous [");
            }
            this.optionalEnd();
          } else if (cur === "{" || cur === "}" || cur === "#") {
            throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
          } else {
            this.appendLiteral(cur);
          }
        }
      };
      _proto._parseField = function _parseField(cur, count, field) {
        switch (cur) {
          case "u":
          case "y":
            if (count === 2) {
              this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
            } else if (count < 4) {
              this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
            } else {
              this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
            }
            break;
          case "M":
          case "Q":
            switch (count) {
              case 1:
                this.appendValue(field);
                break;
              case 2:
                this.appendValue(field, 2);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "L":
          case "q":
            switch (count) {
              case 1:
                this.appendValue(field);
                break;
              case 2:
                this.appendValue(field, 2);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT_STANDALONE);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL_STANDALONE);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW_STANDALONE);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "e":
            switch (count) {
              case 1:
              case 2:
                this.appendWeekField("e", count);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "c":
            switch (count) {
              case 1:
                this.appendWeekField("c", count);
                break;
              case 2:
                throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);
              case 3:
                this.appendText(field, TextStyle.SHORT_STANDALONE);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL_STANDALONE);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW_STANDALONE);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "a":
            if (count === 1) {
              this.appendText(field, TextStyle.SHORT);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "E":
          case "G":
            switch (count) {
              case 1:
              case 2:
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "S":
            this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
            break;
          case "F":
            if (count === 1) {
              this.appendValue(field);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "d":
          case "h":
          case "H":
          case "k":
          case "K":
          case "m":
          case "s":
            if (count === 1) {
              this.appendValue(field);
            } else if (count === 2) {
              this.appendValue(field, count);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "D":
            if (count === 1) {
              this.appendValue(field);
            } else if (count <= 3) {
              this.appendValue(field, count);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          default:
            if (count === 1) {
              this.appendValue(field);
            } else {
              this.appendValue(field, count);
            }
            break;
        }
      };
      _proto.padNext = function padNext() {
        if (arguments.length === 1) {
          return this._padNext1.apply(this, arguments);
        } else {
          return this._padNext2.apply(this, arguments);
        }
      };
      _proto._padNext1 = function _padNext1(padWidth) {
        return this._padNext2(padWidth, " ");
      };
      _proto._padNext2 = function _padNext2(padWidth, padChar) {
        if (padWidth < 1) {
          throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
        }
        this._active._padNextWidth = padWidth;
        this._active._padNextChar = padChar;
        this._active._valueParserIndex = -1;
        return this;
      };
      _proto.optionalStart = function optionalStart() {
        this._active._valueParserIndex = -1;
        this._active = DateTimeFormatterBuilder2._of(this._active, true);
        return this;
      };
      _proto.optionalEnd = function optionalEnd() {
        if (this._active._parent == null) {
          throw new IllegalStateException("Cannot call optionalEnd() as there was no previous call to optionalStart()");
        }
        if (this._active._printerParsers.length > 0) {
          var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
          this._active = this._active._parent;
          this._appendInternal(cpp);
        } else {
          this._active = this._active._parent;
        }
        return this;
      };
      _proto._appendInternal = function _appendInternal(pp) {
        assert(pp != null);
        if (this._active._padNextWidth > 0) {
          if (pp != null) {
            pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
          }
          this._active._padNextWidth = 0;
          this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
      };
      _proto.appendLiteral = function appendLiteral(literal) {
        assert(literal != null);
        if (literal.length > 0) {
          if (literal.length === 1) {
            this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
          } else {
            this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
          }
        }
        return this;
      };
      _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
        assert(pp != null);
        if (this._active._padNextWidth > 0) {
          if (pp != null) {
            pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
          }
          this._active._padNextWidth = 0;
          this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
      };
      _proto.append = function append(formatter) {
        requireNonNull(formatter, "formatter");
        this._appendInternal(formatter._toPrinterParser(false));
        return this;
      };
      _proto.toFormatter = function toFormatter(resolverStyle) {
        if (resolverStyle === void 0) {
          resolverStyle = ResolverStyle.SMART;
        }
        while (this._active._parent != null) {
          this.optionalEnd();
        }
        var pp = new CompositePrinterParser(this._printerParsers, false);
        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
      };
      return DateTimeFormatterBuilder2;
    }();
    SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
    SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;
    InstantPrinterParser = function() {
      function InstantPrinterParser2(fractionalDigits) {
        this.fractionalDigits = fractionalDigits;
      }
      var _proto2 = InstantPrinterParser2.prototype;
      _proto2.print = function print(context, buf) {
        var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
        var inNanos = 0;
        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
          inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
        }
        if (inSecs == null) {
          return false;
        }
        var inSec = inSecs;
        var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
        if (inSec >= -SECONDS_0000_TO_1970) {
          var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
          var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
          var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
          var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
          if (hi > 0) {
            buf.append("+").append(hi);
          }
          buf.append(ldt.toString());
          if (ldt.second() === 0) {
            buf.append(":00");
          }
        } else {
          var _zeroSecs = inSec + SECONDS_0000_TO_1970;
          var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
          var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
          var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
          var pos = buf.length();
          buf.append(_ldt.toString());
          if (_ldt.second() === 0) {
            buf.append(":00");
          }
          if (_hi < 0) {
            if (_ldt.year() === -1e4) {
              buf.replace(pos, pos + 2, "" + (_hi - 1));
            } else if (_lo === 0) {
              buf.insert(pos, _hi);
            } else {
              buf.insert(pos + 1, Math.abs(_hi));
            }
          }
        }
        if (this.fractionalDigits === -2) {
          if (inNano !== 0) {
            buf.append(".");
            if (MathUtil.intMod(inNano, 1e6) === 0) {
              buf.append(("" + (MathUtil.intDiv(inNano, 1e6) + 1e3)).substring(1));
            } else if (MathUtil.intMod(inNano, 1e3) === 0) {
              buf.append(("" + (MathUtil.intDiv(inNano, 1e3) + 1e6)).substring(1));
            } else {
              buf.append(("" + (inNano + 1e9)).substring(1));
            }
          }
        } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
          buf.append(".");
          var div = 1e8;
          for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
            var digit = MathUtil.intDiv(inNano, div);
            buf.append(digit);
            inNano = inNano - digit * div;
            div = MathUtil.intDiv(div, 10);
          }
        }
        buf.append("Z");
        return true;
      };
      _proto2.parse = function parse2(context, text, position) {
        var newContext = context.copy();
        var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
        var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
        var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral("Z").toFormatter()._toPrinterParser(false);
        var pos = parser.parse(newContext, text, position);
        if (pos < 0) {
          return pos;
        }
        var yearParsed = newContext.getParsed(ChronoField.YEAR);
        var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
        var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
        var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
        var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
        var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
        var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
        var sec = secVal != null ? secVal : 0;
        var nano = nanoVal != null ? nanoVal : 0;
        var year = MathUtil.intMod(yearParsed, 1e4);
        var days = 0;
        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
          hour = 0;
          days = 1;
        } else if (hour === 23 && min === 59 && sec === 60) {
          context.setParsedLeapSecond();
          sec = 59;
        }
        var instantSecs;
        try {
          var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
          instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
          instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 1e4), SECONDS_PER_10000_YEARS);
        } catch (ex) {
          return ~position;
        }
        var successPos = pos;
        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
      };
      _proto2.toString = function toString() {
        return "Instant()";
      };
      return InstantPrinterParser2;
    }();
    DefaultingParser = function() {
      function DefaultingParser2(field, value) {
        this._field = field;
        this._value = value;
      }
      var _proto3 = DefaultingParser2.prototype;
      _proto3.print = function print() {
        return true;
      };
      _proto3.parse = function parse2(context, text, position) {
        if (context.getParsed(this._field) == null) {
          context.setParsedField(this._field, this._value, position, position);
        }
        return position;
      };
      return DefaultingParser2;
    }();
    StringBuilder = function() {
      function StringBuilder2() {
        this._str = "";
      }
      var _proto = StringBuilder2.prototype;
      _proto.append = function append(str) {
        this._str += str;
        return this;
      };
      _proto.appendChar = function appendChar(str) {
        this._str += str[0];
        return this;
      };
      _proto.insert = function insert(offset, str) {
        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
        return this;
      };
      _proto.replace = function replace(start, end, str) {
        this._str = this._str.slice(0, start) + str + this._str.slice(end);
        return this;
      };
      _proto.length = function length() {
        return this._str.length;
      };
      _proto.setLength = function setLength(length) {
        this._str = this._str.slice(0, length);
        return this;
      };
      _proto.toString = function toString() {
        return this._str;
      };
      return StringBuilder2;
    }();
    DateTimeFormatter = function() {
      DateTimeFormatter2.parsedExcessDays = function parsedExcessDays() {
        return DateTimeFormatter2.PARSED_EXCESS_DAYS;
      };
      DateTimeFormatter2.parsedLeapSecond = function parsedLeapSecond() {
        return DateTimeFormatter2.PARSED_LEAP_SECOND;
      };
      DateTimeFormatter2.ofPattern = function ofPattern(pattern) {
        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
      };
      function DateTimeFormatter2(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
        if (chrono === void 0) {
          chrono = IsoChronology.INSTANCE;
        }
        assert(printerParser != null);
        assert(decimalStyle != null);
        assert(resolverStyle != null);
        this._printerParser = printerParser;
        this._locale = locale;
        this._decimalStyle = decimalStyle;
        this._resolverStyle = resolverStyle;
        this._resolverFields = resolverFields;
        this._chrono = chrono;
        this._zone = zone;
      }
      var _proto = DateTimeFormatter2.prototype;
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.decimalStyle = function decimalStyle() {
        return this._decimalStyle;
      };
      _proto.chronology = function chronology() {
        return this._chrono;
      };
      _proto.withChronology = function withChronology(chrono) {
        if (this._chrono != null && this._chrono.equals(chrono)) {
          return this;
        }
        return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
      };
      _proto.withLocale = function withLocale() {
        return this;
      };
      _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
        requireNonNull(resolverStyle, "resolverStyle");
        if (resolverStyle.equals(this._resolverStyle)) {
          return this;
        }
        return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
      };
      _proto.format = function format(temporal) {
        var buf = new StringBuilder(32);
        this._formatTo(temporal, buf);
        return buf.toString();
      };
      _proto._formatTo = function _formatTo(temporal, appendable) {
        requireNonNull(temporal, "temporal");
        requireNonNull(appendable, "appendable");
        var context = new DateTimePrintContext(temporal, this);
        this._printerParser.print(context, appendable);
      };
      _proto.parse = function parse2(text, type2) {
        if (arguments.length === 1) {
          return this.parse1(text);
        } else {
          return this.parse2(text, type2);
        }
      };
      _proto.parse1 = function parse1(text) {
        requireNonNull(text, "text");
        try {
          return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
        } catch (ex) {
          if (ex instanceof DateTimeParseException) {
            throw ex;
          } else {
            throw this._createError(text, ex);
          }
        }
      };
      _proto.parse2 = function parse2(text, type2) {
        requireNonNull(text, "text");
        requireNonNull(type2, "type");
        try {
          var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
          return builder.build(type2);
        } catch (ex) {
          if (ex instanceof DateTimeParseException) {
            throw ex;
          } else {
            throw this._createError(text, ex);
          }
        }
      };
      _proto._createError = function _createError(text, ex) {
        var abbr = "";
        if (text.length > 64) {
          abbr = text.substring(0, 64) + "...";
        } else {
          abbr = text;
        }
        return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text, 0, ex);
      };
      _proto._parseToBuilder = function _parseToBuilder(text, position) {
        var pos = position != null ? position : new ParsePosition(0);
        var result = this._parseUnresolved0(text, pos);
        if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
          var abbr = "";
          if (text.length > 64) {
            abbr = text.substr(0, 64).toString() + "...";
          } else {
            abbr = text;
          }
          if (pos.getErrorIndex() >= 0) {
            throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text, pos.getErrorIndex());
          } else {
            throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text, pos.getIndex());
          }
        }
        return result.toBuilder();
      };
      _proto.parseUnresolved = function parseUnresolved(text, position) {
        return this._parseUnresolved0(text, position);
      };
      _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {
        assert(text != null, "text", NullPointerException);
        assert(position != null, "position", NullPointerException);
        var context = new DateTimeParseContext(this);
        var pos = position.getIndex();
        pos = this._printerParser.parse(context, text, pos);
        if (pos < 0) {
          position.setErrorIndex(~pos);
          return null;
        }
        position.setIndex(pos);
        return context.toParsed();
      };
      _proto._toPrinterParser = function _toPrinterParser(optional) {
        return this._printerParser.withOptional(optional);
      };
      _proto.toString = function toString() {
        var pattern = this._printerParser.toString();
        return pattern.indexOf("[") === 0 ? pattern : pattern.substring(1, pattern.length - 1);
      };
      return DateTimeFormatter2;
    }();
    MonthDay = function(_TemporalAccessor) {
      _inheritsLoose(MonthDay2, _TemporalAccessor);
      MonthDay2.now = function now(zoneIdOrClock) {
        if (arguments.length === 0) {
          return MonthDay2.now0();
        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
          return MonthDay2.nowZoneId(zoneIdOrClock);
        } else {
          return MonthDay2.nowClock(zoneIdOrClock);
        }
      };
      MonthDay2.now0 = function now0() {
        return this.nowClock(Clock.systemDefaultZone());
      };
      MonthDay2.nowZoneId = function nowZoneId(zone) {
        requireNonNull(zone, "zone");
        return this.nowClock(Clock.system(zone));
      };
      MonthDay2.nowClock = function nowClock(clock) {
        requireNonNull(clock, "clock");
        var now = LocalDate.now(clock);
        return MonthDay2.of(now.month(), now.dayOfMonth());
      };
      MonthDay2.of = function of(monthOrNumber, number) {
        if (arguments.length === 2 && monthOrNumber instanceof Month) {
          return MonthDay2.ofMonthNumber(monthOrNumber, number);
        } else {
          return MonthDay2.ofNumberNumber(monthOrNumber, number);
        }
      };
      MonthDay2.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
        requireNonNull(month, "month");
        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
        if (dayOfMonth > month.maxLength()) {
          throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
        }
        return new MonthDay2(month.value(), dayOfMonth);
      };
      MonthDay2.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
        requireNonNull(month, "month");
        requireNonNull(dayOfMonth, "dayOfMonth");
        return MonthDay2.of(Month.of(month), dayOfMonth);
      };
      MonthDay2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, TemporalAccessor, "temporal");
        if (temporal instanceof MonthDay2) {
          return temporal;
        }
        try {
          return MonthDay2.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      MonthDay2.parse = function parse2(text, formatter) {
        if (arguments.length === 1) {
          return MonthDay2.parseString(text);
        } else {
          return MonthDay2.parseStringFormatter(text, formatter);
        }
      };
      MonthDay2.parseString = function parseString(text) {
        return MonthDay2.parseStringFormatter(text, PARSER$2);
      };
      MonthDay2.parseStringFormatter = function parseStringFormatter(text, formatter) {
        requireNonNull(text, "text");
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.parse(text, MonthDay2.FROM);
      };
      function MonthDay2(month, dayOfMonth) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._month = MathUtil.safeToInt(month);
        _this._day = MathUtil.safeToInt(dayOfMonth);
        return _this;
      }
      var _proto = MonthDay2.prototype;
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._day;
      };
      _proto.isSupported = function isSupported(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return field.range();
        } else if (field === ChronoField.DAY_OF_MONTH) {
          return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
        }
        return _TemporalAccessor.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.DAY_OF_MONTH:
              return this._day;
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.isValidYear = function isValidYear(year) {
        return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
      };
      _proto.withMonth = function withMonth(month) {
        return this.with(Month.of(month));
      };
      _proto.with = function _with(month) {
        requireNonNull(month, "month");
        if (month.value() === this._month) {
          return this;
        }
        var day = Math.min(this._day, month.maxLength());
        return new MonthDay2(month.value(), day);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        if (dayOfMonth === this._day) {
          return this;
        }
        return MonthDay2.of(this._month, dayOfMonth);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        requireInstance(_query, TemporalQuery, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        }
        return _TemporalAccessor.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
        return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
      };
      _proto.atYear = function atYear(year) {
        return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        var cmp = this._month - other.monthValue();
        if (cmp === 0) {
          cmp = this._day - other.dayOfMonth();
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof MonthDay2) {
          var other = obj;
          return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
        }
        return false;
      };
      _proto.toString = function toString() {
        return "--" + (this._month < 10 ? "0" : "") + this._month + (this._day < 10 ? "-0" : "-") + this._day;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      return MonthDay2;
    }(TemporalAccessor);
    YearMonth = function(_Temporal) {
      _inheritsLoose(YearMonth2, _Temporal);
      YearMonth2.now = function now(zoneIdOrClock) {
        if (arguments.length === 0) {
          return YearMonth2.now0();
        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
          return YearMonth2.nowZoneId(zoneIdOrClock);
        } else {
          return YearMonth2.nowClock(zoneIdOrClock);
        }
      };
      YearMonth2.now0 = function now0() {
        return YearMonth2.nowClock(Clock.systemDefaultZone());
      };
      YearMonth2.nowZoneId = function nowZoneId(zone) {
        return YearMonth2.nowClock(Clock.system(zone));
      };
      YearMonth2.nowClock = function nowClock(clock) {
        var now = LocalDate.now(clock);
        return YearMonth2.of(now.year(), now.month());
      };
      YearMonth2.of = function of(year, monthOrNumber) {
        if (arguments.length === 2 && monthOrNumber instanceof Month) {
          return YearMonth2.ofNumberMonth(year, monthOrNumber);
        } else {
          return YearMonth2.ofNumberNumber(year, monthOrNumber);
        }
      };
      YearMonth2.ofNumberMonth = function ofNumberMonth(year, month) {
        requireNonNull(month, "month");
        requireInstance(month, Month, "month");
        return YearMonth2.ofNumberNumber(year, month.value());
      };
      YearMonth2.ofNumberNumber = function ofNumberNumber(year, month) {
        requireNonNull(year, "year");
        requireNonNull(month, "month");
        ChronoField.YEAR.checkValidValue(year);
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        return new YearMonth2(year, month);
      };
      YearMonth2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof YearMonth2) {
          return temporal;
        }
        try {
          return YearMonth2.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      YearMonth2.parse = function parse2(text, formatter) {
        if (arguments.length === 1) {
          return YearMonth2.parseString(text);
        } else {
          return YearMonth2.parseStringFormatter(text, formatter);
        }
      };
      YearMonth2.parseString = function parseString(text) {
        return YearMonth2.parseStringFormatter(text, PARSER$1);
      };
      YearMonth2.parseStringFormatter = function parseStringFormatter(text, formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, YearMonth2.FROM);
      };
      function YearMonth2(year, month) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this._year = MathUtil.safeToInt(year);
        _this._month = MathUtil.safeToInt(month);
        return _this;
      }
      var _proto = YearMonth2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
          return this.isSupportedField(fieldOrUnit);
        } else {
          return this.isSupportedUnit(fieldOrUnit);
        }
      };
      _proto.isSupportedField = function isSupportedField(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.isSupportedUnit = function isSupportedUnit(unit) {
        if (unit instanceof ChronoUnit) {
          return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
        }
        return unit != null && unit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.YEAR_OF_ERA) {
          return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
        }
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
            case ChronoField.PROLEPTIC_MONTH:
              return this._getProlepticMonth();
            case ChronoField.YEAR_OF_ERA:
              return this._year < 1 ? 1 - this._year : this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year < 1 ? 0 : 1;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto._getProlepticMonth = function _getProlepticMonth() {
        return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
      };
      _proto.year = function year() {
        return this._year;
      };
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.isLeapYear = function isLeapYear() {
        return IsoChronology.isLeapYear(this._year);
      };
      _proto.isValidDay = function isValidDay(dayOfMonth) {
        return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
      };
      _proto.lengthOfMonth = function lengthOfMonth() {
        return this.month().length(this.isLeapYear());
      };
      _proto.lengthOfYear = function lengthOfYear() {
        return this.isLeapYear() ? 366 : 365;
      };
      _proto.with = function _with(adjusterOrField, value) {
        if (arguments.length === 1) {
          return this._withAdjuster(adjusterOrField);
        } else {
          return this._withField(adjusterOrField, value);
        }
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          var f = field;
          f.checkValidValue(newValue);
          switch (f) {
            case ChronoField.MONTH_OF_YEAR:
              return this.withMonth(newValue);
            case ChronoField.PROLEPTIC_MONTH:
              return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
            case ChronoField.YEAR_OF_ERA:
              return this.withYear(this._year < 1 ? 1 - newValue : newValue);
            case ChronoField.YEAR:
              return this.withYear(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        ChronoField.YEAR.checkValidValue(year);
        return new YearMonth2(year, this._month);
      };
      _proto.withMonth = function withMonth(month) {
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        return new YearMonth2(this._year, month);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.MONTHS:
              return this.plusMonths(amountToAdd);
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
        return this.withYear(newYear);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        var monthCount = this._year * 12 + (this._month - 1);
        var calcMonths = monthCount + monthsToAdd;
        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
        return new YearMonth2(newYear, newMonth);
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        requireInstance(_query, TemporalQuery, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.MONTHS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, Temporal, "temporal");
        return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        requireInstance(endExclusive, Temporal, "endExclusive");
        requireInstance(unit, TemporalUnit, "unit");
        var end = YearMonth2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();
          switch (unit) {
            case ChronoUnit.MONTHS:
              return monthsUntil;
            case ChronoUnit.YEARS:
              return MathUtil.intDiv(monthsUntil, 12);
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(monthsUntil, 120);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(monthsUntil, 1200);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(monthsUntil, 12e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.atDay = function atDay(dayOfMonth) {
        requireNonNull(dayOfMonth, "dayOfMonth");
        return LocalDate.of(this._year, this._month, dayOfMonth);
      };
      _proto.atEndOfMonth = function atEndOfMonth() {
        return LocalDate.of(this._year, this._month, this.lengthOfMonth());
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, YearMonth2, "other");
        var cmp = this._year - other.year();
        if (cmp === 0) {
          cmp = this._month - other.monthValue();
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof YearMonth2) {
          var other = obj;
          return this.year() === other.year() && this.monthValue() === other.monthValue();
        }
        return false;
      };
      _proto.toString = function toString() {
        return PARSER$1.format(this);
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return YearMonth2;
    }(Temporal);
    Year = function(_Temporal) {
      _inheritsLoose(Year2, _Temporal);
      function Year2(value) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this._year = MathUtil.safeToInt(value);
        return _this;
      }
      var _proto = Year2.prototype;
      _proto.value = function value() {
        return this._year;
      };
      Year2.now = function now(zoneIdOrClock) {
        if (zoneIdOrClock === void 0) {
          zoneIdOrClock = void 0;
        }
        if (zoneIdOrClock === void 0) {
          return Year2.now0();
        } else if (zoneIdOrClock instanceof ZoneId) {
          return Year2.nowZoneId(zoneIdOrClock);
        } else {
          return Year2.nowClock(zoneIdOrClock);
        }
      };
      Year2.now0 = function now0() {
        return Year2.nowClock(Clock.systemDefaultZone());
      };
      Year2.nowZoneId = function nowZoneId(zone) {
        requireNonNull(zone, "zone");
        requireInstance(zone, ZoneId, "zone");
        return Year2.nowClock(Clock.system(zone));
      };
      Year2.nowClock = function nowClock(clock) {
        requireNonNull(clock, "clock");
        requireInstance(clock, Clock, "clock");
        var now = LocalDate.now(clock);
        return Year2.of(now.year());
      };
      Year2.of = function of(isoYear) {
        requireNonNull(isoYear, "isoYear");
        ChronoField.YEAR.checkValidValue(isoYear);
        return new Year2(isoYear);
      };
      Year2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, TemporalAccessor, "temporal");
        if (temporal instanceof Year2) {
          return temporal;
        }
        try {
          return Year2.of(temporal.get(ChronoField.YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      Year2.parse = function parse2(text, formatter) {
        if (arguments.length <= 1) {
          return Year2.parseText(text);
        } else {
          return Year2.parseTextFormatter(text, formatter);
        }
      };
      Year2.parseText = function parseText(text) {
        requireNonNull(text, "text");
        return Year2.parse(text, PARSER);
      };
      Year2.parseTextFormatter = function parseTextFormatter(text, formatter) {
        if (formatter === void 0) {
          formatter = PARSER;
        }
        requireNonNull(text, "text");
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.parse(text, Year2.FROM);
      };
      Year2.isLeap = function isLeap(year) {
        return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
          return this.isSupportedField(fieldOrUnit);
        } else {
          return this.isSupportedUnit(fieldOrUnit);
        }
      };
      _proto.isSupportedField = function isSupportedField(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.isSupportedUnit = function isSupportedUnit(unit) {
        if (unit instanceof ChronoUnit) {
          return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
        }
        return unit != null && unit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (this.isSupported(field)) {
          return field.range();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.YEAR_OF_ERA:
              return this._year < 1 ? 1 - this._year : this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year < 1 ? 0 : 1;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.isLeap = function isLeap() {
        return Year2.isLeap(this._year);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.YEAR_OF_ERA:
              return Year2.of(this._year < 1 ? 1 - newValue : newValue);
            case ChronoField.YEAR:
              return Year2.of(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : Year2.of(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        return Year2.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.YEAR, this._year);
      };
      _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
        return monthDay != null && monthDay.isValidYear(this._year);
      };
      _proto.length = function length() {
        return this.isLeap() ? 366 : 365;
      };
      _proto.atDay = function atDay(dayOfYear) {
        return LocalDate.ofYearDay(this._year, dayOfYear);
      };
      _proto.atMonth = function atMonth(monthOrNumber) {
        if (arguments.length === 1 && monthOrNumber instanceof Month) {
          return this.atMonthMonth(monthOrNumber);
        } else {
          return this.atMonthNumber(monthOrNumber);
        }
      };
      _proto.atMonthMonth = function atMonthMonth(month) {
        requireNonNull(month, "month");
        requireInstance(month, Month, "month");
        return YearMonth.of(this._year, month);
      };
      _proto.atMonthNumber = function atMonthNumber(month) {
        requireNonNull(month, "month");
        return YearMonth.of(this._year, month);
      };
      _proto.atMonthDay = function atMonthDay(monthDay) {
        requireNonNull(monthDay, "monthDay");
        requireInstance(monthDay, MonthDay, "monthDay");
        return monthDay.atYear(this._year);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query()");
        requireInstance(_query, TemporalQuery, "query()");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.YEARS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year - other._year;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year > other._year;
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year < other._year;
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Year2) {
          return this.value() === other.value();
        }
        return false;
      };
      _proto.toString = function toString() {
        return "" + this._year;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.until = function until(endExclusive, unit) {
        var end = Year2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var yearsUntil = end.value() - this.value();
          switch (unit) {
            case ChronoUnit.YEARS:
              return yearsUntil;
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(yearsUntil, 10);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(yearsUntil, 100);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(yearsUntil, 1e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      return Year2;
    }(Temporal);
    TemporalAdjuster = function() {
      function TemporalAdjuster2() {
      }
      var _proto = TemporalAdjuster2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        abstractMethodFail("adjustInto");
      };
      return TemporalAdjuster2;
    }();
    TemporalAdjusters = function() {
      function TemporalAdjusters2() {
      }
      TemporalAdjusters2.firstDayOfMonth = function firstDayOfMonth() {
        return Impl.FIRST_DAY_OF_MONTH;
      };
      TemporalAdjusters2.lastDayOfMonth = function lastDayOfMonth() {
        return Impl.LAST_DAY_OF_MONTH;
      };
      TemporalAdjusters2.firstDayOfNextMonth = function firstDayOfNextMonth() {
        return Impl.FIRST_DAY_OF_NEXT_MONTH;
      };
      TemporalAdjusters2.firstDayOfYear = function firstDayOfYear() {
        return Impl.FIRST_DAY_OF_YEAR;
      };
      TemporalAdjusters2.lastDayOfYear = function lastDayOfYear() {
        return Impl.LAST_DAY_OF_YEAR;
      };
      TemporalAdjusters2.firstDayOfNextYear = function firstDayOfNextYear() {
        return Impl.FIRST_DAY_OF_NEXT_YEAR;
      };
      TemporalAdjusters2.firstInMonth = function firstInMonth(dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(1, dayOfWeek);
      };
      TemporalAdjusters2.lastInMonth = function lastInMonth(dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(-1, dayOfWeek);
      };
      TemporalAdjusters2.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(ordinal, dayOfWeek);
      };
      TemporalAdjusters2.next = function next(dayOfWeek) {
        return new RelativeDayOfWeek(2, dayOfWeek);
      };
      TemporalAdjusters2.nextOrSame = function nextOrSame(dayOfWeek) {
        return new RelativeDayOfWeek(0, dayOfWeek);
      };
      TemporalAdjusters2.previous = function previous(dayOfWeek) {
        return new RelativeDayOfWeek(3, dayOfWeek);
      };
      TemporalAdjusters2.previousOrSame = function previousOrSame(dayOfWeek) {
        return new RelativeDayOfWeek(1, dayOfWeek);
      };
      return TemporalAdjusters2;
    }();
    Impl = function(_TemporalAdjuster) {
      _inheritsLoose(Impl2, _TemporalAdjuster);
      function Impl2(ordinal) {
        var _this;
        _this = _TemporalAdjuster.call(this) || this;
        _this._ordinal = ordinal;
        return _this;
      }
      var _proto = Impl2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        switch (this._ordinal) {
          case 0:
            return temporal.with(ChronoField.DAY_OF_MONTH, 1);
          case 1:
            return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
          case 2:
            return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
          case 3:
            return temporal.with(ChronoField.DAY_OF_YEAR, 1);
          case 4:
            return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
          case 5:
            return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
        }
        throw new IllegalStateException("Unreachable");
      };
      return Impl2;
    }(TemporalAdjuster);
    Impl.FIRST_DAY_OF_MONTH = new Impl(0);
    Impl.LAST_DAY_OF_MONTH = new Impl(1);
    Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
    Impl.FIRST_DAY_OF_YEAR = new Impl(3);
    Impl.LAST_DAY_OF_YEAR = new Impl(4);
    Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);
    DayOfWeekInMonth = function(_TemporalAdjuster2) {
      _inheritsLoose(DayOfWeekInMonth2, _TemporalAdjuster2);
      function DayOfWeekInMonth2(ordinal, dow) {
        var _this2;
        _this2 = _TemporalAdjuster2.call(this) || this;
        _this2._ordinal = ordinal;
        _this2._dowValue = dow.value();
        return _this2;
      }
      var _proto2 = DayOfWeekInMonth2.prototype;
      _proto2.adjustInto = function adjustInto(temporal) {
        if (this._ordinal >= 0) {
          var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
          var curDow = temp.get(ChronoField.DAY_OF_WEEK);
          var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
          dowDiff += (this._ordinal - 1) * 7;
          return temp.plus(dowDiff, ChronoUnit.DAYS);
        } else {
          var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
          var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
          var daysDiff = this._dowValue - _curDow;
          daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
          daysDiff -= (-this._ordinal - 1) * 7;
          return _temp.plus(daysDiff, ChronoUnit.DAYS);
        }
      };
      return DayOfWeekInMonth2;
    }(TemporalAdjuster);
    RelativeDayOfWeek = function(_TemporalAdjuster3) {
      _inheritsLoose(RelativeDayOfWeek2, _TemporalAdjuster3);
      function RelativeDayOfWeek2(relative, dayOfWeek) {
        var _this3;
        _this3 = _TemporalAdjuster3.call(this) || this;
        requireNonNull(dayOfWeek, "dayOfWeek");
        _this3._relative = relative;
        _this3._dowValue = dayOfWeek.value();
        return _this3;
      }
      var _proto3 = RelativeDayOfWeek2.prototype;
      _proto3.adjustInto = function adjustInto(temporal) {
        var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
        if (this._relative < 2 && calDow === this._dowValue) {
          return temporal;
        }
        if ((this._relative & 1) === 0) {
          var daysDiff = calDow - this._dowValue;
          return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
        } else {
          var _daysDiff = this._dowValue - calDow;
          return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
        }
      };
      return RelativeDayOfWeek2;
    }(TemporalAdjuster);
    IsoChronology = function(_Enum) {
      _inheritsLoose(IsoChronology2, _Enum);
      function IsoChronology2() {
        return _Enum.apply(this, arguments) || this;
      }
      IsoChronology2.isLeapYear = function isLeapYear(prolepticYear) {
        return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
      };
      var _proto = IsoChronology2.prototype;
      _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
        requireNonNull(fieldValues, "fieldValues");
        requireNonNull(field, "field");
        var current = fieldValues.get(field);
        if (current != null && current !== value) {
          throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
        }
        fieldValues.put(field, value);
      };
      _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
          return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
        }
        var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
        if (prolepticMonth != null) {
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
          }
          this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
          this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
        }
        var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
        if (yoeLong != null) {
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
          }
          var era = fieldValues.remove(ChronoField.ERA);
          if (era == null) {
            var year = fieldValues.get(ChronoField.YEAR);
            if (resolverStyle === ResolverStyle.STRICT) {
              if (year != null) {
                this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
              } else {
                fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
              }
            } else {
              this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
            }
          } else if (era === 1) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
          } else if (era === 0) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
          } else {
            throw new DateTimeException("Invalid value for era: " + era);
          }
        } else if (fieldValues.containsKey(ChronoField.ERA)) {
          ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
        }
        if (fieldValues.containsKey(ChronoField.YEAR)) {
          if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
            if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
              var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
              var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
              if (resolverStyle === ResolverStyle.LENIENT) {
                var months = moy - 1;
                var days = dom - 1;
                return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
              } else if (resolverStyle === ResolverStyle.SMART) {
                ChronoField.DAY_OF_MONTH.checkValidValue(dom);
                if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
                  dom = Math.min(dom, 30);
                } else if (moy === 2) {
                  dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
                }
                return LocalDate.of(y, moy, dom);
              } else {
                return LocalDate.of(y, moy, dom);
              }
            }
          }
          if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
            var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
            if (resolverStyle === ResolverStyle.LENIENT) {
              var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
              return LocalDate.ofYearDay(_y, 1).plusDays(_days);
            }
            var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
            return LocalDate.ofYearDay(_y, doy);
          }
          if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
            if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
              var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
                return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
              }
              var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
              var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
              var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
              if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
                throw new DateTimeException("Strict mode rejected date parsed to a different year");
              }
              return date;
            }
            if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
              var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
                return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
              }
              var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
              var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
              var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
              if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
                throw new DateTimeException("Strict mode rejected date parsed to a different month");
              }
              return _date;
            }
          }
        }
        return null;
      };
      _proto.date = function date(temporal) {
        return LocalDate.from(temporal);
      };
      return IsoChronology2;
    }(Enum);
    OffsetTime = function(_Temporal) {
      _inheritsLoose(OffsetTime2, _Temporal);
      OffsetTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof OffsetTime2) {
          return temporal;
        } else if (temporal instanceof OffsetDateTime) {
          return temporal.toOffsetTime();
        }
        try {
          var time = LocalTime.from(temporal);
          var offset = ZoneOffset.from(temporal);
          return new OffsetTime2(time, offset);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      OffsetTime2.now = function now(clockOrZone) {
        if (arguments.length === 0) {
          return OffsetTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return OffsetTime2._now(clockOrZone);
        } else {
          return OffsetTime2._now(Clock.system(clockOrZone));
        }
      };
      OffsetTime2._now = function _now(clock) {
        requireNonNull(clock, "clock");
        var now = clock.instant();
        return OffsetTime2.ofInstant(now, clock.zone().rules().offset(now));
      };
      OffsetTime2.of = function of() {
        if (arguments.length <= 2) {
          return OffsetTime2.ofTimeAndOffset.apply(this, arguments);
        } else {
          return OffsetTime2.ofNumbers.apply(this, arguments);
        }
      };
      OffsetTime2.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
        var time = LocalTime.of(hour, minute, second, nanoOfSecond);
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.ofInstant = function ofInstant(instant, zone) {
        requireNonNull(instant, "instant");
        requireInstance(instant, Instant, "instant");
        requireNonNull(zone, "zone");
        requireInstance(zone, ZoneId, "zone");
        var rules = zone.rules();
        var offset = rules.offset(instant);
        var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
        secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;
        if (secsOfDay < 0) {
          secsOfDay += LocalTime.SECONDS_PER_DAY;
        }
        var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_OFFSET_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, OffsetTime2.FROM);
      };
      function OffsetTime2(time, offset) {
        var _this;
        _this = _Temporal.call(this) || this;
        requireNonNull(time, "time");
        requireInstance(time, LocalTime, "time");
        requireNonNull(offset, "offset");
        requireInstance(offset, ZoneOffset, "offset");
        _this._time = time;
        _this._offset = offset;
        return _this;
      }
      var _proto = OffsetTime2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
      };
      _proto.atDate = function atDate(date) {
        return OffsetDateTime.of(date, this._time, this._offset);
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this, OffsetTime2.FROM);
      };
      _proto.get = function get(field) {
        return _Temporal.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._offset.totalSeconds();
          }
          return this._time.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.hour = function hour() {
        return this._time.hour();
      };
      _proto.minute = function minute() {
        return this._time.minute();
      };
      _proto.second = function second() {
        return this._time.second();
      };
      _proto.nano = function nano() {
        return this._time.nano();
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() > other._toEpochNano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() < other._toEpochNano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() === other._toEpochNano();
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount);
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this.plus(-1 * amountToSubtract, unit);
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount);
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this.offset();
        } else if (_query === TemporalQueries.localTime()) {
          return this._time;
        } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._time.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._time;
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = OffsetTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var nanosUntil = end._toEpochNano() - this._toEpochNano();
          switch (unit) {
            case ChronoUnit.NANOS:
              return nanosUntil;
            case ChronoUnit.MICROS:
              return MathUtil.intDiv(nanosUntil, 1e3);
            case ChronoUnit.MILLIS:
              return MathUtil.intDiv(nanosUntil, 1e6);
            case ChronoUnit.SECONDS:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.withHour = function withHour(hour) {
        return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
      };
      _proto.withMinute = function withMinute(minute) {
        return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
      };
      _proto.withSecond = function withSecond(second) {
        return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
      };
      _proto.withNano = function withNano(nano) {
        return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
      };
      _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
        requireNonNull(offset, "offset");
        if (offset.equals(this._offset)) {
          return this;
        }
        var difference = offset.totalSeconds() - this._offset.totalSeconds();
        var adjusted = this._time.plusSeconds(difference);
        return new OffsetTime2(adjusted, offset);
      };
      _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
        return offset != null && offset.equals(this._offset) ? this : new OffsetTime2(this._time, offset);
      };
      _proto._toEpochNano = function _toEpochNano() {
        var nod = this._time.toNanoOfDay();
        var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
        return nod - offsetNanos;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalTime) {
          return this._withLocalTimeOffset(adjuster, this._offset);
        } else if (adjuster instanceof ZoneOffset) {
          return this._withLocalTimeOffset(this._time, adjuster);
        } else if (adjuster instanceof OffsetTime2) {
          return adjuster;
        }
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
          }
          return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {
        if (this._time === time && this._offset.equals(offset)) {
          return this;
        }
        return new OffsetTime2(time, offset);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, OffsetTime2, "other");
        if (this._offset.equals(other._offset)) {
          return this._time.compareTo(other._time);
        }
        var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());
        if (compare === 0) {
          return this._time.compareTo(other._time);
        }
        return compare;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof OffsetTime2) {
          return this._time.equals(other._time) && this._offset.equals(other._offset);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._time.hashCode() ^ this._offset.hashCode();
      };
      _proto.toString = function toString() {
        return this._time.toString() + this._offset.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return OffsetTime2;
    }(Temporal);
    ChronoZonedDateTime = function(_Temporal) {
      _inheritsLoose(ChronoZonedDateTime2, _Temporal);
      function ChronoZonedDateTime2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoZonedDateTime2.prototype;
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
          return this.zone();
        } else if (_query === TemporalQueries.chronology()) {
          return this.toLocalDate().chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset()) {
          return this.offset();
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      _proto.toInstant = function toInstant() {
        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
      };
      _proto.toEpochSecond = function toEpochSecond() {
        var epochDay = this.toLocalDate().toEpochDay();
        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
        secs -= this.offset().totalSeconds();
        return secs;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
        if (cmp === 0) {
          cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
          if (cmp === 0) {
            cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
            if (cmp === 0) {
              cmp = strcmp(this.zone().id(), other.zone().id());
            }
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ChronoZonedDateTime2) {
          return this.compareTo(other) === 0;
        }
        return false;
      };
      return ChronoZonedDateTime2;
    }(Temporal);
    ZonedDateTime = function(_ChronoZonedDateTime) {
      _inheritsLoose(ZonedDateTime2, _ChronoZonedDateTime);
      ZonedDateTime2.now = function now(clockOrZone) {
        var clock;
        if (clockOrZone instanceof ZoneId) {
          clock = Clock.system(clockOrZone);
        } else {
          clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
        }
        return ZonedDateTime2.ofInstant(clock.instant(), clock.zone());
      };
      ZonedDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return ZonedDateTime2.of2.apply(this, arguments);
        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
          return ZonedDateTime2.of3.apply(this, arguments);
        } else {
          return ZonedDateTime2.of8.apply(this, arguments);
        }
      };
      ZonedDateTime2.of3 = function of3(date, time, zone) {
        return ZonedDateTime2.of2(LocalDateTime.of(date, time), zone);
      };
      ZonedDateTime2.of2 = function of2(localDateTime, zone) {
        return ZonedDateTime2.ofLocal(localDateTime, zone, null);
      };
      ZonedDateTime2.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
        return ZonedDateTime2.ofLocal(dt, zone, null);
      };
      ZonedDateTime2.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(zone, "zone");
        if (zone instanceof ZoneOffset) {
          return new ZonedDateTime2(localDateTime, zone, zone);
        }
        var offset = null;
        var rules = zone.rules();
        var validOffsets = rules.validOffsets(localDateTime);
        if (validOffsets.length === 1) {
          offset = validOffsets[0];
        } else if (validOffsets.length === 0) {
          var trans = rules.transition(localDateTime);
          localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
          offset = trans.offsetAfter();
        } else {
          if (preferredOffset != null && validOffsets.some(function(validOffset) {
            return validOffset.equals(preferredOffset);
          })) {
            offset = preferredOffset;
          } else {
            offset = requireNonNull(validOffsets[0], "offset");
          }
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.ofInstant = function ofInstant() {
        if (arguments.length === 2) {
          return ZonedDateTime2.ofInstant2.apply(this, arguments);
        } else {
          return ZonedDateTime2.ofInstant3.apply(this, arguments);
        }
      };
      ZonedDateTime2.ofInstant2 = function ofInstant2(instant, zone) {
        requireNonNull(instant, "instant");
        requireNonNull(zone, "zone");
        return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), zone);
      };
      ZonedDateTime2.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        return ZonedDateTime2._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
      };
      ZonedDateTime2._create = function _create(epochSecond, nanoOfSecond, zone) {
        var rules = zone.rules();
        var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
        var offset = rules.offset(instant);
        var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
        return new ZonedDateTime2(ldt, offset, zone);
      };
      ZonedDateTime2.ofStrict = function ofStrict(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        var rules = zone.rules();
        if (rules.isValidOffset(localDateTime, offset) === false) {
          var trans = rules.transition(localDateTime);
          if (trans != null && trans.isGap()) {
            throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
          }
          throw new DateTimeException('ZoneOffset "' + offset + '" is not valid for LocalDateTime "' + localDateTime + '" in zone "' + zone + '"');
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.ofLenient = function ofLenient(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
          throw new IllegalArgumentException("ZoneId must match ZoneOffset");
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof ZonedDateTime2) {
          return temporal;
        }
        var zone = ZoneId.from(temporal);
        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
          var zdt = ZonedDateTime2._from(temporal, zone);
          if (zdt != null)
            return zdt;
        }
        var ldt = LocalDateTime.from(temporal);
        return ZonedDateTime2.of2(ldt, zone);
      };
      ZonedDateTime2._from = function _from(temporal, zone) {
        try {
          return ZonedDateTime2.__from(temporal, zone);
        } catch (ex) {
          if (!(ex instanceof DateTimeException))
            throw ex;
        }
      };
      ZonedDateTime2.__from = function __from(temporal, zone) {
        var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
        var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
        return ZonedDateTime2._create(epochSecond, nanoOfSecond, zone);
      };
      ZonedDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, ZonedDateTime2.FROM);
      };
      function ZonedDateTime2(dateTime, offset, zone) {
        var _this;
        requireNonNull(dateTime, "dateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        _this = _ChronoZonedDateTime.call(this) || this;
        _this._dateTime = dateTime;
        _this._offset = offset;
        _this._zone = zone;
        return _this;
      }
      var _proto = ZonedDateTime2.prototype;
      _proto._resolveLocal = function _resolveLocal(newDateTime) {
        requireNonNull(newDateTime, "newDateTime");
        return ZonedDateTime2.ofLocal(newDateTime, this._zone, this._offset);
      };
      _proto._resolveInstant = function _resolveInstant(newDateTime) {
        return ZonedDateTime2.ofInstant3(newDateTime, this._offset, this._zone);
      };
      _proto._resolveOffset = function _resolveOffset(offset) {
        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
          return new ZonedDateTime2(this._dateTime, offset, this._zone);
        }
        return this;
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return true;
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._dateTime.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return this.toEpochSecond();
            case ChronoField.OFFSET_SECONDS:
              return this._offset.totalSeconds();
          }
          return this._dateTime.getLong(field);
        }
        requireNonNull(field, "field");
        return field.getFrom(this);
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
        var trans = this._zone.rules().transition(this._dateTime);
        if (trans != null && trans.isOverlap()) {
          var earlierOffset = trans.offsetBefore();
          if (earlierOffset.equals(this._offset) === false) {
            return new ZonedDateTime2(this._dateTime, earlierOffset, this._zone);
          }
        }
        return this;
      };
      _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
        var trans = this._zone.rules().transition(this.toLocalDateTime());
        if (trans != null) {
          var laterOffset = trans.offsetAfter();
          if (laterOffset.equals(this._offset) === false) {
            return new ZonedDateTime2(this._dateTime, laterOffset, this._zone);
          }
        }
        return this;
      };
      _proto.zone = function zone() {
        return this._zone;
      };
      _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
        requireNonNull(zone, "zone");
        return this._zone.equals(zone) ? this : ZonedDateTime2.ofLocal(this._dateTime, zone, this._offset);
      };
      _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
        requireNonNull(zone, "zone");
        return this._zone.equals(zone) ? this : ZonedDateTime2._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
      };
      _proto.withFixedOffsetZone = function withFixedOffsetZone() {
        return this._zone.equals(this._offset) ? this : new ZonedDateTime2(this._dateTime, this._offset, this._offset);
      };
      _proto.year = function year() {
        return this._dateTime.year();
      };
      _proto.monthValue = function monthValue() {
        return this._dateTime.monthValue();
      };
      _proto.month = function month() {
        return this._dateTime.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._dateTime.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._dateTime.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._dateTime.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._dateTime.hour();
      };
      _proto.minute = function minute() {
        return this._dateTime.minute();
      };
      _proto.second = function second() {
        return this._dateTime.second();
      };
      _proto.nano = function nano() {
        return this._dateTime.nano();
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        if (adjuster instanceof LocalDate) {
          return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
        } else if (adjuster instanceof LocalTime) {
          return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
        } else if (adjuster instanceof LocalDateTime) {
          return this._resolveLocal(adjuster);
        } else if (adjuster instanceof Instant) {
          var instant = adjuster;
          return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), this._zone);
        } else if (adjuster instanceof ZoneOffset) {
          return this._resolveOffset(adjuster);
        }
        return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return ZonedDateTime2._create(newValue, this.nano(), this._zone);
            case ChronoField.OFFSET_SECONDS: {
              var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
              return this._resolveOffset(offset);
            }
          }
          return this._resolveLocal(this._dateTime.with(field, newValue));
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        return this._resolveLocal(this._dateTime.withYear(year));
      };
      _proto.withMonth = function withMonth(month) {
        return this._resolveLocal(this._dateTime.withMonth(month));
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
      };
      _proto.withHour = function withHour(hour) {
        return this._resolveLocal(this._dateTime.withHour(hour));
      };
      _proto.withMinute = function withMinute(minute) {
        return this._resolveLocal(this._dateTime.withMinute(minute));
      };
      _proto.withSecond = function withSecond(second) {
        return this._resolveLocal(this._dateTime.withSecond(second));
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._resolveLocal(this._dateTime.truncatedTo(unit));
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          if (unit.isDateBased()) {
            return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
          } else {
            return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
          }
        }
        requireNonNull(unit, "unit");
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        return this._resolveLocal(this._dateTime.plusYears(years));
      };
      _proto.plusMonths = function plusMonths(months) {
        return this._resolveLocal(this._dateTime.plusMonths(months));
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        return this._resolveLocal(this._dateTime.plusWeeks(weeks));
      };
      _proto.plusDays = function plusDays(days) {
        return this._resolveLocal(this._dateTime.plusDays(days));
      };
      _proto.plusHours = function plusHours(hours) {
        return this._resolveInstant(this._dateTime.plusHours(hours));
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._resolveInstant(this._dateTime.plusMinutes(minutes));
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._resolveInstant(this._dateTime.plusSeconds(seconds));
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._resolveInstant(this._dateTime.plusNanos(nanos));
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this.plusYears(-1 * years);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this.plusMonths(-1 * months);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this.plusWeeks(-1 * weeks);
      };
      _proto.minusDays = function minusDays(days) {
        return this.plusDays(-1 * days);
      };
      _proto.minusHours = function minusHours(hours) {
        return this.plusHours(-1 * hours);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this.plusMinutes(-1 * minutes);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this.plusSeconds(-1 * seconds);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this.plusNanos(-1 * nanos);
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        }
        requireNonNull(_query, "query");
        return _ChronoZonedDateTime.prototype.query.call(this, _query);
      };
      _proto.until = function until(endExclusive, unit) {
        var end = ZonedDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          end = end.withZoneSameInstant(this._zone);
          if (unit.isDateBased()) {
            return this._dateTime.until(end._dateTime, unit);
          } else {
            var difference = this._offset.totalSeconds() - end._offset.totalSeconds();
            var adjustedEnd = end._dateTime.plusSeconds(difference);
            return this._dateTime.until(adjustedEnd, unit);
          }
        }
        return unit.between(this, end);
      };
      _proto.toLocalDateTime = function toLocalDateTime() {
        return this._dateTime;
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._dateTime.toLocalDate();
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._dateTime.toLocalTime();
      };
      _proto.toOffsetDateTime = function toOffsetDateTime() {
        return OffsetDateTime.of(this._dateTime, this._offset);
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ZonedDateTime2) {
          return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
      };
      _proto.toString = function toString() {
        var str = this._dateTime.toString() + this._offset.toString();
        if (this._offset !== this._zone) {
          str += "[" + this._zone.toString() + "]";
        }
        return str;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        return _ChronoZonedDateTime.prototype.format.call(this, formatter);
      };
      return ZonedDateTime2;
    }(ChronoZonedDateTime);
    OffsetDateTime = function(_Temporal) {
      _inheritsLoose(OffsetDateTime2, _Temporal);
      OffsetDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof OffsetDateTime2) {
          return temporal;
        }
        try {
          var offset = ZoneOffset.from(temporal);
          try {
            var ldt = LocalDateTime.from(temporal);
            return OffsetDateTime2.of(ldt, offset);
          } catch (_2) {
            var instant = Instant.from(temporal);
            return OffsetDateTime2.ofInstant(instant, offset);
          }
        } catch (ex) {
          throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      OffsetDateTime2.now = function now(clockOrZone) {
        if (arguments.length === 0) {
          return OffsetDateTime2.now(Clock.systemDefaultZone());
        } else {
          requireNonNull(clockOrZone, "clockOrZone");
          if (clockOrZone instanceof ZoneId) {
            return OffsetDateTime2.now(Clock.system(clockOrZone));
          } else if (clockOrZone instanceof Clock) {
            var now2 = clockOrZone.instant();
            return OffsetDateTime2.ofInstant(now2, clockOrZone.zone().rules().offset(now2));
          } else {
            throw new IllegalArgumentException("clockOrZone must be an instance of ZoneId or Clock");
          }
        }
      };
      OffsetDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return OffsetDateTime2.ofDateTime.apply(this, arguments);
        } else if (arguments.length === 3) {
          return OffsetDateTime2.ofDateAndTime.apply(this, arguments);
        } else {
          return OffsetDateTime2.ofNumbers.apply(this, arguments);
        }
      };
      OffsetDateTime2.ofDateTime = function ofDateTime(dateTime, offset) {
        return new OffsetDateTime2(dateTime, offset);
      };
      OffsetDateTime2.ofDateAndTime = function ofDateAndTime(date, time, offset) {
        var dt = LocalDateTime.of(date, time);
        return new OffsetDateTime2(dt, offset);
      };
      OffsetDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
        return new OffsetDateTime2(dt, offset);
      };
      OffsetDateTime2.ofInstant = function ofInstant(instant, zone) {
        requireNonNull(instant, "instant");
        requireNonNull(zone, "zone");
        var rules = zone.rules();
        var offset = rules.offset(instant);
        var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
        return new OffsetDateTime2(ldt, offset);
      };
      OffsetDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, OffsetDateTime2.FROM);
      };
      function OffsetDateTime2(dateTime, offset) {
        var _this;
        _this = _Temporal.call(this) || this;
        requireNonNull(dateTime, "dateTime");
        requireInstance(dateTime, LocalDateTime, "dateTime");
        requireNonNull(offset, "offset");
        requireInstance(offset, ZoneOffset, "offset");
        _this._dateTime = dateTime;
        _this._offset = offset;
        return _this;
      }
      var _proto = OffsetDateTime2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
      };
      _proto.until = function until(endExclusive, unit) {
        var end = OffsetDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          end = end.withOffsetSameInstant(this._offset);
          return this._dateTime.until(end._dateTime, unit);
        }
        return unit.between(this, end);
      };
      _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
        return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
      };
      _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
        return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this.offset();
        } else if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        } else if (_query === TemporalQueries.zoneId()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.get = function get(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              throw new DateTimeException("Field too large for an int: " + field);
            case ChronoField.OFFSET_SECONDS:
              return this.offset().totalSeconds();
          }
          return this._dateTime.get(field);
        }
        return _Temporal.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return this.toEpochSecond();
            case ChronoField.OFFSET_SECONDS:
              return this.offset().totalSeconds();
          }
          return this._dateTime.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.year = function year() {
        return this._dateTime.year();
      };
      _proto.monthValue = function monthValue() {
        return this._dateTime.monthValue();
      };
      _proto.month = function month() {
        return this._dateTime.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._dateTime.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._dateTime.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._dateTime.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._dateTime.hour();
      };
      _proto.minute = function minute() {
        return this._dateTime.minute();
      };
      _proto.second = function second() {
        return this._dateTime.second();
      };
      _proto.nano = function nano() {
        return this._dateTime.nano();
      };
      _proto.toLocalDateTime = function toLocalDateTime() {
        return this._dateTime;
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._dateTime.toLocalDate();
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._dateTime.toLocalTime();
      };
      _proto.toOffsetTime = function toOffsetTime() {
        return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
      };
      _proto.toZonedDateTime = function toZonedDateTime() {
        return ZonedDateTime.of(this._dateTime, this._offset);
      };
      _proto.toInstant = function toInstant() {
        return this._dateTime.toInstant(this._offset);
      };
      _proto.toEpochSecond = function toEpochSecond() {
        return this._dateTime.toEpochSecond(this._offset);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._dateTime.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster);
        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
          return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
        } else if (adjuster instanceof Instant) {
          return OffsetDateTime2.ofInstant(adjuster, this._offset);
        } else if (adjuster instanceof ZoneOffset) {
          return this._withDateTimeOffset(this._dateTime, adjuster);
        } else if (adjuster instanceof OffsetDateTime2) {
          return adjuster;
        }
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field);
        if (field instanceof ChronoField) {
          var f = field;
          switch (f) {
            case ChronoField.INSTANT_SECONDS:
              return OffsetDateTime2.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);
            case ChronoField.OFFSET_SECONDS: {
              return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
            }
          }
          return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
        if (this._dateTime === dateTime && this._offset.equals(offset)) {
          return this;
        }
        return new OffsetDateTime2(dateTime, offset);
      };
      _proto.withYear = function withYear(year) {
        return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
      };
      _proto.withMonth = function withMonth(month) {
        return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
      };
      _proto.withHour = function withHour(hour) {
        return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
      };
      _proto.withMinute = function withMinute(minute) {
        return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
      };
      _proto.withSecond = function withSecond(second) {
        return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
      };
      _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
        requireNonNull(offset, "offset");
        return this._withDateTimeOffset(this._dateTime, offset);
      };
      _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
        requireNonNull(offset, "offset");
        if (offset.equals(this._offset)) {
          return this;
        }
        var difference = offset.totalSeconds() - this._offset.totalSeconds();
        var adjusted = this._dateTime.plusSeconds(difference);
        return new OffsetDateTime2(adjusted, offset);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount, "amount");
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
      };
      _proto.plusMonths = function plusMonths(months) {
        return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
      };
      _proto.plusDays = function plusDays(days) {
        return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount);
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this.plus(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
      };
      _proto.minusDays = function minusDays(days) {
        return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, OffsetDateTime2, "other");
        if (this.offset().equals(other.offset())) {
          return this.toLocalDateTime().compareTo(other.toLocalDateTime());
        }
        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
        if (cmp === 0) {
          cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
          if (cmp === 0) {
            cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof OffsetDateTime2) {
          return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._dateTime.hashCode() ^ this._offset.hashCode();
      };
      _proto.toString = function toString() {
        return this._dateTime.toString() + this._offset.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return OffsetDateTime2;
    }(Temporal);
    DAYS_PER_CYCLE = 146097;
    DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
    LocalDate = function(_ChronoLocalDate) {
      _inheritsLoose(LocalDate2, _ChronoLocalDate);
      LocalDate2.now = function now(clockOrZone) {
        var clock;
        if (clockOrZone == null) {
          clock = Clock.systemDefaultZone();
        } else if (clockOrZone instanceof ZoneId) {
          clock = Clock.system(clockOrZone);
        } else {
          clock = clockOrZone;
        }
        return LocalDate2.ofInstant(clock.instant(), clock.zone());
      };
      LocalDate2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(instant, "instant");
        var offset = zone.rules().offset(instant);
        var epochSec = instant.epochSecond() + offset.totalSeconds();
        var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
        return LocalDate2.ofEpochDay(epochDay);
      };
      LocalDate2.of = function of(year, month, dayOfMonth) {
        return new LocalDate2(year, month, dayOfMonth);
      };
      LocalDate2.ofYearDay = function ofYearDay(year, dayOfYear) {
        ChronoField.YEAR.checkValidValue(year);
        var leap = IsoChronology.isLeapYear(year);
        if (dayOfYear === 366 && leap === false) {
          assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
        }
        var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
        var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
        if (dayOfYear > monthEnd) {
          moy = moy.plus(1);
        }
        var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
        return new LocalDate2(year, moy.value(), dom);
      };
      LocalDate2.ofEpochDay = function ofEpochDay(epochDay) {
        if (epochDay === void 0) {
          epochDay = 0;
        }
        var adjust, adjustCycles, doyEst, yearEst, zeroDay;
        zeroDay = epochDay + DAYS_0000_TO_1970;
        zeroDay -= 60;
        adjust = 0;
        if (zeroDay < 0) {
          adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
          adjust = adjustCycles * 400;
          zeroDay += -adjustCycles * DAYS_PER_CYCLE;
        }
        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
        if (doyEst < 0) {
          yearEst--;
          doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
        }
        yearEst += adjust;
        var marchDoy0 = doyEst;
        var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
        var month = (marchMonth0 + 2) % 12 + 1;
        var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
        yearEst += MathUtil.intDiv(marchMonth0, 10);
        var year = yearEst;
        return new LocalDate2(year, month, dom);
      };
      LocalDate2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var date = temporal.query(TemporalQueries.localDate());
        if (date == null) {
          throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return date;
      };
      LocalDate2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_DATE;
        }
        assert(formatter != null, "formatter", NullPointerException);
        return formatter.parse(text, LocalDate2.FROM);
      };
      LocalDate2._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
        switch (month) {
          case 2:
            day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
            break;
          case 4:
          case 6:
          case 9:
          case 11:
            day = Math.min(day, 30);
            break;
        }
        return LocalDate2.of(year, month, day);
      };
      function LocalDate2(year, month, dayOfMonth) {
        var _this;
        _this = _ChronoLocalDate.call(this) || this;
        requireNonNull(year, "year");
        requireNonNull(month, "month");
        requireNonNull(dayOfMonth, "dayOfMonth");
        if (month instanceof Month) {
          month = month.value();
        }
        _this._year = MathUtil.safeToInt(year);
        _this._month = MathUtil.safeToInt(month);
        _this._day = MathUtil.safeToInt(dayOfMonth);
        LocalDate2._validate(_this._year, _this._month, _this._day);
        return _this;
      }
      LocalDate2._validate = function _validate(year, month, dayOfMonth) {
        var dom;
        ChronoField.YEAR.checkValidValue(year);
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
        if (dayOfMonth > 28) {
          dom = 31;
          switch (month) {
            case 2:
              dom = IsoChronology.isLeapYear(year) ? 29 : 28;
              break;
            case 4:
            case 6:
            case 9:
            case 11:
              dom = 30;
          }
          if (dayOfMonth > dom) {
            if (dayOfMonth === 29) {
              assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
            } else {
              assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
            }
          }
        }
      };
      var _proto = LocalDate2.prototype;
      _proto.isSupported = function isSupported(field) {
        return _ChronoLocalDate.prototype.isSupported.call(this, field);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field.isDateBased()) {
            switch (field) {
              case ChronoField.DAY_OF_MONTH:
                return ValueRange.of(1, this.lengthOfMonth());
              case ChronoField.DAY_OF_YEAR:
                return ValueRange.of(1, this.lengthOfYear());
              case ChronoField.ALIGNED_WEEK_OF_MONTH:
                return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
              case ChronoField.YEAR_OF_ERA:
                return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
            }
            return field.range();
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        assert(field != null, "", NullPointerException);
        if (field instanceof ChronoField) {
          return this._get0(field);
        }
        return field.getFrom(this);
      };
      _proto._get0 = function _get0(field) {
        switch (field) {
          case ChronoField.DAY_OF_WEEK:
            return this.dayOfWeek().value();
          case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
            return MathUtil.intMod(this._day - 1, 7) + 1;
          case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
            return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
          case ChronoField.DAY_OF_MONTH:
            return this._day;
          case ChronoField.DAY_OF_YEAR:
            return this.dayOfYear();
          case ChronoField.EPOCH_DAY:
            return this.toEpochDay();
          case ChronoField.ALIGNED_WEEK_OF_MONTH:
            return MathUtil.intDiv(this._day - 1, 7) + 1;
          case ChronoField.ALIGNED_WEEK_OF_YEAR:
            return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
          case ChronoField.MONTH_OF_YEAR:
            return this._month;
          case ChronoField.PROLEPTIC_MONTH:
            return this._prolepticMonth();
          case ChronoField.YEAR_OF_ERA:
            return this._year >= 1 ? this._year : 1 - this._year;
          case ChronoField.YEAR:
            return this._year;
          case ChronoField.ERA:
            return this._year >= 1 ? 1 : 0;
        }
        throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
      };
      _proto._prolepticMonth = function _prolepticMonth() {
        return this._year * 12 + (this._month - 1);
      };
      _proto.chronology = function chronology() {
        return IsoChronology.INSTANCE;
      };
      _proto.year = function year() {
        return this._year;
      };
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._day;
      };
      _proto.dayOfYear = function dayOfYear() {
        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
      };
      _proto.dayOfWeek = function dayOfWeek() {
        var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
        return DayOfWeek.of(dow0 + 1);
      };
      _proto.isLeapYear = function isLeapYear() {
        return IsoChronology.isLeapYear(this._year);
      };
      _proto.lengthOfMonth = function lengthOfMonth() {
        switch (this._month) {
          case 2:
            return this.isLeapYear() ? 29 : 28;
          case 4:
          case 6:
          case 9:
          case 11:
            return 30;
          default:
            return 31;
        }
      };
      _proto.lengthOfYear = function lengthOfYear() {
        return this.isLeapYear() ? 366 : 365;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalDate2) {
          return adjuster;
        }
        return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        assert(field != null, "field", NullPointerException);
        if (field instanceof ChronoField) {
          var f = field;
          f.checkValidValue(newValue);
          switch (f) {
            case ChronoField.DAY_OF_WEEK:
              return this.plusDays(newValue - this.dayOfWeek().value());
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
              return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
              return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
            case ChronoField.DAY_OF_MONTH:
              return this.withDayOfMonth(newValue);
            case ChronoField.DAY_OF_YEAR:
              return this.withDayOfYear(newValue);
            case ChronoField.EPOCH_DAY:
              return LocalDate2.ofEpochDay(newValue);
            case ChronoField.ALIGNED_WEEK_OF_MONTH:
              return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
            case ChronoField.ALIGNED_WEEK_OF_YEAR:
              return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
            case ChronoField.MONTH_OF_YEAR:
              return this.withMonth(newValue);
            case ChronoField.PROLEPTIC_MONTH:
              return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
            case ChronoField.YEAR_OF_ERA:
              return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
            case ChronoField.YEAR:
              return this.withYear(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        if (this._year === year) {
          return this;
        }
        ChronoField.YEAR.checkValidValue(year);
        return LocalDate2._resolvePreviousValid(year, this._month, this._day);
      };
      _proto.withMonth = function withMonth(month) {
        var m = month instanceof Month ? month.value() : month;
        if (this._month === m) {
          return this;
        }
        ChronoField.MONTH_OF_YEAR.checkValidValue(m);
        return LocalDate2._resolvePreviousValid(this._year, m, this._day);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        if (this._day === dayOfMonth) {
          return this;
        }
        return LocalDate2.of(this._year, this._month, dayOfMonth);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        if (this.dayOfYear() === dayOfYear) {
          return this;
        }
        return LocalDate2.ofYearDay(this._year, dayOfYear);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.DAYS:
              return this.plusDays(amountToAdd);
            case ChronoUnit.WEEKS:
              return this.plusWeeks(amountToAdd);
            case ChronoUnit.MONTHS:
              return this.plusMonths(amountToAdd);
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
        return LocalDate2._resolvePreviousValid(newYear, this._month, this._day);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        var monthCount = this._year * 12 + (this._month - 1);
        var calcMonths = monthCount + monthsToAdd;
        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
        return LocalDate2._resolvePreviousValid(newYear, newMonth, this._day);
      };
      _proto.plusWeeks = function plusWeeks(weeksToAdd) {
        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        if (daysToAdd === 0) {
          return this;
        }
        var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
        return LocalDate2.ofEpochDay(mjDay);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return this.plusYears(yearsToSubtract * -1);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return this.plusMonths(monthsToSubtract * -1);
      };
      _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
        return this.plusWeeks(weeksToSubtract * -1);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return this.plusDays(daysToSubtract * -1);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.localDate()) {
          return this;
        }
        return _ChronoLocalDate.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
      };
      _proto.until = function until(p1, p2) {
        if (arguments.length < 2) {
          return this.until1(p1);
        } else {
          return this.until2(p1, p2);
        }
      };
      _proto.until2 = function until2(endExclusive, unit) {
        var end = LocalDate2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.DAYS:
              return this.daysUntil(end);
            case ChronoUnit.WEEKS:
              return MathUtil.intDiv(this.daysUntil(end), 7);
            case ChronoUnit.MONTHS:
              return this._monthsUntil(end);
            case ChronoUnit.YEARS:
              return MathUtil.intDiv(this._monthsUntil(end), 12);
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(this._monthsUntil(end), 120);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(this._monthsUntil(end), 1200);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(this._monthsUntil(end), 12e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.daysUntil = function daysUntil(end) {
        return end.toEpochDay() - this.toEpochDay();
      };
      _proto._monthsUntil = function _monthsUntil(end) {
        var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
        var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
        return MathUtil.intDiv(packed2 - packed1, 32);
      };
      _proto.until1 = function until1(endDate) {
        var end = LocalDate2.from(endDate);
        var totalMonths = end._prolepticMonth() - this._prolepticMonth();
        var days = end._day - this._day;
        if (totalMonths > 0 && days < 0) {
          totalMonths--;
          var calcDate = this.plusMonths(totalMonths);
          days = end.toEpochDay() - calcDate.toEpochDay();
        } else if (totalMonths < 0 && days > 0) {
          totalMonths++;
          days -= end.lengthOfMonth();
        }
        var years = MathUtil.intDiv(totalMonths, 12);
        var months = MathUtil.intMod(totalMonths, 12);
        return Period.of(years, months, days);
      };
      _proto.atTime = function atTime() {
        if (arguments.length === 1) {
          return this.atTime1.apply(this, arguments);
        } else {
          return this.atTime4.apply(this, arguments);
        }
      };
      _proto.atTime1 = function atTime1(time) {
        requireNonNull(time, "time");
        if (time instanceof LocalTime) {
          return LocalDateTime.of(this, time);
        } else if (time instanceof OffsetTime) {
          return this._atTimeOffsetTime(time);
        } else {
          throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time && time.constructor && time.constructor.name ? ", but is " + time.constructor.name : ""));
        }
      };
      _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
      };
      _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {
        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());
      };
      _proto.atStartOfDay = function atStartOfDay(zone) {
        if (zone != null) {
          return this._atStartOfDayWithZone(zone);
        } else {
          return LocalDateTime.of(this, LocalTime.MIDNIGHT);
        }
      };
      _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
        requireNonNull(zone, "zone");
        var ldt = this.atTime(LocalTime.MIDNIGHT);
        if (zone instanceof ZoneOffset === false) {
          var trans = zone.rules().transition(ldt);
          if (trans != null && trans.isGap()) {
            ldt = trans.dateTimeAfter();
          }
        }
        return ZonedDateTime.of(ldt, zone);
      };
      _proto.toEpochDay = function toEpochDay() {
        var y = this._year;
        var m = this._month;
        var total = 0;
        total += 365 * y;
        if (y >= 0) {
          total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
        } else {
          total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
        }
        total += MathUtil.intDiv(367 * m - 362, 12);
        total += this.dayOfMonth() - 1;
        if (m > 2) {
          total--;
          if (!IsoChronology.isLeapYear(y)) {
            total--;
          }
        }
        return total - DAYS_0000_TO_1970;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalDate2, "other");
        return this._compareTo0(other);
      };
      _proto._compareTo0 = function _compareTo0(otherDate) {
        var cmp = this._year - otherDate._year;
        if (cmp === 0) {
          cmp = this._month - otherDate._month;
          if (cmp === 0) {
            cmp = this._day - otherDate._day;
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.isEqual = function isEqual(other) {
        return this.compareTo(other) === 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalDate2) {
          return this._compareTo0(other) === 0;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        var yearValue = this._year;
        var monthValue = this._month;
        var dayValue = this._day;
        return MathUtil.hash(yearValue & 4294965248 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
      };
      _proto.toString = function toString() {
        var dayString, monthString, yearString;
        var yearValue = this._year;
        var monthValue = this._month;
        var dayValue = this._day;
        var absYear = Math.abs(yearValue);
        if (absYear < 1e3) {
          if (yearValue < 0) {
            yearString = "-" + ("" + (yearValue - 1e4)).slice(-4);
          } else {
            yearString = ("" + (yearValue + 1e4)).slice(-4);
          }
        } else {
          if (yearValue > 9999) {
            yearString = "+" + yearValue;
          } else {
            yearString = "" + yearValue;
          }
        }
        if (monthValue < 10) {
          monthString = "-0" + monthValue;
        } else {
          monthString = "-" + monthValue;
        }
        if (dayValue < 10) {
          dayString = "-0" + dayValue;
        } else {
          dayString = "-" + dayValue;
        }
        return yearString + monthString + dayString;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return _ChronoLocalDate.prototype.format.call(this, formatter);
      };
      return LocalDate2;
    }(ChronoLocalDate);
    ChronoLocalDateTime = function(_Temporal) {
      _inheritsLoose(ChronoLocalDateTime2, _Temporal);
      function ChronoLocalDateTime2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoLocalDateTime2.prototype;
      _proto.chronology = function chronology() {
        return this.toLocalDate().chronology();
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
      };
      _proto.toInstant = function toInstant(offset) {
        requireInstance(offset, ZoneOffset, "zoneId");
        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
      };
      _proto.toEpochSecond = function toEpochSecond(offset) {
        requireNonNull(offset, "offset");
        var epochDay = this.toLocalDate().toEpochDay();
        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
        secs -= offset.totalSeconds();
        return MathUtil.safeToInt(secs);
      };
      return ChronoLocalDateTime2;
    }(Temporal);
    LocalDateTime = function(_ChronoLocalDateTime) {
      _inheritsLoose(LocalDateTime2, _ChronoLocalDateTime);
      LocalDateTime2.now = function now(clockOrZone) {
        if (clockOrZone == null) {
          return LocalDateTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return LocalDateTime2._now(clockOrZone);
        } else {
          return LocalDateTime2._now(Clock.system(clockOrZone));
        }
      };
      LocalDateTime2._now = function _now(clock) {
        requireNonNull(clock, "clock");
        return LocalDateTime2.ofInstant(clock.instant(), clock.zone());
      };
      LocalDateTime2._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
        var localSecond = MathUtil.floorDiv(epochMilli, 1e3) + offset.totalSeconds();
        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
        var nanoOfSecond = MathUtil.floorMod(epochMilli, 1e3) * 1e6;
        var date = LocalDate.ofEpochDay(localEpochDay);
        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return LocalDateTime2.ofDateAndTime.apply(this, arguments);
        } else {
          return LocalDateTime2.ofNumbers.apply(this, arguments);
        }
      };
      LocalDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        var date = LocalDate.of(year, month, dayOfMonth);
        var time = LocalTime.of(hour, minute, second, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.ofDateAndTime = function ofDateAndTime(date, time) {
        requireNonNull(date, "date");
        requireNonNull(time, "time");
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(instant, "instant");
        requireInstance(instant, Instant, "instant");
        requireNonNull(zone, "zone");
        var offset = zone.rules().offset(instant);
        return LocalDateTime2.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
      };
      LocalDateTime2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
        if (epochSecond === void 0) {
          epochSecond = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
          offset = nanoOfSecond;
          nanoOfSecond = 0;
        }
        requireNonNull(offset, "offset");
        var localSecond = epochSecond + offset.totalSeconds();
        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
        var date = LocalDate.ofEpochDay(localEpochDay);
        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof LocalDateTime2) {
          return temporal;
        } else if (temporal instanceof ZonedDateTime) {
          return temporal.toLocalDateTime();
        }
        try {
          var date = LocalDate.from(temporal);
          var time = LocalTime.from(temporal);
          return new LocalDateTime2(date, time);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      LocalDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, LocalDateTime2.FROM);
      };
      function LocalDateTime2(date, time) {
        var _this;
        _this = _ChronoLocalDateTime.call(this) || this;
        requireInstance(date, LocalDate, "date");
        requireInstance(time, LocalTime, "time");
        _this._date = date;
        _this._time = time;
        return _this;
      }
      var _proto = LocalDateTime2.prototype;
      _proto._withDateTime = function _withDateTime(newDate, newTime) {
        if (this._date.equals(newDate) && this._time.equals(newTime)) {
          return this;
        }
        return new LocalDateTime2(newDate, newTime);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
        }
        return _ChronoLocalDateTime.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.year = function year() {
        return this._date.year();
      };
      _proto.monthValue = function monthValue() {
        return this._date.monthValue();
      };
      _proto.month = function month() {
        return this._date.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._date.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._date.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._date.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._time.hour();
      };
      _proto.minute = function minute() {
        return this._time.minute();
      };
      _proto.second = function second() {
        return this._time.second();
      };
      _proto.nano = function nano() {
        return this._time.nano();
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalDate) {
          return this._withDateTime(adjuster, this._time);
        } else if (adjuster instanceof LocalTime) {
          return this._withDateTime(this._date, adjuster);
        } else if (adjuster instanceof LocalDateTime2) {
          return adjuster;
        }
        return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          if (field.isTimeBased()) {
            return this._withDateTime(this._date, this._time.with(field, newValue));
          } else {
            return this._withDateTime(this._date.with(field, newValue), this._time);
          }
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        return this._withDateTime(this._date.withYear(year), this._time);
      };
      _proto.withMonth = function withMonth(month) {
        return this._withDateTime(this._date.withMonth(month), this._time);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
      };
      _proto.withHour = function withHour(hour) {
        var newTime = this._time.withHour(hour);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withMinute = function withMinute(minute) {
        var newTime = this._time.withMinute(minute);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withSecond = function withSecond(second) {
        var newTime = this._time.withSecond(second);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        var newTime = this._time.withNano(nanoOfSecond);
        return this._withDateTime(this._date, newTime);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withDateTime(this._date, this._time.truncatedTo(unit));
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1e6);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusMinutes(amountToAdd);
            case ChronoUnit.HOURS:
              return this.plusHours(amountToAdd);
            case ChronoUnit.HALF_DAYS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
          }
          return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        var newDate = this._date.plusYears(years);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusMonths = function plusMonths(months) {
        var newDate = this._date.plusMonths(months);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        var newDate = this._date.plusWeeks(weeks);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusDays = function plusDays(days) {
        var newDate = this._date.plusDays(days);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this.plusYears(-1 * years);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this.plusMonths(-1 * months);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this.plusWeeks(-1 * weeks);
      };
      _proto.minusDays = function minusDays(days) {
        return this.plusDays(-1 * days);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
      };
      _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {
        if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
          return this._withDateTime(newDate, this._time);
        }
        var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
        totDays *= sign;
        var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
        var curNoD = this._time.toNanoOfDay();
        totNanos = totNanos * sign + curNoD;
        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
        var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
        var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
        return this._withDateTime(newDate.plusDays(totDays), newTime);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        }
        return _ChronoLocalDateTime.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = LocalDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          if (unit.isTimeBased()) {
            var daysUntil = this._date.daysUntil(end._date);
            var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();
            if (daysUntil > 0 && timeUntil < 0) {
              daysUntil--;
              timeUntil += LocalTime.NANOS_PER_DAY;
            } else if (daysUntil < 0 && timeUntil > 0) {
              daysUntil++;
              timeUntil -= LocalTime.NANOS_PER_DAY;
            }
            var amount = daysUntil;
            switch (unit) {
              case ChronoUnit.NANOS:
                amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
                return MathUtil.safeAdd(amount, timeUntil);
              case ChronoUnit.MICROS:
                amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e3));
              case ChronoUnit.MILLIS:
                amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e6));
              case ChronoUnit.SECONDS:
                amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
              case ChronoUnit.MINUTES:
                amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
              case ChronoUnit.HOURS:
                amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
              case ChronoUnit.HALF_DAYS:
                amount = MathUtil.safeMultiply(amount, 2);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          var endDate = end._date;
          var endTime = end._time;
          if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
            endDate = endDate.minusDays(1);
          } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
            endDate = endDate.plusDays(1);
          }
          return this._date.until(endDate, unit);
        }
        return unit.between(this, end);
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetDateTime.of(this, offset);
      };
      _proto.atZone = function atZone(zone) {
        return ZonedDateTime.of(this, zone);
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._date;
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._time;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalDateTime2, "other");
        return this._compareTo0(other);
      };
      _proto._compareTo0 = function _compareTo0(other) {
        var cmp = this._date.compareTo(other.toLocalDate());
        if (cmp === 0) {
          cmp = this._time.compareTo(other.toLocalTime());
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.isEqual = function isEqual(other) {
        return this.compareTo(other) === 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalDateTime2) {
          return this._date.equals(other._date) && this._time.equals(other._time);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._date.hashCode() ^ this._time.hashCode();
      };
      _proto.toString = function toString() {
        return this._date.toString() + "T" + this._time.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return LocalDateTime2;
    }(ChronoLocalDateTime);
    LocalTime = function(_Temporal) {
      _inheritsLoose(LocalTime2, _Temporal);
      LocalTime2.now = function now(clockOrZone) {
        if (clockOrZone == null) {
          return LocalTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return LocalTime2._now(clockOrZone);
        } else {
          return LocalTime2._now(Clock.system(clockOrZone));
        }
      };
      LocalTime2._now = function _now(clock) {
        if (clock === void 0) {
          clock = Clock.systemDefaultZone();
        }
        requireNonNull(clock, "clock");
        return LocalTime2.ofInstant(clock.instant(), clock.zone());
      };
      LocalTime2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        var offset = zone.rules().offset(instant);
        var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime2.SECONDS_PER_DAY);
        secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime2.SECONDS_PER_DAY);
        if (secsOfDay < 0) {
          secsOfDay += LocalTime2.SECONDS_PER_DAY;
        }
        return LocalTime2.ofSecondOfDay(secsOfDay, instant.nano());
      };
      LocalTime2.of = function of(hour, minute, second, nanoOfSecond) {
        return new LocalTime2(hour, minute, second, nanoOfSecond);
      };
      LocalTime2.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
        if (secondOfDay === void 0) {
          secondOfDay = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
        var hours = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_HOUR);
        secondOfDay -= hours * LocalTime2.SECONDS_PER_HOUR;
        var minutes = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_MINUTE);
        secondOfDay -= minutes * LocalTime2.SECONDS_PER_MINUTE;
        return new LocalTime2(hours, minutes, secondOfDay, nanoOfSecond);
      };
      LocalTime2.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
        if (nanoOfDay === void 0) {
          nanoOfDay = 0;
        }
        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
        var hours = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_HOUR);
        nanoOfDay -= hours * LocalTime2.NANOS_PER_HOUR;
        var minutes = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_MINUTE);
        nanoOfDay -= minutes * LocalTime2.NANOS_PER_MINUTE;
        var seconds = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_SECOND);
        nanoOfDay -= seconds * LocalTime2.NANOS_PER_SECOND;
        return new LocalTime2(hours, minutes, seconds, nanoOfDay);
      };
      LocalTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var time = temporal.query(TemporalQueries.localTime());
        if (time == null) {
          throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return time;
      };
      LocalTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, LocalTime2.FROM);
      };
      function LocalTime2(hour, minute, second, nanoOfSecond) {
        var _this;
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        _this = _Temporal.call(this) || this;
        var _hour = MathUtil.safeToInt(hour);
        var _minute = MathUtil.safeToInt(minute);
        var _second = MathUtil.safeToInt(second);
        var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
        LocalTime2._validate(_hour, _minute, _second, _nanoOfSecond);
        if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
          if (!LocalTime2.HOURS[_hour]) {
            _this._hour = _hour;
            _this._minute = _minute;
            _this._second = _second;
            _this._nano = _nanoOfSecond;
            LocalTime2.HOURS[_hour] = _assertThisInitialized(_this);
          }
          return LocalTime2.HOURS[_hour] || _assertThisInitialized(_this);
        }
        _this._hour = _hour;
        _this._minute = _minute;
        _this._second = _second;
        _this._nano = _nanoOfSecond;
        return _this;
      }
      LocalTime2._validate = function _validate(hour, minute, second, nanoOfSecond) {
        ChronoField.HOUR_OF_DAY.checkValidValue(hour);
        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
      };
      var _proto = LocalTime2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isTimeBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        requireNonNull(field);
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          return this._get0(field);
        }
        return field.getFrom(this);
      };
      _proto._get0 = function _get0(field) {
        switch (field) {
          case ChronoField.NANO_OF_SECOND:
            return this._nano;
          case ChronoField.NANO_OF_DAY:
            return this.toNanoOfDay();
          case ChronoField.MICRO_OF_SECOND:
            return MathUtil.intDiv(this._nano, 1e3);
          case ChronoField.MICRO_OF_DAY:
            return MathUtil.intDiv(this.toNanoOfDay(), 1e3);
          case ChronoField.MILLI_OF_SECOND:
            return MathUtil.intDiv(this._nano, 1e6);
          case ChronoField.MILLI_OF_DAY:
            return MathUtil.intDiv(this.toNanoOfDay(), 1e6);
          case ChronoField.SECOND_OF_MINUTE:
            return this._second;
          case ChronoField.SECOND_OF_DAY:
            return this.toSecondOfDay();
          case ChronoField.MINUTE_OF_HOUR:
            return this._minute;
          case ChronoField.MINUTE_OF_DAY:
            return this._hour * 60 + this._minute;
          case ChronoField.HOUR_OF_AMPM:
            return MathUtil.intMod(this._hour, 12);
          case ChronoField.CLOCK_HOUR_OF_AMPM: {
            var ham = MathUtil.intMod(this._hour, 12);
            return ham % 12 === 0 ? 12 : ham;
          }
          case ChronoField.HOUR_OF_DAY:
            return this._hour;
          case ChronoField.CLOCK_HOUR_OF_DAY:
            return this._hour === 0 ? 24 : this._hour;
          case ChronoField.AMPM_OF_DAY:
            return MathUtil.intDiv(this._hour, 12);
        }
        throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
      };
      _proto.hour = function hour() {
        return this._hour;
      };
      _proto.minute = function minute() {
        return this._minute;
      };
      _proto.second = function second() {
        return this._second;
      };
      _proto.nano = function nano() {
        return this._nano;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalTime2) {
          return adjuster;
        }
        return _Temporal.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this.withNano(newValue);
            case ChronoField.NANO_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue);
            case ChronoField.MICRO_OF_SECOND:
              return this.withNano(newValue * 1e3);
            case ChronoField.MICRO_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue * 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return this.withNano(newValue * 1e6);
            case ChronoField.MILLI_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue * 1e6);
            case ChronoField.SECOND_OF_MINUTE:
              return this.withSecond(newValue);
            case ChronoField.SECOND_OF_DAY:
              return this.plusSeconds(newValue - this.toSecondOfDay());
            case ChronoField.MINUTE_OF_HOUR:
              return this.withMinute(newValue);
            case ChronoField.MINUTE_OF_DAY:
              return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
            case ChronoField.HOUR_OF_AMPM:
              return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
            case ChronoField.CLOCK_HOUR_OF_AMPM:
              return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
            case ChronoField.HOUR_OF_DAY:
              return this.withHour(newValue);
            case ChronoField.CLOCK_HOUR_OF_DAY:
              return this.withHour(newValue === 24 ? 0 : newValue);
            case ChronoField.AMPM_OF_DAY:
              return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withHour = function withHour(hour) {
        if (hour === void 0) {
          hour = 0;
        }
        if (this._hour === hour) {
          return this;
        }
        return new LocalTime2(hour, this._minute, this._second, this._nano);
      };
      _proto.withMinute = function withMinute(minute) {
        if (minute === void 0) {
          minute = 0;
        }
        if (this._minute === minute) {
          return this;
        }
        return new LocalTime2(this._hour, minute, this._second, this._nano);
      };
      _proto.withSecond = function withSecond(second) {
        if (second === void 0) {
          second = 0;
        }
        if (this._second === second) {
          return this;
        }
        return new LocalTime2(this._hour, this._minute, second, this._nano);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        if (this._nano === nanoOfSecond) {
          return this;
        }
        return new LocalTime2(this._hour, this._minute, this._second, nanoOfSecond);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.NANOS) {
          return this;
        }
        var unitDur = unit.duration();
        if (unitDur.seconds() > LocalTime2.SECONDS_PER_DAY) {
          throw new DateTimeException("Unit is too large to be used for truncation");
        }
        var dur = unitDur.toNanos();
        if (MathUtil.intMod(LocalTime2.NANOS_PER_DAY, dur) !== 0) {
          throw new DateTimeException("Unit must divide into a standard day without remainder");
        }
        var nod = this.toNanoOfDay();
        return LocalTime2.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MICROS_PER_DAY) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MILLIS_PER_DAY) * 1e6);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusMinutes(amountToAdd);
            case ChronoUnit.HOURS:
              return this.plusHours(amountToAdd);
            case ChronoUnit.HALF_DAYS:
              return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusHours = function plusHours(hoursToAdd) {
        if (hoursToAdd === 0) {
          return this;
        }
        var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime2.HOURS_PER_DAY) + this._hour + LocalTime2.HOURS_PER_DAY, LocalTime2.HOURS_PER_DAY);
        return new LocalTime2(newHour, this._minute, this._second, this._nano);
      };
      _proto.plusMinutes = function plusMinutes(minutesToAdd) {
        if (minutesToAdd === 0) {
          return this;
        }
        var mofd = this._hour * LocalTime2.MINUTES_PER_HOUR + this._minute;
        var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime2.MINUTES_PER_DAY) + mofd + LocalTime2.MINUTES_PER_DAY, LocalTime2.MINUTES_PER_DAY);
        if (mofd === newMofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newMofd, LocalTime2.MINUTES_PER_HOUR);
        var newMinute = MathUtil.intMod(newMofd, LocalTime2.MINUTES_PER_HOUR);
        return new LocalTime2(newHour, newMinute, this._second, this._nano);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        if (secondsToAdd === 0) {
          return this;
        }
        var sofd = this._hour * LocalTime2.SECONDS_PER_HOUR + this._minute * LocalTime2.SECONDS_PER_MINUTE + this._second;
        var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime2.SECONDS_PER_DAY) + sofd + LocalTime2.SECONDS_PER_DAY, LocalTime2.SECONDS_PER_DAY);
        if (sofd === newSofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_HOUR);
        var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
        var newSecond = MathUtil.intMod(newSofd, LocalTime2.SECONDS_PER_MINUTE);
        return new LocalTime2(newHour, newMinute, newSecond, this._nano);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        if (nanosToAdd === 0) {
          return this;
        }
        var nofd = this.toNanoOfDay();
        var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime2.NANOS_PER_DAY) + nofd + LocalTime2.NANOS_PER_DAY, LocalTime2.NANOS_PER_DAY);
        if (nofd === newNofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_HOUR);
        var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
        var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_SECOND), LocalTime2.SECONDS_PER_MINUTE);
        var newNano = MathUtil.intMod(newNofd, LocalTime2.NANOS_PER_SECOND);
        return new LocalTime2(newHour, newMinute, newSecond, newNano);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusHours = function minusHours(hoursToSubtract) {
        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime2.HOURS_PER_DAY));
      };
      _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime2.MINUTES_PER_DAY));
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime2.SECONDS_PER_DAY));
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime2.NANOS_PER_DAY));
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.localTime()) {
          return this;
        }
        if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(LocalTime2.NANO_OF_DAY, this.toNanoOfDay());
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = LocalTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();
          switch (unit) {
            case ChronoUnit.NANOS:
              return nanosUntil;
            case ChronoUnit.MICROS:
              return MathUtil.intDiv(nanosUntil, 1e3);
            case ChronoUnit.MILLIS:
              return MathUtil.intDiv(nanosUntil, 1e6);
            case ChronoUnit.SECONDS:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_SECOND);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(nanosUntil, 12 * LocalTime2.NANOS_PER_HOUR);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.atDate = function atDate(date) {
        return LocalDateTime.of(date, this);
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetTime.of(this, offset);
      };
      _proto.toSecondOfDay = function toSecondOfDay() {
        var total = this._hour * LocalTime2.SECONDS_PER_HOUR;
        total += this._minute * LocalTime2.SECONDS_PER_MINUTE;
        total += this._second;
        return total;
      };
      _proto.toNanoOfDay = function toNanoOfDay() {
        var total = this._hour * LocalTime2.NANOS_PER_HOUR;
        total += this._minute * LocalTime2.NANOS_PER_MINUTE;
        total += this._second * LocalTime2.NANOS_PER_SECOND;
        total += this._nano;
        return total;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalTime2, "other");
        var cmp = MathUtil.compareNumbers(this._hour, other._hour);
        if (cmp === 0) {
          cmp = MathUtil.compareNumbers(this._minute, other._minute);
          if (cmp === 0) {
            cmp = MathUtil.compareNumbers(this._second, other._second);
            if (cmp === 0) {
              cmp = MathUtil.compareNumbers(this._nano, other._nano);
            }
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalTime2) {
          return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        var nod = this.toNanoOfDay();
        return MathUtil.hash(nod);
      };
      _proto.toString = function toString() {
        var buf = "";
        var hourValue = this._hour;
        var minuteValue = this._minute;
        var secondValue = this._second;
        var nanoValue = this._nano;
        buf += hourValue < 10 ? "0" : "";
        buf += hourValue;
        buf += minuteValue < 10 ? ":0" : ":";
        buf += minuteValue;
        if (secondValue > 0 || nanoValue > 0) {
          buf += secondValue < 10 ? ":0" : ":";
          buf += secondValue;
          if (nanoValue > 0) {
            buf += ".";
            if (MathUtil.intMod(nanoValue, 1e6) === 0) {
              buf += ("" + (MathUtil.intDiv(nanoValue, 1e6) + 1e3)).substring(1);
            } else if (MathUtil.intMod(nanoValue, 1e3) === 0) {
              buf += ("" + (MathUtil.intDiv(nanoValue, 1e3) + 1e6)).substring(1);
            } else {
              buf += ("" + (nanoValue + 1e9)).substring(1);
            }
          }
        }
        return buf;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return LocalTime2;
    }(Temporal);
    LocalTime.HOURS_PER_DAY = 24;
    LocalTime.MINUTES_PER_HOUR = 60;
    LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
    LocalTime.SECONDS_PER_MINUTE = 60;
    LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
    LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
    LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e3;
    LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e6;
    LocalTime.NANOS_PER_SECOND = 1e9;
    LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
    LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
    LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;
    NANOS_PER_MILLI = 1e6;
    Instant = function(_Temporal) {
      _inheritsLoose(Instant2, _Temporal);
      Instant2.now = function now(clock) {
        if (clock === void 0) {
          clock = Clock.systemUTC();
        }
        return clock.instant();
      };
      Instant2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        return Instant2._create(secs, nos);
      };
      Instant2.ofEpochMilli = function ofEpochMilli(epochMilli) {
        var secs = MathUtil.floorDiv(epochMilli, 1e3);
        var mos = MathUtil.floorMod(epochMilli, 1e3);
        return Instant2._create(secs, mos * 1e6);
      };
      Instant2.ofEpochMicro = function ofEpochMicro(epochMicro) {
        var secs = MathUtil.floorDiv(epochMicro, 1e6);
        var mos = MathUtil.floorMod(epochMicro, 1e6);
        return Instant2._create(secs, mos * 1e3);
      };
      Instant2.from = function from(temporal) {
        try {
          var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
          var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
          return Instant2.ofEpochSecond(instantSecs, nanoOfSecond);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
        }
      };
      Instant2.parse = function parse2(text) {
        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant2.FROM);
      };
      Instant2._create = function _create(seconds, nanoOfSecond) {
        if (seconds === 0 && nanoOfSecond === 0) {
          return Instant2.EPOCH;
        }
        return new Instant2(seconds, nanoOfSecond);
      };
      Instant2._validate = function _validate(seconds, nanoOfSecond) {
        if (seconds < Instant2.MIN_SECONDS || seconds > Instant2.MAX_SECONDS) {
          throw new DateTimeException("Instant exceeds minimum or maximum instant");
        }
        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
          throw new DateTimeException("Instant exceeds minimum or maximum instant");
        }
      };
      function Instant2(seconds, nanoOfSecond) {
        var _this;
        _this = _Temporal.call(this) || this;
        Instant2._validate(seconds, nanoOfSecond);
        _this._seconds = MathUtil.safeToInt(seconds);
        _this._nanos = MathUtil.safeToInt(nanoOfSecond);
        return _this;
      }
      var _proto = Instant2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
        }
        if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this._nanos;
            case ChronoField.MICRO_OF_SECOND:
              return MathUtil.intDiv(this._nanos, 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
            case ChronoField.INSTANT_SECONDS:
              return this._seconds;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.epochSecond = function epochSecond() {
        return this._seconds;
      };
      _proto.nano = function nano() {
        return this._nanos;
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.MILLI_OF_SECOND: {
              var nval = newValue * NANOS_PER_MILLI;
              return nval !== this._nanos ? Instant2._create(this._seconds, nval) : this;
            }
            case ChronoField.MICRO_OF_SECOND: {
              var _nval = newValue * 1e3;
              return _nval !== this._nanos ? Instant2._create(this._seconds, _nval) : this;
            }
            case ChronoField.NANO_OF_SECOND:
              return newValue !== this._nanos ? Instant2._create(this._seconds, newValue) : this;
            case ChronoField.INSTANT_SECONDS:
              return newValue !== this._seconds ? Instant2._create(newValue, this._nanos) : this;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.NANOS) {
          return this;
        }
        var unitDur = unit.duration();
        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
          throw new DateTimeException("Unit is too large to be used for truncation");
        }
        var dur = unitDur.toNanos();
        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
          throw new DateTimeException("Unit must divide into a standard day without remainder");
        }
        var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
        var result = MathUtil.intDiv(nod, dur) * dur;
        return this.plusNanos(result - nod);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusMicros(amountToAdd);
            case ChronoUnit.MILLIS:
              return this.plusMillis(amountToAdd);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
            case ChronoUnit.HOURS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
            case ChronoUnit.HALF_DAYS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
            case ChronoUnit.DAYS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        return this._plus(secondsToAdd, 0);
      };
      _proto.plusMillis = function plusMillis(millisToAdd) {
        return this._plus(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * NANOS_PER_MILLI);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        return this._plus(0, nanosToAdd);
      };
      _proto.plusMicros = function plusMicros(microsToAdd) {
        return this._plus(MathUtil.intDiv(microsToAdd, 1e6), MathUtil.intMod(microsToAdd, 1e6) * 1e3);
      };
      _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
        if (secondsToAdd === 0 && nanosToAdd === 0) {
          return this;
        }
        var epochSec = this._seconds + secondsToAdd;
        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
        var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
        return Instant2.ofEpochSecond(epochSec, nanoAdjustment);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return this.plusSeconds(secondsToSubtract * -1);
      };
      _proto.minusMillis = function minusMillis(millisToSubtract) {
        return this.plusMillis(-1 * millisToSubtract);
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return this.plusNanos(-1 * nanosToSubtract);
      };
      _proto.minusMicros = function minusMicros(microsToSubtract) {
        return this.plusMicros(-1 * microsToSubtract);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        }
        if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = Instant2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this._nanosUntil(end);
            case ChronoUnit.MICROS:
              return this._microsUntil(end);
            case ChronoUnit.MILLIS:
              return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());
            case ChronoUnit.SECONDS:
              return this._secondsUntil(end);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);
            case ChronoUnit.DAYS:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto._microsUntil = function _microsUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var totalMicros = MathUtil.safeMultiply(secsDiff, 1e6);
        return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1e3));
      };
      _proto._nanosUntil = function _nanosUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
      };
      _proto._secondsUntil = function _secondsUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var nanosDiff = end.nano() - this.nano();
        if (secsDiff > 0 && nanosDiff < 0) {
          secsDiff--;
        } else if (secsDiff < 0 && nanosDiff > 0) {
          secsDiff++;
        }
        return secsDiff;
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetDateTime.ofInstant(this, offset);
      };
      _proto.atZone = function atZone(zone) {
        return ZonedDateTime.ofInstant(this, zone);
      };
      _proto.toEpochMilli = function toEpochMilli() {
        var millis = MathUtil.safeMultiply(this._seconds, 1e3);
        return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
      };
      _proto.compareTo = function compareTo(otherInstant) {
        requireNonNull(otherInstant, "otherInstant");
        requireInstance(otherInstant, Instant2, "otherInstant");
        var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
        if (cmp !== 0) {
          return cmp;
        }
        return this._nanos - otherInstant._nanos;
      };
      _proto.isAfter = function isAfter(otherInstant) {
        return this.compareTo(otherInstant) > 0;
      };
      _proto.isBefore = function isBefore(otherInstant) {
        return this.compareTo(otherInstant) < 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Instant2) {
          return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._seconds, this._nanos);
      };
      _proto.toString = function toString() {
        return DateTimeFormatter.ISO_INSTANT.format(this);
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Instant2;
    }(Temporal);
    Clock = function() {
      function Clock2() {
      }
      Clock2.systemUTC = function systemUTC() {
        return new SystemClock(ZoneOffset.UTC);
      };
      Clock2.systemDefaultZone = function systemDefaultZone() {
        return new SystemClock(ZoneId.systemDefault());
      };
      Clock2.system = function system(zone) {
        return new SystemClock(zone);
      };
      Clock2.fixed = function fixed(fixedInstant, zoneId) {
        return new FixedClock(fixedInstant, zoneId);
      };
      Clock2.offset = function offset(baseClock, duration) {
        return new OffsetClock(baseClock, duration);
      };
      var _proto = Clock2.prototype;
      _proto.millis = function millis() {
        abstractMethodFail("Clock.millis");
      };
      _proto.instant = function instant() {
        abstractMethodFail("Clock.instant");
      };
      _proto.zone = function zone() {
        abstractMethodFail("Clock.zone");
      };
      _proto.withZone = function withZone() {
        abstractMethodFail("Clock.withZone");
      };
      return Clock2;
    }();
    SystemClock = function(_Clock) {
      _inheritsLoose(SystemClock2, _Clock);
      function SystemClock2(zone) {
        var _this;
        requireNonNull(zone, "zone");
        _this = _Clock.call(this) || this;
        _this._zone = zone;
        return _this;
      }
      var _proto2 = SystemClock2.prototype;
      _proto2.zone = function zone() {
        return this._zone;
      };
      _proto2.millis = function millis() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      _proto2.instant = function instant() {
        return Instant.ofEpochMilli(this.millis());
      };
      _proto2.equals = function equals(obj) {
        if (obj instanceof SystemClock2) {
          return this._zone.equals(obj._zone);
        }
        return false;
      };
      _proto2.withZone = function withZone(zone) {
        if (zone.equals(this._zone)) {
          return this;
        }
        return new SystemClock2(zone);
      };
      _proto2.toString = function toString() {
        return "SystemClock[" + this._zone.toString() + "]";
      };
      return SystemClock2;
    }(Clock);
    FixedClock = function(_Clock2) {
      _inheritsLoose(FixedClock2, _Clock2);
      function FixedClock2(fixedInstant, zoneId) {
        var _this2;
        _this2 = _Clock2.call(this) || this;
        _this2._instant = fixedInstant;
        _this2._zoneId = zoneId;
        return _this2;
      }
      var _proto3 = FixedClock2.prototype;
      _proto3.instant = function instant() {
        return this._instant;
      };
      _proto3.millis = function millis() {
        return this._instant.toEpochMilli();
      };
      _proto3.zone = function zone() {
        return this._zoneId;
      };
      _proto3.toString = function toString() {
        return "FixedClock[]";
      };
      _proto3.equals = function equals(obj) {
        if (obj instanceof FixedClock2) {
          return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
        }
        return false;
      };
      _proto3.withZone = function withZone(zone) {
        if (zone.equals(this._zoneId)) {
          return this;
        }
        return new FixedClock2(this._instant, zone);
      };
      return FixedClock2;
    }(Clock);
    OffsetClock = function(_Clock3) {
      _inheritsLoose(OffsetClock2, _Clock3);
      function OffsetClock2(baseClock, offset) {
        var _this3;
        _this3 = _Clock3.call(this) || this;
        _this3._baseClock = baseClock;
        _this3._offset = offset;
        return _this3;
      }
      var _proto4 = OffsetClock2.prototype;
      _proto4.zone = function zone() {
        return this._baseClock.zone();
      };
      _proto4.withZone = function withZone(zone) {
        if (zone.equals(this._baseClock.zone())) {
          return this;
        }
        return new OffsetClock2(this._baseClock.withZone(zone), this._offset);
      };
      _proto4.millis = function millis() {
        return this._baseClock.millis() + this._offset.toMillis();
      };
      _proto4.instant = function instant() {
        return this._baseClock.instant().plus(this._offset);
      };
      _proto4.equals = function equals(obj) {
        if (obj instanceof OffsetClock2) {
          return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
        }
        return false;
      };
      _proto4.toString = function toString() {
        return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
      };
      return OffsetClock2;
    }(Clock);
    ZoneOffsetTransition = function() {
      ZoneOffsetTransition2.of = function of(transition, offsetBefore, offsetAfter) {
        return new ZoneOffsetTransition2(transition, offsetBefore, offsetAfter);
      };
      function ZoneOffsetTransition2(transition, offsetBefore, offsetAfter) {
        requireNonNull(transition, "transition");
        requireNonNull(offsetBefore, "offsetBefore");
        requireNonNull(offsetAfter, "offsetAfter");
        if (offsetBefore.equals(offsetAfter)) {
          throw new IllegalArgumentException("Offsets must not be equal");
        }
        if (transition.nano() !== 0) {
          throw new IllegalArgumentException("Nano-of-second must be zero");
        }
        if (transition instanceof LocalDateTime) {
          this._transition = transition;
        } else {
          this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
        }
        this._offsetBefore = offsetBefore;
        this._offsetAfter = offsetAfter;
      }
      var _proto = ZoneOffsetTransition2.prototype;
      _proto.instant = function instant() {
        return this._transition.toInstant(this._offsetBefore);
      };
      _proto.toEpochSecond = function toEpochSecond() {
        return this._transition.toEpochSecond(this._offsetBefore);
      };
      _proto.dateTimeBefore = function dateTimeBefore() {
        return this._transition;
      };
      _proto.dateTimeAfter = function dateTimeAfter() {
        return this._transition.plusSeconds(this.durationSeconds());
      };
      _proto.offsetBefore = function offsetBefore() {
        return this._offsetBefore;
      };
      _proto.offsetAfter = function offsetAfter() {
        return this._offsetAfter;
      };
      _proto.duration = function duration() {
        return Duration.ofSeconds(this.durationSeconds());
      };
      _proto.durationSeconds = function durationSeconds() {
        return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
      };
      _proto.isGap = function isGap() {
        return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
      };
      _proto.isOverlap = function isOverlap() {
        return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
      };
      _proto.isValidOffset = function isValidOffset(offset) {
        return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
      };
      _proto.validOffsets = function validOffsets() {
        if (this.isGap()) {
          return [];
        } else {
          return [this._offsetBefore, this._offsetAfter];
        }
      };
      _proto.compareTo = function compareTo(transition) {
        return this.instant().compareTo(transition.instant());
      };
      _proto.equals = function equals(other) {
        if (other === this) {
          return true;
        }
        if (other instanceof ZoneOffsetTransition2) {
          var d = other;
          return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
      };
      _proto.toString = function toString() {
        return "Transition[" + (this.isGap() ? "Gap" : "Overlap") + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
      };
      return ZoneOffsetTransition2;
    }();
    SystemDefaultZoneRules = function(_ZoneRules) {
      _inheritsLoose(SystemDefaultZoneRules2, _ZoneRules);
      function SystemDefaultZoneRules2() {
        return _ZoneRules.apply(this, arguments) || this;
      }
      var _proto = SystemDefaultZoneRules2.prototype;
      _proto.isFixedOffset = function isFixedOffset() {
        return false;
      };
      _proto.offsetOfInstant = function offsetOfInstant(instant) {
        var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
      };
      _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
        var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
      };
      _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
        var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1e3;
        var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
        var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 6e4;
        var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
      };
      _proto.validOffsets = function validOffsets(localDateTime) {
        return [this.offsetOfLocalDateTime(localDateTime)];
      };
      _proto.transition = function transition() {
        return null;
      };
      _proto.standardOffset = function standardOffset(instant) {
        return this.offsetOfInstant(instant);
      };
      _proto.daylightSavings = function daylightSavings() {
        this._throwNotSupported();
      };
      _proto.isDaylightSavings = function isDaylightSavings() {
        this._throwNotSupported();
      };
      _proto.isValidOffset = function isValidOffset(dateTime, offset) {
        return this.offsetOfLocalDateTime(dateTime).equals(offset);
      };
      _proto.nextTransition = function nextTransition() {
        this._throwNotSupported();
      };
      _proto.previousTransition = function previousTransition() {
        this._throwNotSupported();
      };
      _proto.transitions = function transitions() {
        this._throwNotSupported();
      };
      _proto.transitionRules = function transitionRules() {
        this._throwNotSupported();
      };
      _proto._throwNotSupported = function _throwNotSupported() {
        throw new DateTimeException("not supported operation");
      };
      _proto.equals = function equals(other) {
        if (this === other || other instanceof SystemDefaultZoneRules2) {
          return true;
        } else {
          return false;
        }
      };
      _proto.toString = function toString() {
        return "SYSTEM";
      };
      return SystemDefaultZoneRules2;
    }(ZoneRules);
    SystemDefaultZoneId = function(_ZoneId) {
      _inheritsLoose(SystemDefaultZoneId2, _ZoneId);
      function SystemDefaultZoneId2() {
        var _this;
        _this = _ZoneId.call(this) || this;
        _this._rules = new SystemDefaultZoneRules();
        return _this;
      }
      var _proto = SystemDefaultZoneId2.prototype;
      _proto.rules = function rules() {
        return this._rules;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        return false;
      };
      _proto.id = function id() {
        return "SYSTEM";
      };
      return SystemDefaultZoneId2;
    }(ZoneId);
    ZoneIdFactory = function() {
      function ZoneIdFactory2() {
      }
      ZoneIdFactory2.systemDefault = function systemDefault() {
        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
      };
      ZoneIdFactory2.getAvailableZoneIds = function getAvailableZoneIds() {
        return ZoneRulesProvider.getAvailableZoneIds();
      };
      ZoneIdFactory2.of = function of(zoneId) {
        requireNonNull(zoneId, "zoneId");
        if (zoneId === "Z") {
          return ZoneOffset.UTC;
        }
        if (zoneId.length === 1) {
          throw new DateTimeException("Invalid zone: " + zoneId);
        }
        if (StringUtil.startsWith(zoneId, "+") || StringUtil.startsWith(zoneId, "-")) {
          return ZoneOffset.of(zoneId);
        }
        if (zoneId === "UTC" || zoneId === "GMT" || zoneId === "GMT0" || zoneId === "UT") {
          return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
        }
        if (StringUtil.startsWith(zoneId, "UTC+") || StringUtil.startsWith(zoneId, "GMT+") || StringUtil.startsWith(zoneId, "UTC-") || StringUtil.startsWith(zoneId, "GMT-")) {
          var offset = ZoneOffset.of(zoneId.substring(3));
          if (offset.totalSeconds() === 0) {
            return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
          }
          return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
        }
        if (StringUtil.startsWith(zoneId, "UT+") || StringUtil.startsWith(zoneId, "UT-")) {
          var _offset = ZoneOffset.of(zoneId.substring(2));
          if (_offset.totalSeconds() === 0) {
            return new ZoneRegion("UT", _offset.rules());
          }
          return new ZoneRegion("UT" + _offset.id(), _offset.rules());
        }
        if (zoneId === "SYSTEM") {
          return ZoneId.systemDefault();
        }
        return ZoneRegion.ofId(zoneId);
      };
      ZoneIdFactory2.ofOffset = function ofOffset(prefix, offset) {
        requireNonNull(prefix, "prefix");
        requireNonNull(offset, "offset");
        if (prefix.length === 0) {
          return offset;
        }
        if (prefix === "GMT" || prefix === "UTC" || prefix === "UT") {
          if (offset.totalSeconds() === 0) {
            return new ZoneRegion(prefix, offset.rules());
          }
          return new ZoneRegion(prefix + offset.id(), offset.rules());
        }
        throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
      };
      ZoneIdFactory2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var obj = temporal.query(TemporalQueries.zone());
        if (obj == null) {
          throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return obj;
      };
      return ZoneIdFactory2;
    }();
    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
    isInit = false;
    init();
    ToNativeJsConverter = function() {
      function ToNativeJsConverter2(temporal, zone) {
        var zonedDateTime;
        if (temporal instanceof Instant) {
          this.instant = temporal;
          return;
        } else if (temporal instanceof LocalDate) {
          zone = zone == null ? ZoneId.systemDefault() : zone;
          zonedDateTime = temporal.atStartOfDay(zone);
        } else if (temporal instanceof LocalDateTime) {
          zone = zone == null ? ZoneId.systemDefault() : zone;
          zonedDateTime = temporal.atZone(zone);
        } else if (temporal instanceof ZonedDateTime) {
          if (zone == null) {
            zonedDateTime = temporal;
          } else {
            zonedDateTime = temporal.withZoneSameInstant(zone);
          }
        } else {
          throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
        }
        this.instant = zonedDateTime.toInstant();
      }
      var _proto = ToNativeJsConverter2.prototype;
      _proto.toDate = function toDate() {
        return new Date(this.instant.toEpochMilli());
      };
      _proto.toEpochMilli = function toEpochMilli() {
        return this.instant.toEpochMilli();
      };
      return ToNativeJsConverter2;
    }();
    _ = {
      assert: assert$1,
      DateTimeBuilder,
      DateTimeParseContext,
      DateTimePrintContext,
      MathUtil,
      StringUtil,
      StringBuilder
    };
    jsJodaExports = {
      _,
      convert,
      nativeJs,
      ArithmeticException,
      DateTimeException,
      DateTimeParseException,
      IllegalArgumentException,
      IllegalStateException,
      UnsupportedTemporalTypeException,
      NullPointerException,
      Clock,
      DayOfWeek,
      Duration,
      Instant,
      LocalDate,
      LocalTime,
      LocalDateTime,
      OffsetTime,
      OffsetDateTime,
      Month,
      MonthDay,
      ParsePosition,
      Period,
      Year,
      YearConstants,
      YearMonth,
      ZonedDateTime,
      ZoneOffset,
      ZoneId,
      ZoneRegion,
      ZoneOffsetTransition,
      ZoneRules,
      ZoneRulesProvider,
      ChronoLocalDate,
      ChronoLocalDateTime,
      ChronoZonedDateTime,
      IsoChronology,
      ChronoField,
      ChronoUnit,
      IsoFields,
      Temporal,
      TemporalAccessor,
      TemporalAdjuster,
      TemporalAdjusters,
      TemporalAmount,
      TemporalField,
      TemporalQueries,
      TemporalQuery,
      TemporalUnit,
      ValueRange,
      DateTimeFormatter,
      DateTimeFormatterBuilder,
      DecimalStyle,
      ResolverStyle,
      SignStyle,
      TextStyle
    };
    use = bindUse(jsJodaExports);
    jsJodaExports.use = use;
  }
});

// node_modules/tedious/lib/data-types/datetime.js
var require_datetime = __commonJS({
  "node_modules/tedious/lib/data-types/datetime.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1900, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var DateTime7 = {
      id: 61,
      type: "DATETIME",
      name: "DateTime",
      declaration: function() {
        return "datetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        let days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        let milliseconds, threeHundredthsOfSecond;
        if (options.useUTC) {
          let seconds = value.getUTCHours() * 60 * 60;
          seconds += value.getUTCMinutes() * 60;
          seconds += value.getUTCSeconds();
          milliseconds = seconds * 1e3 + value.getUTCMilliseconds();
        } else {
          let seconds = value.getHours() * 60 * 60;
          seconds += value.getMinutes() * 60;
          seconds += value.getSeconds();
          milliseconds = seconds * 1e3 + value.getMilliseconds();
        }
        threeHundredthsOfSecond = milliseconds / (3 + 1 / 3);
        threeHundredthsOfSecond = Math.round(threeHundredthsOfSecond);
        if (threeHundredthsOfSecond === 2592e4) {
          days += 1;
          threeHundredthsOfSecond = 0;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(days, 0);
        buffer.writeUInt32LE(threeHundredthsOfSecond, 4);
        yield buffer;
      },
      // TODO: type 'any' needs to be revisited.
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1753 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = DateTime7;
    module2.exports = DateTime7;
  }
});

// node_modules/tedious/lib/data-types/float.js
var require_float = __commonJS({
  "node_modules/tedious/lib/data-types/float.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Float = {
      id: 62,
      type: "FLT8",
      name: "Float",
      declaration: function() {
        return "float";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return Buffer.from([8]);
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeDoubleLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports2.default = Float;
    module2.exports = Float;
  }
});

// node_modules/tedious/lib/data-types/decimaln.js
var require_decimaln = __commonJS({
  "node_modules/tedious/lib/data-types/decimaln.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var DecimalN = {
      id: 106,
      type: "DECIMALN",
      name: "DecimalN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = DecimalN;
    module2.exports = DecimalN;
  }
});

// node_modules/tedious/lib/data-types/decimal.js
var require_decimal = __commonJS({
  "node_modules/tedious/lib/data-types/decimal.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Decimal = {
      id: 55,
      type: "DECIMAL",
      name: "Decimal",
      declaration: function(parameter) {
        return "decimal(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter, _options) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_decimaln.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        const precision = parameter.precision;
        if (precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(9);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(13);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(17);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports2.default = Decimal;
    module2.exports = Decimal;
  }
});

// node_modules/tedious/lib/data-types/numericn.js
var require_numericn = __commonJS({
  "node_modules/tedious/lib/data-types/numericn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NumericN = {
      id: 108,
      type: "NUMERICN",
      name: "NumericN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = NumericN;
    module2.exports = NumericN;
  }
});

// node_modules/tedious/lib/data-types/numeric.js
var require_numeric = __commonJS({
  "node_modules/tedious/lib/data-types/numeric.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _numericn = _interopRequireDefault(require_numericn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Numeric = {
      id: 63,
      type: "NUMERIC",
      name: "Numeric",
      declaration: function(parameter) {
        return "numeric(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_numericn.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        if (parameter.precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (parameter.precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(10);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (parameter.precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(14);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(18);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports2.default = Numeric;
    module2.exports = Numeric;
  }
});

// node_modules/tedious/lib/data-types/smallmoney.js
var require_smallmoney = __commonJS({
  "node_modules/tedious/lib/data-types/smallmoney.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallMoney = {
      id: 122,
      type: "MONEY4",
      name: "SmallMoney",
      declaration: function() {
        return "smallmoney";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value * 1e4, 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -214748.3648 || value > 214748.3647) {
          throw new TypeError("Value must be between -214748.3648 and 214748.3647.");
        }
        return value;
      }
    };
    var _default = exports2.default = SmallMoney;
    module2.exports = SmallMoney;
  }
});

// node_modules/tedious/lib/data-types/bigint.js
var require_bigint = __commonJS({
  "node_modules/tedious/lib/data-types/bigint.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([8]);
    var NULL_LENGTH = Buffer.from([0]);
    var MAX_SAFE_BIGINT = 9223372036854775807n;
    var MIN_SAFE_BIGINT = -9223372036854775808n;
    var BigInt2 = {
      id: 127,
      type: "INT8",
      name: "BigInt",
      declaration: function() {
        return "bigint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(8);
        buffer.writeBigInt64LE(typeof parameter.value === "bigint" ? parameter.value : globalThis.BigInt(parameter.value));
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "bigint") {
          value = globalThis.BigInt(value);
        }
        if (value < MIN_SAFE_BIGINT || value > MAX_SAFE_BIGINT) {
          throw new TypeError(`Value must be between ${MIN_SAFE_BIGINT} and ${MAX_SAFE_BIGINT}, inclusive.`);
        }
        return value;
      }
    };
    var _default = exports2.default = BigInt2;
    module2.exports = BigInt2;
  }
});

// node_modules/tedious/lib/data-types/image.js
var require_image = __commonJS({
  "node_modules/tedious/lib/data-types/image.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Image = {
      id: 34,
      type: "IMAGE",
      name: "Image",
      hasTableName: true,
      declaration: function() {
        return "image";
      },
      resolveLength: function(parameter) {
        if (parameter.value != null) {
          const value = parameter.value;
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(5);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports2.default = Image;
    module2.exports = Image;
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "node_modules/iconv-lite/lib/bom-handling.js"(exports2) {
    "use strict";
    var BOMChar = "\uFEFF";
    exports2.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports2.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "node_modules/iconv-lite/encodings/internal.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module2.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\u{1F4A9}") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require("string_decoder").StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options, codec) {
      this.decoder = new StringDecoder(codec.enc);
    }
    InternalDecoder.prototype.write = function(buf) {
      if (!Buffer2.isBuffer(buf)) {
        buf = Buffer2.from(buf);
      }
      return this.decoder.write(buf);
    };
    InternalDecoder.prototype.end = function() {
      return this.decoder.end();
    };
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer2.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer2.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer2.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS({
  "node_modules/iconv-lite/encodings/utf32.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._utf32 = Utf32Codec;
    function Utf32Codec(codecOptions, iconv) {
      this.iconv = iconv;
      this.bomAware = true;
      this.isLE = codecOptions.isLE;
    }
    exports2.utf32le = { type: "_utf32", isLE: true };
    exports2.utf32be = { type: "_utf32", isLE: false };
    exports2.ucs4le = "utf32le";
    exports2.ucs4be = "utf32be";
    Utf32Codec.prototype.encoder = Utf32Encoder;
    Utf32Codec.prototype.decoder = Utf32Decoder;
    function Utf32Encoder(options, codec) {
      this.isLE = codec.isLE;
      this.highSurrogate = 0;
    }
    Utf32Encoder.prototype.write = function(str) {
      var src = Buffer2.from(str, "ucs2");
      var dst = Buffer2.alloc(src.length * 2);
      var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
      var offset = 0;
      for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = 55296 <= code && code < 56320;
        var isLowSurrogate = 56320 <= code && code < 57344;
        if (this.highSurrogate) {
          if (isHighSurrogate || !isLowSurrogate) {
            write32.call(dst, this.highSurrogate, offset);
            offset += 4;
          } else {
            var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
            write32.call(dst, codepoint, offset);
            offset += 4;
            this.highSurrogate = 0;
            continue;
          }
        }
        if (isHighSurrogate)
          this.highSurrogate = code;
        else {
          write32.call(dst, code, offset);
          offset += 4;
          this.highSurrogate = 0;
        }
      }
      if (offset < dst.length)
        dst = dst.slice(0, offset);
      return dst;
    };
    Utf32Encoder.prototype.end = function() {
      if (!this.highSurrogate)
        return;
      var buf = Buffer2.alloc(4);
      if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
      else
        buf.writeUInt32BE(this.highSurrogate, 0);
      this.highSurrogate = 0;
      return buf;
    };
    function Utf32Decoder(options, codec) {
      this.isLE = codec.isLE;
      this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
      this.overflow = [];
    }
    Utf32Decoder.prototype.write = function(src) {
      if (src.length === 0)
        return "";
      var i = 0;
      var codepoint = 0;
      var dst = Buffer2.alloc(src.length + 4);
      var offset = 0;
      var isLE = this.isLE;
      var overflow = this.overflow;
      var badChar = this.badChar;
      if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++)
          overflow.push(src[i]);
        if (overflow.length === 4) {
          if (isLE) {
            codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
          } else {
            codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
          }
          overflow.length = 0;
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
      }
      for (; i < src.length - 3; i += 4) {
        if (isLE) {
          codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
        } else {
          codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
      for (; i < src.length; i++) {
        overflow.push(src[i]);
      }
      return dst.slice(0, offset).toString("ucs2");
    };
    function _writeCodepoint(dst, offset, codepoint, badChar) {
      if (codepoint < 0 || codepoint > 1114111) {
        codepoint = badChar;
      }
      if (codepoint >= 65536) {
        codepoint -= 65536;
        var high = 55296 | codepoint >> 10;
        dst[offset++] = high & 255;
        dst[offset++] = high >> 8;
        var codepoint = 56320 | codepoint & 1023;
      }
      dst[offset++] = codepoint & 255;
      dst[offset++] = codepoint >> 8;
      return offset;
    }
    Utf32Decoder.prototype.end = function() {
      this.overflow.length = 0;
    };
    exports2.utf32 = Utf32AutoCodec;
    exports2.ucs4 = "utf32";
    function Utf32AutoCodec(options, iconv) {
      this.iconv = iconv;
    }
    Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
    Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
    function Utf32AutoEncoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
    }
    Utf32AutoEncoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf32AutoEncoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf32AutoDecoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf32AutoDecoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 32)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf32AutoDecoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var invalidLE = 0, invalidBE = 0;
      var bmpCharsLE = 0, bmpCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16)
                invalidBE++;
              if (b[3] !== 0 || b[2] > 16)
                invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0))
                bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0)
                bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
        return "utf-32be";
      if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
        return "utf-32le";
      return defaultEncoding || "utf-32le";
    }
  }
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "node_modules/iconv-lite/encodings/utf16.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer2.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
      this.overflowByte = -1;
    };
    exports2.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 16)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var asciiCharsLE = 0, asciiCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254)
                  return "utf-16le";
                if (b[0] === 254 && b[1] === 255)
                  return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0)
                asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0)
                asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (asciiCharsBE > asciiCharsLE)
        return "utf-16be";
      if (asciiCharsBE < asciiCharsLE)
        return "utf-16le";
      return defaultEncoding || "utf-16le";
    }
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "node_modules/iconv-lite/encodings/utf7.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2.utf7 = Utf7Codec;
    exports2.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }.bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports2.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer2.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer2.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-codec.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer2.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Not supported by iconv, not sure why.
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
      },
      "mik": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "cp720": {
        "type": "_sbcs",
        "chars": "\x80\x81\xE9\xE2\x84\xE0\x86\xE7\xEA\xEB\xE8\xEF\xEE\x8D\x8E\x8F\x90\u0651\u0652\xF4\xA4\u0640\xFB\xF9\u0621\u0622\u0623\u0624\xA3\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0636\u0637\u0638\u0639\u063A\u0641\xB5\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u2261\u064B\u064C\u064D\u064E\u064F\u0650\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      // Aliases of generated encodings.
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macroman": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macromania": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\xDA\u1EE4\u1EEA\u1EEC\u1EEE\x07\b	\n\v\f\r\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "pt154": {
        "type": "_sbcs",
        "chars": "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\u1EB2\u1EB4\u1EAA\x07\b	\n\v\f\r\u1EF6\u1EF8\x1B\u1EF4 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "ascii": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "tis620": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      }
    };
  }
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-codec.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    var i;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var firstByteNode = this.decodeTables[0];
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
          for (var j = 48; j <= 57; j++) {
            if (secondByteNode[j] === UNASSIGNED) {
              secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
            } else if (secondByteNode[j] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 2");
            }
            var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
            for (var k = 129; k <= 254; k++) {
              if (thirdByteNode[k] === UNASSIGNED) {
                thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
              } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                continue;
              } else if (thirdByteNode[k] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 3");
              }
              var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
              for (var l = 48; l <= 57; l++) {
                if (fourthByteNode[l] === UNASSIGNED)
                  fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = "?".charCodeAt(0);
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>>= 8)
        bytes.push(addr & 255);
      if (bytes.length == 0)
        bytes.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED)
          node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      var hasValues = false;
      var subNodeEmpty = {};
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0) {
          this._setEncodeChar(uCode, mbCode);
          hasValues = true;
        } else if (uCode <= NODE_START) {
          var subNodeIdx = NODE_START - uCode;
          if (!subNodeEmpty[subNodeIdx]) {
            var newPrefix = mbCode << 8 >>> 0;
            if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
              hasValues = true;
            else
              subNodeEmpty[subNodeIdx] = true;
          }
        } else if (uCode <= SEQ_START) {
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
          hasValues = true;
        }
      }
      return hasValues;
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length)
            break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else if (dbcsCode < 16777216) {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >>> 24;
          newBuf[j++] = dbcsCode >>> 16 & 255;
          newBuf[j++] = dbcsCode >>> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBytes = [];
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          uCode = this.defaultCharUnicode.charCodeAt(0);
          i2 = seqStart;
        } else if (uCode === GB18030_CODE) {
          if (i2 >= 3) {
            var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
          } else {
            var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
          }
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode >= 65536) {
          uCode -= 65536;
          var uCodeLead = 55296 | uCode >> 10;
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 | uCode & 1023;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBytes.length > 0) {
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0)
          ret += this.write(bytesArr);
      }
      this.prevBytes = [];
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + (r - l + 1 >> 1);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 128],
      ["a1", "\uFF61", 62],
      ["8140", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7"],
      ["8180", "\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["81b8", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["81c8", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["81da", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["81f0", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["81fc", "\u25EF"],
      ["824f", "\uFF10", 9],
      ["8260", "\uFF21", 25],
      ["8281", "\uFF41", 25],
      ["829f", "\u3041", 82],
      ["8340", "\u30A1", 62],
      ["8380", "\u30E0", 22],
      ["839f", "\u0391", 16, "\u03A3", 6],
      ["83bf", "\u03B1", 16, "\u03C3", 6],
      ["8440", "\u0410", 5, "\u0401\u0416", 25],
      ["8470", "\u0430", 5, "\u0451\u0436", 7],
      ["8480", "\u043E", 17],
      ["849f", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["8740", "\u2460", 19, "\u2160", 9],
      ["875f", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["877e", "\u337B"],
      ["8780", "\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["889f", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["8940", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186"],
      ["8980", "\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["8a40", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B"],
      ["8a80", "\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["8b40", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551"],
      ["8b80", "\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["8c40", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8"],
      ["8c80", "\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["8d40", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D"],
      ["8d80", "\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["8e40", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62"],
      ["8e80", "\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["8f40", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3"],
      ["8f80", "\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["9040", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8"],
      ["9080", "\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["9140", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB"],
      ["9180", "\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["9240", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4"],
      ["9280", "\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["9340", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC"],
      ["9380", "\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["9440", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885"],
      ["9480", "\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["9540", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577"],
      ["9580", "\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["9640", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6"],
      ["9680", "\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["9740", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32"],
      ["9780", "\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["9840", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["989f", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["9940", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED"],
      ["9980", "\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["9a40", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638"],
      ["9a80", "\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["9b40", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80"],
      ["9b80", "\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["9c40", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060"],
      ["9c80", "\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["9d40", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B"],
      ["9d80", "\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["9e40", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E"],
      ["9e80", "\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["9f40", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF"],
      ["9f80", "\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["e040", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD"],
      ["e080", "\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e140", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF"],
      ["e180", "\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e240", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0"],
      ["e280", "\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e340", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37"],
      ["e380", "\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e440", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264"],
      ["e480", "\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e540", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC"],
      ["e580", "\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["e640", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7"],
      ["e680", "\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["e740", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C"],
      ["e780", "\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["e840", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599"],
      ["e880", "\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["e940", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43"],
      ["e980", "\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["ea40", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF"],
      ["ea80", "\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["ed40", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F"],
      ["ed80", "\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["ee40", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559"],
      ["ee80", "\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["eeef", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["f040", "\uE000", 62],
      ["f080", "\uE03F", 124],
      ["f140", "\uE0BC", 62],
      ["f180", "\uE0FB", 124],
      ["f240", "\uE178", 62],
      ["f280", "\uE1B7", 124],
      ["f340", "\uE234", 62],
      ["f380", "\uE273", 124],
      ["f440", "\uE2F0", 62],
      ["f480", "\uE32F", 124],
      ["f540", "\uE3AC", 62],
      ["f580", "\uE3EB", 124],
      ["f640", "\uE468", 62],
      ["f680", "\uE4A7", 124],
      ["f740", "\uE524", 62],
      ["f780", "\uE563", 124],
      ["f840", "\uE5E0", 62],
      ["f880", "\uE61F", 124],
      ["f940", "\uE69C"],
      ["fa40", "\u2170", 9, "\u2160", 9, "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u2235\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A"],
      ["fa80", "\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F"],
      ["fb40", "\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19"],
      ["fb80", "\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9"],
      ["fc40", "\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "node_modules/iconv-lite/encodings/tables/eucjp.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8ea1", "\uFF61", 62],
      ["a1a1", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7"],
      ["a2a1", "\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["a2ba", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["a2ca", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["a2dc", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["a2f2", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["a2fe", "\u25EF"],
      ["a3b0", "\uFF10", 9],
      ["a3c1", "\uFF21", 25],
      ["a3e1", "\uFF41", 25],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a8a1", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["ada1", "\u2460", 19, "\u2160", 9],
      ["adc0", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["addf", "\u337B\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["b0a1", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["b1a1", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC"],
      ["b2a1", "\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["b3a1", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431"],
      ["b4a1", "\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["b5a1", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC"],
      ["b6a1", "\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["b7a1", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372"],
      ["b8a1", "\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["b9a1", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC"],
      ["baa1", "\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["bba1", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642"],
      ["bca1", "\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["bda1", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F"],
      ["bea1", "\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["bfa1", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE"],
      ["c0a1", "\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["c1a1", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E"],
      ["c2a1", "\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["c3a1", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5"],
      ["c4a1", "\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["c5a1", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230"],
      ["c6a1", "\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["c7a1", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6"],
      ["c8a1", "\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["c9a1", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D"],
      ["caa1", "\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["cba1", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80"],
      ["cca1", "\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["cda1", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483"],
      ["cea1", "\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["cfa1", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["d0a1", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["d1a1", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8"],
      ["d2a1", "\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["d3a1", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709"],
      ["d4a1", "\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["d5a1", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53"],
      ["d6a1", "\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["d7a1", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A"],
      ["d8a1", "\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["d9a1", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC"],
      ["daa1", "\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["dba1", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD"],
      ["dca1", "\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["dda1", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE"],
      ["dea1", "\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["dfa1", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC"],
      ["e0a1", "\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e1a1", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670"],
      ["e2a1", "\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e3a1", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50"],
      ["e4a1", "\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e5a1", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A"],
      ["e6a1", "\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e7a1", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9"],
      ["e8a1", "\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e9a1", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759"],
      ["eaa1", "\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["eba1", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B"],
      ["eca1", "\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["eda1", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8"],
      ["eea1", "\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["efa1", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E"],
      ["f0a1", "\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["f1a1", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7"],
      ["f2a1", "\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["f3a1", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0"],
      ["f4a1", "\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["f9a1", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7"],
      ["faa1", "\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["fba1", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA"],
      ["fca1", "\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["fcf1", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["8fa2af", "\u02D8\u02C7\xB8\u02D9\u02DD\xAF\u02DB\u02DA\uFF5E\u0384\u0385"],
      ["8fa2c2", "\xA1\xA6\xBF"],
      ["8fa2eb", "\xBA\xAA\xA9\xAE\u2122\xA4\u2116"],
      ["8fa6e1", "\u0386\u0388\u0389\u038A\u03AA"],
      ["8fa6e7", "\u038C"],
      ["8fa6e9", "\u038E\u03AB"],
      ["8fa6ec", "\u038F"],
      ["8fa6f1", "\u03AC\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03C2\u03CD\u03CB\u03B0\u03CE"],
      ["8fa7c2", "\u0402", 10, "\u040E\u040F"],
      ["8fa7f2", "\u0452", 10, "\u045E\u045F"],
      ["8fa9a1", "\xC6\u0110"],
      ["8fa9a4", "\u0126"],
      ["8fa9a6", "\u0132"],
      ["8fa9a8", "\u0141\u013F"],
      ["8fa9ab", "\u014A\xD8\u0152"],
      ["8fa9af", "\u0166\xDE"],
      ["8fa9c1", "\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0142\u0140\u0149\u014B\xF8\u0153\xDF\u0167\xFE"],
      ["8faaa1", "\xC1\xC0\xC4\xC2\u0102\u01CD\u0100\u0104\xC5\xC3\u0106\u0108\u010C\xC7\u010A\u010E\xC9\xC8\xCB\xCA\u011A\u0116\u0112\u0118"],
      ["8faaba", "\u011C\u011E\u0122\u0120\u0124\xCD\xCC\xCF\xCE\u01CF\u0130\u012A\u012E\u0128\u0134\u0136\u0139\u013D\u013B\u0143\u0147\u0145\xD1\xD3\xD2\xD6\xD4\u01D1\u0150\u014C\xD5\u0154\u0158\u0156\u015A\u015C\u0160\u015E\u0164\u0162\xDA\xD9\xDC\xDB\u016C\u01D3\u0170\u016A\u0172\u016E\u0168\u01D7\u01DB\u01D9\u01D5\u0174\xDD\u0178\u0176\u0179\u017D\u017B"],
      ["8faba1", "\xE1\xE0\xE4\xE2\u0103\u01CE\u0101\u0105\xE5\xE3\u0107\u0109\u010D\xE7\u010B\u010F\xE9\xE8\xEB\xEA\u011B\u0117\u0113\u0119\u01F5\u011D\u011F"],
      ["8fabbd", "\u0121\u0125\xED\xEC\xEF\xEE\u01D0"],
      ["8fabc5", "\u012B\u012F\u0129\u0135\u0137\u013A\u013E\u013C\u0144\u0148\u0146\xF1\xF3\xF2\xF6\xF4\u01D2\u0151\u014D\xF5\u0155\u0159\u0157\u015B\u015D\u0161\u015F\u0165\u0163\xFA\xF9\xFC\xFB\u016D\u01D4\u0171\u016B\u0173\u016F\u0169\u01D8\u01DC\u01DA\u01D6\u0175\xFD\xFF\u0177\u017A\u017E\u017C"],
      ["8fb0a1", "\u4E02\u4E04\u4E05\u4E0C\u4E12\u4E1F\u4E23\u4E24\u4E28\u4E2B\u4E2E\u4E2F\u4E30\u4E35\u4E40\u4E41\u4E44\u4E47\u4E51\u4E5A\u4E5C\u4E63\u4E68\u4E69\u4E74\u4E75\u4E79\u4E7F\u4E8D\u4E96\u4E97\u4E9D\u4EAF\u4EB9\u4EC3\u4ED0\u4EDA\u4EDB\u4EE0\u4EE1\u4EE2\u4EE8\u4EEF\u4EF1\u4EF3\u4EF5\u4EFD\u4EFE\u4EFF\u4F00\u4F02\u4F03\u4F08\u4F0B\u4F0C\u4F12\u4F15\u4F16\u4F17\u4F19\u4F2E\u4F31\u4F60\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E\u4F40\u4F42\u4F48\u4F49\u4F4B\u4F4C\u4F52\u4F54\u4F56\u4F58\u4F5F\u4F63\u4F6A\u4F6C\u4F6E\u4F71\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F7E\u4F81\u4F82\u4F84"],
      ["8fb1a1", "\u4F85\u4F89\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F94\u4F97\u4F99\u4F9A\u4F9E\u4F9F\u4FB2\u4FB7\u4FB9\u4FBB\u4FBC\u4FBD\u4FBE\u4FC0\u4FC1\u4FC5\u4FC6\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FCF\u4FD2\u4FDC\u4FE0\u4FE2\u4FF0\u4FF2\u4FFC\u4FFD\u4FFF\u5000\u5001\u5004\u5007\u500A\u500C\u500E\u5010\u5013\u5017\u5018\u501B\u501C\u501D\u501E\u5022\u5027\u502E\u5030\u5032\u5033\u5035\u5040\u5041\u5042\u5045\u5046\u504A\u504C\u504E\u5051\u5052\u5053\u5057\u5059\u505F\u5060\u5062\u5063\u5066\u5067\u506A\u506D\u5070\u5071\u503B\u5081\u5083\u5084\u5086\u508A\u508E\u508F\u5090"],
      ["8fb2a1", "\u5092\u5093\u5094\u5096\u509B\u509C\u509E", 4, "\u50AA\u50AF\u50B0\u50B9\u50BA\u50BD\u50C0\u50C3\u50C4\u50C7\u50CC\u50CE\u50D0\u50D3\u50D4\u50D8\u50DC\u50DD\u50DF\u50E2\u50E4\u50E6\u50E8\u50E9\u50EF\u50F1\u50F6\u50FA\u50FE\u5103\u5106\u5107\u5108\u510B\u510C\u510D\u510E\u50F2\u5110\u5117\u5119\u511B\u511C\u511D\u511E\u5123\u5127\u5128\u512C\u512D\u512F\u5131\u5133\u5134\u5135\u5138\u5139\u5142\u514A\u514F\u5153\u5155\u5157\u5158\u515F\u5164\u5166\u517E\u5183\u5184\u518B\u518E\u5198\u519D\u51A1\u51A3\u51AD\u51B8\u51BA\u51BC\u51BE\u51BF\u51C2"],
      ["8fb3a1", "\u51C8\u51CF\u51D1\u51D2\u51D3\u51D5\u51D8\u51DE\u51E2\u51E5\u51EE\u51F2\u51F3\u51F4\u51F7\u5201\u5202\u5205\u5212\u5213\u5215\u5216\u5218\u5222\u5228\u5231\u5232\u5235\u523C\u5245\u5249\u5255\u5257\u5258\u525A\u525C\u525F\u5260\u5261\u5266\u526E\u5277\u5278\u5279\u5280\u5282\u5285\u528A\u528C\u5293\u5295\u5296\u5297\u5298\u529A\u529C\u52A4\u52A5\u52A6\u52A7\u52AF\u52B0\u52B6\u52B7\u52B8\u52BA\u52BB\u52BD\u52C0\u52C4\u52C6\u52C8\u52CC\u52CF\u52D1\u52D4\u52D6\u52DB\u52DC\u52E1\u52E5\u52E8\u52E9\u52EA\u52EC\u52F0\u52F1\u52F4\u52F6\u52F7\u5300\u5303\u530A\u530B"],
      ["8fb4a1", "\u530C\u5311\u5313\u5318\u531B\u531C\u531E\u531F\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u5330\u5332\u5335\u533C\u533D\u533E\u5342\u534C\u534B\u5359\u535B\u5361\u5363\u5365\u536C\u536D\u5372\u5379\u537E\u5383\u5387\u5388\u538E\u5393\u5394\u5399\u539D\u53A1\u53A4\u53AA\u53AB\u53AF\u53B2\u53B4\u53B5\u53B7\u53B8\u53BA\u53BD\u53C0\u53C5\u53CF\u53D2\u53D3\u53D5\u53DA\u53DD\u53DE\u53E0\u53E6\u53E7\u53F5\u5402\u5413\u541A\u5421\u5427\u5428\u542A\u542F\u5431\u5434\u5435\u5443\u5444\u5447\u544D\u544F\u545E\u5462\u5464\u5466\u5467\u5469\u546B\u546D\u546E\u5474\u547F"],
      ["8fb5a1", "\u5481\u5483\u5485\u5488\u5489\u548D\u5491\u5495\u5496\u549C\u549F\u54A1\u54A6\u54A7\u54A9\u54AA\u54AD\u54AE\u54B1\u54B7\u54B9\u54BA\u54BB\u54BF\u54C6\u54CA\u54CD\u54CE\u54E0\u54EA\u54EC\u54EF\u54F6\u54FC\u54FE\u54FF\u5500\u5501\u5505\u5508\u5509\u550C\u550D\u550E\u5515\u552A\u552B\u5532\u5535\u5536\u553B\u553C\u553D\u5541\u5547\u5549\u554A\u554D\u5550\u5551\u5558\u555A\u555B\u555E\u5560\u5561\u5564\u5566\u557F\u5581\u5582\u5586\u5588\u558E\u558F\u5591\u5592\u5593\u5594\u5597\u55A3\u55A4\u55AD\u55B2\u55BF\u55C1\u55C3\u55C6\u55C9\u55CB\u55CC\u55CE\u55D1\u55D2"],
      ["8fb6a1", "\u55D3\u55D7\u55D8\u55DB\u55DE\u55E2\u55E9\u55F6\u55FF\u5605\u5608\u560A\u560D", 5, "\u5619\u562C\u5630\u5633\u5635\u5637\u5639\u563B\u563C\u563D\u563F\u5640\u5641\u5643\u5644\u5646\u5649\u564B\u564D\u564F\u5654\u565E\u5660\u5661\u5662\u5663\u5666\u5669\u566D\u566F\u5671\u5672\u5675\u5684\u5685\u5688\u568B\u568C\u5695\u5699\u569A\u569D\u569E\u569F\u56A6\u56A7\u56A8\u56A9\u56AB\u56AC\u56AD\u56B1\u56B3\u56B7\u56BE\u56C5\u56C9\u56CA\u56CB\u56CF\u56D0\u56CC\u56CD\u56D9\u56DC\u56DD\u56DF\u56E1\u56E4", 4, "\u56F1\u56EB\u56ED"],
      ["8fb7a1", "\u56F6\u56F7\u5701\u5702\u5707\u570A\u570C\u5711\u5715\u571A\u571B\u571D\u5720\u5722\u5723\u5724\u5725\u5729\u572A\u572C\u572E\u572F\u5733\u5734\u573D\u573E\u573F\u5745\u5746\u574C\u574D\u5752\u5762\u5765\u5767\u5768\u576B\u576D", 4, "\u5773\u5774\u5775\u5777\u5779\u577A\u577B\u577C\u577E\u5781\u5783\u578C\u5794\u5797\u5799\u579A\u579C\u579D\u579E\u579F\u57A1\u5795\u57A7\u57A8\u57A9\u57AC\u57B8\u57BD\u57C7\u57C8\u57CC\u57CF\u57D5\u57DD\u57DE\u57E4\u57E6\u57E7\u57E9\u57ED\u57F0\u57F5\u57F6\u57F8\u57FD\u57FE\u57FF\u5803\u5804\u5808\u5809\u57E1"],
      ["8fb8a1", "\u580C\u580D\u581B\u581E\u581F\u5820\u5826\u5827\u582D\u5832\u5839\u583F\u5849\u584C\u584D\u584F\u5850\u5855\u585F\u5861\u5864\u5867\u5868\u5878\u587C\u587F\u5880\u5881\u5887\u5888\u5889\u588A\u588C\u588D\u588F\u5890\u5894\u5896\u589D\u58A0\u58A1\u58A2\u58A6\u58A9\u58B1\u58B2\u58C4\u58BC\u58C2\u58C8\u58CD\u58CE\u58D0\u58D2\u58D4\u58D6\u58DA\u58DD\u58E1\u58E2\u58E9\u58F3\u5905\u5906\u590B\u590C\u5912\u5913\u5914\u8641\u591D\u5921\u5923\u5924\u5928\u592F\u5930\u5933\u5935\u5936\u593F\u5943\u5946\u5952\u5953\u5959\u595B\u595D\u595E\u595F\u5961\u5963\u596B\u596D"],
      ["8fb9a1", "\u596F\u5972\u5975\u5976\u5979\u597B\u597C\u598B\u598C\u598E\u5992\u5995\u5997\u599F\u59A4\u59A7\u59AD\u59AE\u59AF\u59B0\u59B3\u59B7\u59BA\u59BC\u59C1\u59C3\u59C4\u59C8\u59CA\u59CD\u59D2\u59DD\u59DE\u59DF\u59E3\u59E4\u59E7\u59EE\u59EF\u59F1\u59F2\u59F4\u59F7\u5A00\u5A04\u5A0C\u5A0D\u5A0E\u5A12\u5A13\u5A1E\u5A23\u5A24\u5A27\u5A28\u5A2A\u5A2D\u5A30\u5A44\u5A45\u5A47\u5A48\u5A4C\u5A50\u5A55\u5A5E\u5A63\u5A65\u5A67\u5A6D\u5A77\u5A7A\u5A7B\u5A7E\u5A8B\u5A90\u5A93\u5A96\u5A99\u5A9C\u5A9E\u5A9F\u5AA0\u5AA2\u5AA7\u5AAC\u5AB1\u5AB2\u5AB3\u5AB5\u5AB8\u5ABA\u5ABB\u5ABF"],
      ["8fbaa1", "\u5AC4\u5AC6\u5AC8\u5ACF\u5ADA\u5ADC\u5AE0\u5AE5\u5AEA\u5AEE\u5AF5\u5AF6\u5AFD\u5B00\u5B01\u5B08\u5B17\u5B34\u5B19\u5B1B\u5B1D\u5B21\u5B25\u5B2D\u5B38\u5B41\u5B4B\u5B4C\u5B52\u5B56\u5B5E\u5B68\u5B6E\u5B6F\u5B7C\u5B7D\u5B7E\u5B7F\u5B81\u5B84\u5B86\u5B8A\u5B8E\u5B90\u5B91\u5B93\u5B94\u5B96\u5BA8\u5BA9\u5BAC\u5BAD\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBC\u5BC0\u5BC1\u5BCD\u5BCF\u5BD6", 4, "\u5BE0\u5BEF\u5BF1\u5BF4\u5BFD\u5C0C\u5C17\u5C1E\u5C1F\u5C23\u5C26\u5C29\u5C2B\u5C2C\u5C2E\u5C30\u5C32\u5C35\u5C36\u5C59\u5C5A\u5C5C\u5C62\u5C63\u5C67\u5C68\u5C69"],
      ["8fbba1", "\u5C6D\u5C70\u5C74\u5C75\u5C7A\u5C7B\u5C7C\u5C7D\u5C87\u5C88\u5C8A\u5C8F\u5C92\u5C9D\u5C9F\u5CA0\u5CA2\u5CA3\u5CA6\u5CAA\u5CB2\u5CB4\u5CB5\u5CBA\u5CC9\u5CCB\u5CD2\u5CDD\u5CD7\u5CEE\u5CF1\u5CF2\u5CF4\u5D01\u5D06\u5D0D\u5D12\u5D2B\u5D23\u5D24\u5D26\u5D27\u5D31\u5D34\u5D39\u5D3D\u5D3F\u5D42\u5D43\u5D46\u5D48\u5D55\u5D51\u5D59\u5D4A\u5D5F\u5D60\u5D61\u5D62\u5D64\u5D6A\u5D6D\u5D70\u5D79\u5D7A\u5D7E\u5D7F\u5D81\u5D83\u5D88\u5D8A\u5D92\u5D93\u5D94\u5D95\u5D99\u5D9B\u5D9F\u5DA0\u5DA7\u5DAB\u5DB0\u5DB4\u5DB8\u5DB9\u5DC3\u5DC7\u5DCB\u5DD0\u5DCE\u5DD8\u5DD9\u5DE0\u5DE4"],
      ["8fbca1", "\u5DE9\u5DF8\u5DF9\u5E00\u5E07\u5E0D\u5E12\u5E14\u5E15\u5E18\u5E1F\u5E20\u5E2E\u5E28\u5E32\u5E35\u5E3E\u5E4B\u5E50\u5E49\u5E51\u5E56\u5E58\u5E5B\u5E5C\u5E5E\u5E68\u5E6A", 4, "\u5E70\u5E80\u5E8B\u5E8E\u5EA2\u5EA4\u5EA5\u5EA8\u5EAA\u5EAC\u5EB1\u5EB3\u5EBD\u5EBE\u5EBF\u5EC6\u5ECC\u5ECB\u5ECE\u5ED1\u5ED2\u5ED4\u5ED5\u5EDC\u5EDE\u5EE5\u5EEB\u5F02\u5F06\u5F07\u5F08\u5F0E\u5F19\u5F1C\u5F1D\u5F21\u5F22\u5F23\u5F24\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F34\u5F36\u5F3B\u5F3D\u5F3F\u5F40\u5F44\u5F45\u5F47\u5F4D\u5F50\u5F54\u5F58\u5F5B\u5F60\u5F63\u5F64\u5F67"],
      ["8fbda1", "\u5F6F\u5F72\u5F74\u5F75\u5F78\u5F7A\u5F7D\u5F7E\u5F89\u5F8D\u5F8F\u5F96\u5F9C\u5F9D\u5FA2\u5FA7\u5FAB\u5FA4\u5FAC\u5FAF\u5FB0\u5FB1\u5FB8\u5FC4\u5FC7\u5FC8\u5FC9\u5FCB\u5FD0", 4, "\u5FDE\u5FE1\u5FE2\u5FE8\u5FE9\u5FEA\u5FEC\u5FED\u5FEE\u5FEF\u5FF2\u5FF3\u5FF6\u5FFA\u5FFC\u6007\u600A\u600D\u6013\u6014\u6017\u6018\u601A\u601F\u6024\u602D\u6033\u6035\u6040\u6047\u6048\u6049\u604C\u6051\u6054\u6056\u6057\u605D\u6061\u6067\u6071\u607E\u607F\u6082\u6086\u6088\u608A\u608E\u6091\u6093\u6095\u6098\u609D\u609E\u60A2\u60A4\u60A5\u60A8\u60B0\u60B1\u60B7"],
      ["8fbea1", "\u60BB\u60BE\u60C2\u60C4\u60C8\u60C9\u60CA\u60CB\u60CE\u60CF\u60D4\u60D5\u60D9\u60DB\u60DD\u60DE\u60E2\u60E5\u60F2\u60F5\u60F8\u60FC\u60FD\u6102\u6107\u610A\u610C\u6110", 4, "\u6116\u6117\u6119\u611C\u611E\u6122\u612A\u612B\u6130\u6131\u6135\u6136\u6137\u6139\u6141\u6145\u6146\u6149\u615E\u6160\u616C\u6172\u6178\u617B\u617C\u617F\u6180\u6181\u6183\u6184\u618B\u618D\u6192\u6193\u6197\u6198\u619C\u619D\u619F\u61A0\u61A5\u61A8\u61AA\u61AD\u61B8\u61B9\u61BC\u61C0\u61C1\u61C2\u61CE\u61CF\u61D5\u61DC\u61DD\u61DE\u61DF\u61E1\u61E2\u61E7\u61E9\u61E5"],
      ["8fbfa1", "\u61EC\u61ED\u61EF\u6201\u6203\u6204\u6207\u6213\u6215\u621C\u6220\u6222\u6223\u6227\u6229\u622B\u6239\u623D\u6242\u6243\u6244\u6246\u624C\u6250\u6251\u6252\u6254\u6256\u625A\u625C\u6264\u626D\u626F\u6273\u627A\u627D\u628D\u628E\u628F\u6290\u62A6\u62A8\u62B3\u62B6\u62B7\u62BA\u62BE\u62BF\u62C4\u62CE\u62D5\u62D6\u62DA\u62EA\u62F2\u62F4\u62FC\u62FD\u6303\u6304\u630A\u630B\u630D\u6310\u6313\u6316\u6318\u6329\u632A\u632D\u6335\u6336\u6339\u633C\u6341\u6342\u6343\u6344\u6346\u634A\u634B\u634E\u6352\u6353\u6354\u6358\u635B\u6365\u6366\u636C\u636D\u6371\u6374\u6375"],
      ["8fc0a1", "\u6378\u637C\u637D\u637F\u6382\u6384\u6387\u638A\u6390\u6394\u6395\u6399\u639A\u639E\u63A4\u63A6\u63AD\u63AE\u63AF\u63BD\u63C1\u63C5\u63C8\u63CE\u63D1\u63D3\u63D4\u63D5\u63DC\u63E0\u63E5\u63EA\u63EC\u63F2\u63F3\u63F5\u63F8\u63F9\u6409\u640A\u6410\u6412\u6414\u6418\u641E\u6420\u6422\u6424\u6425\u6429\u642A\u642F\u6430\u6435\u643D\u643F\u644B\u644F\u6451\u6452\u6453\u6454\u645A\u645B\u645C\u645D\u645F\u6460\u6461\u6463\u646D\u6473\u6474\u647B\u647D\u6485\u6487\u648F\u6490\u6491\u6498\u6499\u649B\u649D\u649F\u64A1\u64A3\u64A6\u64A8\u64AC\u64B3\u64BD\u64BE\u64BF"],
      ["8fc1a1", "\u64C4\u64C9\u64CA\u64CB\u64CC\u64CE\u64D0\u64D1\u64D5\u64D7\u64E4\u64E5\u64E9\u64EA\u64ED\u64F0\u64F5\u64F7\u64FB\u64FF\u6501\u6504\u6508\u6509\u650A\u650F\u6513\u6514\u6516\u6519\u651B\u651E\u651F\u6522\u6526\u6529\u652E\u6531\u653A\u653C\u653D\u6543\u6547\u6549\u6550\u6552\u6554\u655F\u6560\u6567\u656B\u657A\u657D\u6581\u6585\u658A\u6592\u6595\u6598\u659D\u65A0\u65A3\u65A6\u65AE\u65B2\u65B3\u65B4\u65BF\u65C2\u65C8\u65C9\u65CE\u65D0\u65D4\u65D6\u65D8\u65DF\u65F0\u65F2\u65F4\u65F5\u65F9\u65FE\u65FF\u6600\u6604\u6608\u6609\u660D\u6611\u6612\u6615\u6616\u661D"],
      ["8fc2a1", "\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6631\u6633\u6639\u6637\u6640\u6645\u6646\u664A\u664C\u6651\u664E\u6657\u6658\u6659\u665B\u665C\u6660\u6661\u66FB\u666A\u666B\u666C\u667E\u6673\u6675\u667F\u6677\u6678\u6679\u667B\u6680\u667C\u668B\u668C\u668D\u6690\u6692\u6699\u669A\u669B\u669C\u669F\u66A0\u66A4\u66AD\u66B1\u66B2\u66B5\u66BB\u66BF\u66C0\u66C2\u66C3\u66C8\u66CC\u66CE\u66CF\u66D4\u66DB\u66DF\u66E8\u66EB\u66EC\u66EE\u66FA\u6705\u6707\u670E\u6713\u6719\u671C\u6720\u6722\u6733\u673E\u6745\u6747\u6748\u674C\u6754\u6755\u675D"],
      ["8fc3a1", "\u6766\u676C\u676E\u6774\u6776\u677B\u6781\u6784\u678E\u678F\u6791\u6793\u6796\u6798\u6799\u679B\u67B0\u67B1\u67B2\u67B5\u67BB\u67BC\u67BD\u67F9\u67C0\u67C2\u67C3\u67C5\u67C8\u67C9\u67D2\u67D7\u67D9\u67DC\u67E1\u67E6\u67F0\u67F2\u67F6\u67F7\u6852\u6814\u6819\u681D\u681F\u6828\u6827\u682C\u682D\u682F\u6830\u6831\u6833\u683B\u683F\u6844\u6845\u684A\u684C\u6855\u6857\u6858\u685B\u686B\u686E", 4, "\u6875\u6879\u687A\u687B\u687C\u6882\u6884\u6886\u6888\u6896\u6898\u689A\u689C\u68A1\u68A3\u68A5\u68A9\u68AA\u68AE\u68B2\u68BB\u68C5\u68C8\u68CC\u68CF"],
      ["8fc4a1", "\u68D0\u68D1\u68D3\u68D6\u68D9\u68DC\u68DD\u68E5\u68E8\u68EA\u68EB\u68EC\u68ED\u68F0\u68F1\u68F5\u68F6\u68FB\u68FC\u68FD\u6906\u6909\u690A\u6910\u6911\u6913\u6916\u6917\u6931\u6933\u6935\u6938\u693B\u6942\u6945\u6949\u694E\u6957\u695B\u6963\u6964\u6965\u6966\u6968\u6969\u696C\u6970\u6971\u6972\u697A\u697B\u697F\u6980\u698D\u6992\u6996\u6998\u69A1\u69A5\u69A6\u69A8\u69AB\u69AD\u69AF\u69B7\u69B8\u69BA\u69BC\u69C5\u69C8\u69D1\u69D6\u69D7\u69E2\u69E5\u69EE\u69EF\u69F1\u69F3\u69F5\u69FE\u6A00\u6A01\u6A03\u6A0F\u6A11\u6A15\u6A1A\u6A1D\u6A20\u6A24\u6A28\u6A30\u6A32"],
      ["8fc5a1", "\u6A34\u6A37\u6A3B\u6A3E\u6A3F\u6A45\u6A46\u6A49\u6A4A\u6A4E\u6A50\u6A51\u6A52\u6A55\u6A56\u6A5B\u6A64\u6A67\u6A6A\u6A71\u6A73\u6A7E\u6A81\u6A83\u6A86\u6A87\u6A89\u6A8B\u6A91\u6A9B\u6A9D\u6A9E\u6A9F\u6AA5\u6AAB\u6AAF\u6AB0\u6AB1\u6AB4\u6ABD\u6ABE\u6ABF\u6AC6\u6AC9\u6AC8\u6ACC\u6AD0\u6AD4\u6AD5\u6AD6\u6ADC\u6ADD\u6AE4\u6AE7\u6AEC\u6AF0\u6AF1\u6AF2\u6AFC\u6AFD\u6B02\u6B03\u6B06\u6B07\u6B09\u6B0F\u6B10\u6B11\u6B17\u6B1B\u6B1E\u6B24\u6B28\u6B2B\u6B2C\u6B2F\u6B35\u6B36\u6B3B\u6B3F\u6B46\u6B4A\u6B4D\u6B52\u6B56\u6B58\u6B5D\u6B60\u6B67\u6B6B\u6B6E\u6B70\u6B75\u6B7D"],
      ["8fc6a1", "\u6B7E\u6B82\u6B85\u6B97\u6B9B\u6B9F\u6BA0\u6BA2\u6BA3\u6BA8\u6BA9\u6BAC\u6BAD\u6BAE\u6BB0\u6BB8\u6BB9\u6BBD\u6BBE\u6BC3\u6BC4\u6BC9\u6BCC\u6BD6\u6BDA\u6BE1\u6BE3\u6BE6\u6BE7\u6BEE\u6BF1\u6BF7\u6BF9\u6BFF\u6C02\u6C04\u6C05\u6C09\u6C0D\u6C0E\u6C10\u6C12\u6C19\u6C1F\u6C26\u6C27\u6C28\u6C2C\u6C2E\u6C33\u6C35\u6C36\u6C3A\u6C3B\u6C3F\u6C4A\u6C4B\u6C4D\u6C4F\u6C52\u6C54\u6C59\u6C5B\u6C5C\u6C6B\u6C6D\u6C6F\u6C74\u6C76\u6C78\u6C79\u6C7B\u6C85\u6C86\u6C87\u6C89\u6C94\u6C95\u6C97\u6C98\u6C9C\u6C9F\u6CB0\u6CB2\u6CB4\u6CC2\u6CC6\u6CCD\u6CCF\u6CD0\u6CD1\u6CD2\u6CD4\u6CD6"],
      ["8fc7a1", "\u6CDA\u6CDC\u6CE0\u6CE7\u6CE9\u6CEB\u6CEC\u6CEE\u6CF2\u6CF4\u6D04\u6D07\u6D0A\u6D0E\u6D0F\u6D11\u6D13\u6D1A\u6D26\u6D27\u6D28\u6C67\u6D2E\u6D2F\u6D31\u6D39\u6D3C\u6D3F\u6D57\u6D5E\u6D5F\u6D61\u6D65\u6D67\u6D6F\u6D70\u6D7C\u6D82\u6D87\u6D91\u6D92\u6D94\u6D96\u6D97\u6D98\u6DAA\u6DAC\u6DB4\u6DB7\u6DB9\u6DBD\u6DBF\u6DC4\u6DC8\u6DCA\u6DCE\u6DCF\u6DD6\u6DDB\u6DDD\u6DDF\u6DE0\u6DE2\u6DE5\u6DE9\u6DEF\u6DF0\u6DF4\u6DF6\u6DFC\u6E00\u6E04\u6E1E\u6E22\u6E27\u6E32\u6E36\u6E39\u6E3B\u6E3C\u6E44\u6E45\u6E48\u6E49\u6E4B\u6E4F\u6E51\u6E52\u6E53\u6E54\u6E57\u6E5C\u6E5D\u6E5E"],
      ["8fc8a1", "\u6E62\u6E63\u6E68\u6E73\u6E7B\u6E7D\u6E8D\u6E93\u6E99\u6EA0\u6EA7\u6EAD\u6EAE\u6EB1\u6EB3\u6EBB\u6EBF\u6EC0\u6EC1\u6EC3\u6EC7\u6EC8\u6ECA\u6ECD\u6ECE\u6ECF\u6EEB\u6EED\u6EEE\u6EF9\u6EFB\u6EFD\u6F04\u6F08\u6F0A\u6F0C\u6F0D\u6F16\u6F18\u6F1A\u6F1B\u6F26\u6F29\u6F2A\u6F2F\u6F30\u6F33\u6F36\u6F3B\u6F3C\u6F2D\u6F4F\u6F51\u6F52\u6F53\u6F57\u6F59\u6F5A\u6F5D\u6F5E\u6F61\u6F62\u6F68\u6F6C\u6F7D\u6F7E\u6F83\u6F87\u6F88\u6F8B\u6F8C\u6F8D\u6F90\u6F92\u6F93\u6F94\u6F96\u6F9A\u6F9F\u6FA0\u6FA5\u6FA6\u6FA7\u6FA8\u6FAE\u6FAF\u6FB0\u6FB5\u6FB6\u6FBC\u6FC5\u6FC7\u6FC8\u6FCA"],
      ["8fc9a1", "\u6FDA\u6FDE\u6FE8\u6FE9\u6FF0\u6FF5\u6FF9\u6FFC\u6FFD\u7000\u7005\u7006\u7007\u700D\u7017\u7020\u7023\u702F\u7034\u7037\u7039\u703C\u7043\u7044\u7048\u7049\u704A\u704B\u7054\u7055\u705D\u705E\u704E\u7064\u7065\u706C\u706E\u7075\u7076\u707E\u7081\u7085\u7086\u7094", 4, "\u709B\u70A4\u70AB\u70B0\u70B1\u70B4\u70B7\u70CA\u70D1\u70D3\u70D4\u70D5\u70D6\u70D8\u70DC\u70E4\u70FA\u7103", 4, "\u710B\u710C\u710F\u711E\u7120\u712B\u712D\u712F\u7130\u7131\u7138\u7141\u7145\u7146\u7147\u714A\u714B\u7150\u7152\u7157\u715A\u715C\u715E\u7160"],
      ["8fcaa1", "\u7168\u7179\u7180\u7185\u7187\u718C\u7192\u719A\u719B\u71A0\u71A2\u71AF\u71B0\u71B2\u71B3\u71BA\u71BF\u71C0\u71C1\u71C4\u71CB\u71CC\u71D3\u71D6\u71D9\u71DA\u71DC\u71F8\u71FE\u7200\u7207\u7208\u7209\u7213\u7217\u721A\u721D\u721F\u7224\u722B\u722F\u7234\u7238\u7239\u7241\u7242\u7243\u7245\u724E\u724F\u7250\u7253\u7255\u7256\u725A\u725C\u725E\u7260\u7263\u7268\u726B\u726E\u726F\u7271\u7277\u7278\u727B\u727C\u727F\u7284\u7289\u728D\u728E\u7293\u729B\u72A8\u72AD\u72AE\u72B1\u72B4\u72BE\u72C1\u72C7\u72C9\u72CC\u72D5\u72D6\u72D8\u72DF\u72E5\u72F3\u72F4\u72FA\u72FB"],
      ["8fcba1", "\u72FE\u7302\u7304\u7305\u7307\u730B\u730D\u7312\u7313\u7318\u7319\u731E\u7322\u7324\u7327\u7328\u732C\u7331\u7332\u7335\u733A\u733B\u733D\u7343\u734D\u7350\u7352\u7356\u7358\u735D\u735E\u735F\u7360\u7366\u7367\u7369\u736B\u736C\u736E\u736F\u7371\u7377\u7379\u737C\u7380\u7381\u7383\u7385\u7386\u738E\u7390\u7393\u7395\u7397\u7398\u739C\u739E\u739F\u73A0\u73A2\u73A5\u73A6\u73AA\u73AB\u73AD\u73B5\u73B7\u73B9\u73BC\u73BD\u73BF\u73C5\u73C6\u73C9\u73CB\u73CC\u73CF\u73D2\u73D3\u73D6\u73D9\u73DD\u73E1\u73E3\u73E6\u73E7\u73E9\u73F4\u73F5\u73F7\u73F9\u73FA\u73FB\u73FD"],
      ["8fcca1", "\u73FF\u7400\u7401\u7404\u7407\u740A\u7411\u741A\u741B\u7424\u7426\u7428", 9, "\u7439\u7440\u7443\u7444\u7446\u7447\u744B\u744D\u7451\u7452\u7457\u745D\u7462\u7466\u7467\u7468\u746B\u746D\u746E\u7471\u7472\u7480\u7481\u7485\u7486\u7487\u7489\u748F\u7490\u7491\u7492\u7498\u7499\u749A\u749C\u749F\u74A0\u74A1\u74A3\u74A6\u74A8\u74A9\u74AA\u74AB\u74AE\u74AF\u74B1\u74B2\u74B5\u74B9\u74BB\u74BF\u74C8\u74C9\u74CC\u74D0\u74D3\u74D8\u74DA\u74DB\u74DE\u74DF\u74E4\u74E8\u74EA\u74EB\u74EF\u74F4\u74FA\u74FB\u74FC\u74FF\u7506"],
      ["8fcda1", "\u7512\u7516\u7517\u7520\u7521\u7524\u7527\u7529\u752A\u752F\u7536\u7539\u753D\u753E\u753F\u7540\u7543\u7547\u7548\u754E\u7550\u7552\u7557\u755E\u755F\u7561\u756F\u7571\u7579", 5, "\u7581\u7585\u7590\u7592\u7593\u7595\u7599\u759C\u75A2\u75A4\u75B4\u75BA\u75BF\u75C0\u75C1\u75C4\u75C6\u75CC\u75CE\u75CF\u75D7\u75DC\u75DF\u75E0\u75E1\u75E4\u75E7\u75EC\u75EE\u75EF\u75F1\u75F9\u7600\u7602\u7603\u7604\u7607\u7608\u760A\u760C\u760F\u7612\u7613\u7615\u7616\u7619\u761B\u761C\u761D\u761E\u7623\u7625\u7626\u7629\u762D\u7632\u7633\u7635\u7638\u7639"],
      ["8fcea1", "\u763A\u763C\u764A\u7640\u7641\u7643\u7644\u7645\u7649\u764B\u7655\u7659\u765F\u7664\u7665\u766D\u766E\u766F\u7671\u7674\u7681\u7685\u768C\u768D\u7695\u769B\u769C\u769D\u769F\u76A0\u76A2", 6, "\u76AA\u76AD\u76BD\u76C1\u76C5\u76C9\u76CB\u76CC\u76CE\u76D4\u76D9\u76E0\u76E6\u76E8\u76EC\u76F0\u76F1\u76F6\u76F9\u76FC\u7700\u7706\u770A\u770E\u7712\u7714\u7715\u7717\u7719\u771A\u771C\u7722\u7728\u772D\u772E\u772F\u7734\u7735\u7736\u7739\u773D\u773E\u7742\u7745\u7746\u774A\u774D\u774E\u774F\u7752\u7756\u7757\u775C\u775E\u775F\u7760\u7762"],
      ["8fcfa1", "\u7764\u7767\u776A\u776C\u7770\u7772\u7773\u7774\u777A\u777D\u7780\u7784\u778C\u778D\u7794\u7795\u7796\u779A\u779F\u77A2\u77A7\u77AA\u77AE\u77AF\u77B1\u77B5\u77BE\u77C3\u77C9\u77D1\u77D2\u77D5\u77D9\u77DE\u77DF\u77E0\u77E4\u77E6\u77EA\u77EC\u77F0\u77F1\u77F4\u77F8\u77FB\u7805\u7806\u7809\u780D\u780E\u7811\u781D\u7821\u7822\u7823\u782D\u782E\u7830\u7835\u7837\u7843\u7844\u7847\u7848\u784C\u784E\u7852\u785C\u785E\u7860\u7861\u7863\u7864\u7868\u786A\u786E\u787A\u787E\u788A\u788F\u7894\u7898\u78A1\u789D\u789E\u789F\u78A4\u78A8\u78AC\u78AD\u78B0\u78B1\u78B2\u78B3"],
      ["8fd0a1", "\u78BB\u78BD\u78BF\u78C7\u78C8\u78C9\u78CC\u78CE\u78D2\u78D3\u78D5\u78D6\u78E4\u78DB\u78DF\u78E0\u78E1\u78E6\u78EA\u78F2\u78F3\u7900\u78F6\u78F7\u78FA\u78FB\u78FF\u7906\u790C\u7910\u791A\u791C\u791E\u791F\u7920\u7925\u7927\u7929\u792D\u7931\u7934\u7935\u793B\u793D\u793F\u7944\u7945\u7946\u794A\u794B\u794F\u7951\u7954\u7958\u795B\u795C\u7967\u7969\u796B\u7972\u7979\u797B\u797C\u797E\u798B\u798C\u7991\u7993\u7994\u7995\u7996\u7998\u799B\u799C\u79A1\u79A8\u79A9\u79AB\u79AF\u79B1\u79B4\u79B8\u79BB\u79C2\u79C4\u79C7\u79C8\u79CA\u79CF\u79D4\u79D6\u79DA\u79DD\u79DE"],
      ["8fd1a1", "\u79E0\u79E2\u79E5\u79EA\u79EB\u79ED\u79F1\u79F8\u79FC\u7A02\u7A03\u7A07\u7A09\u7A0A\u7A0C\u7A11\u7A15\u7A1B\u7A1E\u7A21\u7A27\u7A2B\u7A2D\u7A2F\u7A30\u7A34\u7A35\u7A38\u7A39\u7A3A\u7A44\u7A45\u7A47\u7A48\u7A4C\u7A55\u7A56\u7A59\u7A5C\u7A5D\u7A5F\u7A60\u7A65\u7A67\u7A6A\u7A6D\u7A75\u7A78\u7A7E\u7A80\u7A82\u7A85\u7A86\u7A8A\u7A8B\u7A90\u7A91\u7A94\u7A9E\u7AA0\u7AA3\u7AAC\u7AB3\u7AB5\u7AB9\u7ABB\u7ABC\u7AC6\u7AC9\u7ACC\u7ACE\u7AD1\u7ADB\u7AE8\u7AE9\u7AEB\u7AEC\u7AF1\u7AF4\u7AFB\u7AFD\u7AFE\u7B07\u7B14\u7B1F\u7B23\u7B27\u7B29\u7B2A\u7B2B\u7B2D\u7B2E\u7B2F\u7B30"],
      ["8fd2a1", "\u7B31\u7B34\u7B3D\u7B3F\u7B40\u7B41\u7B47\u7B4E\u7B55\u7B60\u7B64\u7B66\u7B69\u7B6A\u7B6D\u7B6F\u7B72\u7B73\u7B77\u7B84\u7B89\u7B8E\u7B90\u7B91\u7B96\u7B9B\u7B9E\u7BA0\u7BA5\u7BAC\u7BAF\u7BB0\u7BB2\u7BB5\u7BB6\u7BBA\u7BBB\u7BBC\u7BBD\u7BC2\u7BC5\u7BC8\u7BCA\u7BD4\u7BD6\u7BD7\u7BD9\u7BDA\u7BDB\u7BE8\u7BEA\u7BF2\u7BF4\u7BF5\u7BF8\u7BF9\u7BFA\u7BFC\u7BFE\u7C01\u7C02\u7C03\u7C04\u7C06\u7C09\u7C0B\u7C0C\u7C0E\u7C0F\u7C19\u7C1B\u7C20\u7C25\u7C26\u7C28\u7C2C\u7C31\u7C33\u7C34\u7C36\u7C39\u7C3A\u7C46\u7C4A\u7C55\u7C51\u7C52\u7C53\u7C59", 5],
      ["8fd3a1", "\u7C61\u7C63\u7C67\u7C69\u7C6D\u7C6E\u7C70\u7C72\u7C79\u7C7C\u7C7D\u7C86\u7C87\u7C8F\u7C94\u7C9E\u7CA0\u7CA6\u7CB0\u7CB6\u7CB7\u7CBA\u7CBB\u7CBC\u7CBF\u7CC4\u7CC7\u7CC8\u7CC9\u7CCD\u7CCF\u7CD3\u7CD4\u7CD5\u7CD7\u7CD9\u7CDA\u7CDD\u7CE6\u7CE9\u7CEB\u7CF5\u7D03\u7D07\u7D08\u7D09\u7D0F\u7D11\u7D12\u7D13\u7D16\u7D1D\u7D1E\u7D23\u7D26\u7D2A\u7D2D\u7D31\u7D3C\u7D3D\u7D3E\u7D40\u7D41\u7D47\u7D48\u7D4D\u7D51\u7D53\u7D57\u7D59\u7D5A\u7D5C\u7D5D\u7D65\u7D67\u7D6A\u7D70\u7D78\u7D7A\u7D7B\u7D7F\u7D81\u7D82\u7D83\u7D85\u7D86\u7D88\u7D8B\u7D8C\u7D8D\u7D91\u7D96\u7D97\u7D9D"],
      ["8fd4a1", "\u7D9E\u7DA6\u7DA7\u7DAA\u7DB3\u7DB6\u7DB7\u7DB9\u7DC2", 4, "\u7DCC\u7DCD\u7DCE\u7DD7\u7DD9\u7E00\u7DE2\u7DE5\u7DE6\u7DEA\u7DEB\u7DED\u7DF1\u7DF5\u7DF6\u7DF9\u7DFA\u7E08\u7E10\u7E11\u7E15\u7E17\u7E1C\u7E1D\u7E20\u7E27\u7E28\u7E2C\u7E2D\u7E2F\u7E33\u7E36\u7E3F\u7E44\u7E45\u7E47\u7E4E\u7E50\u7E52\u7E58\u7E5F\u7E61\u7E62\u7E65\u7E6B\u7E6E\u7E6F\u7E73\u7E78\u7E7E\u7E81\u7E86\u7E87\u7E8A\u7E8D\u7E91\u7E95\u7E98\u7E9A\u7E9D\u7E9E\u7F3C\u7F3B\u7F3D\u7F3E\u7F3F\u7F43\u7F44\u7F47\u7F4F\u7F52\u7F53\u7F5B\u7F5C\u7F5D\u7F61\u7F63\u7F64\u7F65\u7F66\u7F6D"],
      ["8fd5a1", "\u7F71\u7F7D\u7F7E\u7F7F\u7F80\u7F8B\u7F8D\u7F8F\u7F90\u7F91\u7F96\u7F97\u7F9C\u7FA1\u7FA2\u7FA6\u7FAA\u7FAD\u7FB4\u7FBC\u7FBF\u7FC0\u7FC3\u7FC8\u7FCE\u7FCF\u7FDB\u7FDF\u7FE3\u7FE5\u7FE8\u7FEC\u7FEE\u7FEF\u7FF2\u7FFA\u7FFD\u7FFE\u7FFF\u8007\u8008\u800A\u800D\u800E\u800F\u8011\u8013\u8014\u8016\u801D\u801E\u801F\u8020\u8024\u8026\u802C\u802E\u8030\u8034\u8035\u8037\u8039\u803A\u803C\u803E\u8040\u8044\u8060\u8064\u8066\u806D\u8071\u8075\u8081\u8088\u808E\u809C\u809E\u80A6\u80A7\u80AB\u80B8\u80B9\u80C8\u80CD\u80CF\u80D2\u80D4\u80D5\u80D7\u80D8\u80E0\u80ED\u80EE"],
      ["8fd6a1", "\u80F0\u80F2\u80F3\u80F6\u80F9\u80FA\u80FE\u8103\u810B\u8116\u8117\u8118\u811C\u811E\u8120\u8124\u8127\u812C\u8130\u8135\u813A\u813C\u8145\u8147\u814A\u814C\u8152\u8157\u8160\u8161\u8167\u8168\u8169\u816D\u816F\u8177\u8181\u8190\u8184\u8185\u8186\u818B\u818E\u8196\u8198\u819B\u819E\u81A2\u81AE\u81B2\u81B4\u81BB\u81CB\u81C3\u81C5\u81CA\u81CE\u81CF\u81D5\u81D7\u81DB\u81DD\u81DE\u81E1\u81E4\u81EB\u81EC\u81F0\u81F1\u81F2\u81F5\u81F6\u81F8\u81F9\u81FD\u81FF\u8200\u8203\u820F\u8213\u8214\u8219\u821A\u821D\u8221\u8222\u8228\u8232\u8234\u823A\u8243\u8244\u8245\u8246"],
      ["8fd7a1", "\u824B\u824E\u824F\u8251\u8256\u825C\u8260\u8263\u8267\u826D\u8274\u827B\u827D\u827F\u8280\u8281\u8283\u8284\u8287\u8289\u828A\u828E\u8291\u8294\u8296\u8298\u829A\u829B\u82A0\u82A1\u82A3\u82A4\u82A7\u82A8\u82A9\u82AA\u82AE\u82B0\u82B2\u82B4\u82B7\u82BA\u82BC\u82BE\u82BF\u82C6\u82D0\u82D5\u82DA\u82E0\u82E2\u82E4\u82E8\u82EA\u82ED\u82EF\u82F6\u82F7\u82FD\u82FE\u8300\u8301\u8307\u8308\u830A\u830B\u8354\u831B\u831D\u831E\u831F\u8321\u8322\u832C\u832D\u832E\u8330\u8333\u8337\u833A\u833C\u833D\u8342\u8343\u8344\u8347\u834D\u834E\u8351\u8355\u8356\u8357\u8370\u8378"],
      ["8fd8a1", "\u837D\u837F\u8380\u8382\u8384\u8386\u838D\u8392\u8394\u8395\u8398\u8399\u839B\u839C\u839D\u83A6\u83A7\u83A9\u83AC\u83BE\u83BF\u83C0\u83C7\u83C9\u83CF\u83D0\u83D1\u83D4\u83DD\u8353\u83E8\u83EA\u83F6\u83F8\u83F9\u83FC\u8401\u8406\u840A\u840F\u8411\u8415\u8419\u83AD\u842F\u8439\u8445\u8447\u8448\u844A\u844D\u844F\u8451\u8452\u8456\u8458\u8459\u845A\u845C\u8460\u8464\u8465\u8467\u846A\u8470\u8473\u8474\u8476\u8478\u847C\u847D\u8481\u8485\u8492\u8493\u8495\u849E\u84A6\u84A8\u84A9\u84AA\u84AF\u84B1\u84B4\u84BA\u84BD\u84BE\u84C0\u84C2\u84C7\u84C8\u84CC\u84CF\u84D3"],
      ["8fd9a1", "\u84DC\u84E7\u84EA\u84EF\u84F0\u84F1\u84F2\u84F7\u8532\u84FA\u84FB\u84FD\u8502\u8503\u8507\u850C\u850E\u8510\u851C\u851E\u8522\u8523\u8524\u8525\u8527\u852A\u852B\u852F\u8533\u8534\u8536\u853F\u8546\u854F", 4, "\u8556\u8559\u855C", 6, "\u8564\u856B\u856F\u8579\u857A\u857B\u857D\u857F\u8581\u8585\u8586\u8589\u858B\u858C\u858F\u8593\u8598\u859D\u859F\u85A0\u85A2\u85A5\u85A7\u85B4\u85B6\u85B7\u85B8\u85BC\u85BD\u85BE\u85BF\u85C2\u85C7\u85CA\u85CB\u85CE\u85AD\u85D8\u85DA\u85DF\u85E0\u85E6\u85E8\u85ED\u85F3\u85F6\u85FC"],
      ["8fdaa1", "\u85FF\u8600\u8604\u8605\u860D\u860E\u8610\u8611\u8612\u8618\u8619\u861B\u861E\u8621\u8627\u8629\u8636\u8638\u863A\u863C\u863D\u8640\u8642\u8646\u8652\u8653\u8656\u8657\u8658\u8659\u865D\u8660", 4, "\u8669\u866C\u866F\u8675\u8676\u8677\u867A\u868D\u8691\u8696\u8698\u869A\u869C\u86A1\u86A6\u86A7\u86A8\u86AD\u86B1\u86B3\u86B4\u86B5\u86B7\u86B8\u86B9\u86BF\u86C0\u86C1\u86C3\u86C5\u86D1\u86D2\u86D5\u86D7\u86DA\u86DC\u86E0\u86E3\u86E5\u86E7\u8688\u86FA\u86FC\u86FD\u8704\u8705\u8707\u870B\u870E\u870F\u8710\u8713\u8714\u8719\u871E\u871F\u8721\u8723"],
      ["8fdba1", "\u8728\u872E\u872F\u8731\u8732\u8739\u873A\u873C\u873D\u873E\u8740\u8743\u8745\u874D\u8758\u875D\u8761\u8764\u8765\u876F\u8771\u8772\u877B\u8783", 6, "\u878B\u878C\u8790\u8793\u8795\u8797\u8798\u8799\u879E\u87A0\u87A3\u87A7\u87AC\u87AD\u87AE\u87B1\u87B5\u87BE\u87BF\u87C1\u87C8\u87C9\u87CA\u87CE\u87D5\u87D6\u87D9\u87DA\u87DC\u87DF\u87E2\u87E3\u87E4\u87EA\u87EB\u87ED\u87F1\u87F3\u87F8\u87FA\u87FF\u8801\u8803\u8806\u8809\u880A\u880B\u8810\u8819\u8812\u8813\u8814\u8818\u881A\u881B\u881C\u881E\u881F\u8828\u882D\u882E\u8830\u8832\u8835"],
      ["8fdca1", "\u883A\u883C\u8841\u8843\u8845\u8848\u8849\u884A\u884B\u884E\u8851\u8855\u8856\u8858\u885A\u885C\u885F\u8860\u8864\u8869\u8871\u8879\u887B\u8880\u8898\u889A\u889B\u889C\u889F\u88A0\u88A8\u88AA\u88BA\u88BD\u88BE\u88C0\u88CA", 4, "\u88D1\u88D2\u88D3\u88DB\u88DE\u88E7\u88EF\u88F0\u88F1\u88F5\u88F7\u8901\u8906\u890D\u890E\u890F\u8915\u8916\u8918\u8919\u891A\u891C\u8920\u8926\u8927\u8928\u8930\u8931\u8932\u8935\u8939\u893A\u893E\u8940\u8942\u8945\u8946\u8949\u894F\u8952\u8957\u895A\u895B\u895C\u8961\u8962\u8963\u896B\u896E\u8970\u8973\u8975\u897A"],
      ["8fdda1", "\u897B\u897C\u897D\u8989\u898D\u8990\u8994\u8995\u899B\u899C\u899F\u89A0\u89A5\u89B0\u89B4\u89B5\u89B6\u89B7\u89BC\u89D4", 4, "\u89E5\u89E9\u89EB\u89ED\u89F1\u89F3\u89F6\u89F9\u89FD\u89FF\u8A04\u8A05\u8A07\u8A0F\u8A11\u8A12\u8A14\u8A15\u8A1E\u8A20\u8A22\u8A24\u8A26\u8A2B\u8A2C\u8A2F\u8A35\u8A37\u8A3D\u8A3E\u8A40\u8A43\u8A45\u8A47\u8A49\u8A4D\u8A4E\u8A53\u8A56\u8A57\u8A58\u8A5C\u8A5D\u8A61\u8A65\u8A67\u8A75\u8A76\u8A77\u8A79\u8A7A\u8A7B\u8A7E\u8A7F\u8A80\u8A83\u8A86\u8A8B\u8A8F\u8A90\u8A92\u8A96\u8A97\u8A99\u8A9F\u8AA7\u8AA9\u8AAE\u8AAF\u8AB3"],
      ["8fdea1", "\u8AB6\u8AB7\u8ABB\u8ABE\u8AC3\u8AC6\u8AC8\u8AC9\u8ACA\u8AD1\u8AD3\u8AD4\u8AD5\u8AD7\u8ADD\u8ADF\u8AEC\u8AF0\u8AF4\u8AF5\u8AF6\u8AFC\u8AFF\u8B05\u8B06\u8B0B\u8B11\u8B1C\u8B1E\u8B1F\u8B0A\u8B2D\u8B30\u8B37\u8B3C\u8B42", 4, "\u8B48\u8B52\u8B53\u8B54\u8B59\u8B4D\u8B5E\u8B63\u8B6D\u8B76\u8B78\u8B79\u8B7C\u8B7E\u8B81\u8B84\u8B85\u8B8B\u8B8D\u8B8F\u8B94\u8B95\u8B9C\u8B9E\u8B9F\u8C38\u8C39\u8C3D\u8C3E\u8C45\u8C47\u8C49\u8C4B\u8C4F\u8C51\u8C53\u8C54\u8C57\u8C58\u8C5B\u8C5D\u8C59\u8C63\u8C64\u8C66\u8C68\u8C69\u8C6D\u8C73\u8C75\u8C76\u8C7B\u8C7E\u8C86"],
      ["8fdfa1", "\u8C87\u8C8B\u8C90\u8C92\u8C93\u8C99\u8C9B\u8C9C\u8CA4\u8CB9\u8CBA\u8CC5\u8CC6\u8CC9\u8CCB\u8CCF\u8CD6\u8CD5\u8CD9\u8CDD\u8CE1\u8CE8\u8CEC\u8CEF\u8CF0\u8CF2\u8CF5\u8CF7\u8CF8\u8CFE\u8CFF\u8D01\u8D03\u8D09\u8D12\u8D17\u8D1B\u8D65\u8D69\u8D6C\u8D6E\u8D7F\u8D82\u8D84\u8D88\u8D8D\u8D90\u8D91\u8D95\u8D9E\u8D9F\u8DA0\u8DA6\u8DAB\u8DAC\u8DAF\u8DB2\u8DB5\u8DB7\u8DB9\u8DBB\u8DC0\u8DC5\u8DC6\u8DC7\u8DC8\u8DCA\u8DCE\u8DD1\u8DD4\u8DD5\u8DD7\u8DD9\u8DE4\u8DE5\u8DE7\u8DEC\u8DF0\u8DBC\u8DF1\u8DF2\u8DF4\u8DFD\u8E01\u8E04\u8E05\u8E06\u8E0B\u8E11\u8E14\u8E16\u8E20\u8E21\u8E22"],
      ["8fe0a1", "\u8E23\u8E26\u8E27\u8E31\u8E33\u8E36\u8E37\u8E38\u8E39\u8E3D\u8E40\u8E41\u8E4B\u8E4D\u8E4E\u8E4F\u8E54\u8E5B\u8E5C\u8E5D\u8E5E\u8E61\u8E62\u8E69\u8E6C\u8E6D\u8E6F\u8E70\u8E71\u8E79\u8E7A\u8E7B\u8E82\u8E83\u8E89\u8E90\u8E92\u8E95\u8E9A\u8E9B\u8E9D\u8E9E\u8EA2\u8EA7\u8EA9\u8EAD\u8EAE\u8EB3\u8EB5\u8EBA\u8EBB\u8EC0\u8EC1\u8EC3\u8EC4\u8EC7\u8ECF\u8ED1\u8ED4\u8EDC\u8EE8\u8EEE\u8EF0\u8EF1\u8EF7\u8EF9\u8EFA\u8EED\u8F00\u8F02\u8F07\u8F08\u8F0F\u8F10\u8F16\u8F17\u8F18\u8F1E\u8F20\u8F21\u8F23\u8F25\u8F27\u8F28\u8F2C\u8F2D\u8F2E\u8F34\u8F35\u8F36\u8F37\u8F3A\u8F40\u8F41"],
      ["8fe1a1", "\u8F43\u8F47\u8F4F\u8F51", 4, "\u8F58\u8F5D\u8F5E\u8F65\u8F9D\u8FA0\u8FA1\u8FA4\u8FA5\u8FA6\u8FB5\u8FB6\u8FB8\u8FBE\u8FC0\u8FC1\u8FC6\u8FCA\u8FCB\u8FCD\u8FD0\u8FD2\u8FD3\u8FD5\u8FE0\u8FE3\u8FE4\u8FE8\u8FEE\u8FF1\u8FF5\u8FF6\u8FFB\u8FFE\u9002\u9004\u9008\u900C\u9018\u901B\u9028\u9029\u902F\u902A\u902C\u902D\u9033\u9034\u9037\u903F\u9043\u9044\u904C\u905B\u905D\u9062\u9066\u9067\u906C\u9070\u9074\u9079\u9085\u9088\u908B\u908C\u908E\u9090\u9095\u9097\u9098\u9099\u909B\u90A0\u90A1\u90A2\u90A5\u90B0\u90B2\u90B3\u90B4\u90B6\u90BD\u90CC\u90BE\u90C3"],
      ["8fe2a1", "\u90C4\u90C5\u90C7\u90C8\u90D5\u90D7\u90D8\u90D9\u90DC\u90DD\u90DF\u90E5\u90D2\u90F6\u90EB\u90EF\u90F0\u90F4\u90FE\u90FF\u9100\u9104\u9105\u9106\u9108\u910D\u9110\u9114\u9116\u9117\u9118\u911A\u911C\u911E\u9120\u9125\u9122\u9123\u9127\u9129\u912E\u912F\u9131\u9134\u9136\u9137\u9139\u913A\u913C\u913D\u9143\u9147\u9148\u914F\u9153\u9157\u9159\u915A\u915B\u9161\u9164\u9167\u916D\u9174\u9179\u917A\u917B\u9181\u9183\u9185\u9186\u918A\u918E\u9191\u9193\u9194\u9195\u9198\u919E\u91A1\u91A6\u91A8\u91AC\u91AD\u91AE\u91B0\u91B1\u91B2\u91B3\u91B6\u91BB\u91BC\u91BD\u91BF"],
      ["8fe3a1", "\u91C2\u91C3\u91C5\u91D3\u91D4\u91D7\u91D9\u91DA\u91DE\u91E4\u91E5\u91E9\u91EA\u91EC", 5, "\u91F7\u91F9\u91FB\u91FD\u9200\u9201\u9204\u9205\u9206\u9207\u9209\u920A\u920C\u9210\u9212\u9213\u9216\u9218\u921C\u921D\u9223\u9224\u9225\u9226\u9228\u922E\u922F\u9230\u9233\u9235\u9236\u9238\u9239\u923A\u923C\u923E\u9240\u9242\u9243\u9246\u9247\u924A\u924D\u924E\u924F\u9251\u9258\u9259\u925C\u925D\u9260\u9261\u9265\u9267\u9268\u9269\u926E\u926F\u9270\u9275", 4, "\u927B\u927C\u927D\u927F\u9288\u9289\u928A\u928D\u928E\u9292\u9297"],
      ["8fe4a1", "\u9299\u929F\u92A0\u92A4\u92A5\u92A7\u92A8\u92AB\u92AF\u92B2\u92B6\u92B8\u92BA\u92BB\u92BC\u92BD\u92BF", 4, "\u92C5\u92C6\u92C7\u92C8\u92CB\u92CC\u92CD\u92CE\u92D0\u92D3\u92D5\u92D7\u92D8\u92D9\u92DC\u92DD\u92DF\u92E0\u92E1\u92E3\u92E5\u92E7\u92E8\u92EC\u92EE\u92F0\u92F9\u92FB\u92FF\u9300\u9302\u9308\u930D\u9311\u9314\u9315\u931C\u931D\u931E\u931F\u9321\u9324\u9325\u9327\u9329\u932A\u9333\u9334\u9336\u9337\u9347\u9348\u9349\u9350\u9351\u9352\u9355\u9357\u9358\u935A\u935E\u9364\u9365\u9367\u9369\u936A\u936D\u936F\u9370\u9371\u9373\u9374\u9376"],
      ["8fe5a1", "\u937A\u937D\u937F\u9380\u9381\u9382\u9388\u938A\u938B\u938D\u938F\u9392\u9395\u9398\u939B\u939E\u93A1\u93A3\u93A4\u93A6\u93A8\u93AB\u93B4\u93B5\u93B6\u93BA\u93A9\u93C1\u93C4\u93C5\u93C6\u93C7\u93C9", 4, "\u93D3\u93D9\u93DC\u93DE\u93DF\u93E2\u93E6\u93E7\u93F9\u93F7\u93F8\u93FA\u93FB\u93FD\u9401\u9402\u9404\u9408\u9409\u940D\u940E\u940F\u9415\u9416\u9417\u941F\u942E\u942F\u9431\u9432\u9433\u9434\u943B\u943F\u943D\u9443\u9445\u9448\u944A\u944C\u9455\u9459\u945C\u945F\u9461\u9463\u9468\u946B\u946D\u946E\u946F\u9471\u9472\u9484\u9483\u9578\u9579"],
      ["8fe6a1", "\u957E\u9584\u9588\u958C\u958D\u958E\u959D\u959E\u959F\u95A1\u95A6\u95A9\u95AB\u95AC\u95B4\u95B6\u95BA\u95BD\u95BF\u95C6\u95C8\u95C9\u95CB\u95D0\u95D1\u95D2\u95D3\u95D9\u95DA\u95DD\u95DE\u95DF\u95E0\u95E4\u95E6\u961D\u961E\u9622\u9624\u9625\u9626\u962C\u9631\u9633\u9637\u9638\u9639\u963A\u963C\u963D\u9641\u9652\u9654\u9656\u9657\u9658\u9661\u966E\u9674\u967B\u967C\u967E\u967F\u9681\u9682\u9683\u9684\u9689\u9691\u9696\u969A\u969D\u969F\u96A4\u96A5\u96A6\u96A9\u96AE\u96AF\u96B3\u96BA\u96CA\u96D2\u5DB2\u96D8\u96DA\u96DD\u96DE\u96DF\u96E9\u96EF\u96F1\u96FA\u9702"],
      ["8fe7a1", "\u9703\u9705\u9709\u971A\u971B\u971D\u9721\u9722\u9723\u9728\u9731\u9733\u9741\u9743\u974A\u974E\u974F\u9755\u9757\u9758\u975A\u975B\u9763\u9767\u976A\u976E\u9773\u9776\u9777\u9778\u977B\u977D\u977F\u9780\u9789\u9795\u9796\u9797\u9799\u979A\u979E\u979F\u97A2\u97AC\u97AE\u97B1\u97B2\u97B5\u97B6\u97B8\u97B9\u97BA\u97BC\u97BE\u97BF\u97C1\u97C4\u97C5\u97C7\u97C9\u97CA\u97CC\u97CD\u97CE\u97D0\u97D1\u97D4\u97D7\u97D8\u97D9\u97DD\u97DE\u97E0\u97DB\u97E1\u97E4\u97EF\u97F1\u97F4\u97F7\u97F8\u97FA\u9807\u980A\u9819\u980D\u980E\u9814\u9816\u981C\u981E\u9820\u9823\u9826"],
      ["8fe8a1", "\u982B\u982E\u982F\u9830\u9832\u9833\u9835\u9825\u983E\u9844\u9847\u984A\u9851\u9852\u9853\u9856\u9857\u9859\u985A\u9862\u9863\u9865\u9866\u986A\u986C\u98AB\u98AD\u98AE\u98B0\u98B4\u98B7\u98B8\u98BA\u98BB\u98BF\u98C2\u98C5\u98C8\u98CC\u98E1\u98E3\u98E5\u98E6\u98E7\u98EA\u98F3\u98F6\u9902\u9907\u9908\u9911\u9915\u9916\u9917\u991A\u991B\u991C\u991F\u9922\u9926\u9927\u992B\u9931", 4, "\u9939\u993A\u993B\u993C\u9940\u9941\u9946\u9947\u9948\u994D\u994E\u9954\u9958\u9959\u995B\u995C\u995E\u995F\u9960\u999B\u999D\u999F\u99A6\u99B0\u99B1\u99B2\u99B5"],
      ["8fe9a1", "\u99B9\u99BA\u99BD\u99BF\u99C3\u99C9\u99D3\u99D4\u99D9\u99DA\u99DC\u99DE\u99E7\u99EA\u99EB\u99EC\u99F0\u99F4\u99F5\u99F9\u99FD\u99FE\u9A02\u9A03\u9A04\u9A0B\u9A0C\u9A10\u9A11\u9A16\u9A1E\u9A20\u9A22\u9A23\u9A24\u9A27\u9A2D\u9A2E\u9A33\u9A35\u9A36\u9A38\u9A47\u9A41\u9A44\u9A4A\u9A4B\u9A4C\u9A4E\u9A51\u9A54\u9A56\u9A5D\u9AAA\u9AAC\u9AAE\u9AAF\u9AB2\u9AB4\u9AB5\u9AB6\u9AB9\u9ABB\u9ABE\u9ABF\u9AC1\u9AC3\u9AC6\u9AC8\u9ACE\u9AD0\u9AD2\u9AD5\u9AD6\u9AD7\u9ADB\u9ADC\u9AE0\u9AE4\u9AE5\u9AE7\u9AE9\u9AEC\u9AF2\u9AF3\u9AF5\u9AF9\u9AFA\u9AFD\u9AFF", 4],
      ["8feaa1", "\u9B04\u9B05\u9B08\u9B09\u9B0B\u9B0C\u9B0D\u9B0E\u9B10\u9B12\u9B16\u9B19\u9B1B\u9B1C\u9B20\u9B26\u9B2B\u9B2D\u9B33\u9B34\u9B35\u9B37\u9B39\u9B3A\u9B3D\u9B48\u9B4B\u9B4C\u9B55\u9B56\u9B57\u9B5B\u9B5E\u9B61\u9B63\u9B65\u9B66\u9B68\u9B6A", 4, "\u9B73\u9B75\u9B77\u9B78\u9B79\u9B7F\u9B80\u9B84\u9B85\u9B86\u9B87\u9B89\u9B8A\u9B8B\u9B8D\u9B8F\u9B90\u9B94\u9B9A\u9B9D\u9B9E\u9BA6\u9BA7\u9BA9\u9BAC\u9BB0\u9BB1\u9BB2\u9BB7\u9BB8\u9BBB\u9BBC\u9BBE\u9BBF\u9BC1\u9BC7\u9BC8\u9BCE\u9BD0\u9BD7\u9BD8\u9BDD\u9BDF\u9BE5\u9BE7\u9BEA\u9BEB\u9BEF\u9BF3\u9BF7\u9BF8"],
      ["8feba1", "\u9BF9\u9BFA\u9BFD\u9BFF\u9C00\u9C02\u9C0B\u9C0F\u9C11\u9C16\u9C18\u9C19\u9C1A\u9C1C\u9C1E\u9C22\u9C23\u9C26", 4, "\u9C31\u9C35\u9C36\u9C37\u9C3D\u9C41\u9C43\u9C44\u9C45\u9C49\u9C4A\u9C4E\u9C4F\u9C50\u9C53\u9C54\u9C56\u9C58\u9C5B\u9C5D\u9C5E\u9C5F\u9C63\u9C69\u9C6A\u9C5C\u9C6B\u9C68\u9C6E\u9C70\u9C72\u9C75\u9C77\u9C7B\u9CE6\u9CF2\u9CF7\u9CF9\u9D0B\u9D02\u9D11\u9D17\u9D18\u9D1C\u9D1D\u9D1E\u9D2F\u9D30\u9D32\u9D33\u9D34\u9D3A\u9D3C\u9D45\u9D3D\u9D42\u9D43\u9D47\u9D4A\u9D53\u9D54\u9D5F\u9D63\u9D62\u9D65\u9D69\u9D6A\u9D6B\u9D70\u9D76\u9D77\u9D7B"],
      ["8feca1", "\u9D7C\u9D7E\u9D83\u9D84\u9D86\u9D8A\u9D8D\u9D8E\u9D92\u9D93\u9D95\u9D96\u9D97\u9D98\u9DA1\u9DAA\u9DAC\u9DAE\u9DB1\u9DB5\u9DB9\u9DBC\u9DBF\u9DC3\u9DC7\u9DC9\u9DCA\u9DD4\u9DD5\u9DD6\u9DD7\u9DDA\u9DDE\u9DDF\u9DE0\u9DE5\u9DE7\u9DE9\u9DEB\u9DEE\u9DF0\u9DF3\u9DF4\u9DFE\u9E0A\u9E02\u9E07\u9E0E\u9E10\u9E11\u9E12\u9E15\u9E16\u9E19\u9E1C\u9E1D\u9E7A\u9E7B\u9E7C\u9E80\u9E82\u9E83\u9E84\u9E85\u9E87\u9E8E\u9E8F\u9E96\u9E98\u9E9B\u9E9E\u9EA4\u9EA8\u9EAC\u9EAE\u9EAF\u9EB0\u9EB3\u9EB4\u9EB5\u9EC6\u9EC8\u9ECB\u9ED5\u9EDF\u9EE4\u9EE7\u9EEC\u9EED\u9EEE\u9EF0\u9EF1\u9EF2\u9EF5"],
      ["8feda1", "\u9EF8\u9EFF\u9F02\u9F03\u9F09\u9F0F\u9F10\u9F11\u9F12\u9F14\u9F16\u9F17\u9F19\u9F1A\u9F1B\u9F1F\u9F22\u9F26\u9F2A\u9F2B\u9F2F\u9F31\u9F32\u9F34\u9F37\u9F39\u9F3A\u9F3C\u9F3D\u9F3F\u9F41\u9F43", 4, "\u9F53\u9F55\u9F56\u9F57\u9F58\u9F5A\u9F5D\u9F5E\u9F68\u9F69\u9F6D", 4, "\u9F73\u9F75\u9F7A\u9F7D\u9F8F\u9F90\u9F91\u9F92\u9F94\u9F96\u9F97\u9F9E\u9FA1\u9FA2\u9FA3\u9FA5"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp936.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127, "\u20AC"],
      ["8140", "\u4E02\u4E04\u4E05\u4E06\u4E0F\u4E12\u4E17\u4E1F\u4E20\u4E21\u4E23\u4E26\u4E29\u4E2E\u4E2F\u4E31\u4E33\u4E35\u4E37\u4E3C\u4E40\u4E41\u4E42\u4E44\u4E46\u4E4A\u4E51\u4E55\u4E57\u4E5A\u4E5B\u4E62\u4E63\u4E64\u4E65\u4E67\u4E68\u4E6A", 5, "\u4E72\u4E74", 9, "\u4E7F", 6, "\u4E87\u4E8A"],
      ["8180", "\u4E90\u4E96\u4E97\u4E99\u4E9C\u4E9D\u4E9E\u4EA3\u4EAA\u4EAF\u4EB0\u4EB1\u4EB4\u4EB6\u4EB7\u4EB8\u4EB9\u4EBC\u4EBD\u4EBE\u4EC8\u4ECC\u4ECF\u4ED0\u4ED2\u4EDA\u4EDB\u4EDC\u4EE0\u4EE2\u4EE6\u4EE7\u4EE9\u4EED\u4EEE\u4EEF\u4EF1\u4EF4\u4EF8\u4EF9\u4EFA\u4EFC\u4EFE\u4F00\u4F02", 6, "\u4F0B\u4F0C\u4F12", 4, "\u4F1C\u4F1D\u4F21\u4F23\u4F28\u4F29\u4F2C\u4F2D\u4F2E\u4F31\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E", 4, "\u4F44\u4F45\u4F47", 5, "\u4F52\u4F54\u4F56\u4F61\u4F62\u4F66\u4F68\u4F6A\u4F6B\u4F6D\u4F6E\u4F71\u4F72\u4F75\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F80\u4F81\u4F82\u4F85\u4F86\u4F87\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F95\u4F96\u4F98\u4F99\u4F9A\u4F9C\u4F9E\u4F9F\u4FA1\u4FA2"],
      ["8240", "\u4FA4\u4FAB\u4FAD\u4FB0", 4, "\u4FB6", 8, "\u4FC0\u4FC1\u4FC2\u4FC6\u4FC7\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FD2", 4, "\u4FD9\u4FDB\u4FE0\u4FE2\u4FE4\u4FE5\u4FE7\u4FEB\u4FEC\u4FF0\u4FF2\u4FF4\u4FF5\u4FF6\u4FF7\u4FF9\u4FFB\u4FFC\u4FFD\u4FFF", 11],
      ["8280", "\u500B\u500E\u5010\u5011\u5013\u5015\u5016\u5017\u501B\u501D\u501E\u5020\u5022\u5023\u5024\u5027\u502B\u502F", 10, "\u503B\u503D\u503F\u5040\u5041\u5042\u5044\u5045\u5046\u5049\u504A\u504B\u504D\u5050", 4, "\u5056\u5057\u5058\u5059\u505B\u505D", 7, "\u5066", 5, "\u506D", 8, "\u5078\u5079\u507A\u507C\u507D\u5081\u5082\u5083\u5084\u5086\u5087\u5089\u508A\u508B\u508C\u508E", 20, "\u50A4\u50A6\u50AA\u50AB\u50AD", 4, "\u50B3", 6, "\u50BC"],
      ["8340", "\u50BD", 17, "\u50D0", 5, "\u50D7\u50D8\u50D9\u50DB", 10, "\u50E8\u50E9\u50EA\u50EB\u50EF\u50F0\u50F1\u50F2\u50F4\u50F6", 4, "\u50FC", 9, "\u5108"],
      ["8380", "\u5109\u510A\u510C", 5, "\u5113", 13, "\u5122", 28, "\u5142\u5147\u514A\u514C\u514E\u514F\u5150\u5152\u5153\u5157\u5158\u5159\u515B\u515D", 4, "\u5163\u5164\u5166\u5167\u5169\u516A\u516F\u5172\u517A\u517E\u517F\u5183\u5184\u5186\u5187\u518A\u518B\u518E\u518F\u5190\u5191\u5193\u5194\u5198\u519A\u519D\u519E\u519F\u51A1\u51A3\u51A6", 4, "\u51AD\u51AE\u51B4\u51B8\u51B9\u51BA\u51BE\u51BF\u51C1\u51C2\u51C3\u51C5\u51C8\u51CA\u51CD\u51CE\u51D0\u51D2", 5],
      ["8440", "\u51D8\u51D9\u51DA\u51DC\u51DE\u51DF\u51E2\u51E3\u51E5", 5, "\u51EC\u51EE\u51F1\u51F2\u51F4\u51F7\u51FE\u5204\u5205\u5209\u520B\u520C\u520F\u5210\u5213\u5214\u5215\u521C\u521E\u521F\u5221\u5222\u5223\u5225\u5226\u5227\u522A\u522C\u522F\u5231\u5232\u5234\u5235\u523C\u523E\u5244", 5, "\u524B\u524E\u524F\u5252\u5253\u5255\u5257\u5258"],
      ["8480", "\u5259\u525A\u525B\u525D\u525F\u5260\u5262\u5263\u5264\u5266\u5268\u526B\u526C\u526D\u526E\u5270\u5271\u5273", 9, "\u527E\u5280\u5283", 4, "\u5289", 6, "\u5291\u5292\u5294", 6, "\u529C\u52A4\u52A5\u52A6\u52A7\u52AE\u52AF\u52B0\u52B4", 9, "\u52C0\u52C1\u52C2\u52C4\u52C5\u52C6\u52C8\u52CA\u52CC\u52CD\u52CE\u52CF\u52D1\u52D3\u52D4\u52D5\u52D7\u52D9", 5, "\u52E0\u52E1\u52E2\u52E3\u52E5", 10, "\u52F1", 7, "\u52FB\u52FC\u52FD\u5301\u5302\u5303\u5304\u5307\u5309\u530A\u530B\u530C\u530E"],
      ["8540", "\u5311\u5312\u5313\u5314\u5318\u531B\u531C\u531E\u531F\u5322\u5324\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u532F", 9, "\u533C\u533D\u5340\u5342\u5344\u5346\u534B\u534C\u534D\u5350\u5354\u5358\u5359\u535B\u535D\u5365\u5368\u536A\u536C\u536D\u5372\u5376\u5379\u537B\u537C\u537D\u537E\u5380\u5381\u5383\u5387\u5388\u538A\u538E\u538F"],
      ["8580", "\u5390", 4, "\u5396\u5397\u5399\u539B\u539C\u539E\u53A0\u53A1\u53A4\u53A7\u53AA\u53AB\u53AC\u53AD\u53AF", 6, "\u53B7\u53B8\u53B9\u53BA\u53BC\u53BD\u53BE\u53C0\u53C3", 4, "\u53CE\u53CF\u53D0\u53D2\u53D3\u53D5\u53DA\u53DC\u53DD\u53DE\u53E1\u53E2\u53E7\u53F4\u53FA\u53FE\u53FF\u5400\u5402\u5405\u5407\u540B\u5414\u5418\u5419\u541A\u541C\u5422\u5424\u5425\u542A\u5430\u5433\u5436\u5437\u543A\u543D\u543F\u5441\u5442\u5444\u5445\u5447\u5449\u544C\u544D\u544E\u544F\u5451\u545A\u545D", 4, "\u5463\u5465\u5467\u5469", 7, "\u5474\u5479\u547A\u547E\u547F\u5481\u5483\u5485\u5487\u5488\u5489\u548A\u548D\u5491\u5493\u5497\u5498\u549C\u549E\u549F\u54A0\u54A1"],
      ["8640", "\u54A2\u54A5\u54AE\u54B0\u54B2\u54B5\u54B6\u54B7\u54B9\u54BA\u54BC\u54BE\u54C3\u54C5\u54CA\u54CB\u54D6\u54D8\u54DB\u54E0", 4, "\u54EB\u54EC\u54EF\u54F0\u54F1\u54F4", 5, "\u54FB\u54FE\u5500\u5502\u5503\u5504\u5505\u5508\u550A", 4, "\u5512\u5513\u5515", 5, "\u551C\u551D\u551E\u551F\u5521\u5525\u5526"],
      ["8680", "\u5528\u5529\u552B\u552D\u5532\u5534\u5535\u5536\u5538\u5539\u553A\u553B\u553D\u5540\u5542\u5545\u5547\u5548\u554B", 4, "\u5551\u5552\u5553\u5554\u5557", 4, "\u555D\u555E\u555F\u5560\u5562\u5563\u5568\u5569\u556B\u556F", 5, "\u5579\u557A\u557D\u557F\u5585\u5586\u558C\u558D\u558E\u5590\u5592\u5593\u5595\u5596\u5597\u559A\u559B\u559E\u55A0", 6, "\u55A8", 8, "\u55B2\u55B4\u55B6\u55B8\u55BA\u55BC\u55BF", 4, "\u55C6\u55C7\u55C8\u55CA\u55CB\u55CE\u55CF\u55D0\u55D5\u55D7", 4, "\u55DE\u55E0\u55E2\u55E7\u55E9\u55ED\u55EE\u55F0\u55F1\u55F4\u55F6\u55F8", 4, "\u55FF\u5602\u5603\u5604\u5605"],
      ["8740", "\u5606\u5607\u560A\u560B\u560D\u5610", 7, "\u5619\u561A\u561C\u561D\u5620\u5621\u5622\u5625\u5626\u5628\u5629\u562A\u562B\u562E\u562F\u5630\u5633\u5635\u5637\u5638\u563A\u563C\u563D\u563E\u5640", 11, "\u564F", 4, "\u5655\u5656\u565A\u565B\u565D", 4],
      ["8780", "\u5663\u5665\u5666\u5667\u566D\u566E\u566F\u5670\u5672\u5673\u5674\u5675\u5677\u5678\u5679\u567A\u567D", 7, "\u5687", 6, "\u5690\u5691\u5692\u5694", 14, "\u56A4", 10, "\u56B0", 6, "\u56B8\u56B9\u56BA\u56BB\u56BD", 12, "\u56CB", 8, "\u56D5\u56D6\u56D8\u56D9\u56DC\u56E3\u56E5", 5, "\u56EC\u56EE\u56EF\u56F2\u56F3\u56F6\u56F7\u56F8\u56FB\u56FC\u5700\u5701\u5702\u5705\u5707\u570B", 6],
      ["8840", "\u5712", 9, "\u571D\u571E\u5720\u5721\u5722\u5724\u5725\u5726\u5727\u572B\u5731\u5732\u5734", 4, "\u573C\u573D\u573F\u5741\u5743\u5744\u5745\u5746\u5748\u5749\u574B\u5752", 4, "\u5758\u5759\u5762\u5763\u5765\u5767\u576C\u576E\u5770\u5771\u5772\u5774\u5775\u5778\u5779\u577A\u577D\u577E\u577F\u5780"],
      ["8880", "\u5781\u5787\u5788\u5789\u578A\u578D", 4, "\u5794", 6, "\u579C\u579D\u579E\u579F\u57A5\u57A8\u57AA\u57AC\u57AF\u57B0\u57B1\u57B3\u57B5\u57B6\u57B7\u57B9", 8, "\u57C4", 6, "\u57CC\u57CD\u57D0\u57D1\u57D3\u57D6\u57D7\u57DB\u57DC\u57DE\u57E1\u57E2\u57E3\u57E5", 7, "\u57EE\u57F0\u57F1\u57F2\u57F3\u57F5\u57F6\u57F7\u57FB\u57FC\u57FE\u57FF\u5801\u5803\u5804\u5805\u5808\u5809\u580A\u580C\u580E\u580F\u5810\u5812\u5813\u5814\u5816\u5817\u5818\u581A\u581B\u581C\u581D\u581F\u5822\u5823\u5825", 4, "\u582B", 4, "\u5831\u5832\u5833\u5834\u5836", 7],
      ["8940", "\u583E", 5, "\u5845", 6, "\u584E\u584F\u5850\u5852\u5853\u5855\u5856\u5857\u5859", 4, "\u585F", 5, "\u5866", 4, "\u586D", 16, "\u587F\u5882\u5884\u5886\u5887\u5888\u588A\u588B\u588C"],
      ["8980", "\u588D", 4, "\u5894", 4, "\u589B\u589C\u589D\u58A0", 7, "\u58AA", 17, "\u58BD\u58BE\u58BF\u58C0\u58C2\u58C3\u58C4\u58C6", 10, "\u58D2\u58D3\u58D4\u58D6", 13, "\u58E5", 5, "\u58ED\u58EF\u58F1\u58F2\u58F4\u58F5\u58F7\u58F8\u58FA", 7, "\u5903\u5905\u5906\u5908", 4, "\u590E\u5910\u5911\u5912\u5913\u5917\u5918\u591B\u591D\u591E\u5920\u5921\u5922\u5923\u5926\u5928\u592C\u5930\u5932\u5933\u5935\u5936\u593B"],
      ["8a40", "\u593D\u593E\u593F\u5940\u5943\u5945\u5946\u594A\u594C\u594D\u5950\u5952\u5953\u5959\u595B", 4, "\u5961\u5963\u5964\u5966", 12, "\u5975\u5977\u597A\u597B\u597C\u597E\u597F\u5980\u5985\u5989\u598B\u598C\u598E\u598F\u5990\u5991\u5994\u5995\u5998\u599A\u599B\u599C\u599D\u599F\u59A0\u59A1\u59A2\u59A6"],
      ["8a80", "\u59A7\u59AC\u59AD\u59B0\u59B1\u59B3", 5, "\u59BA\u59BC\u59BD\u59BF", 6, "\u59C7\u59C8\u59C9\u59CC\u59CD\u59CE\u59CF\u59D5\u59D6\u59D9\u59DB\u59DE", 4, "\u59E4\u59E6\u59E7\u59E9\u59EA\u59EB\u59ED", 11, "\u59FA\u59FC\u59FD\u59FE\u5A00\u5A02\u5A0A\u5A0B\u5A0D\u5A0E\u5A0F\u5A10\u5A12\u5A14\u5A15\u5A16\u5A17\u5A19\u5A1A\u5A1B\u5A1D\u5A1E\u5A21\u5A22\u5A24\u5A26\u5A27\u5A28\u5A2A", 6, "\u5A33\u5A35\u5A37", 4, "\u5A3D\u5A3E\u5A3F\u5A41", 4, "\u5A47\u5A48\u5A4B", 9, "\u5A56\u5A57\u5A58\u5A59\u5A5B", 5],
      ["8b40", "\u5A61\u5A63\u5A64\u5A65\u5A66\u5A68\u5A69\u5A6B", 8, "\u5A78\u5A79\u5A7B\u5A7C\u5A7D\u5A7E\u5A80", 17, "\u5A93", 6, "\u5A9C", 13, "\u5AAB\u5AAC"],
      ["8b80", "\u5AAD", 4, "\u5AB4\u5AB6\u5AB7\u5AB9", 4, "\u5ABF\u5AC0\u5AC3", 5, "\u5ACA\u5ACB\u5ACD", 4, "\u5AD3\u5AD5\u5AD7\u5AD9\u5ADA\u5ADB\u5ADD\u5ADE\u5ADF\u5AE2\u5AE4\u5AE5\u5AE7\u5AE8\u5AEA\u5AEC", 4, "\u5AF2", 22, "\u5B0A", 11, "\u5B18", 25, "\u5B33\u5B35\u5B36\u5B38", 7, "\u5B41", 6],
      ["8c40", "\u5B48", 7, "\u5B52\u5B56\u5B5E\u5B60\u5B61\u5B67\u5B68\u5B6B\u5B6D\u5B6E\u5B6F\u5B72\u5B74\u5B76\u5B77\u5B78\u5B79\u5B7B\u5B7C\u5B7E\u5B7F\u5B82\u5B86\u5B8A\u5B8D\u5B8E\u5B90\u5B91\u5B92\u5B94\u5B96\u5B9F\u5BA7\u5BA8\u5BA9\u5BAC\u5BAD\u5BAE\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBB\u5BBC\u5BC0\u5BC1\u5BC3\u5BC8\u5BC9\u5BCA\u5BCB\u5BCD\u5BCE\u5BCF"],
      ["8c80", "\u5BD1\u5BD4", 8, "\u5BE0\u5BE2\u5BE3\u5BE6\u5BE7\u5BE9", 4, "\u5BEF\u5BF1", 6, "\u5BFD\u5BFE\u5C00\u5C02\u5C03\u5C05\u5C07\u5C08\u5C0B\u5C0C\u5C0D\u5C0E\u5C10\u5C12\u5C13\u5C17\u5C19\u5C1B\u5C1E\u5C1F\u5C20\u5C21\u5C23\u5C26\u5C28\u5C29\u5C2A\u5C2B\u5C2D\u5C2E\u5C2F\u5C30\u5C32\u5C33\u5C35\u5C36\u5C37\u5C43\u5C44\u5C46\u5C47\u5C4C\u5C4D\u5C52\u5C53\u5C54\u5C56\u5C57\u5C58\u5C5A\u5C5B\u5C5C\u5C5D\u5C5F\u5C62\u5C64\u5C67", 6, "\u5C70\u5C72", 6, "\u5C7B\u5C7C\u5C7D\u5C7E\u5C80\u5C83", 4, "\u5C89\u5C8A\u5C8B\u5C8E\u5C8F\u5C92\u5C93\u5C95\u5C9D", 4, "\u5CA4", 4],
      ["8d40", "\u5CAA\u5CAE\u5CAF\u5CB0\u5CB2\u5CB4\u5CB6\u5CB9\u5CBA\u5CBB\u5CBC\u5CBE\u5CC0\u5CC2\u5CC3\u5CC5", 5, "\u5CCC", 5, "\u5CD3", 5, "\u5CDA", 6, "\u5CE2\u5CE3\u5CE7\u5CE9\u5CEB\u5CEC\u5CEE\u5CEF\u5CF1", 9, "\u5CFC", 4],
      ["8d80", "\u5D01\u5D04\u5D05\u5D08", 5, "\u5D0F", 4, "\u5D15\u5D17\u5D18\u5D19\u5D1A\u5D1C\u5D1D\u5D1F", 4, "\u5D25\u5D28\u5D2A\u5D2B\u5D2C\u5D2F", 4, "\u5D35", 7, "\u5D3F", 7, "\u5D48\u5D49\u5D4D", 10, "\u5D59\u5D5A\u5D5C\u5D5E", 10, "\u5D6A\u5D6D\u5D6E\u5D70\u5D71\u5D72\u5D73\u5D75", 12, "\u5D83", 21, "\u5D9A\u5D9B\u5D9C\u5D9E\u5D9F\u5DA0"],
      ["8e40", "\u5DA1", 21, "\u5DB8", 12, "\u5DC6", 6, "\u5DCE", 12, "\u5DDC\u5DDF\u5DE0\u5DE3\u5DE4\u5DEA\u5DEC\u5DED"],
      ["8e80", "\u5DF0\u5DF5\u5DF6\u5DF8", 4, "\u5DFF\u5E00\u5E04\u5E07\u5E09\u5E0A\u5E0B\u5E0D\u5E0E\u5E12\u5E13\u5E17\u5E1E", 7, "\u5E28", 4, "\u5E2F\u5E30\u5E32", 4, "\u5E39\u5E3A\u5E3E\u5E3F\u5E40\u5E41\u5E43\u5E46", 5, "\u5E4D", 6, "\u5E56", 4, "\u5E5C\u5E5D\u5E5F\u5E60\u5E63", 14, "\u5E75\u5E77\u5E79\u5E7E\u5E81\u5E82\u5E83\u5E85\u5E88\u5E89\u5E8C\u5E8D\u5E8E\u5E92\u5E98\u5E9B\u5E9D\u5EA1\u5EA2\u5EA3\u5EA4\u5EA8", 4, "\u5EAE", 4, "\u5EB4\u5EBA\u5EBB\u5EBC\u5EBD\u5EBF", 6],
      ["8f40", "\u5EC6\u5EC7\u5EC8\u5ECB", 5, "\u5ED4\u5ED5\u5ED7\u5ED8\u5ED9\u5EDA\u5EDC", 11, "\u5EE9\u5EEB", 8, "\u5EF5\u5EF8\u5EF9\u5EFB\u5EFC\u5EFD\u5F05\u5F06\u5F07\u5F09\u5F0C\u5F0D\u5F0E\u5F10\u5F12\u5F14\u5F16\u5F19\u5F1A\u5F1C\u5F1D\u5F1E\u5F21\u5F22\u5F23\u5F24"],
      ["8f80", "\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F32", 6, "\u5F3B\u5F3D\u5F3E\u5F3F\u5F41", 14, "\u5F51\u5F54\u5F59\u5F5A\u5F5B\u5F5C\u5F5E\u5F5F\u5F60\u5F63\u5F65\u5F67\u5F68\u5F6B\u5F6E\u5F6F\u5F72\u5F74\u5F75\u5F76\u5F78\u5F7A\u5F7D\u5F7E\u5F7F\u5F83\u5F86\u5F8D\u5F8E\u5F8F\u5F91\u5F93\u5F94\u5F96\u5F9A\u5F9B\u5F9D\u5F9E\u5F9F\u5FA0\u5FA2", 5, "\u5FA9\u5FAB\u5FAC\u5FAF", 5, "\u5FB6\u5FB8\u5FB9\u5FBA\u5FBB\u5FBE", 4, "\u5FC7\u5FC8\u5FCA\u5FCB\u5FCE\u5FD3\u5FD4\u5FD5\u5FDA\u5FDB\u5FDC\u5FDE\u5FDF\u5FE2\u5FE3\u5FE5\u5FE6\u5FE8\u5FE9\u5FEC\u5FEF\u5FF0\u5FF2\u5FF3\u5FF4\u5FF6\u5FF7\u5FF9\u5FFA\u5FFC\u6007"],
      ["9040", "\u6008\u6009\u600B\u600C\u6010\u6011\u6013\u6017\u6018\u601A\u601E\u601F\u6022\u6023\u6024\u602C\u602D\u602E\u6030", 4, "\u6036", 4, "\u603D\u603E\u6040\u6044", 6, "\u604C\u604E\u604F\u6051\u6053\u6054\u6056\u6057\u6058\u605B\u605C\u605E\u605F\u6060\u6061\u6065\u6066\u606E\u6071\u6072\u6074\u6075\u6077\u607E\u6080"],
      ["9080", "\u6081\u6082\u6085\u6086\u6087\u6088\u608A\u608B\u608E\u608F\u6090\u6091\u6093\u6095\u6097\u6098\u6099\u609C\u609E\u60A1\u60A2\u60A4\u60A5\u60A7\u60A9\u60AA\u60AE\u60B0\u60B3\u60B5\u60B6\u60B7\u60B9\u60BA\u60BD", 7, "\u60C7\u60C8\u60C9\u60CC", 4, "\u60D2\u60D3\u60D4\u60D6\u60D7\u60D9\u60DB\u60DE\u60E1", 4, "\u60EA\u60F1\u60F2\u60F5\u60F7\u60F8\u60FB", 4, "\u6102\u6103\u6104\u6105\u6107\u610A\u610B\u610C\u6110", 4, "\u6116\u6117\u6118\u6119\u611B\u611C\u611D\u611E\u6121\u6122\u6125\u6128\u6129\u612A\u612C", 18, "\u6140", 6],
      ["9140", "\u6147\u6149\u614B\u614D\u614F\u6150\u6152\u6153\u6154\u6156", 6, "\u615E\u615F\u6160\u6161\u6163\u6164\u6165\u6166\u6169", 6, "\u6171\u6172\u6173\u6174\u6176\u6178", 18, "\u618C\u618D\u618F", 4, "\u6195"],
      ["9180", "\u6196", 6, "\u619E", 8, "\u61AA\u61AB\u61AD", 9, "\u61B8", 5, "\u61BF\u61C0\u61C1\u61C3", 4, "\u61C9\u61CC", 4, "\u61D3\u61D5", 16, "\u61E7", 13, "\u61F6", 8, "\u6200", 5, "\u6207\u6209\u6213\u6214\u6219\u621C\u621D\u621E\u6220\u6223\u6226\u6227\u6228\u6229\u622B\u622D\u622F\u6230\u6231\u6232\u6235\u6236\u6238", 4, "\u6242\u6244\u6245\u6246\u624A"],
      ["9240", "\u624F\u6250\u6255\u6256\u6257\u6259\u625A\u625C", 6, "\u6264\u6265\u6268\u6271\u6272\u6274\u6275\u6277\u6278\u627A\u627B\u627D\u6281\u6282\u6283\u6285\u6286\u6287\u6288\u628B", 5, "\u6294\u6299\u629C\u629D\u629E\u62A3\u62A6\u62A7\u62A9\u62AA\u62AD\u62AE\u62AF\u62B0\u62B2\u62B3\u62B4\u62B6\u62B7\u62B8\u62BA\u62BE\u62C0\u62C1"],
      ["9280", "\u62C3\u62CB\u62CF\u62D1\u62D5\u62DD\u62DE\u62E0\u62E1\u62E4\u62EA\u62EB\u62F0\u62F2\u62F5\u62F8\u62F9\u62FA\u62FB\u6300\u6303\u6304\u6305\u6306\u630A\u630B\u630C\u630D\u630F\u6310\u6312\u6313\u6314\u6315\u6317\u6318\u6319\u631C\u6326\u6327\u6329\u632C\u632D\u632E\u6330\u6331\u6333", 5, "\u633B\u633C\u633E\u633F\u6340\u6341\u6344\u6347\u6348\u634A\u6351\u6352\u6353\u6354\u6356", 7, "\u6360\u6364\u6365\u6366\u6368\u636A\u636B\u636C\u636F\u6370\u6372\u6373\u6374\u6375\u6378\u6379\u637C\u637D\u637E\u637F\u6381\u6383\u6384\u6385\u6386\u638B\u638D\u6391\u6393\u6394\u6395\u6397\u6399", 6, "\u63A1\u63A4\u63A6\u63AB\u63AF\u63B1\u63B2\u63B5\u63B6\u63B9\u63BB\u63BD\u63BF\u63C0"],
      ["9340", "\u63C1\u63C2\u63C3\u63C5\u63C7\u63C8\u63CA\u63CB\u63CC\u63D1\u63D3\u63D4\u63D5\u63D7", 6, "\u63DF\u63E2\u63E4", 4, "\u63EB\u63EC\u63EE\u63EF\u63F0\u63F1\u63F3\u63F5\u63F7\u63F9\u63FA\u63FB\u63FC\u63FE\u6403\u6404\u6406", 4, "\u640D\u640E\u6411\u6412\u6415", 5, "\u641D\u641F\u6422\u6423\u6424"],
      ["9380", "\u6425\u6427\u6428\u6429\u642B\u642E", 5, "\u6435", 4, "\u643B\u643C\u643E\u6440\u6442\u6443\u6449\u644B", 6, "\u6453\u6455\u6456\u6457\u6459", 4, "\u645F", 7, "\u6468\u646A\u646B\u646C\u646E", 9, "\u647B", 6, "\u6483\u6486\u6488", 8, "\u6493\u6494\u6497\u6498\u649A\u649B\u649C\u649D\u649F", 4, "\u64A5\u64A6\u64A7\u64A8\u64AA\u64AB\u64AF\u64B1\u64B2\u64B3\u64B4\u64B6\u64B9\u64BB\u64BD\u64BE\u64BF\u64C1\u64C3\u64C4\u64C6", 6, "\u64CF\u64D1\u64D3\u64D4\u64D5\u64D6\u64D9\u64DA"],
      ["9440", "\u64DB\u64DC\u64DD\u64DF\u64E0\u64E1\u64E3\u64E5\u64E7", 24, "\u6501", 7, "\u650A", 7, "\u6513", 4, "\u6519", 8],
      ["9480", "\u6522\u6523\u6524\u6526", 4, "\u652C\u652D\u6530\u6531\u6532\u6533\u6537\u653A\u653C\u653D\u6540", 4, "\u6546\u6547\u654A\u654B\u654D\u654E\u6550\u6552\u6553\u6554\u6557\u6558\u655A\u655C\u655F\u6560\u6561\u6564\u6565\u6567\u6568\u6569\u656A\u656D\u656E\u656F\u6571\u6573\u6575\u6576\u6578", 14, "\u6588\u6589\u658A\u658D\u658E\u658F\u6592\u6594\u6595\u6596\u6598\u659A\u659D\u659E\u65A0\u65A2\u65A3\u65A6\u65A8\u65AA\u65AC\u65AE\u65B1", 7, "\u65BA\u65BB\u65BE\u65BF\u65C0\u65C2\u65C7\u65C8\u65C9\u65CA\u65CD\u65D0\u65D1\u65D3\u65D4\u65D5\u65D8", 7, "\u65E1\u65E3\u65E4\u65EA\u65EB"],
      ["9540", "\u65F2\u65F3\u65F4\u65F5\u65F8\u65F9\u65FB", 4, "\u6601\u6604\u6605\u6607\u6608\u6609\u660B\u660D\u6610\u6611\u6612\u6616\u6617\u6618\u661A\u661B\u661C\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6632\u6633\u6637", 4, "\u663D\u663F\u6640\u6642\u6644", 6, "\u664D\u664E\u6650\u6651\u6658"],
      ["9580", "\u6659\u665B\u665C\u665D\u665E\u6660\u6662\u6663\u6665\u6667\u6669", 4, "\u6671\u6672\u6673\u6675\u6678\u6679\u667B\u667C\u667D\u667F\u6680\u6681\u6683\u6685\u6686\u6688\u6689\u668A\u668B\u668D\u668E\u668F\u6690\u6692\u6693\u6694\u6695\u6698", 4, "\u669E", 8, "\u66A9", 4, "\u66AF", 4, "\u66B5\u66B6\u66B7\u66B8\u66BA\u66BB\u66BC\u66BD\u66BF", 25, "\u66DA\u66DE", 7, "\u66E7\u66E8\u66EA", 5, "\u66F1\u66F5\u66F6\u66F8\u66FA\u66FB\u66FD\u6701\u6702\u6703"],
      ["9640", "\u6704\u6705\u6706\u6707\u670C\u670E\u670F\u6711\u6712\u6713\u6716\u6718\u6719\u671A\u671C\u671E\u6720", 5, "\u6727\u6729\u672E\u6730\u6732\u6733\u6736\u6737\u6738\u6739\u673B\u673C\u673E\u673F\u6741\u6744\u6745\u6747\u674A\u674B\u674D\u6752\u6754\u6755\u6757", 4, "\u675D\u6762\u6763\u6764\u6766\u6767\u676B\u676C\u676E\u6771\u6774\u6776"],
      ["9680", "\u6778\u6779\u677A\u677B\u677D\u6780\u6782\u6783\u6785\u6786\u6788\u678A\u678C\u678D\u678E\u678F\u6791\u6792\u6793\u6794\u6796\u6799\u679B\u679F\u67A0\u67A1\u67A4\u67A6\u67A9\u67AC\u67AE\u67B1\u67B2\u67B4\u67B9", 7, "\u67C2\u67C5", 9, "\u67D5\u67D6\u67D7\u67DB\u67DF\u67E1\u67E3\u67E4\u67E6\u67E7\u67E8\u67EA\u67EB\u67ED\u67EE\u67F2\u67F5", 7, "\u67FE\u6801\u6802\u6803\u6804\u6806\u680D\u6810\u6812\u6814\u6815\u6818", 4, "\u681E\u681F\u6820\u6822", 6, "\u682B", 6, "\u6834\u6835\u6836\u683A\u683B\u683F\u6847\u684B\u684D\u684F\u6852\u6856", 5],
      ["9740", "\u685C\u685D\u685E\u685F\u686A\u686C", 7, "\u6875\u6878", 8, "\u6882\u6884\u6887", 7, "\u6890\u6891\u6892\u6894\u6895\u6896\u6898", 9, "\u68A3\u68A4\u68A5\u68A9\u68AA\u68AB\u68AC\u68AE\u68B1\u68B2\u68B4\u68B6\u68B7\u68B8"],
      ["9780", "\u68B9", 6, "\u68C1\u68C3", 5, "\u68CA\u68CC\u68CE\u68CF\u68D0\u68D1\u68D3\u68D4\u68D6\u68D7\u68D9\u68DB", 4, "\u68E1\u68E2\u68E4", 9, "\u68EF\u68F2\u68F3\u68F4\u68F6\u68F7\u68F8\u68FB\u68FD\u68FE\u68FF\u6900\u6902\u6903\u6904\u6906", 4, "\u690C\u690F\u6911\u6913", 11, "\u6921\u6922\u6923\u6925", 7, "\u692E\u692F\u6931\u6932\u6933\u6935\u6936\u6937\u6938\u693A\u693B\u693C\u693E\u6940\u6941\u6943", 16, "\u6955\u6956\u6958\u6959\u695B\u695C\u695F"],
      ["9840", "\u6961\u6962\u6964\u6965\u6967\u6968\u6969\u696A\u696C\u696D\u696F\u6970\u6972", 4, "\u697A\u697B\u697D\u697E\u697F\u6981\u6983\u6985\u698A\u698B\u698C\u698E", 5, "\u6996\u6997\u6999\u699A\u699D", 9, "\u69A9\u69AA\u69AC\u69AE\u69AF\u69B0\u69B2\u69B3\u69B5\u69B6\u69B8\u69B9\u69BA\u69BC\u69BD"],
      ["9880", "\u69BE\u69BF\u69C0\u69C2", 7, "\u69CB\u69CD\u69CF\u69D1\u69D2\u69D3\u69D5", 5, "\u69DC\u69DD\u69DE\u69E1", 11, "\u69EE\u69EF\u69F0\u69F1\u69F3", 9, "\u69FE\u6A00", 9, "\u6A0B", 11, "\u6A19", 5, "\u6A20\u6A22", 5, "\u6A29\u6A2B\u6A2C\u6A2D\u6A2E\u6A30\u6A32\u6A33\u6A34\u6A36", 6, "\u6A3F", 4, "\u6A45\u6A46\u6A48", 7, "\u6A51", 6, "\u6A5A"],
      ["9940", "\u6A5C", 4, "\u6A62\u6A63\u6A64\u6A66", 10, "\u6A72", 6, "\u6A7A\u6A7B\u6A7D\u6A7E\u6A7F\u6A81\u6A82\u6A83\u6A85", 8, "\u6A8F\u6A92", 4, "\u6A98", 7, "\u6AA1", 5],
      ["9980", "\u6AA7\u6AA8\u6AAA\u6AAD", 114, "\u6B25\u6B26\u6B28", 6],
      ["9a40", "\u6B2F\u6B30\u6B31\u6B33\u6B34\u6B35\u6B36\u6B38\u6B3B\u6B3C\u6B3D\u6B3F\u6B40\u6B41\u6B42\u6B44\u6B45\u6B48\u6B4A\u6B4B\u6B4D", 11, "\u6B5A", 7, "\u6B68\u6B69\u6B6B", 13, "\u6B7A\u6B7D\u6B7E\u6B7F\u6B80\u6B85\u6B88"],
      ["9a80", "\u6B8C\u6B8E\u6B8F\u6B90\u6B91\u6B94\u6B95\u6B97\u6B98\u6B99\u6B9C", 4, "\u6BA2", 7, "\u6BAB", 7, "\u6BB6\u6BB8", 6, "\u6BC0\u6BC3\u6BC4\u6BC6", 4, "\u6BCC\u6BCE\u6BD0\u6BD1\u6BD8\u6BDA\u6BDC", 4, "\u6BE2", 7, "\u6BEC\u6BED\u6BEE\u6BF0\u6BF1\u6BF2\u6BF4\u6BF6\u6BF7\u6BF8\u6BFA\u6BFB\u6BFC\u6BFE", 6, "\u6C08", 4, "\u6C0E\u6C12\u6C17\u6C1C\u6C1D\u6C1E\u6C20\u6C23\u6C25\u6C2B\u6C2C\u6C2D\u6C31\u6C33\u6C36\u6C37\u6C39\u6C3A\u6C3B\u6C3C\u6C3E\u6C3F\u6C43\u6C44\u6C45\u6C48\u6C4B", 4, "\u6C51\u6C52\u6C53\u6C56\u6C58"],
      ["9b40", "\u6C59\u6C5A\u6C62\u6C63\u6C65\u6C66\u6C67\u6C6B", 4, "\u6C71\u6C73\u6C75\u6C77\u6C78\u6C7A\u6C7B\u6C7C\u6C7F\u6C80\u6C84\u6C87\u6C8A\u6C8B\u6C8D\u6C8E\u6C91\u6C92\u6C95\u6C96\u6C97\u6C98\u6C9A\u6C9C\u6C9D\u6C9E\u6CA0\u6CA2\u6CA8\u6CAC\u6CAF\u6CB0\u6CB4\u6CB5\u6CB6\u6CB7\u6CBA\u6CC0\u6CC1\u6CC2\u6CC3\u6CC6\u6CC7\u6CC8\u6CCB\u6CCD\u6CCE\u6CCF\u6CD1\u6CD2\u6CD8"],
      ["9b80", "\u6CD9\u6CDA\u6CDC\u6CDD\u6CDF\u6CE4\u6CE6\u6CE7\u6CE9\u6CEC\u6CED\u6CF2\u6CF4\u6CF9\u6CFF\u6D00\u6D02\u6D03\u6D05\u6D06\u6D08\u6D09\u6D0A\u6D0D\u6D0F\u6D10\u6D11\u6D13\u6D14\u6D15\u6D16\u6D18\u6D1C\u6D1D\u6D1F", 5, "\u6D26\u6D28\u6D29\u6D2C\u6D2D\u6D2F\u6D30\u6D34\u6D36\u6D37\u6D38\u6D3A\u6D3F\u6D40\u6D42\u6D44\u6D49\u6D4C\u6D50\u6D55\u6D56\u6D57\u6D58\u6D5B\u6D5D\u6D5F\u6D61\u6D62\u6D64\u6D65\u6D67\u6D68\u6D6B\u6D6C\u6D6D\u6D70\u6D71\u6D72\u6D73\u6D75\u6D76\u6D79\u6D7A\u6D7B\u6D7D", 4, "\u6D83\u6D84\u6D86\u6D87\u6D8A\u6D8B\u6D8D\u6D8F\u6D90\u6D92\u6D96", 4, "\u6D9C\u6DA2\u6DA5\u6DAC\u6DAD\u6DB0\u6DB1\u6DB3\u6DB4\u6DB6\u6DB7\u6DB9", 5, "\u6DC1\u6DC2\u6DC3\u6DC8\u6DC9\u6DCA"],
      ["9c40", "\u6DCD\u6DCE\u6DCF\u6DD0\u6DD2\u6DD3\u6DD4\u6DD5\u6DD7\u6DDA\u6DDB\u6DDC\u6DDF\u6DE2\u6DE3\u6DE5\u6DE7\u6DE8\u6DE9\u6DEA\u6DED\u6DEF\u6DF0\u6DF2\u6DF4\u6DF5\u6DF6\u6DF8\u6DFA\u6DFD", 7, "\u6E06\u6E07\u6E08\u6E09\u6E0B\u6E0F\u6E12\u6E13\u6E15\u6E18\u6E19\u6E1B\u6E1C\u6E1E\u6E1F\u6E22\u6E26\u6E27\u6E28\u6E2A\u6E2C\u6E2E\u6E30\u6E31\u6E33\u6E35"],
      ["9c80", "\u6E36\u6E37\u6E39\u6E3B", 7, "\u6E45", 7, "\u6E4F\u6E50\u6E51\u6E52\u6E55\u6E57\u6E59\u6E5A\u6E5C\u6E5D\u6E5E\u6E60", 10, "\u6E6C\u6E6D\u6E6F", 14, "\u6E80\u6E81\u6E82\u6E84\u6E87\u6E88\u6E8A", 4, "\u6E91", 6, "\u6E99\u6E9A\u6E9B\u6E9D\u6E9E\u6EA0\u6EA1\u6EA3\u6EA4\u6EA6\u6EA8\u6EA9\u6EAB\u6EAC\u6EAD\u6EAE\u6EB0\u6EB3\u6EB5\u6EB8\u6EB9\u6EBC\u6EBE\u6EBF\u6EC0\u6EC3\u6EC4\u6EC5\u6EC6\u6EC8\u6EC9\u6ECA\u6ECC\u6ECD\u6ECE\u6ED0\u6ED2\u6ED6\u6ED8\u6ED9\u6EDB\u6EDC\u6EDD\u6EE3\u6EE7\u6EEA", 5],
      ["9d40", "\u6EF0\u6EF1\u6EF2\u6EF3\u6EF5\u6EF6\u6EF7\u6EF8\u6EFA", 7, "\u6F03\u6F04\u6F05\u6F07\u6F08\u6F0A", 4, "\u6F10\u6F11\u6F12\u6F16", 9, "\u6F21\u6F22\u6F23\u6F25\u6F26\u6F27\u6F28\u6F2C\u6F2E\u6F30\u6F32\u6F34\u6F35\u6F37", 6, "\u6F3F\u6F40\u6F41\u6F42"],
      ["9d80", "\u6F43\u6F44\u6F45\u6F48\u6F49\u6F4A\u6F4C\u6F4E", 9, "\u6F59\u6F5A\u6F5B\u6F5D\u6F5F\u6F60\u6F61\u6F63\u6F64\u6F65\u6F67", 5, "\u6F6F\u6F70\u6F71\u6F73\u6F75\u6F76\u6F77\u6F79\u6F7B\u6F7D", 6, "\u6F85\u6F86\u6F87\u6F8A\u6F8B\u6F8F", 12, "\u6F9D\u6F9E\u6F9F\u6FA0\u6FA2", 4, "\u6FA8", 10, "\u6FB4\u6FB5\u6FB7\u6FB8\u6FBA", 5, "\u6FC1\u6FC3", 5, "\u6FCA", 6, "\u6FD3", 10, "\u6FDF\u6FE2\u6FE3\u6FE4\u6FE5"],
      ["9e40", "\u6FE6", 7, "\u6FF0", 32, "\u7012", 7, "\u701C", 6, "\u7024", 6],
      ["9e80", "\u702B", 9, "\u7036\u7037\u7038\u703A", 17, "\u704D\u704E\u7050", 13, "\u705F", 11, "\u706E\u7071\u7072\u7073\u7074\u7077\u7079\u707A\u707B\u707D\u7081\u7082\u7083\u7084\u7086\u7087\u7088\u708B\u708C\u708D\u708F\u7090\u7091\u7093\u7097\u7098\u709A\u709B\u709E", 12, "\u70B0\u70B2\u70B4\u70B5\u70B6\u70BA\u70BE\u70BF\u70C4\u70C5\u70C6\u70C7\u70C9\u70CB", 12, "\u70DA"],
      ["9f40", "\u70DC\u70DD\u70DE\u70E0\u70E1\u70E2\u70E3\u70E5\u70EA\u70EE\u70F0", 6, "\u70F8\u70FA\u70FB\u70FC\u70FE", 10, "\u710B", 4, "\u7111\u7112\u7114\u7117\u711B", 10, "\u7127", 7, "\u7132\u7133\u7134"],
      ["9f80", "\u7135\u7137", 13, "\u7146\u7147\u7148\u7149\u714B\u714D\u714F", 12, "\u715D\u715F", 4, "\u7165\u7169", 4, "\u716F\u7170\u7171\u7174\u7175\u7176\u7177\u7179\u717B\u717C\u717E", 5, "\u7185", 4, "\u718B\u718C\u718D\u718E\u7190\u7191\u7192\u7193\u7195\u7196\u7197\u719A", 4, "\u71A1", 6, "\u71A9\u71AA\u71AB\u71AD", 5, "\u71B4\u71B6\u71B7\u71B8\u71BA", 8, "\u71C4", 9, "\u71CF", 4],
      ["a040", "\u71D6", 9, "\u71E1\u71E2\u71E3\u71E4\u71E6\u71E8", 5, "\u71EF", 9, "\u71FA", 11, "\u7207", 19],
      ["a080", "\u721B\u721C\u721E", 9, "\u7229\u722B\u722D\u722E\u722F\u7232\u7233\u7234\u723A\u723C\u723E\u7240", 6, "\u7249\u724A\u724B\u724E\u724F\u7250\u7251\u7253\u7254\u7255\u7257\u7258\u725A\u725C\u725E\u7260\u7263\u7264\u7265\u7268\u726A\u726B\u726C\u726D\u7270\u7271\u7273\u7274\u7276\u7277\u7278\u727B\u727C\u727D\u7282\u7283\u7285", 4, "\u728C\u728E\u7290\u7291\u7293", 11, "\u72A0", 11, "\u72AE\u72B1\u72B2\u72B3\u72B5\u72BA", 6, "\u72C5\u72C6\u72C7\u72C9\u72CA\u72CB\u72CC\u72CF\u72D1\u72D3\u72D4\u72D5\u72D6\u72D8\u72DA\u72DB"],
      ["a1a1", "\u3000\u3001\u3002\xB7\u02C9\u02C7\xA8\u3003\u3005\u2014\uFF5E\u2016\u2026\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 7, "\u3016\u3017\u3010\u3011\xB1\xD7\xF7\u2236\u2227\u2228\u2211\u220F\u222A\u2229\u2208\u2237\u221A\u22A5\u2225\u2220\u2312\u2299\u222B\u222E\u2261\u224C\u2248\u223D\u221D\u2260\u226E\u226F\u2264\u2265\u221E\u2235\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFF04\xA4\uFFE0\uFFE1\u2030\xA7\u2116\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u203B\u2192\u2190\u2191\u2193\u3013"],
      ["a2a1", "\u2170", 9],
      ["a2b1", "\u2488", 19, "\u2474", 19, "\u2460", 9],
      ["a2e5", "\u3220", 9],
      ["a2f1", "\u2160", 11],
      ["a3a1", "\uFF01\uFF02\uFF03\uFFE5\uFF05", 88, "\uFFE3"],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a6e0", "\uFE35\uFE36\uFE39\uFE3A\uFE3F\uFE40\uFE3D\uFE3E\uFE41\uFE42\uFE43\uFE44"],
      ["a6ee", "\uFE3B\uFE3C\uFE37\uFE38\uFE31"],
      ["a6f4", "\uFE33\uFE34"],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a840", "\u02CA\u02CB\u02D9\u2013\u2015\u2025\u2035\u2105\u2109\u2196\u2197\u2198\u2199\u2215\u221F\u2223\u2252\u2266\u2267\u22BF\u2550", 35, "\u2581", 6],
      ["a880", "\u2588", 7, "\u2593\u2594\u2595\u25BC\u25BD\u25E2\u25E3\u25E4\u25E5\u2609\u2295\u3012\u301D\u301E"],
      ["a8a1", "\u0101\xE1\u01CE\xE0\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA\u01DC\xFC\xEA\u0251"],
      ["a8bd", "\u0144\u0148"],
      ["a8c0", "\u0261"],
      ["a8c5", "\u3105", 36],
      ["a940", "\u3021", 8, "\u32A3\u338E\u338F\u339C\u339D\u339E\u33A1\u33C4\u33CE\u33D1\u33D2\u33D5\uFE30\uFFE2\uFFE4"],
      ["a959", "\u2121\u3231"],
      ["a95c", "\u2010"],
      ["a960", "\u30FC\u309B\u309C\u30FD\u30FE\u3006\u309D\u309E\uFE49", 9, "\uFE54\uFE55\uFE56\uFE57\uFE59", 8],
      ["a980", "\uFE62", 4, "\uFE68\uFE69\uFE6A\uFE6B"],
      ["a996", "\u3007"],
      ["a9a4", "\u2500", 75],
      ["aa40", "\u72DC\u72DD\u72DF\u72E2", 5, "\u72EA\u72EB\u72F5\u72F6\u72F9\u72FD\u72FE\u72FF\u7300\u7302\u7304", 5, "\u730B\u730C\u730D\u730F\u7310\u7311\u7312\u7314\u7318\u7319\u731A\u731F\u7320\u7323\u7324\u7326\u7327\u7328\u732D\u732F\u7330\u7332\u7333\u7335\u7336\u733A\u733B\u733C\u733D\u7340", 8],
      ["aa80", "\u7349\u734A\u734B\u734C\u734E\u734F\u7351\u7353\u7354\u7355\u7356\u7358", 7, "\u7361", 10, "\u736E\u7370\u7371"],
      ["ab40", "\u7372", 11, "\u737F", 4, "\u7385\u7386\u7388\u738A\u738C\u738D\u738F\u7390\u7392\u7393\u7394\u7395\u7397\u7398\u7399\u739A\u739C\u739D\u739E\u73A0\u73A1\u73A3", 5, "\u73AA\u73AC\u73AD\u73B1\u73B4\u73B5\u73B6\u73B8\u73B9\u73BC\u73BD\u73BE\u73BF\u73C1\u73C3", 4],
      ["ab80", "\u73CB\u73CC\u73CE\u73D2", 6, "\u73DA\u73DB\u73DC\u73DD\u73DF\u73E1\u73E2\u73E3\u73E4\u73E6\u73E8\u73EA\u73EB\u73EC\u73EE\u73EF\u73F0\u73F1\u73F3", 4],
      ["ac40", "\u73F8", 10, "\u7404\u7407\u7408\u740B\u740C\u740D\u740E\u7411", 8, "\u741C", 5, "\u7423\u7424\u7427\u7429\u742B\u742D\u742F\u7431\u7432\u7437", 4, "\u743D\u743E\u743F\u7440\u7442", 11],
      ["ac80", "\u744E", 6, "\u7456\u7458\u745D\u7460", 12, "\u746E\u746F\u7471", 4, "\u7478\u7479\u747A"],
      ["ad40", "\u747B\u747C\u747D\u747F\u7482\u7484\u7485\u7486\u7488\u7489\u748A\u748C\u748D\u748F\u7491", 10, "\u749D\u749F", 7, "\u74AA", 15, "\u74BB", 12],
      ["ad80", "\u74C8", 9, "\u74D3", 8, "\u74DD\u74DF\u74E1\u74E5\u74E7", 6, "\u74F0\u74F1\u74F2"],
      ["ae40", "\u74F3\u74F5\u74F8", 6, "\u7500\u7501\u7502\u7503\u7505", 7, "\u750E\u7510\u7512\u7514\u7515\u7516\u7517\u751B\u751D\u751E\u7520", 4, "\u7526\u7527\u752A\u752E\u7534\u7536\u7539\u753C\u753D\u753F\u7541\u7542\u7543\u7544\u7546\u7547\u7549\u754A\u754D\u7550\u7551\u7552\u7553\u7555\u7556\u7557\u7558"],
      ["ae80", "\u755D", 7, "\u7567\u7568\u7569\u756B", 6, "\u7573\u7575\u7576\u7577\u757A", 4, "\u7580\u7581\u7582\u7584\u7585\u7587"],
      ["af40", "\u7588\u7589\u758A\u758C\u758D\u758E\u7590\u7593\u7595\u7598\u759B\u759C\u759E\u75A2\u75A6", 4, "\u75AD\u75B6\u75B7\u75BA\u75BB\u75BF\u75C0\u75C1\u75C6\u75CB\u75CC\u75CE\u75CF\u75D0\u75D1\u75D3\u75D7\u75D9\u75DA\u75DC\u75DD\u75DF\u75E0\u75E1\u75E5\u75E9\u75EC\u75ED\u75EE\u75EF\u75F2\u75F3\u75F5\u75F6\u75F7\u75F8\u75FA\u75FB\u75FD\u75FE\u7602\u7604\u7606\u7607"],
      ["af80", "\u7608\u7609\u760B\u760D\u760E\u760F\u7611\u7612\u7613\u7614\u7616\u761A\u761C\u761D\u761E\u7621\u7623\u7627\u7628\u762C\u762E\u762F\u7631\u7632\u7636\u7637\u7639\u763A\u763B\u763D\u7641\u7642\u7644"],
      ["b040", "\u7645", 6, "\u764E", 5, "\u7655\u7657", 4, "\u765D\u765F\u7660\u7661\u7662\u7664", 6, "\u766C\u766D\u766E\u7670", 7, "\u7679\u767A\u767C\u767F\u7680\u7681\u7683\u7685\u7689\u768A\u768C\u768D\u768F\u7690\u7692\u7694\u7695\u7697\u7698\u769A\u769B"],
      ["b080", "\u769C", 7, "\u76A5", 8, "\u76AF\u76B0\u76B3\u76B5", 9, "\u76C0\u76C1\u76C3\u554A\u963F\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u80AE\u6602\u76CE\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u82DE\u80DE\u5305\u8912\u5265"],
      ["b140", "\u76C4\u76C7\u76C9\u76CB\u76CC\u76D3\u76D5\u76D9\u76DA\u76DC\u76DD\u76DE\u76E0", 4, "\u76E6", 7, "\u76F0\u76F3\u76F5\u76F6\u76F7\u76FA\u76FB\u76FD\u76FF\u7700\u7702\u7703\u7705\u7706\u770A\u770C\u770E", 10, "\u771B\u771C\u771D\u771E\u7721\u7723\u7724\u7725\u7727\u772A\u772B"],
      ["b180", "\u772C\u772E\u7730", 4, "\u7739\u773B\u773D\u773E\u773F\u7742\u7744\u7745\u7746\u7748", 7, "\u7752", 7, "\u775C\u8584\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5954\u82EF\u672C\u7B28\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u6807\u5F6A\u8198\u8868\u9CD6\u618B\u522B\u762A\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3"],
      ["b240", "\u775D\u775E\u775F\u7760\u7764\u7767\u7769\u776A\u776D", 11, "\u777A\u777B\u777C\u7781\u7782\u7783\u7786", 5, "\u778F\u7790\u7793", 11, "\u77A1\u77A3\u77A4\u77A6\u77A8\u77AB\u77AD\u77AE\u77AF\u77B1\u77B2\u77B4\u77B6", 4],
      ["b280", "\u77BC\u77BE\u77C0", 12, "\u77CE", 8, "\u77D8\u77D9\u77DA\u77DD", 4, "\u77E4\u75C5\u5E76\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u64E6\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u82CD\u8231\u4ED3\u6CA7\u85CF\u64CD\u7CD9\u69FD\u66F9\u8349\u5395\u7B56\u4FA7\u518C\u6D4B\u5C42\u8E6D\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u62C6\u67F4\u8C7A\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u660C\u7316"],
      ["b340", "\u77E6\u77E8\u77EA\u77EF\u77F0\u77F1\u77F2\u77F4\u77F5\u77F7\u77F9\u77FA\u77FB\u77FC\u7803", 5, "\u780A\u780B\u780E\u780F\u7810\u7813\u7815\u7819\u781B\u781E\u7820\u7821\u7822\u7824\u7828\u782A\u782B\u782E\u782F\u7831\u7832\u7833\u7835\u7836\u783D\u783F\u7841\u7842\u7843\u7844\u7846\u7848\u7849\u784A\u784B\u784D\u784F\u7851\u7853\u7854\u7858\u7859\u785A"],
      ["b380", "\u785B\u785C\u785E", 11, "\u786F", 7, "\u7878\u7879\u787A\u787B\u787D", 6, "\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u6491\u79F0\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u5145\u51B2\u866B\u5D07\u5BA0\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A"],
      ["b440", "\u7884\u7885\u7886\u7888\u788A\u788B\u788F\u7890\u7892\u7894\u7895\u7896\u7899\u789D\u789E\u78A0\u78A2\u78A4\u78A6\u78A8", 7, "\u78B5\u78B6\u78B7\u78B8\u78BA\u78BB\u78BC\u78BD\u78BF\u78C0\u78C2\u78C3\u78C4\u78C6\u78C7\u78C8\u78CC\u78CD\u78CE\u78CF\u78D1\u78D2\u78D3\u78D6\u78D7\u78D8\u78DA", 9],
      ["b480", "\u78E4\u78E5\u78E6\u78E7\u78E9\u78EA\u78EB\u78ED", 4, "\u78F3\u78F5\u78F6\u78F8\u78F9\u78FB", 5, "\u7902\u7903\u7904\u7906", 6, "\u7840\u50A8\u77D7\u6410\u89E6\u5904\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u5439\u708A\u6376\u9524\u5782\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u6233\u7EF0\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u51D1\u7C97\u918B\u7C07\u4FC3\u8E7F\u7BE1\u7A9C\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u6751\u5B58\u5BF8\u78CB\u64AE\u6413\u63AA\u632B\u9519\u642D\u8FBE\u7B54\u7629\u6253\u5927\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E"],
      ["b540", "\u790D", 5, "\u7914", 9, "\u791F", 4, "\u7925", 14, "\u7935", 4, "\u793D\u793F\u7942\u7943\u7944\u7945\u7947\u794A", 8, "\u7954\u7955\u7958\u7959\u7961\u7963"],
      ["b580", "\u7964\u7966\u7969\u796A\u796B\u796C\u796E\u7970", 6, "\u7979\u797B", 4, "\u7982\u7983\u7986\u7987\u7988\u7989\u798B\u798C\u798D\u798E\u7990\u7991\u7992\u6020\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u5F53\u6321\u515A\u8361\u6863\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u5FB7\u5F97\u7684\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0"],
      ["b640", "\u7993", 6, "\u799B", 11, "\u79A8", 10, "\u79B4", 4, "\u79BC\u79BF\u79C2\u79C4\u79C5\u79C7\u79C8\u79CA\u79CC\u79CE\u79CF\u79D0\u79D3\u79D4\u79D6\u79D7\u79D9", 5, "\u79E0\u79E1\u79E2\u79E5\u79E8\u79EA"],
      ["b680", "\u79EC\u79EE\u79F1", 6, "\u79F9\u79FA\u79FC\u79FE\u79FF\u7A01\u7A04\u7A05\u7A07\u7A08\u7A09\u7A0A\u7A0C\u7A0F", 4, "\u7A15\u7A16\u7A18\u7A19\u7A1B\u7A1C\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5806\u5151\u961F\u5BF9\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u6069\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C"],
      ["b740", "\u7A1D\u7A1F\u7A21\u7A22\u7A24", 14, "\u7A34\u7A35\u7A36\u7A38\u7A3A\u7A3E\u7A40", 5, "\u7A47", 9, "\u7A52", 4, "\u7A58", 16],
      ["b780", "\u7A69", 6, "\u7A71\u7A72\u7A73\u7A75\u7A7B\u7A7C\u7A7D\u7A7E\u7A82\u7A85\u7A87\u7A89\u7A8A\u7A8B\u7A8C\u7A8E\u7A8F\u7A90\u7A93\u7A94\u7A99\u7A9A\u7A9B\u7A9E\u7AA1\u7AA2\u8D30\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D"],
      ["b840", "\u7AA3\u7AA4\u7AA7\u7AA9\u7AAA\u7AAB\u7AAE", 4, "\u7AB4", 10, "\u7AC0", 10, "\u7ACC", 9, "\u7AD7\u7AD8\u7ADA\u7ADB\u7ADC\u7ADD\u7AE1\u7AE2\u7AE4\u7AE7", 5, "\u7AEE\u7AF0\u7AF1\u7AF2\u7AF3"],
      ["b880", "\u7AF4", 4, "\u7AFB\u7AFC\u7AFE\u7B00\u7B01\u7B02\u7B05\u7B07\u7B09\u7B0C\u7B0D\u7B0E\u7B10\u7B12\u7B13\u7B16\u7B17\u7B18\u7B1A\u7B1C\u7B1D\u7B1F\u7B21\u7B22\u7B23\u7B27\u7B29\u7B2D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5676\u560E\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6760\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u86E4\u9601\u9694\u94EC\u4E2A\u5404\u7ED9\u6839\u8DDF\u8015\u66F4\u5E9A\u7FB9"],
      ["b940", "\u7B2F\u7B30\u7B32\u7B34\u7B35\u7B36\u7B37\u7B39\u7B3B\u7B3D\u7B3F", 5, "\u7B46\u7B48\u7B4A\u7B4D\u7B4E\u7B53\u7B55\u7B57\u7B59\u7B5C\u7B5E\u7B5F\u7B61\u7B63", 10, "\u7B6F\u7B70\u7B73\u7B74\u7B76\u7B78\u7B7A\u7B7C\u7B7D\u7B7F\u7B81\u7B82\u7B83\u7B84\u7B86", 6, "\u7B8E\u7B8F"],
      ["b980", "\u7B91\u7B92\u7B93\u7B96\u7B98\u7B99\u7B9A\u7B9B\u7B9E\u7B9F\u7BA0\u7BA3\u7BA4\u7BA5\u7BAE\u7BAF\u7BB0\u7BB2\u7BB3\u7BB5\u7BB6\u7BB7\u7BB9", 7, "\u7BC2\u7BC3\u7BC4\u57C2\u803F\u6897\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u522E\u74DC\u5250\u5BE1\u6302\u8902\u4E56\u62D0\u602A\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u5149\u5E7F\u901B\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u8F8A\u6EDA\u68CD\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u54C8"],
      ["ba40", "\u7BC5\u7BC8\u7BC9\u7BCA\u7BCB\u7BCD\u7BCE\u7BCF\u7BD0\u7BD2\u7BD4", 4, "\u7BDB\u7BDC\u7BDE\u7BDF\u7BE0\u7BE2\u7BE3\u7BE4\u7BE7\u7BE8\u7BE9\u7BEB\u7BEC\u7BED\u7BEF\u7BF0\u7BF2", 4, "\u7BF8\u7BF9\u7BFA\u7BFB\u7BFD\u7BFF", 7, "\u7C08\u7C09\u7C0A\u7C0D\u7C0E\u7C10", 5, "\u7C17\u7C18\u7C19"],
      ["ba80", "\u7C1A", 4, "\u7C20", 5, "\u7C28\u7C29\u7C2B", 12, "\u7C39", 5, "\u7C42\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u592F\u676D\u822A\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u563F\u9ED1\u75D5\u5F88\u72E0\u6068\u54FC\u4EA8\u6A2A\u8861\u6052\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56"],
      ["bb40", "\u7C43", 9, "\u7C4E", 36, "\u7C75", 5, "\u7C7E", 9],
      ["bb80", "\u7C88\u7C8A", 6, "\u7C93\u7C94\u7C96\u7C99\u7C9A\u7C9B\u7CA0\u7CA1\u7CA3\u7CA6\u7CA7\u7CA8\u7CA9\u7CAB\u7CAC\u7CAD\u7CAF\u7CB0\u7CB4", 4, "\u7CBA\u7CBB\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u69D0\u5F8A\u6000\u6DEE\u574F\u6B22\u73AF\u6853\u8FD8\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95"],
      ["bc40", "\u7CBF\u7CC0\u7CC2\u7CC3\u7CC4\u7CC6\u7CC9\u7CCB\u7CCE", 6, "\u7CD8\u7CDA\u7CDB\u7CDD\u7CDE\u7CE1", 6, "\u7CE9", 5, "\u7CF0", 7, "\u7CF9\u7CFA\u7CFC", 13, "\u7D0B", 5],
      ["bc80", "\u7D11", 14, "\u7D21\u7D23\u7D24\u7D25\u7D26\u7D28\u7D29\u7D2A\u7D2C\u7D2D\u7D2E\u7D30", 6, "\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6"],
      ["bd40", "\u7D37", 54, "\u7D6F", 7],
      ["bd80", "\u7D78", 32, "\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78"],
      ["be40", "\u7D99", 12, "\u7DA7", 6, "\u7DAF", 42],
      ["be80", "\u7DDA", 32, "\u5C3D\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u70AF\u7A98\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u97A0\u62D8\u72D9\u75BD\u5C45\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u5747\u83CC\u94A7\u519B\u541B\u5CFB"],
      ["bf40", "\u7DFB", 62],
      ["bf80", "\u7E3A\u7E3C", 4, "\u7E42", 4, "\u7E48", 21, "\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u5580\u5496\u5361\u54AF\u5F00\u63E9\u6977\u51EF\u6168\u520A\u582A\u52D8\u574E\u780D\u770B\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u8003\u62F7\u70E4\u9760\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u80AF\u5543\u57A6\u6073\u5751\u542D\u7A7A\u6050\u5B54\u63A7\u62A0\u53E3\u6263\u5BC7\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5938\u57AE\u630E\u8DE8\u80EF\u5757\u7B77\u4FA9\u5FEB\u5BBD\u6B3E\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080"],
      ["c040", "\u7E5E", 35, "\u7E83", 23, "\u7E9C\u7E9D\u7E9E"],
      ["c080", "\u7EAE\u7EB4\u7EBB\u7EBC\u7ED6\u7EE4\u7EEC\u7EF9\u7F0A\u7F10\u7F1E\u7F37\u7F39\u7F3B", 6, "\u7F43\u7F46", 9, "\u7F52\u7F53\u9988\u6127\u6E83\u5764\u6606\u6346\u56F0\u62EC\u6269\u5ED3\u9614\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u83B1\u6765\u8D56\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u52D2\u4E50\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u808B\u7C7B\u6CEA\u68F1\u695E\u51B7\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0"],
      ["c140", "\u7F56\u7F59\u7F5B\u7F5C\u7F5D\u7F5E\u7F60\u7F63", 4, "\u7F6B\u7F6C\u7F6D\u7F6F\u7F70\u7F73\u7F75\u7F76\u7F77\u7F78\u7F7A\u7F7B\u7F7C\u7F7D\u7F7F\u7F80\u7F82", 7, "\u7F8B\u7F8D\u7F8F", 4, "\u7F95", 4, "\u7F9B\u7F9C\u7FA0\u7FA2\u7FA3\u7FA5\u7FA6\u7FA8", 6, "\u7FB1"],
      ["c180", "\u7FB3", 4, "\u7FBA\u7FBB\u7FBE\u7FC0\u7FC2\u7FC3\u7FC4\u7FC6\u7FC7\u7FC8\u7FC9\u7FCB\u7FCD\u7FCF", 4, "\u7FD6\u7FD7\u7FD9", 5, "\u7FE2\u7FE3\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u5217\u88C2\u70C8\u52A3\u730E\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u9F99\u804B\u5499\u7B3C\u7ABF"],
      ["c240", "\u7FE4\u7FE7\u7FE8\u7FEA\u7FEB\u7FEC\u7FED\u7FEF\u7FF2\u7FF4", 6, "\u7FFD\u7FFE\u7FFF\u8002\u8007\u8008\u8009\u800A\u800E\u800F\u8011\u8013\u801A\u801B\u801D\u801E\u801F\u8021\u8023\u8024\u802B", 5, "\u8032\u8034\u8039\u803A\u803C\u803E\u8040\u8041\u8044\u8045\u8047\u8048\u8049\u804E\u804F\u8050\u8051\u8053\u8055\u8056\u8057"],
      ["c280", "\u8059\u805B", 13, "\u806B", 5, "\u8072", 11, "\u9686\u5784\u62E2\u9647\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u5CE6\u631B\u5B6A\u6EE6\u5375\u4E71\u63A0\u7565\u62A1\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B"],
      ["c340", "\u807E\u8081\u8082\u8085\u8088\u808A\u808D", 5, "\u8094\u8095\u8097\u8099\u809E\u80A3\u80A6\u80A7\u80A8\u80AC\u80B0\u80B3\u80B5\u80B6\u80B8\u80B9\u80BB\u80C5\u80C7", 4, "\u80CF", 6, "\u80D8\u80DF\u80E0\u80E2\u80E3\u80E6\u80EE\u80F5\u80F7\u80F9\u80FB\u80FE\u80FF\u8100\u8101\u8103\u8104\u8105\u8107\u8108\u810B"],
      ["c380", "\u810C\u8115\u8117\u8119\u811B\u811C\u811D\u811F", 12, "\u812D\u812E\u8130\u8133\u8134\u8135\u8137\u8139", 4, "\u813F\u8C29\u8292\u832B\u76F2\u6C13\u5FD9\u83BD\u732B\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4E48\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u95E8\u95F7\u4EEC\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u8511\u706D\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u660E\u879F\u9E23\u94ED\u540D\u547D\u8C2C\u6478"],
      ["c440", "\u8140", 5, "\u8147\u8149\u814D\u814E\u814F\u8152\u8156\u8157\u8158\u815B", 4, "\u8161\u8162\u8163\u8164\u8166\u8168\u816A\u816B\u816C\u816F\u8172\u8173\u8175\u8176\u8177\u8178\u8181\u8183", 4, "\u8189\u818B\u818C\u818D\u818E\u8190\u8192", 5, "\u8199\u819A\u819E", 4, "\u81A4\u81A5"],
      ["c480", "\u81A7\u81A9\u81AB", 7, "\u81B4", 5, "\u81BC\u81BD\u81BE\u81BF\u81C4\u81C5\u81C7\u81C8\u81C9\u81CB\u81CD", 6, "\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C0B\u725F\u67D0\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u6C16\u4E43\u5976\u8010\u5948\u5357\u7537\u96BE\u56CA\u6320\u8111\u607C\u95F9\u6DD6\u5462\u9981\u5185\u5AE9\u80FD\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5A18\u917F\u9E1F\u5C3F\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u60A8\u67E0\u72DE\u51DD\u5B81"],
      ["c540", "\u81D4", 14, "\u81E4\u81E5\u81E6\u81E8\u81E9\u81EB\u81EE", 4, "\u81F5", 5, "\u81FD\u81FF\u8203\u8207", 4, "\u820E\u820F\u8211\u8213\u8215", 5, "\u821D\u8220\u8224\u8225\u8226\u8227\u8229\u822E\u8232\u823A\u823C\u823D\u823F"],
      ["c580", "\u8240\u8241\u8242\u8243\u8245\u8246\u8248\u824A\u824C\u824D\u824E\u8250", 7, "\u8259\u825B\u825C\u825D\u825E\u8260", 7, "\u8269\u62E7\u6CDE\u725B\u626D\u94AE\u7EBD\u8113\u6D53\u519C\u5F04\u5974\u52AA\u6012\u5973\u6696\u8650\u759F\u632A\u61E6\u7CEF\u8BFA\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u556A\u8DB4\u722C\u5E15\u6015\u7436\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u4E53\u5E9E\u65C1\u802A\u80D6\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u55B7\u76C6\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7"],
      ["c640", "\u826A\u826B\u826C\u826D\u8271\u8275\u8276\u8277\u8278\u827B\u827C\u8280\u8281\u8283\u8285\u8286\u8287\u8289\u828C\u8290\u8293\u8294\u8295\u8296\u829A\u829B\u829E\u82A0\u82A2\u82A3\u82A7\u82B2\u82B5\u82B6\u82BA\u82BB\u82BC\u82BF\u82C0\u82C2\u82C3\u82C5\u82C6\u82C9\u82D0\u82D6\u82D9\u82DA\u82DD\u82E2\u82E7\u82E8\u82E9\u82EA\u82EC\u82ED\u82EE\u82F0\u82F2\u82F3\u82F5\u82F6\u82F8"],
      ["c680", "\u82FA\u82FC", 4, "\u830A\u830B\u830D\u8310\u8312\u8313\u8316\u8318\u8319\u831D", 9, "\u8329\u832A\u832E\u8330\u8332\u8337\u833B\u833D\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u7BC7\u504F\u7247\u9A97\u98D8\u6F02\u74E2\u7968\u6487\u77A5\u62FC\u9891\u8D2B\u54C1\u8058\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u5256\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u6390"],
      ["c740", "\u833E\u833F\u8341\u8342\u8344\u8345\u8348\u834A", 4, "\u8353\u8355", 4, "\u835D\u8362\u8370", 6, "\u8379\u837A\u837E", 6, "\u8387\u8388\u838A\u838B\u838C\u838D\u838F\u8390\u8391\u8394\u8395\u8396\u8397\u8399\u839A\u839D\u839F\u83A1", 6, "\u83AC\u83AD\u83AE"],
      ["c780", "\u83AF\u83B5\u83BB\u83BE\u83BF\u83C2\u83C3\u83C4\u83C6\u83C8\u83C9\u83CB\u83CD\u83CE\u83D0\u83D1\u83D2\u83D3\u83D5\u83D7\u83D9\u83DA\u83DB\u83DE\u83E2\u83E3\u83E4\u83E6\u83E7\u83E8\u83EB\u83EC\u83ED\u6070\u6D3D\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5207\u8304\u4E14\u602F\u7A83\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u743C\u7A77\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20"],
      ["c840", "\u83EE\u83EF\u83F3", 4, "\u83FA\u83FB\u83FC\u83FE\u83FF\u8400\u8402\u8405\u8407\u8408\u8409\u840A\u8410\u8412", 5, "\u8419\u841A\u841B\u841E", 5, "\u8429", 7, "\u8432", 5, "\u8439\u843A\u843B\u843E", 7, "\u8447\u8448\u8449"],
      ["c880", "\u844A", 6, "\u8452", 4, "\u8458\u845D\u845E\u845F\u8460\u8462\u8464", 4, "\u846A\u846E\u846F\u8470\u8472\u8474\u8477\u8479\u847B\u847C\u53D6\u5A36\u9F8B\u8DA3\u53BB\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u88D9\u7FA4\u7136\u71C3\u5189\u67D3\u74E4\u58E4\u6518\u56B7\u8BA9\u9976\u6270\u7ED5\u60F9\u70ED\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u6254\u4ECD\u65E5\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u63C9\u67D4\u8089\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u8F6F\u962E\u854A\u745E\u9510\u95F0\u6DA6\u82E5\u5F31\u6492\u6D12\u8428\u816E\u9CC3\u585E\u8D5B\u4E09\u53C1"],
      ["c940", "\u847D", 4, "\u8483\u8484\u8485\u8486\u848A\u848D\u848F", 7, "\u8498\u849A\u849B\u849D\u849E\u849F\u84A0\u84A2", 12, "\u84B0\u84B1\u84B3\u84B5\u84B6\u84B7\u84BB\u84BC\u84BE\u84C0\u84C2\u84C3\u84C5\u84C6\u84C7\u84C8\u84CB\u84CC\u84CE\u84CF\u84D2\u84D4\u84D5\u84D7"],
      ["c980", "\u84D8", 4, "\u84DE\u84E1\u84E2\u84E4\u84E7", 4, "\u84ED\u84EE\u84EF\u84F1", 10, "\u84FD\u84FE\u8500\u8501\u8502\u4F1E\u6563\u6851\u55D3\u4E27\u6414\u9A9A\u626B\u5AC2\u745F\u8272\u6DA9\u68EE\u50E7\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u7B5B\u6652\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u58F0\u751F\u7525\u7272\u5347\u7EF3"],
      ["ca40", "\u8503", 8, "\u850D\u850E\u850F\u8510\u8512\u8514\u8515\u8516\u8518\u8519\u851B\u851C\u851D\u851E\u8520\u8522", 8, "\u852D", 9, "\u853E", 4, "\u8544\u8545\u8546\u8547\u854B", 10],
      ["ca80", "\u8557\u8558\u855A\u855B\u855C\u855D\u855F", 4, "\u8565\u8566\u8567\u8569", 8, "\u8573\u8575\u8576\u8577\u8578\u857C\u857D\u857F\u8580\u8581\u7701\u76DB\u5269\u80DC\u5723\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31"],
      ["cb40", "\u8582\u8583\u8586\u8588", 6, "\u8590", 10, "\u859D", 6, "\u85A5\u85A6\u85A7\u85A9\u85AB\u85AC\u85AD\u85B1", 5, "\u85B8\u85BA", 6, "\u85C2", 6, "\u85CA", 4, "\u85D1\u85D2"],
      ["cb80", "\u85D4\u85D6", 5, "\u85DD", 6, "\u85E5\u85E6\u85E7\u85E8\u85EA", 14, "\u6055\u5237\u800D\u6454\u8870\u7529\u5E05\u6813\u62F4\u971C\u53CC\u723D\u8C01\u6C34\u7761\u7A0E\u542E\u77AC\u987A\u821C\u8BF4\u7855\u6714\u70C1\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u641C\u8258\u64DE\u55FD\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u9178\u849C\u7B97\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u5B59\u635F\u7B0B\u84D1\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u584C\u4ED6\u5B83\u5979\u5854"],
      ["cc40", "\u85F9\u85FA\u85FC\u85FD\u85FE\u8600", 4, "\u8606", 10, "\u8612\u8613\u8614\u8615\u8617", 15, "\u8628\u862A", 13, "\u8639\u863A\u863B\u863D\u863E\u863F\u8640"],
      ["cc80", "\u8641", 11, "\u8652\u8653\u8655", 4, "\u865B\u865C\u865D\u865F\u8660\u8661\u8663", 7, "\u736D\u631E\u8E4B\u8E0F\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u5018\u8EBA\u6DCC\u8D9F\u70EB\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u7279\u85E4\u817E\u75BC\u8A8A\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u6311\u6761\u8FE2\u773A\u8DF3\u8D34\u94C1\u5E16\u5385\u542C\u70C3"],
      ["cd40", "\u866D\u866F\u8670\u8672", 6, "\u8683", 6, "\u868E", 4, "\u8694\u8696", 5, "\u869E", 4, "\u86A5\u86A6\u86AB\u86AD\u86AE\u86B2\u86B3\u86B7\u86B8\u86B9\u86BB", 4, "\u86C1\u86C2\u86C3\u86C5\u86C8\u86CC\u86CD\u86D2\u86D3\u86D5\u86D6\u86D7\u86DA\u86DC"],
      ["cd80", "\u86DD\u86E0\u86E1\u86E2\u86E3\u86E5\u86E6\u86E7\u86E8\u86EA\u86EB\u86EC\u86EF\u86F5\u86F6\u86F7\u86FA\u86FB\u86FC\u86FD\u86FF\u8701\u8704\u8705\u8706\u870B\u870C\u870E\u870F\u8710\u8711\u8714\u8716\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u5077\u6295\u5934\u900F\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u6E4D\u56E2\u63A8\u9893\u817F\u8715\u892A\u9000\u541E\u5C6F\u81C0\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u6B6A\u5916\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u5A01"],
      ["ce40", "\u8719\u871B\u871D\u871F\u8720\u8724\u8726\u8727\u8728\u872A\u872B\u872C\u872D\u872F\u8730\u8732\u8733\u8735\u8736\u8738\u8739\u873A\u873C\u873D\u8740", 6, "\u874A\u874B\u874D\u874F\u8750\u8751\u8752\u8754\u8755\u8756\u8758\u875A", 5, "\u8761\u8762\u8766", 7, "\u876F\u8771\u8772\u8773\u8775"],
      ["ce80", "\u8777\u8778\u8779\u877A\u877F\u8780\u8781\u8784\u8786\u8787\u8789\u878A\u878C\u878E", 4, "\u8794\u8795\u8796\u8798", 6, "\u87A0", 4, "\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u55E1\u7FC1\u74EE\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A"],
      ["cf40", "\u87A5\u87A6\u87A7\u87A9\u87AA\u87AE\u87B0\u87B1\u87B2\u87B4\u87B6\u87B7\u87B8\u87B9\u87BB\u87BC\u87BE\u87BF\u87C1", 4, "\u87C7\u87C8\u87C9\u87CC", 4, "\u87D4", 6, "\u87DC\u87DD\u87DE\u87DF\u87E1\u87E2\u87E3\u87E4\u87E6\u87E7\u87E8\u87E9\u87EB\u87EC\u87ED\u87EF", 9],
      ["cf80", "\u87FA\u87FB\u87FC\u87FD\u87FF\u8800\u8801\u8802\u8804", 5, "\u880B", 7, "\u8814\u8817\u8818\u8819\u881A\u881C", 4, "\u8823\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653"],
      ["d040", "\u8824", 13, "\u8833", 5, "\u883A\u883B\u883D\u883E\u883F\u8841\u8842\u8843\u8846", 5, "\u884E", 5, "\u8855\u8856\u8858\u885A", 6, "\u8866\u8867\u886A\u886D\u886F\u8871\u8873\u8874\u8875\u8876\u8878\u8879\u887A"],
      ["d080", "\u887B\u887C\u8880\u8883\u8886\u8887\u8889\u888A\u888C\u888E\u888F\u8890\u8891\u8893\u8894\u8895\u8897", 4, "\u889D", 4, "\u88A3\u88A5", 5, "\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384"],
      ["d140", "\u88AC\u88AE\u88AF\u88B0\u88B2", 4, "\u88B8\u88B9\u88BA\u88BB\u88BD\u88BE\u88BF\u88C0\u88C3\u88C4\u88C7\u88C8\u88CA\u88CB\u88CC\u88CD\u88CF\u88D0\u88D1\u88D3\u88D6\u88D7\u88DA", 4, "\u88E0\u88E1\u88E6\u88E7\u88E9", 6, "\u88F2\u88F5\u88F6\u88F7\u88FA\u88FB\u88FD\u88FF\u8900\u8901\u8903", 5],
      ["d180", "\u8909\u890B", 4, "\u8911\u8914", 4, "\u891C", 4, "\u8922\u8923\u8924\u8926\u8927\u8928\u8929\u892C\u892D\u892E\u892F\u8931\u8932\u8933\u8935\u8937\u9009\u7663\u7729\u7EDA\u9774\u859B\u5B66\u7A74\u96EA\u8840\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u9080\u8170\u5996\u7476"],
      ["d240", "\u8938", 8, "\u8942\u8943\u8945", 24, "\u8960", 5, "\u8967", 19, "\u897C"],
      ["d280", "\u897D\u897E\u8980\u8982\u8984\u8985\u8987", 26, "\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690"],
      ["d340", "\u89A2", 30, "\u89C3\u89CD\u89D3\u89D4\u89D5\u89D7\u89D8\u89D9\u89DB\u89DD\u89DF\u89E0\u89E1\u89E2\u89E4\u89E7\u89E8\u89E9\u89EA\u89EC\u89ED\u89EE\u89F0\u89F1\u89F2\u89F4", 6],
      ["d380", "\u89FB", 4, "\u8A01", 5, "\u8A08", 21, "\u5370\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u54DF\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89"],
      ["d440", "\u8A1E", 31, "\u8A3F", 8, "\u8A49", 21],
      ["d480", "\u8A5F", 25, "\u8A7A", 6, "\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u531D\u7838\u6742\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u6512\u6682\u8D5E\u8D43\u810F\u846C\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u8D23\u62E9\u5219\u6CFD\u8D3C\u600E\u589E\u618E\u66FE\u8D60\u624E\u55B3\u6E23\u672D\u8F67"],
      ["d540", "\u8A81", 7, "\u8A8B", 7, "\u8A94", 46],
      ["d580", "\u8AC3", 32, "\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F"],
      ["d640", "\u8AE4", 34, "\u8B08", 27],
      ["d680", "\u8B24\u8B25\u8B27", 30, "\u5E27\u75C7\u90D1\u8BC1\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51"],
      ["d740", "\u8B46", 31, "\u8B67", 4, "\u8B6D", 25],
      ["d780", "\u8B87", 24, "\u8BAC\u8BB1\u8BBB\u8BC7\u8BD0\u8BEA\u8C09\u8C1E\u4F4F\u6CE8\u795D\u9A7B\u6293\u722A\u62FD\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8C06\u51C6\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u5544\u7740\u707C\u6D4A\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u90B9\u8D70\u594F\u63CD\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u94BB\u7E82\u5634\u9189\u6700\u7F6A\u5C0A\u9075\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7"],
      ["d840", "\u8C38", 8, "\u8C42\u8C43\u8C44\u8C45\u8C48\u8C4A\u8C4B\u8C4D", 7, "\u8C56\u8C57\u8C58\u8C59\u8C5B", 5, "\u8C63", 6, "\u8C6C", 6, "\u8C74\u8C75\u8C76\u8C77\u8C7B", 6, "\u8C83\u8C84\u8C86\u8C87"],
      ["d880", "\u8C88\u8C8B\u8C8D", 6, "\u8C95\u8C96\u8C97\u8C99", 20, "\u4E8D\u4E0C\u5140\u4E10\u5EFF\u5345\u4E15\u4E98\u4E1E\u9B32\u5B6C\u5669\u4E28\u79BA\u4E3F\u5315\u4E47\u592D\u723B\u536E\u6C10\u56DF\u80E4\u9997\u6BD3\u777E\u9F17\u4E36\u4E9F\u9F10\u4E5C\u4E69\u4E93\u8288\u5B5B\u556C\u560F\u4EC4\u538D\u539D\u53A3\u53A5\u53AE\u9765\u8D5D\u531A\u53F5\u5326\u532E\u533E\u8D5C\u5366\u5363\u5202\u5208\u520E\u522D\u5233\u523F\u5240\u524C\u525E\u5261\u525C\u84AF\u527D\u5282\u5281\u5290\u5293\u5182\u7F54\u4EBB\u4EC3\u4EC9\u4EC2\u4EE8\u4EE1\u4EEB\u4EDE\u4F1B\u4EF3\u4F22\u4F64\u4EF5\u4F25\u4F27\u4F09\u4F2B\u4F5E\u4F67\u6538\u4F5A\u4F5D"],
      ["d940", "\u8CAE", 62],
      ["d980", "\u8CED", 32, "\u4F5F\u4F57\u4F32\u4F3D\u4F76\u4F74\u4F91\u4F89\u4F83\u4F8F\u4F7E\u4F7B\u4FAA\u4F7C\u4FAC\u4F94\u4FE6\u4FE8\u4FEA\u4FC5\u4FDA\u4FE3\u4FDC\u4FD1\u4FDF\u4FF8\u5029\u504C\u4FF3\u502C\u500F\u502E\u502D\u4FFE\u501C\u500C\u5025\u5028\u507E\u5043\u5055\u5048\u504E\u506C\u507B\u50A5\u50A7\u50A9\u50BA\u50D6\u5106\u50ED\u50EC\u50E6\u50EE\u5107\u510B\u4EDD\u6C3D\u4F58\u4F65\u4FCE\u9FA0\u6C46\u7C74\u516E\u5DFD\u9EC9\u9998\u5181\u5914\u52F9\u530D\u8A07\u5310\u51EB\u5919\u5155\u4EA0\u5156\u4EB3\u886E\u88A4\u4EB5\u8114\u88D2\u7980\u5B34\u8803\u7FB8\u51AB\u51B1\u51BD\u51BC"],
      ["da40", "\u8D0E", 14, "\u8D20\u8D51\u8D52\u8D57\u8D5F\u8D65\u8D68\u8D69\u8D6A\u8D6C\u8D6E\u8D6F\u8D71\u8D72\u8D78", 8, "\u8D82\u8D83\u8D86\u8D87\u8D88\u8D89\u8D8C", 4, "\u8D92\u8D93\u8D95", 9, "\u8DA0\u8DA1"],
      ["da80", "\u8DA2\u8DA4", 12, "\u8DB2\u8DB6\u8DB7\u8DB9\u8DBB\u8DBD\u8DC0\u8DC1\u8DC2\u8DC5\u8DC7\u8DC8\u8DC9\u8DCA\u8DCD\u8DD0\u8DD2\u8DD3\u8DD4\u51C7\u5196\u51A2\u51A5\u8BA0\u8BA6\u8BA7\u8BAA\u8BB4\u8BB5\u8BB7\u8BC2\u8BC3\u8BCB\u8BCF\u8BCE\u8BD2\u8BD3\u8BD4\u8BD6\u8BD8\u8BD9\u8BDC\u8BDF\u8BE0\u8BE4\u8BE8\u8BE9\u8BEE\u8BF0\u8BF3\u8BF6\u8BF9\u8BFC\u8BFF\u8C00\u8C02\u8C04\u8C07\u8C0C\u8C0F\u8C11\u8C12\u8C14\u8C15\u8C16\u8C19\u8C1B\u8C18\u8C1D\u8C1F\u8C20\u8C21\u8C25\u8C27\u8C2A\u8C2B\u8C2E\u8C2F\u8C32\u8C33\u8C35\u8C36\u5369\u537A\u961D\u9622\u9621\u9631\u962A\u963D\u963C\u9642\u9649\u9654\u965F\u9667\u966C\u9672\u9674\u9688\u968D\u9697\u96B0\u9097\u909B\u909D\u9099\u90AC\u90A1\u90B4\u90B3\u90B6\u90BA"],
      ["db40", "\u8DD5\u8DD8\u8DD9\u8DDC\u8DE0\u8DE1\u8DE2\u8DE5\u8DE6\u8DE7\u8DE9\u8DED\u8DEE\u8DF0\u8DF1\u8DF2\u8DF4\u8DF6\u8DFC\u8DFE", 6, "\u8E06\u8E07\u8E08\u8E0B\u8E0D\u8E0E\u8E10\u8E11\u8E12\u8E13\u8E15", 7, "\u8E20\u8E21\u8E24", 4, "\u8E2B\u8E2D\u8E30\u8E32\u8E33\u8E34\u8E36\u8E37\u8E38\u8E3B\u8E3C\u8E3E"],
      ["db80", "\u8E3F\u8E43\u8E45\u8E46\u8E4C", 4, "\u8E53", 5, "\u8E5A", 11, "\u8E67\u8E68\u8E6A\u8E6B\u8E6E\u8E71\u90B8\u90B0\u90CF\u90C5\u90BE\u90D0\u90C4\u90C7\u90D3\u90E6\u90E2\u90DC\u90D7\u90DB\u90EB\u90EF\u90FE\u9104\u9122\u911E\u9123\u9131\u912F\u9139\u9143\u9146\u520D\u5942\u52A2\u52AC\u52AD\u52BE\u54FF\u52D0\u52D6\u52F0\u53DF\u71EE\u77CD\u5EF4\u51F5\u51FC\u9B2F\u53B6\u5F01\u755A\u5DEF\u574C\u57A9\u57A1\u587E\u58BC\u58C5\u58D1\u5729\u572C\u572A\u5733\u5739\u572E\u572F\u575C\u573B\u5742\u5769\u5785\u576B\u5786\u577C\u577B\u5768\u576D\u5776\u5773\u57AD\u57A4\u578C\u57B2\u57CF\u57A7\u57B4\u5793\u57A0\u57D5\u57D8\u57DA\u57D9\u57D2\u57B8\u57F4\u57EF\u57F8\u57E4\u57DD"],
      ["dc40", "\u8E73\u8E75\u8E77", 4, "\u8E7D\u8E7E\u8E80\u8E82\u8E83\u8E84\u8E86\u8E88", 6, "\u8E91\u8E92\u8E93\u8E95", 6, "\u8E9D\u8E9F", 11, "\u8EAD\u8EAE\u8EB0\u8EB1\u8EB3", 6, "\u8EBB", 7],
      ["dc80", "\u8EC3", 10, "\u8ECF", 21, "\u580B\u580D\u57FD\u57ED\u5800\u581E\u5819\u5844\u5820\u5865\u586C\u5881\u5889\u589A\u5880\u99A8\u9F19\u61FF\u8279\u827D\u827F\u828F\u828A\u82A8\u8284\u828E\u8291\u8297\u8299\u82AB\u82B8\u82BE\u82B0\u82C8\u82CA\u82E3\u8298\u82B7\u82AE\u82CB\u82CC\u82C1\u82A9\u82B4\u82A1\u82AA\u829F\u82C4\u82CE\u82A4\u82E1\u8309\u82F7\u82E4\u830F\u8307\u82DC\u82F4\u82D2\u82D8\u830C\u82FB\u82D3\u8311\u831A\u8306\u8314\u8315\u82E0\u82D5\u831C\u8351\u835B\u835C\u8308\u8392\u833C\u8334\u8331\u839B\u835E\u832F\u834F\u8347\u8343\u835F\u8340\u8317\u8360\u832D\u833A\u8333\u8366\u8365"],
      ["dd40", "\u8EE5", 62],
      ["dd80", "\u8F24", 32, "\u8368\u831B\u8369\u836C\u836A\u836D\u836E\u83B0\u8378\u83B3\u83B4\u83A0\u83AA\u8393\u839C\u8385\u837C\u83B6\u83A9\u837D\u83B8\u837B\u8398\u839E\u83A8\u83BA\u83BC\u83C1\u8401\u83E5\u83D8\u5807\u8418\u840B\u83DD\u83FD\u83D6\u841C\u8438\u8411\u8406\u83D4\u83DF\u840F\u8403\u83F8\u83F9\u83EA\u83C5\u83C0\u8426\u83F0\u83E1\u845C\u8451\u845A\u8459\u8473\u8487\u8488\u847A\u8489\u8478\u843C\u8446\u8469\u8476\u848C\u848E\u8431\u846D\u84C1\u84CD\u84D0\u84E6\u84BD\u84D3\u84CA\u84BF\u84BA\u84E0\u84A1\u84B9\u84B4\u8497\u84E5\u84E3\u850C\u750D\u8538\u84F0\u8539\u851F\u853A"],
      ["de40", "\u8F45", 32, "\u8F6A\u8F80\u8F8C\u8F92\u8F9D\u8FA0\u8FA1\u8FA2\u8FA4\u8FA5\u8FA6\u8FA7\u8FAA\u8FAC\u8FAD\u8FAE\u8FAF\u8FB2\u8FB3\u8FB4\u8FB5\u8FB7\u8FB8\u8FBA\u8FBB\u8FBC\u8FBF\u8FC0\u8FC3\u8FC6"],
      ["de80", "\u8FC9", 4, "\u8FCF\u8FD2\u8FD6\u8FD7\u8FDA\u8FE0\u8FE1\u8FE3\u8FE7\u8FEC\u8FEF\u8FF1\u8FF2\u8FF4\u8FF5\u8FF6\u8FFA\u8FFB\u8FFC\u8FFE\u8FFF\u9007\u9008\u900C\u900E\u9013\u9015\u9018\u8556\u853B\u84FF\u84FC\u8559\u8548\u8568\u8564\u855E\u857A\u77A2\u8543\u8572\u857B\u85A4\u85A8\u8587\u858F\u8579\u85AE\u859C\u8585\u85B9\u85B7\u85B0\u85D3\u85C1\u85DC\u85FF\u8627\u8605\u8629\u8616\u863C\u5EFE\u5F08\u593C\u5941\u8037\u5955\u595A\u5958\u530F\u5C22\u5C25\u5C2C\u5C34\u624C\u626A\u629F\u62BB\u62CA\u62DA\u62D7\u62EE\u6322\u62F6\u6339\u634B\u6343\u63AD\u63F6\u6371\u637A\u638E\u63B4\u636D\u63AC\u638A\u6369\u63AE\u63BC\u63F2\u63F8\u63E0\u63FF\u63C4\u63DE\u63CE\u6452\u63C6\u63BE\u6445\u6441\u640B\u641B\u6420\u640C\u6426\u6421\u645E\u6484\u646D\u6496"],
      ["df40", "\u9019\u901C\u9023\u9024\u9025\u9027", 5, "\u9030", 4, "\u9037\u9039\u903A\u903D\u903F\u9040\u9043\u9045\u9046\u9048", 4, "\u904E\u9054\u9055\u9056\u9059\u905A\u905C", 5, "\u9064\u9066\u9067\u9069\u906A\u906B\u906C\u906F", 4, "\u9076", 6, "\u907E\u9081"],
      ["df80", "\u9084\u9085\u9086\u9087\u9089\u908A\u908C", 4, "\u9092\u9094\u9096\u9098\u909A\u909C\u909E\u909F\u90A0\u90A4\u90A5\u90A7\u90A8\u90A9\u90AB\u90AD\u90B2\u90B7\u90BC\u90BD\u90BF\u90C0\u647A\u64B7\u64B8\u6499\u64BA\u64C0\u64D0\u64D7\u64E4\u64E2\u6509\u6525\u652E\u5F0B\u5FD2\u7519\u5F11\u535F\u53F1\u53FD\u53E9\u53E8\u53FB\u5412\u5416\u5406\u544B\u5452\u5453\u5454\u5456\u5443\u5421\u5457\u5459\u5423\u5432\u5482\u5494\u5477\u5471\u5464\u549A\u549B\u5484\u5476\u5466\u549D\u54D0\u54AD\u54C2\u54B4\u54D2\u54A7\u54A6\u54D3\u54D4\u5472\u54A3\u54D5\u54BB\u54BF\u54CC\u54D9\u54DA\u54DC\u54A9\u54AA\u54A4\u54DD\u54CF\u54DE\u551B\u54E7\u5520\u54FD\u5514\u54F3\u5522\u5523\u550F\u5511\u5527\u552A\u5567\u558F\u55B5\u5549\u556D\u5541\u5555\u553F\u5550\u553C"],
      ["e040", "\u90C2\u90C3\u90C6\u90C8\u90C9\u90CB\u90CC\u90CD\u90D2\u90D4\u90D5\u90D6\u90D8\u90D9\u90DA\u90DE\u90DF\u90E0\u90E3\u90E4\u90E5\u90E9\u90EA\u90EC\u90EE\u90F0\u90F1\u90F2\u90F3\u90F5\u90F6\u90F7\u90F9\u90FA\u90FB\u90FC\u90FF\u9100\u9101\u9103\u9105", 19, "\u911A\u911B\u911C"],
      ["e080", "\u911D\u911F\u9120\u9121\u9124", 10, "\u9130\u9132", 6, "\u913A", 8, "\u9144\u5537\u5556\u5575\u5576\u5577\u5533\u5530\u555C\u558B\u55D2\u5583\u55B1\u55B9\u5588\u5581\u559F\u557E\u55D6\u5591\u557B\u55DF\u55BD\u55BE\u5594\u5599\u55EA\u55F7\u55C9\u561F\u55D1\u55EB\u55EC\u55D4\u55E6\u55DD\u55C4\u55EF\u55E5\u55F2\u55F3\u55CC\u55CD\u55E8\u55F5\u55E4\u8F94\u561E\u5608\u560C\u5601\u5624\u5623\u55FE\u5600\u5627\u562D\u5658\u5639\u5657\u562C\u564D\u5662\u5659\u565C\u564C\u5654\u5686\u5664\u5671\u566B\u567B\u567C\u5685\u5693\u56AF\u56D4\u56D7\u56DD\u56E1\u56F5\u56EB\u56F9\u56FF\u5704\u570A\u5709\u571C\u5E0F\u5E19\u5E14\u5E11\u5E31\u5E3B\u5E3C"],
      ["e140", "\u9145\u9147\u9148\u9151\u9153\u9154\u9155\u9156\u9158\u9159\u915B\u915C\u915F\u9160\u9166\u9167\u9168\u916B\u916D\u9173\u917A\u917B\u917C\u9180", 4, "\u9186\u9188\u918A\u918E\u918F\u9193", 6, "\u919C", 5, "\u91A4", 5, "\u91AB\u91AC\u91B0\u91B1\u91B2\u91B3\u91B6\u91B7\u91B8\u91B9\u91BB"],
      ["e180", "\u91BC", 10, "\u91C8\u91CB\u91D0\u91D2", 9, "\u91DD", 8, "\u5E37\u5E44\u5E54\u5E5B\u5E5E\u5E61\u5C8C\u5C7A\u5C8D\u5C90\u5C96\u5C88\u5C98\u5C99\u5C91\u5C9A\u5C9C\u5CB5\u5CA2\u5CBD\u5CAC\u5CAB\u5CB1\u5CA3\u5CC1\u5CB7\u5CC4\u5CD2\u5CE4\u5CCB\u5CE5\u5D02\u5D03\u5D27\u5D26\u5D2E\u5D24\u5D1E\u5D06\u5D1B\u5D58\u5D3E\u5D34\u5D3D\u5D6C\u5D5B\u5D6F\u5D5D\u5D6B\u5D4B\u5D4A\u5D69\u5D74\u5D82\u5D99\u5D9D\u8C73\u5DB7\u5DC5\u5F73\u5F77\u5F82\u5F87\u5F89\u5F8C\u5F95\u5F99\u5F9C\u5FA8\u5FAD\u5FB5\u5FBC\u8862\u5F61\u72AD\u72B0\u72B4\u72B7\u72B8\u72C3\u72C1\u72CE\u72CD\u72D2\u72E8\u72EF\u72E9\u72F2\u72F4\u72F7\u7301\u72F3\u7303\u72FA"],
      ["e240", "\u91E6", 62],
      ["e280", "\u9225", 32, "\u72FB\u7317\u7313\u7321\u730A\u731E\u731D\u7315\u7322\u7339\u7325\u732C\u7338\u7331\u7350\u734D\u7357\u7360\u736C\u736F\u737E\u821B\u5925\u98E7\u5924\u5902\u9963\u9967", 5, "\u9974\u9977\u997D\u9980\u9984\u9987\u998A\u998D\u9990\u9991\u9993\u9994\u9995\u5E80\u5E91\u5E8B\u5E96\u5EA5\u5EA0\u5EB9\u5EB5\u5EBE\u5EB3\u8D53\u5ED2\u5ED1\u5EDB\u5EE8\u5EEA\u81BA\u5FC4\u5FC9\u5FD6\u5FCF\u6003\u5FEE\u6004\u5FE1\u5FE4\u5FFE\u6005\u6006\u5FEA\u5FED\u5FF8\u6019\u6035\u6026\u601B\u600F\u600D\u6029\u602B\u600A\u603F\u6021\u6078\u6079\u607B\u607A\u6042"],
      ["e340", "\u9246", 45, "\u9275", 16],
      ["e380", "\u9286", 7, "\u928F", 24, "\u606A\u607D\u6096\u609A\u60AD\u609D\u6083\u6092\u608C\u609B\u60EC\u60BB\u60B1\u60DD\u60D8\u60C6\u60DA\u60B4\u6120\u6126\u6115\u6123\u60F4\u6100\u610E\u612B\u614A\u6175\u61AC\u6194\u61A7\u61B7\u61D4\u61F5\u5FDD\u96B3\u95E9\u95EB\u95F1\u95F3\u95F5\u95F6\u95FC\u95FE\u9603\u9604\u9606\u9608\u960A\u960B\u960C\u960D\u960F\u9612\u9615\u9616\u9617\u9619\u961A\u4E2C\u723F\u6215\u6C35\u6C54\u6C5C\u6C4A\u6CA3\u6C85\u6C90\u6C94\u6C8C\u6C68\u6C69\u6C74\u6C76\u6C86\u6CA9\u6CD0\u6CD4\u6CAD\u6CF7\u6CF8\u6CF1\u6CD7\u6CB2\u6CE0\u6CD6\u6CFA\u6CEB\u6CEE\u6CB1\u6CD3\u6CEF\u6CFE"],
      ["e440", "\u92A8", 5, "\u92AF", 24, "\u92C9", 31],
      ["e480", "\u92E9", 32, "\u6D39\u6D27\u6D0C\u6D43\u6D48\u6D07\u6D04\u6D19\u6D0E\u6D2B\u6D4D\u6D2E\u6D35\u6D1A\u6D4F\u6D52\u6D54\u6D33\u6D91\u6D6F\u6D9E\u6DA0\u6D5E\u6D93\u6D94\u6D5C\u6D60\u6D7C\u6D63\u6E1A\u6DC7\u6DC5\u6DDE\u6E0E\u6DBF\u6DE0\u6E11\u6DE6\u6DDD\u6DD9\u6E16\u6DAB\u6E0C\u6DAE\u6E2B\u6E6E\u6E4E\u6E6B\u6EB2\u6E5F\u6E86\u6E53\u6E54\u6E32\u6E25\u6E44\u6EDF\u6EB1\u6E98\u6EE0\u6F2D\u6EE2\u6EA5\u6EA7\u6EBD\u6EBB\u6EB7\u6ED7\u6EB4\u6ECF\u6E8F\u6EC2\u6E9F\u6F62\u6F46\u6F47\u6F24\u6F15\u6EF9\u6F2F\u6F36\u6F4B\u6F74\u6F2A\u6F09\u6F29\u6F89\u6F8D\u6F8C\u6F78\u6F72\u6F7C\u6F7A\u6FD1"],
      ["e540", "\u930A", 51, "\u933F", 10],
      ["e580", "\u934A", 31, "\u936B\u6FC9\u6FA7\u6FB9\u6FB6\u6FC2\u6FE1\u6FEE\u6FDE\u6FE0\u6FEF\u701A\u7023\u701B\u7039\u7035\u704F\u705E\u5B80\u5B84\u5B95\u5B93\u5BA5\u5BB8\u752F\u9A9E\u6434\u5BE4\u5BEE\u8930\u5BF0\u8E47\u8B07\u8FB6\u8FD3\u8FD5\u8FE5\u8FEE\u8FE4\u8FE9\u8FE6\u8FF3\u8FE8\u9005\u9004\u900B\u9026\u9011\u900D\u9016\u9021\u9035\u9036\u902D\u902F\u9044\u9051\u9052\u9050\u9068\u9058\u9062\u905B\u66B9\u9074\u907D\u9082\u9088\u9083\u908B\u5F50\u5F57\u5F56\u5F58\u5C3B\u54AB\u5C50\u5C59\u5B71\u5C63\u5C66\u7FBC\u5F2A\u5F29\u5F2D\u8274\u5F3C\u9B3B\u5C6E\u5981\u5983\u598D\u59A9\u59AA\u59A3"],
      ["e640", "\u936C", 34, "\u9390", 27],
      ["e680", "\u93AC", 29, "\u93CB\u93CC\u93CD\u5997\u59CA\u59AB\u599E\u59A4\u59D2\u59B2\u59AF\u59D7\u59BE\u5A05\u5A06\u59DD\u5A08\u59E3\u59D8\u59F9\u5A0C\u5A09\u5A32\u5A34\u5A11\u5A23\u5A13\u5A40\u5A67\u5A4A\u5A55\u5A3C\u5A62\u5A75\u80EC\u5AAA\u5A9B\u5A77\u5A7A\u5ABE\u5AEB\u5AB2\u5AD2\u5AD4\u5AB8\u5AE0\u5AE3\u5AF1\u5AD6\u5AE6\u5AD8\u5ADC\u5B09\u5B17\u5B16\u5B32\u5B37\u5B40\u5C15\u5C1C\u5B5A\u5B65\u5B73\u5B51\u5B53\u5B62\u9A75\u9A77\u9A78\u9A7A\u9A7F\u9A7D\u9A80\u9A81\u9A85\u9A88\u9A8A\u9A90\u9A92\u9A93\u9A96\u9A98\u9A9B\u9A9C\u9A9D\u9A9F\u9AA0\u9AA2\u9AA3\u9AA5\u9AA7\u7E9F\u7EA1\u7EA3\u7EA5\u7EA8\u7EA9"],
      ["e740", "\u93CE", 7, "\u93D7", 54],
      ["e780", "\u940E", 32, "\u7EAD\u7EB0\u7EBE\u7EC0\u7EC1\u7EC2\u7EC9\u7ECB\u7ECC\u7ED0\u7ED4\u7ED7\u7EDB\u7EE0\u7EE1\u7EE8\u7EEB\u7EEE\u7EEF\u7EF1\u7EF2\u7F0D\u7EF6\u7EFA\u7EFB\u7EFE\u7F01\u7F02\u7F03\u7F07\u7F08\u7F0B\u7F0C\u7F0F\u7F11\u7F12\u7F17\u7F19\u7F1C\u7F1B\u7F1F\u7F21", 6, "\u7F2A\u7F2B\u7F2C\u7F2D\u7F2F", 4, "\u7F35\u5E7A\u757F\u5DDB\u753E\u9095\u738E\u7391\u73AE\u73A2\u739F\u73CF\u73C2\u73D1\u73B7\u73B3\u73C0\u73C9\u73C8\u73E5\u73D9\u987C\u740A\u73E9\u73E7\u73DE\u73BA\u73F2\u740F\u742A\u745B\u7426\u7425\u7428\u7430\u742E\u742C"],
      ["e840", "\u942F", 14, "\u943F", 43, "\u946C\u946D\u946E\u946F"],
      ["e880", "\u9470", 20, "\u9491\u9496\u9498\u94C7\u94CF\u94D3\u94D4\u94DA\u94E6\u94FB\u951C\u9520\u741B\u741A\u7441\u745C\u7457\u7455\u7459\u7477\u746D\u747E\u749C\u748E\u7480\u7481\u7487\u748B\u749E\u74A8\u74A9\u7490\u74A7\u74D2\u74BA\u97EA\u97EB\u97EC\u674C\u6753\u675E\u6748\u6769\u67A5\u6787\u676A\u6773\u6798\u67A7\u6775\u67A8\u679E\u67AD\u678B\u6777\u677C\u67F0\u6809\u67D8\u680A\u67E9\u67B0\u680C\u67D9\u67B5\u67DA\u67B3\u67DD\u6800\u67C3\u67B8\u67E2\u680E\u67C1\u67FD\u6832\u6833\u6860\u6861\u684E\u6862\u6844\u6864\u6883\u681D\u6855\u6866\u6841\u6867\u6840\u683E\u684A\u6849\u6829\u68B5\u688F\u6874\u6877\u6893\u686B\u68C2\u696E\u68FC\u691F\u6920\u68F9"],
      ["e940", "\u9527\u9533\u953D\u9543\u9548\u954B\u9555\u955A\u9560\u956E\u9574\u9575\u9577", 7, "\u9580", 42],
      ["e980", "\u95AB", 32, "\u6924\u68F0\u690B\u6901\u6957\u68E3\u6910\u6971\u6939\u6960\u6942\u695D\u6984\u696B\u6980\u6998\u6978\u6934\u69CC\u6987\u6988\u69CE\u6989\u6966\u6963\u6979\u699B\u69A7\u69BB\u69AB\u69AD\u69D4\u69B1\u69C1\u69CA\u69DF\u6995\u69E0\u698D\u69FF\u6A2F\u69ED\u6A17\u6A18\u6A65\u69F2\u6A44\u6A3E\u6AA0\u6A50\u6A5B\u6A35\u6A8E\u6A79\u6A3D\u6A28\u6A58\u6A7C\u6A91\u6A90\u6AA9\u6A97\u6AAB\u7337\u7352\u6B81\u6B82\u6B87\u6B84\u6B92\u6B93\u6B8D\u6B9A\u6B9B\u6BA1\u6BAA\u8F6B\u8F6D\u8F71\u8F72\u8F73\u8F75\u8F76\u8F78\u8F77\u8F79\u8F7A\u8F7C\u8F7E\u8F81\u8F82\u8F84\u8F87\u8F8B"],
      ["ea40", "\u95CC", 27, "\u95EC\u95FF\u9607\u9613\u9618\u961B\u961E\u9620\u9623", 6, "\u962B\u962C\u962D\u962F\u9630\u9637\u9638\u9639\u963A\u963E\u9641\u9643\u964A\u964E\u964F\u9651\u9652\u9653\u9656\u9657"],
      ["ea80", "\u9658\u9659\u965A\u965C\u965D\u965E\u9660\u9663\u9665\u9666\u966B\u966D", 4, "\u9673\u9678", 12, "\u9687\u9689\u968A\u8F8D\u8F8E\u8F8F\u8F98\u8F9A\u8ECE\u620B\u6217\u621B\u621F\u6222\u6221\u6225\u6224\u622C\u81E7\u74EF\u74F4\u74FF\u750F\u7511\u7513\u6534\u65EE\u65EF\u65F0\u660A\u6619\u6772\u6603\u6615\u6600\u7085\u66F7\u661D\u6634\u6631\u6636\u6635\u8006\u665F\u6654\u6641\u664F\u6656\u6661\u6657\u6677\u6684\u668C\u66A7\u669D\u66BE\u66DB\u66DC\u66E6\u66E9\u8D32\u8D33\u8D36\u8D3B\u8D3D\u8D40\u8D45\u8D46\u8D48\u8D49\u8D47\u8D4D\u8D55\u8D59\u89C7\u89CA\u89CB\u89CC\u89CE\u89CF\u89D0\u89D1\u726E\u729F\u725D\u7266\u726F\u727E\u727F\u7284\u728B\u728D\u728F\u7292\u6308\u6332\u63B0"],
      ["eb40", "\u968C\u968E\u9691\u9692\u9693\u9695\u9696\u969A\u969B\u969D", 9, "\u96A8", 7, "\u96B1\u96B2\u96B4\u96B5\u96B7\u96B8\u96BA\u96BB\u96BF\u96C2\u96C3\u96C8\u96CA\u96CB\u96D0\u96D1\u96D3\u96D4\u96D6", 9, "\u96E1", 6, "\u96EB"],
      ["eb80", "\u96EC\u96ED\u96EE\u96F0\u96F1\u96F2\u96F4\u96F5\u96F8\u96FA\u96FB\u96FC\u96FD\u96FF\u9702\u9703\u9705\u970A\u970B\u970C\u9710\u9711\u9712\u9714\u9715\u9717", 4, "\u971D\u971F\u9720\u643F\u64D8\u8004\u6BEA\u6BF3\u6BFD\u6BF5\u6BF9\u6C05\u6C07\u6C06\u6C0D\u6C15\u6C18\u6C19\u6C1A\u6C21\u6C29\u6C24\u6C2A\u6C32\u6535\u6555\u656B\u724D\u7252\u7256\u7230\u8662\u5216\u809F\u809C\u8093\u80BC\u670A\u80BD\u80B1\u80AB\u80AD\u80B4\u80B7\u80E7\u80E8\u80E9\u80EA\u80DB\u80C2\u80C4\u80D9\u80CD\u80D7\u6710\u80DD\u80EB\u80F1\u80F4\u80ED\u810D\u810E\u80F2\u80FC\u6715\u8112\u8C5A\u8136\u811E\u812C\u8118\u8132\u8148\u814C\u8153\u8174\u8159\u815A\u8171\u8160\u8169\u817C\u817D\u816D\u8167\u584D\u5AB5\u8188\u8182\u8191\u6ED5\u81A3\u81AA\u81CC\u6726\u81CA\u81BB"],
      ["ec40", "\u9721", 8, "\u972B\u972C\u972E\u972F\u9731\u9733", 4, "\u973A\u973B\u973C\u973D\u973F", 18, "\u9754\u9755\u9757\u9758\u975A\u975C\u975D\u975F\u9763\u9764\u9766\u9767\u9768\u976A", 7],
      ["ec80", "\u9772\u9775\u9777", 4, "\u977D", 7, "\u9786", 4, "\u978C\u978E\u978F\u9790\u9793\u9795\u9796\u9797\u9799", 4, "\u81C1\u81A6\u6B24\u6B37\u6B39\u6B43\u6B46\u6B59\u98D1\u98D2\u98D3\u98D5\u98D9\u98DA\u6BB3\u5F40\u6BC2\u89F3\u6590\u9F51\u6593\u65BC\u65C6\u65C4\u65C3\u65CC\u65CE\u65D2\u65D6\u7080\u709C\u7096\u709D\u70BB\u70C0\u70B7\u70AB\u70B1\u70E8\u70CA\u7110\u7113\u7116\u712F\u7131\u7173\u715C\u7168\u7145\u7172\u714A\u7178\u717A\u7198\u71B3\u71B5\u71A8\u71A0\u71E0\u71D4\u71E7\u71F9\u721D\u7228\u706C\u7118\u7166\u71B9\u623E\u623D\u6243\u6248\u6249\u793B\u7940\u7946\u7949\u795B\u795C\u7953\u795A\u7962\u7957\u7960\u796F\u7967\u797A\u7985\u798A\u799A\u79A7\u79B3\u5FD1\u5FD0"],
      ["ed40", "\u979E\u979F\u97A1\u97A2\u97A4", 6, "\u97AC\u97AE\u97B0\u97B1\u97B3\u97B5", 46],
      ["ed80", "\u97E4\u97E5\u97E8\u97EE", 4, "\u97F4\u97F7", 23, "\u603C\u605D\u605A\u6067\u6041\u6059\u6063\u60AB\u6106\u610D\u615D\u61A9\u619D\u61CB\u61D1\u6206\u8080\u807F\u6C93\u6CF6\u6DFC\u77F6\u77F8\u7800\u7809\u7817\u7818\u7811\u65AB\u782D\u781C\u781D\u7839\u783A\u783B\u781F\u783C\u7825\u782C\u7823\u7829\u784E\u786D\u7856\u7857\u7826\u7850\u7847\u784C\u786A\u789B\u7893\u789A\u7887\u789C\u78A1\u78A3\u78B2\u78B9\u78A5\u78D4\u78D9\u78C9\u78EC\u78F2\u7905\u78F4\u7913\u7924\u791E\u7934\u9F9B\u9EF9\u9EFB\u9EFC\u76F1\u7704\u770D\u76F9\u7707\u7708\u771A\u7722\u7719\u772D\u7726\u7735\u7738\u7750\u7751\u7747\u7743\u775A\u7768"],
      ["ee40", "\u980F", 62],
      ["ee80", "\u984E", 32, "\u7762\u7765\u777F\u778D\u777D\u7780\u778C\u7791\u779F\u77A0\u77B0\u77B5\u77BD\u753A\u7540\u754E\u754B\u7548\u755B\u7572\u7579\u7583\u7F58\u7F61\u7F5F\u8A48\u7F68\u7F74\u7F71\u7F79\u7F81\u7F7E\u76CD\u76E5\u8832\u9485\u9486\u9487\u948B\u948A\u948C\u948D\u948F\u9490\u9494\u9497\u9495\u949A\u949B\u949C\u94A3\u94A4\u94AB\u94AA\u94AD\u94AC\u94AF\u94B0\u94B2\u94B4\u94B6", 4, "\u94BC\u94BD\u94BF\u94C4\u94C8", 6, "\u94D0\u94D1\u94D2\u94D5\u94D6\u94D7\u94D9\u94D8\u94DB\u94DE\u94DF\u94E0\u94E2\u94E4\u94E5\u94E7\u94E8\u94EA"],
      ["ef40", "\u986F", 5, "\u988B\u988E\u9892\u9895\u9899\u98A3\u98A8", 37, "\u98CF\u98D0\u98D4\u98D6\u98D7\u98DB\u98DC\u98DD\u98E0", 4],
      ["ef80", "\u98E5\u98E6\u98E9", 30, "\u94E9\u94EB\u94EE\u94EF\u94F3\u94F4\u94F5\u94F7\u94F9\u94FC\u94FD\u94FF\u9503\u9502\u9506\u9507\u9509\u950A\u950D\u950E\u950F\u9512", 4, "\u9518\u951B\u951D\u951E\u951F\u9522\u952A\u952B\u9529\u952C\u9531\u9532\u9534\u9536\u9537\u9538\u953C\u953E\u953F\u9542\u9535\u9544\u9545\u9546\u9549\u954C\u954E\u954F\u9552\u9553\u9554\u9556\u9557\u9558\u9559\u955B\u955E\u955F\u955D\u9561\u9562\u9564", 8, "\u956F\u9571\u9572\u9573\u953A\u77E7\u77EC\u96C9\u79D5\u79ED\u79E3\u79EB\u7A06\u5D47\u7A03\u7A02\u7A1E\u7A14"],
      ["f040", "\u9908", 4, "\u990E\u990F\u9911", 28, "\u992F", 26],
      ["f080", "\u994A", 9, "\u9956", 12, "\u9964\u9966\u9973\u9978\u9979\u997B\u997E\u9982\u9983\u9989\u7A39\u7A37\u7A51\u9ECF\u99A5\u7A70\u7688\u768E\u7693\u7699\u76A4\u74DE\u74E0\u752C\u9E20\u9E22\u9E28", 4, "\u9E32\u9E31\u9E36\u9E38\u9E37\u9E39\u9E3A\u9E3E\u9E41\u9E42\u9E44\u9E46\u9E47\u9E48\u9E49\u9E4B\u9E4C\u9E4E\u9E51\u9E55\u9E57\u9E5A\u9E5B\u9E5C\u9E5E\u9E63\u9E66", 6, "\u9E71\u9E6D\u9E73\u7592\u7594\u7596\u75A0\u759D\u75AC\u75A3\u75B3\u75B4\u75B8\u75C4\u75B1\u75B0\u75C3\u75C2\u75D6\u75CD\u75E3\u75E8\u75E6\u75E4\u75EB\u75E7\u7603\u75F1\u75FC\u75FF\u7610\u7600\u7605\u760C\u7617\u760A\u7625\u7618\u7615\u7619"],
      ["f140", "\u998C\u998E\u999A", 10, "\u99A6\u99A7\u99A9", 47],
      ["f180", "\u99D9", 32, "\u761B\u763C\u7622\u7620\u7640\u762D\u7630\u763F\u7635\u7643\u763E\u7633\u764D\u765E\u7654\u765C\u7656\u766B\u766F\u7FCA\u7AE6\u7A78\u7A79\u7A80\u7A86\u7A88\u7A95\u7AA6\u7AA0\u7AAC\u7AA8\u7AAD\u7AB3\u8864\u8869\u8872\u887D\u887F\u8882\u88A2\u88C6\u88B7\u88BC\u88C9\u88E2\u88CE\u88E3\u88E5\u88F1\u891A\u88FC\u88E8\u88FE\u88F0\u8921\u8919\u8913\u891B\u890A\u8934\u892B\u8936\u8941\u8966\u897B\u758B\u80E5\u76B2\u76B4\u77DC\u8012\u8014\u8016\u801C\u8020\u8022\u8025\u8026\u8027\u8029\u8028\u8031\u800B\u8035\u8043\u8046\u804D\u8052\u8069\u8071\u8983\u9878\u9880\u9883"],
      ["f240", "\u99FA", 62],
      ["f280", "\u9A39", 32, "\u9889\u988C\u988D\u988F\u9894\u989A\u989B\u989E\u989F\u98A1\u98A2\u98A5\u98A6\u864D\u8654\u866C\u866E\u867F\u867A\u867C\u867B\u86A8\u868D\u868B\u86AC\u869D\u86A7\u86A3\u86AA\u8693\u86A9\u86B6\u86C4\u86B5\u86CE\u86B0\u86BA\u86B1\u86AF\u86C9\u86CF\u86B4\u86E9\u86F1\u86F2\u86ED\u86F3\u86D0\u8713\u86DE\u86F4\u86DF\u86D8\u86D1\u8703\u8707\u86F8\u8708\u870A\u870D\u8709\u8723\u873B\u871E\u8725\u872E\u871A\u873E\u8748\u8734\u8731\u8729\u8737\u873F\u8782\u8722\u877D\u877E\u877B\u8760\u8770\u874C\u876E\u878B\u8753\u8763\u877C\u8764\u8759\u8765\u8793\u87AF\u87A8\u87D2"],
      ["f340", "\u9A5A", 17, "\u9A72\u9A83\u9A89\u9A8D\u9A8E\u9A94\u9A95\u9A99\u9AA6\u9AA9", 6, "\u9AB2\u9AB3\u9AB4\u9AB5\u9AB9\u9ABB\u9ABD\u9ABE\u9ABF\u9AC3\u9AC4\u9AC6", 4, "\u9ACD\u9ACE\u9ACF\u9AD0\u9AD2\u9AD4\u9AD5\u9AD6\u9AD7\u9AD9\u9ADA\u9ADB\u9ADC"],
      ["f380", "\u9ADD\u9ADE\u9AE0\u9AE2\u9AE3\u9AE4\u9AE5\u9AE7\u9AE8\u9AE9\u9AEA\u9AEC\u9AEE\u9AF0", 8, "\u9AFA\u9AFC", 6, "\u9B04\u9B05\u9B06\u87C6\u8788\u8785\u87AD\u8797\u8783\u87AB\u87E5\u87AC\u87B5\u87B3\u87CB\u87D3\u87BD\u87D1\u87C0\u87CA\u87DB\u87EA\u87E0\u87EE\u8816\u8813\u87FE\u880A\u881B\u8821\u8839\u883C\u7F36\u7F42\u7F44\u7F45\u8210\u7AFA\u7AFD\u7B08\u7B03\u7B04\u7B15\u7B0A\u7B2B\u7B0F\u7B47\u7B38\u7B2A\u7B19\u7B2E\u7B31\u7B20\u7B25\u7B24\u7B33\u7B3E\u7B1E\u7B58\u7B5A\u7B45\u7B75\u7B4C\u7B5D\u7B60\u7B6E\u7B7B\u7B62\u7B72\u7B71\u7B90\u7BA6\u7BA7\u7BB8\u7BAC\u7B9D\u7BA8\u7B85\u7BAA\u7B9C\u7BA2\u7BAB\u7BB4\u7BD1\u7BC1\u7BCC\u7BDD\u7BDA\u7BE5\u7BE6\u7BEA\u7C0C\u7BFE\u7BFC\u7C0F\u7C16\u7C0B"],
      ["f440", "\u9B07\u9B09", 5, "\u9B10\u9B11\u9B12\u9B14", 10, "\u9B20\u9B21\u9B22\u9B24", 10, "\u9B30\u9B31\u9B33", 7, "\u9B3D\u9B3E\u9B3F\u9B40\u9B46\u9B4A\u9B4B\u9B4C\u9B4E\u9B50\u9B52\u9B53\u9B55", 5],
      ["f480", "\u9B5B", 32, "\u7C1F\u7C2A\u7C26\u7C38\u7C41\u7C40\u81FE\u8201\u8202\u8204\u81EC\u8844\u8221\u8222\u8223\u822D\u822F\u8228\u822B\u8238\u823B\u8233\u8234\u823E\u8244\u8249\u824B\u824F\u825A\u825F\u8268\u887E\u8885\u8888\u88D8\u88DF\u895E\u7F9D\u7F9F\u7FA7\u7FAF\u7FB0\u7FB2\u7C7C\u6549\u7C91\u7C9D\u7C9C\u7C9E\u7CA2\u7CB2\u7CBC\u7CBD\u7CC1\u7CC7\u7CCC\u7CCD\u7CC8\u7CC5\u7CD7\u7CE8\u826E\u66A8\u7FBF\u7FCE\u7FD5\u7FE5\u7FE1\u7FE6\u7FE9\u7FEE\u7FF3\u7CF8\u7D77\u7DA6\u7DAE\u7E47\u7E9B\u9EB8\u9EB4\u8D73\u8D84\u8D94\u8D91\u8DB1\u8D67\u8D6D\u8C47\u8C49\u914A\u9150\u914E\u914F\u9164"],
      ["f540", "\u9B7C", 62],
      ["f580", "\u9BBB", 32, "\u9162\u9161\u9170\u9169\u916F\u917D\u917E\u9172\u9174\u9179\u918C\u9185\u9190\u918D\u9191\u91A2\u91A3\u91AA\u91AD\u91AE\u91AF\u91B5\u91B4\u91BA\u8C55\u9E7E\u8DB8\u8DEB\u8E05\u8E59\u8E69\u8DB5\u8DBF\u8DBC\u8DBA\u8DC4\u8DD6\u8DD7\u8DDA\u8DDE\u8DCE\u8DCF\u8DDB\u8DC6\u8DEC\u8DF7\u8DF8\u8DE3\u8DF9\u8DFB\u8DE4\u8E09\u8DFD\u8E14\u8E1D\u8E1F\u8E2C\u8E2E\u8E23\u8E2F\u8E3A\u8E40\u8E39\u8E35\u8E3D\u8E31\u8E49\u8E41\u8E42\u8E51\u8E52\u8E4A\u8E70\u8E76\u8E7C\u8E6F\u8E74\u8E85\u8E8F\u8E94\u8E90\u8E9C\u8E9E\u8C78\u8C82\u8C8A\u8C85\u8C98\u8C94\u659B\u89D6\u89DE\u89DA\u89DC"],
      ["f640", "\u9BDC", 62],
      ["f680", "\u9C1B", 32, "\u89E5\u89EB\u89EF\u8A3E\u8B26\u9753\u96E9\u96F3\u96EF\u9706\u9701\u9708\u970F\u970E\u972A\u972D\u9730\u973E\u9F80\u9F83\u9F85", 5, "\u9F8C\u9EFE\u9F0B\u9F0D\u96B9\u96BC\u96BD\u96CE\u96D2\u77BF\u96E0\u928E\u92AE\u92C8\u933E\u936A\u93CA\u938F\u943E\u946B\u9C7F\u9C82\u9C85\u9C86\u9C87\u9C88\u7A23\u9C8B\u9C8E\u9C90\u9C91\u9C92\u9C94\u9C95\u9C9A\u9C9B\u9C9E", 5, "\u9CA5", 4, "\u9CAB\u9CAD\u9CAE\u9CB0", 7, "\u9CBA\u9CBB\u9CBC\u9CBD\u9CC4\u9CC5\u9CC6\u9CC7\u9CCA\u9CCB"],
      ["f740", "\u9C3C", 62],
      ["f780", "\u9C7B\u9C7D\u9C7E\u9C80\u9C83\u9C84\u9C89\u9C8A\u9C8C\u9C8F\u9C93\u9C96\u9C97\u9C98\u9C99\u9C9D\u9CAA\u9CAC\u9CAF\u9CB9\u9CBE", 4, "\u9CC8\u9CC9\u9CD1\u9CD2\u9CDA\u9CDB\u9CE0\u9CE1\u9CCC", 4, "\u9CD3\u9CD4\u9CD5\u9CD7\u9CD8\u9CD9\u9CDC\u9CDD\u9CDF\u9CE2\u977C\u9785\u9791\u9792\u9794\u97AF\u97AB\u97A3\u97B2\u97B4\u9AB1\u9AB0\u9AB7\u9E58\u9AB6\u9ABA\u9ABC\u9AC1\u9AC0\u9AC5\u9AC2\u9ACB\u9ACC\u9AD1\u9B45\u9B43\u9B47\u9B49\u9B48\u9B4D\u9B51\u98E8\u990D\u992E\u9955\u9954\u9ADF\u9AE1\u9AE6\u9AEF\u9AEB\u9AFB\u9AED\u9AF9\u9B08\u9B0F\u9B13\u9B1F\u9B23\u9EBD\u9EBE\u7E3B\u9E82\u9E87\u9E88\u9E8B\u9E92\u93D6\u9E9D\u9E9F\u9EDB\u9EDC\u9EDD\u9EE0\u9EDF\u9EE2\u9EE9\u9EE7\u9EE5\u9EEA\u9EEF\u9F22\u9F2C\u9F2F\u9F39\u9F37\u9F3D\u9F3E\u9F44"],
      ["f840", "\u9CE3", 62],
      ["f880", "\u9D22", 32],
      ["f940", "\u9D43", 62],
      ["f980", "\u9D82", 32],
      ["fa40", "\u9DA3", 62],
      ["fa80", "\u9DE2", 32],
      ["fb40", "\u9E03", 27, "\u9E24\u9E27\u9E2E\u9E30\u9E34\u9E3B\u9E3C\u9E40\u9E4D\u9E50\u9E52\u9E53\u9E54\u9E56\u9E59\u9E5D\u9E5F\u9E60\u9E61\u9E62\u9E65\u9E6E\u9E6F\u9E72\u9E74", 9, "\u9E80"],
      ["fb80", "\u9E81\u9E83\u9E84\u9E85\u9E86\u9E89\u9E8A\u9E8C", 5, "\u9E94", 8, "\u9E9E\u9EA0", 5, "\u9EA7\u9EA8\u9EA9\u9EAA"],
      ["fc40", "\u9EAB", 8, "\u9EB5\u9EB6\u9EB7\u9EB9\u9EBA\u9EBC\u9EBF", 4, "\u9EC5\u9EC6\u9EC7\u9EC8\u9ECA\u9ECB\u9ECC\u9ED0\u9ED2\u9ED3\u9ED5\u9ED6\u9ED7\u9ED9\u9EDA\u9EDE\u9EE1\u9EE3\u9EE4\u9EE6\u9EE8\u9EEB\u9EEC\u9EED\u9EEE\u9EF0", 8, "\u9EFA\u9EFD\u9EFF", 6],
      ["fc80", "\u9F06", 4, "\u9F0C\u9F0F\u9F11\u9F12\u9F14\u9F15\u9F16\u9F18\u9F1A", 5, "\u9F21\u9F23", 8, "\u9F2D\u9F2E\u9F30\u9F31"],
      ["fd40", "\u9F32", 4, "\u9F38\u9F3A\u9F3C\u9F3F", 4, "\u9F45", 10, "\u9F52", 38],
      ["fd80", "\u9F79", 5, "\u9F81\u9F82\u9F8D", 11, "\u9F9C\u9F9D\u9F9E\u9FA1", 4, "\uF92C\uF979\uF995\uF9E7\uF9F1"],
      ["fe40", "\uFA0C\uFA0D\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA18\uFA1F\uFA20\uFA21\uFA23\uFA24\uFA27\uFA28\uFA29"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports2, module2) {
    module2.exports = [
      ["a140", "\uE4C6", 62],
      ["a180", "\uE505", 32],
      ["a240", "\uE526", 62],
      ["a280", "\uE565", 32],
      ["a2ab", "\uE766", 5],
      ["a2e3", "\u20AC\uE76D"],
      ["a2ef", "\uE76E\uE76F"],
      ["a2fd", "\uE770\uE771"],
      ["a340", "\uE586", 62],
      ["a380", "\uE5C5", 31, "\u3000"],
      ["a440", "\uE5E6", 62],
      ["a480", "\uE625", 32],
      ["a4f4", "\uE772", 10],
      ["a540", "\uE646", 62],
      ["a580", "\uE685", 32],
      ["a5f7", "\uE77D", 7],
      ["a640", "\uE6A6", 62],
      ["a680", "\uE6E5", 32],
      ["a6b9", "\uE785", 7],
      ["a6d9", "\uE78D", 6],
      ["a6ec", "\uE794\uE795"],
      ["a6f3", "\uE796"],
      ["a6f6", "\uE797", 8],
      ["a740", "\uE706", 62],
      ["a780", "\uE745", 32],
      ["a7c2", "\uE7A0", 14],
      ["a7f2", "\uE7AF", 12],
      ["a896", "\uE7BC", 10],
      ["a8bc", "\u1E3F"],
      ["a8bf", "\u01F9"],
      ["a8c1", "\uE7C9\uE7CA\uE7CB\uE7CC"],
      ["a8ea", "\uE7CD", 20],
      ["a958", "\uE7E2"],
      ["a95b", "\uE7E3"],
      ["a95d", "\uE7E4\uE7E5\uE7E6"],
      ["a989", "\u303E\u2FF0", 11],
      ["a997", "\uE7F4", 12],
      ["a9f0", "\uE801", 14],
      ["aaa1", "\uE000", 93],
      ["aba1", "\uE05E", 93],
      ["aca1", "\uE0BC", 93],
      ["ada1", "\uE11A", 93],
      ["aea1", "\uE178", 93],
      ["afa1", "\uE1D6", 93],
      ["d7fa", "\uE810", 4],
      ["f8a1", "\uE234", 93],
      ["f9a1", "\uE292", 93],
      ["faa1", "\uE2F0", 93],
      ["fba1", "\uE34E", 93],
      ["fca1", "\uE3AC", 93],
      ["fda1", "\uE40A", 93],
      ["fe50", "\u2E81\uE816\uE817\uE818\u2E84\u3473\u3447\u2E88\u2E8B\uE81E\u359E\u361A\u360E\u2E8C\u2E97\u396E\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843"],
      ["fe80", "\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13", 6, "\u4DAE\uE864\uE468", 93],
      ["8135f437", "\uE7C7"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports2, module2) {
    module2.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp949.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8141", "\uAC02\uAC03\uAC05\uAC06\uAC0B", 4, "\uAC18\uAC1E\uAC1F\uAC21\uAC22\uAC23\uAC25", 6, "\uAC2E\uAC32\uAC33\uAC34"],
      ["8161", "\uAC35\uAC36\uAC37\uAC3A\uAC3B\uAC3D\uAC3E\uAC3F\uAC41", 9, "\uAC4C\uAC4E", 5, "\uAC55"],
      ["8181", "\uAC56\uAC57\uAC59\uAC5A\uAC5B\uAC5D", 18, "\uAC72\uAC73\uAC75\uAC76\uAC79\uAC7B", 4, "\uAC82\uAC87\uAC88\uAC8D\uAC8E\uAC8F\uAC91\uAC92\uAC93\uAC95", 6, "\uAC9E\uACA2", 5, "\uACAB\uACAD\uACAE\uACB1", 6, "\uACBA\uACBE\uACBF\uACC0\uACC2\uACC3\uACC5\uACC6\uACC7\uACC9\uACCA\uACCB\uACCD", 7, "\uACD6\uACD8", 7, "\uACE2\uACE3\uACE5\uACE6\uACE9\uACEB\uACED\uACEE\uACF2\uACF4\uACF7", 4, "\uACFE\uACFF\uAD01\uAD02\uAD03\uAD05\uAD07", 4, "\uAD0E\uAD10\uAD12\uAD13"],
      ["8241", "\uAD14\uAD15\uAD16\uAD17\uAD19\uAD1A\uAD1B\uAD1D\uAD1E\uAD1F\uAD21", 7, "\uAD2A\uAD2B\uAD2E", 5],
      ["8261", "\uAD36\uAD37\uAD39\uAD3A\uAD3B\uAD3D", 6, "\uAD46\uAD48\uAD4A", 5, "\uAD51\uAD52\uAD53\uAD55\uAD56\uAD57"],
      ["8281", "\uAD59", 7, "\uAD62\uAD64", 7, "\uAD6E\uAD6F\uAD71\uAD72\uAD77\uAD78\uAD79\uAD7A\uAD7E\uAD80\uAD83", 4, "\uAD8A\uAD8B\uAD8D\uAD8E\uAD8F\uAD91", 10, "\uAD9E", 5, "\uADA5", 17, "\uADB8", 7, "\uADC2\uADC3\uADC5\uADC6\uADC7\uADC9", 6, "\uADD2\uADD4", 7, "\uADDD\uADDE\uADDF\uADE1\uADE2\uADE3\uADE5", 18],
      ["8341", "\uADFA\uADFB\uADFD\uADFE\uAE02", 5, "\uAE0A\uAE0C\uAE0E", 5, "\uAE15", 7],
      ["8361", "\uAE1D", 18, "\uAE32\uAE33\uAE35\uAE36\uAE39\uAE3B\uAE3C"],
      ["8381", "\uAE3D\uAE3E\uAE3F\uAE42\uAE44\uAE47\uAE48\uAE49\uAE4B\uAE4F\uAE51\uAE52\uAE53\uAE55\uAE57", 4, "\uAE5E\uAE62\uAE63\uAE64\uAE66\uAE67\uAE6A\uAE6B\uAE6D\uAE6E\uAE6F\uAE71", 6, "\uAE7A\uAE7E", 5, "\uAE86", 5, "\uAE8D", 46, "\uAEBF\uAEC1\uAEC2\uAEC3\uAEC5", 6, "\uAECE\uAED2", 5, "\uAEDA\uAEDB\uAEDD", 8],
      ["8441", "\uAEE6\uAEE7\uAEE9\uAEEA\uAEEC\uAEEE", 5, "\uAEF5\uAEF6\uAEF7\uAEF9\uAEFA\uAEFB\uAEFD", 8],
      ["8461", "\uAF06\uAF09\uAF0A\uAF0B\uAF0C\uAF0E\uAF0F\uAF11", 18],
      ["8481", "\uAF24", 7, "\uAF2E\uAF2F\uAF31\uAF33\uAF35", 6, "\uAF3E\uAF40\uAF44\uAF45\uAF46\uAF47\uAF4A", 5, "\uAF51", 10, "\uAF5E", 5, "\uAF66", 18, "\uAF7A", 5, "\uAF81\uAF82\uAF83\uAF85\uAF86\uAF87\uAF89", 6, "\uAF92\uAF93\uAF94\uAF96", 5, "\uAF9D", 26, "\uAFBA\uAFBB\uAFBD\uAFBE"],
      ["8541", "\uAFBF\uAFC1", 5, "\uAFCA\uAFCC\uAFCF", 4, "\uAFD5", 6, "\uAFDD", 4],
      ["8561", "\uAFE2", 5, "\uAFEA", 5, "\uAFF2\uAFF3\uAFF5\uAFF6\uAFF7\uAFF9", 6, "\uB002\uB003"],
      ["8581", "\uB005", 6, "\uB00D\uB00E\uB00F\uB011\uB012\uB013\uB015", 6, "\uB01E", 9, "\uB029", 26, "\uB046\uB047\uB049\uB04B\uB04D\uB04F\uB050\uB051\uB052\uB056\uB058\uB05A\uB05B\uB05C\uB05E", 29, "\uB07E\uB07F\uB081\uB082\uB083\uB085", 6, "\uB08E\uB090\uB092", 5, "\uB09B\uB09D\uB09E\uB0A3\uB0A4"],
      ["8641", "\uB0A5\uB0A6\uB0A7\uB0AA\uB0B0\uB0B2\uB0B6\uB0B7\uB0B9\uB0BA\uB0BB\uB0BD", 6, "\uB0C6\uB0CA", 5, "\uB0D2"],
      ["8661", "\uB0D3\uB0D5\uB0D6\uB0D7\uB0D9", 6, "\uB0E1\uB0E2\uB0E3\uB0E4\uB0E6", 10],
      ["8681", "\uB0F1", 22, "\uB10A\uB10D\uB10E\uB10F\uB111\uB114\uB115\uB116\uB117\uB11A\uB11E", 4, "\uB126\uB127\uB129\uB12A\uB12B\uB12D", 6, "\uB136\uB13A", 5, "\uB142\uB143\uB145\uB146\uB147\uB149", 6, "\uB152\uB153\uB156\uB157\uB159\uB15A\uB15B\uB15D\uB15E\uB15F\uB161", 22, "\uB17A\uB17B\uB17D\uB17E\uB17F\uB181\uB183", 4, "\uB18A\uB18C\uB18E\uB18F\uB190\uB191\uB195\uB196\uB197\uB199\uB19A\uB19B\uB19D"],
      ["8741", "\uB19E", 9, "\uB1A9", 15],
      ["8761", "\uB1B9", 18, "\uB1CD\uB1CE\uB1CF\uB1D1\uB1D2\uB1D3\uB1D5"],
      ["8781", "\uB1D6", 5, "\uB1DE\uB1E0", 7, "\uB1EA\uB1EB\uB1ED\uB1EE\uB1EF\uB1F1", 7, "\uB1FA\uB1FC\uB1FE", 5, "\uB206\uB207\uB209\uB20A\uB20D", 6, "\uB216\uB218\uB21A", 5, "\uB221", 18, "\uB235", 6, "\uB23D", 26, "\uB259\uB25A\uB25B\uB25D\uB25E\uB25F\uB261", 6, "\uB26A", 4],
      ["8841", "\uB26F", 4, "\uB276", 5, "\uB27D", 6, "\uB286\uB287\uB288\uB28A", 4],
      ["8861", "\uB28F\uB292\uB293\uB295\uB296\uB297\uB29B", 4, "\uB2A2\uB2A4\uB2A7\uB2A8\uB2A9\uB2AB\uB2AD\uB2AE\uB2AF\uB2B1\uB2B2\uB2B3\uB2B5\uB2B6\uB2B7"],
      ["8881", "\uB2B8", 15, "\uB2CA\uB2CB\uB2CD\uB2CE\uB2CF\uB2D1\uB2D3", 4, "\uB2DA\uB2DC\uB2DE\uB2DF\uB2E0\uB2E1\uB2E3\uB2E7\uB2E9\uB2EA\uB2F0\uB2F1\uB2F2\uB2F6\uB2FC\uB2FD\uB2FE\uB302\uB303\uB305\uB306\uB307\uB309", 6, "\uB312\uB316", 5, "\uB31D", 54, "\uB357\uB359\uB35A\uB35D\uB360\uB361\uB362\uB363"],
      ["8941", "\uB366\uB368\uB36A\uB36C\uB36D\uB36F\uB372\uB373\uB375\uB376\uB377\uB379", 6, "\uB382\uB386", 5, "\uB38D"],
      ["8961", "\uB38E\uB38F\uB391\uB392\uB393\uB395", 10, "\uB3A2", 5, "\uB3A9\uB3AA\uB3AB\uB3AD"],
      ["8981", "\uB3AE", 21, "\uB3C6\uB3C7\uB3C9\uB3CA\uB3CD\uB3CF\uB3D1\uB3D2\uB3D3\uB3D6\uB3D8\uB3DA\uB3DC\uB3DE\uB3DF\uB3E1\uB3E2\uB3E3\uB3E5\uB3E6\uB3E7\uB3E9", 18, "\uB3FD", 18, "\uB411", 6, "\uB419\uB41A\uB41B\uB41D\uB41E\uB41F\uB421", 6, "\uB42A\uB42C", 7, "\uB435", 15],
      ["8a41", "\uB445", 10, "\uB452\uB453\uB455\uB456\uB457\uB459", 6, "\uB462\uB464\uB466"],
      ["8a61", "\uB467", 4, "\uB46D", 18, "\uB481\uB482"],
      ["8a81", "\uB483", 4, "\uB489", 19, "\uB49E", 5, "\uB4A5\uB4A6\uB4A7\uB4A9\uB4AA\uB4AB\uB4AD", 7, "\uB4B6\uB4B8\uB4BA", 5, "\uB4C1\uB4C2\uB4C3\uB4C5\uB4C6\uB4C7\uB4C9", 6, "\uB4D1\uB4D2\uB4D3\uB4D4\uB4D6", 5, "\uB4DE\uB4DF\uB4E1\uB4E2\uB4E5\uB4E7", 4, "\uB4EE\uB4F0\uB4F2", 5, "\uB4F9", 26, "\uB516\uB517\uB519\uB51A\uB51D"],
      ["8b41", "\uB51E", 5, "\uB526\uB52B", 4, "\uB532\uB533\uB535\uB536\uB537\uB539", 6, "\uB542\uB546"],
      ["8b61", "\uB547\uB548\uB549\uB54A\uB54E\uB54F\uB551\uB552\uB553\uB555", 6, "\uB55E\uB562", 8],
      ["8b81", "\uB56B", 52, "\uB5A2\uB5A3\uB5A5\uB5A6\uB5A7\uB5A9\uB5AC\uB5AD\uB5AE\uB5AF\uB5B2\uB5B6", 4, "\uB5BE\uB5BF\uB5C1\uB5C2\uB5C3\uB5C5", 6, "\uB5CE\uB5D2", 5, "\uB5D9", 18, "\uB5ED", 18],
      ["8c41", "\uB600", 15, "\uB612\uB613\uB615\uB616\uB617\uB619", 4],
      ["8c61", "\uB61E", 6, "\uB626", 5, "\uB62D", 6, "\uB635", 5],
      ["8c81", "\uB63B", 12, "\uB649", 26, "\uB665\uB666\uB667\uB669", 50, "\uB69E\uB69F\uB6A1\uB6A2\uB6A3\uB6A5", 5, "\uB6AD\uB6AE\uB6AF\uB6B0\uB6B2", 16],
      ["8d41", "\uB6C3", 16, "\uB6D5", 8],
      ["8d61", "\uB6DE", 17, "\uB6F1\uB6F2\uB6F3\uB6F5\uB6F6\uB6F7\uB6F9\uB6FA"],
      ["8d81", "\uB6FB", 4, "\uB702\uB703\uB704\uB706", 33, "\uB72A\uB72B\uB72D\uB72E\uB731", 6, "\uB73A\uB73C", 7, "\uB745\uB746\uB747\uB749\uB74A\uB74B\uB74D", 6, "\uB756", 9, "\uB761\uB762\uB763\uB765\uB766\uB767\uB769", 6, "\uB772\uB774\uB776", 5, "\uB77E\uB77F\uB781\uB782\uB783\uB785", 6, "\uB78E\uB793\uB794\uB795\uB79A\uB79B\uB79D\uB79E"],
      ["8e41", "\uB79F\uB7A1", 6, "\uB7AA\uB7AE", 5, "\uB7B6\uB7B7\uB7B9", 8],
      ["8e61", "\uB7C2", 4, "\uB7C8\uB7CA", 19],
      ["8e81", "\uB7DE", 13, "\uB7EE\uB7EF\uB7F1\uB7F2\uB7F3\uB7F5", 6, "\uB7FE\uB802", 4, "\uB80A\uB80B\uB80D\uB80E\uB80F\uB811", 6, "\uB81A\uB81C\uB81E", 5, "\uB826\uB827\uB829\uB82A\uB82B\uB82D", 6, "\uB836\uB83A", 5, "\uB841\uB842\uB843\uB845", 11, "\uB852\uB854", 7, "\uB85E\uB85F\uB861\uB862\uB863\uB865", 6, "\uB86E\uB870\uB872", 5, "\uB879\uB87A\uB87B\uB87D", 7],
      ["8f41", "\uB885", 7, "\uB88E", 17],
      ["8f61", "\uB8A0", 7, "\uB8A9", 6, "\uB8B1\uB8B2\uB8B3\uB8B5\uB8B6\uB8B7\uB8B9", 4],
      ["8f81", "\uB8BE\uB8BF\uB8C2\uB8C4\uB8C6", 5, "\uB8CD\uB8CE\uB8CF\uB8D1\uB8D2\uB8D3\uB8D5", 7, "\uB8DE\uB8E0\uB8E2", 5, "\uB8EA\uB8EB\uB8ED\uB8EE\uB8EF\uB8F1", 6, "\uB8FA\uB8FC\uB8FE", 5, "\uB905", 18, "\uB919", 6, "\uB921", 26, "\uB93E\uB93F\uB941\uB942\uB943\uB945", 6, "\uB94D\uB94E\uB950\uB952", 5],
      ["9041", "\uB95A\uB95B\uB95D\uB95E\uB95F\uB961", 6, "\uB96A\uB96C\uB96E", 5, "\uB976\uB977\uB979\uB97A\uB97B\uB97D"],
      ["9061", "\uB97E", 5, "\uB986\uB988\uB98B\uB98C\uB98F", 15],
      ["9081", "\uB99F", 12, "\uB9AE\uB9AF\uB9B1\uB9B2\uB9B3\uB9B5", 6, "\uB9BE\uB9C0\uB9C2", 5, "\uB9CA\uB9CB\uB9CD\uB9D3", 4, "\uB9DA\uB9DC\uB9DF\uB9E0\uB9E2\uB9E6\uB9E7\uB9E9\uB9EA\uB9EB\uB9ED", 6, "\uB9F6\uB9FB", 4, "\uBA02", 5, "\uBA09", 11, "\uBA16", 33, "\uBA3A\uBA3B\uBA3D\uBA3E\uBA3F\uBA41\uBA43\uBA44\uBA45\uBA46"],
      ["9141", "\uBA47\uBA4A\uBA4C\uBA4F\uBA50\uBA51\uBA52\uBA56\uBA57\uBA59\uBA5A\uBA5B\uBA5D", 6, "\uBA66\uBA6A", 5],
      ["9161", "\uBA72\uBA73\uBA75\uBA76\uBA77\uBA79", 9, "\uBA86\uBA88\uBA89\uBA8A\uBA8B\uBA8D", 5],
      ["9181", "\uBA93", 20, "\uBAAA\uBAAD\uBAAE\uBAAF\uBAB1\uBAB3", 4, "\uBABA\uBABC\uBABE", 5, "\uBAC5\uBAC6\uBAC7\uBAC9", 14, "\uBADA", 33, "\uBAFD\uBAFE\uBAFF\uBB01\uBB02\uBB03\uBB05", 7, "\uBB0E\uBB10\uBB12", 5, "\uBB19\uBB1A\uBB1B\uBB1D\uBB1E\uBB1F\uBB21", 6],
      ["9241", "\uBB28\uBB2A\uBB2C", 7, "\uBB37\uBB39\uBB3A\uBB3F", 4, "\uBB46\uBB48\uBB4A\uBB4B\uBB4C\uBB4E\uBB51\uBB52"],
      ["9261", "\uBB53\uBB55\uBB56\uBB57\uBB59", 7, "\uBB62\uBB64", 7, "\uBB6D", 4],
      ["9281", "\uBB72", 21, "\uBB89\uBB8A\uBB8B\uBB8D\uBB8E\uBB8F\uBB91", 18, "\uBBA5\uBBA6\uBBA7\uBBA9\uBBAA\uBBAB\uBBAD", 6, "\uBBB5\uBBB6\uBBB8", 7, "\uBBC1\uBBC2\uBBC3\uBBC5\uBBC6\uBBC7\uBBC9", 6, "\uBBD1\uBBD2\uBBD4", 35, "\uBBFA\uBBFB\uBBFD\uBBFE\uBC01"],
      ["9341", "\uBC03", 4, "\uBC0A\uBC0E\uBC10\uBC12\uBC13\uBC19\uBC1A\uBC20\uBC21\uBC22\uBC23\uBC26\uBC28\uBC2A\uBC2B\uBC2C\uBC2E\uBC2F\uBC32\uBC33\uBC35"],
      ["9361", "\uBC36\uBC37\uBC39", 6, "\uBC42\uBC46\uBC47\uBC48\uBC4A\uBC4B\uBC4E\uBC4F\uBC51", 8],
      ["9381", "\uBC5A\uBC5B\uBC5C\uBC5E", 37, "\uBC86\uBC87\uBC89\uBC8A\uBC8D\uBC8F", 4, "\uBC96\uBC98\uBC9B", 4, "\uBCA2\uBCA3\uBCA5\uBCA6\uBCA9", 6, "\uBCB2\uBCB6", 5, "\uBCBE\uBCBF\uBCC1\uBCC2\uBCC3\uBCC5", 7, "\uBCCE\uBCD2\uBCD3\uBCD4\uBCD6\uBCD7\uBCD9\uBCDA\uBCDB\uBCDD", 22, "\uBCF7\uBCF9\uBCFA\uBCFB\uBCFD"],
      ["9441", "\uBCFE", 5, "\uBD06\uBD08\uBD0A", 5, "\uBD11\uBD12\uBD13\uBD15", 8],
      ["9461", "\uBD1E", 5, "\uBD25", 6, "\uBD2D", 12],
      ["9481", "\uBD3A", 5, "\uBD41", 6, "\uBD4A\uBD4B\uBD4D\uBD4E\uBD4F\uBD51", 6, "\uBD5A", 9, "\uBD65\uBD66\uBD67\uBD69", 22, "\uBD82\uBD83\uBD85\uBD86\uBD8B", 4, "\uBD92\uBD94\uBD96\uBD97\uBD98\uBD9B\uBD9D", 6, "\uBDA5", 10, "\uBDB1", 6, "\uBDB9", 24],
      ["9541", "\uBDD2\uBDD3\uBDD6\uBDD7\uBDD9\uBDDA\uBDDB\uBDDD", 11, "\uBDEA", 5, "\uBDF1"],
      ["9561", "\uBDF2\uBDF3\uBDF5\uBDF6\uBDF7\uBDF9", 6, "\uBE01\uBE02\uBE04\uBE06", 5, "\uBE0E\uBE0F\uBE11\uBE12\uBE13"],
      ["9581", "\uBE15", 6, "\uBE1E\uBE20", 35, "\uBE46\uBE47\uBE49\uBE4A\uBE4B\uBE4D\uBE4F", 4, "\uBE56\uBE58\uBE5C\uBE5D\uBE5E\uBE5F\uBE62\uBE63\uBE65\uBE66\uBE67\uBE69\uBE6B", 4, "\uBE72\uBE76", 4, "\uBE7E\uBE7F\uBE81\uBE82\uBE83\uBE85", 6, "\uBE8E\uBE92", 5, "\uBE9A", 13, "\uBEA9", 14],
      ["9641", "\uBEB8", 23, "\uBED2\uBED3"],
      ["9661", "\uBED5\uBED6\uBED9", 6, "\uBEE1\uBEE2\uBEE6", 5, "\uBEED", 8],
      ["9681", "\uBEF6", 10, "\uBF02", 5, "\uBF0A", 13, "\uBF1A\uBF1E", 33, "\uBF42\uBF43\uBF45\uBF46\uBF47\uBF49", 6, "\uBF52\uBF53\uBF54\uBF56", 44],
      ["9741", "\uBF83", 16, "\uBF95", 8],
      ["9761", "\uBF9E", 17, "\uBFB1", 7],
      ["9781", "\uBFB9", 11, "\uBFC6", 5, "\uBFCE\uBFCF\uBFD1\uBFD2\uBFD3\uBFD5", 6, "\uBFDD\uBFDE\uBFE0\uBFE2", 89, "\uC03D\uC03E\uC03F"],
      ["9841", "\uC040", 16, "\uC052", 5, "\uC059\uC05A\uC05B"],
      ["9861", "\uC05D\uC05E\uC05F\uC061", 6, "\uC06A", 15],
      ["9881", "\uC07A", 21, "\uC092\uC093\uC095\uC096\uC097\uC099", 6, "\uC0A2\uC0A4\uC0A6", 5, "\uC0AE\uC0B1\uC0B2\uC0B7", 4, "\uC0BE\uC0C2\uC0C3\uC0C4\uC0C6\uC0C7\uC0CA\uC0CB\uC0CD\uC0CE\uC0CF\uC0D1", 6, "\uC0DA\uC0DE", 5, "\uC0E6\uC0E7\uC0E9\uC0EA\uC0EB\uC0ED", 6, "\uC0F6\uC0F8\uC0FA", 5, "\uC101\uC102\uC103\uC105\uC106\uC107\uC109", 6, "\uC111\uC112\uC113\uC114\uC116", 5, "\uC121\uC122\uC125\uC128\uC129\uC12A\uC12B\uC12E"],
      ["9941", "\uC132\uC133\uC134\uC135\uC137\uC13A\uC13B\uC13D\uC13E\uC13F\uC141", 6, "\uC14A\uC14E", 5, "\uC156\uC157"],
      ["9961", "\uC159\uC15A\uC15B\uC15D", 6, "\uC166\uC16A", 5, "\uC171\uC172\uC173\uC175\uC176\uC177\uC179\uC17A\uC17B"],
      ["9981", "\uC17C", 8, "\uC186", 5, "\uC18F\uC191\uC192\uC193\uC195\uC197", 4, "\uC19E\uC1A0\uC1A2\uC1A3\uC1A4\uC1A6\uC1A7\uC1AA\uC1AB\uC1AD\uC1AE\uC1AF\uC1B1", 11, "\uC1BE", 5, "\uC1C5\uC1C6\uC1C7\uC1C9\uC1CA\uC1CB\uC1CD", 6, "\uC1D5\uC1D6\uC1D9", 6, "\uC1E1\uC1E2\uC1E3\uC1E5\uC1E6\uC1E7\uC1E9", 6, "\uC1F2\uC1F4", 7, "\uC1FE\uC1FF\uC201\uC202\uC203\uC205", 6, "\uC20E\uC210\uC212", 5, "\uC21A\uC21B\uC21D\uC21E\uC221\uC222\uC223"],
      ["9a41", "\uC224\uC225\uC226\uC227\uC22A\uC22C\uC22E\uC230\uC233\uC235", 16],
      ["9a61", "\uC246\uC247\uC249", 6, "\uC252\uC253\uC255\uC256\uC257\uC259", 6, "\uC261\uC262\uC263\uC264\uC266"],
      ["9a81", "\uC267", 4, "\uC26E\uC26F\uC271\uC272\uC273\uC275", 6, "\uC27E\uC280\uC282", 5, "\uC28A", 5, "\uC291", 6, "\uC299\uC29A\uC29C\uC29E", 5, "\uC2A6\uC2A7\uC2A9\uC2AA\uC2AB\uC2AE", 5, "\uC2B6\uC2B8\uC2BA", 33, "\uC2DE\uC2DF\uC2E1\uC2E2\uC2E5", 5, "\uC2EE\uC2F0\uC2F2\uC2F3\uC2F4\uC2F5\uC2F7\uC2FA\uC2FD\uC2FE\uC2FF\uC301", 6, "\uC30A\uC30B\uC30E\uC30F"],
      ["9b41", "\uC310\uC311\uC312\uC316\uC317\uC319\uC31A\uC31B\uC31D", 6, "\uC326\uC327\uC32A", 8],
      ["9b61", "\uC333", 17, "\uC346", 7],
      ["9b81", "\uC34E", 25, "\uC36A\uC36B\uC36D\uC36E\uC36F\uC371\uC373", 4, "\uC37A\uC37B\uC37E", 5, "\uC385\uC386\uC387\uC389\uC38A\uC38B\uC38D", 50, "\uC3C1", 22, "\uC3DA"],
      ["9c41", "\uC3DB\uC3DD\uC3DE\uC3E1\uC3E3", 4, "\uC3EA\uC3EB\uC3EC\uC3EE", 5, "\uC3F6\uC3F7\uC3F9", 5],
      ["9c61", "\uC3FF", 8, "\uC409", 6, "\uC411", 9],
      ["9c81", "\uC41B", 8, "\uC425", 6, "\uC42D\uC42E\uC42F\uC431\uC432\uC433\uC435", 6, "\uC43E", 9, "\uC449", 26, "\uC466\uC467\uC469\uC46A\uC46B\uC46D", 6, "\uC476\uC477\uC478\uC47A", 5, "\uC481", 18, "\uC495", 6, "\uC49D", 12],
      ["9d41", "\uC4AA", 13, "\uC4B9\uC4BA\uC4BB\uC4BD", 8],
      ["9d61", "\uC4C6", 25],
      ["9d81", "\uC4E0", 8, "\uC4EA", 5, "\uC4F2\uC4F3\uC4F5\uC4F6\uC4F7\uC4F9\uC4FB\uC4FC\uC4FD\uC4FE\uC502", 9, "\uC50D\uC50E\uC50F\uC511\uC512\uC513\uC515", 6, "\uC51D", 10, "\uC52A\uC52B\uC52D\uC52E\uC52F\uC531", 6, "\uC53A\uC53C\uC53E", 5, "\uC546\uC547\uC54B\uC54F\uC550\uC551\uC552\uC556\uC55A\uC55B\uC55C\uC55F\uC562\uC563\uC565\uC566\uC567\uC569", 6, "\uC572\uC576", 5, "\uC57E\uC57F\uC581\uC582\uC583\uC585\uC586\uC588\uC589\uC58A\uC58B\uC58E\uC590\uC592\uC593\uC594"],
      ["9e41", "\uC596\uC599\uC59A\uC59B\uC59D\uC59E\uC59F\uC5A1", 7, "\uC5AA", 9, "\uC5B6"],
      ["9e61", "\uC5B7\uC5BA\uC5BF", 4, "\uC5CB\uC5CD\uC5CF\uC5D2\uC5D3\uC5D5\uC5D6\uC5D7\uC5D9", 6, "\uC5E2\uC5E4\uC5E6\uC5E7"],
      ["9e81", "\uC5E8\uC5E9\uC5EA\uC5EB\uC5EF\uC5F1\uC5F2\uC5F3\uC5F5\uC5F8\uC5F9\uC5FA\uC5FB\uC602\uC603\uC604\uC609\uC60A\uC60B\uC60D\uC60E\uC60F\uC611", 6, "\uC61A\uC61D", 6, "\uC626\uC627\uC629\uC62A\uC62B\uC62F\uC631\uC632\uC636\uC638\uC63A\uC63C\uC63D\uC63E\uC63F\uC642\uC643\uC645\uC646\uC647\uC649", 6, "\uC652\uC656", 5, "\uC65E\uC65F\uC661", 10, "\uC66D\uC66E\uC670\uC672", 5, "\uC67A\uC67B\uC67D\uC67E\uC67F\uC681", 6, "\uC68A\uC68C\uC68E", 5, "\uC696\uC697\uC699\uC69A\uC69B\uC69D", 6, "\uC6A6"],
      ["9f41", "\uC6A8\uC6AA", 5, "\uC6B2\uC6B3\uC6B5\uC6B6\uC6B7\uC6BB", 4, "\uC6C2\uC6C4\uC6C6", 5, "\uC6CE"],
      ["9f61", "\uC6CF\uC6D1\uC6D2\uC6D3\uC6D5", 6, "\uC6DE\uC6DF\uC6E2", 5, "\uC6EA\uC6EB\uC6ED\uC6EE\uC6EF\uC6F1\uC6F2"],
      ["9f81", "\uC6F3", 4, "\uC6FA\uC6FB\uC6FC\uC6FE", 5, "\uC706\uC707\uC709\uC70A\uC70B\uC70D", 6, "\uC716\uC718\uC71A", 5, "\uC722\uC723\uC725\uC726\uC727\uC729", 6, "\uC732\uC734\uC736\uC738\uC739\uC73A\uC73B\uC73E\uC73F\uC741\uC742\uC743\uC745", 4, "\uC74B\uC74E\uC750\uC759\uC75A\uC75B\uC75D\uC75E\uC75F\uC761", 6, "\uC769\uC76A\uC76C", 7, "\uC776\uC777\uC779\uC77A\uC77B\uC77F\uC780\uC781\uC782\uC786\uC78B\uC78C\uC78D\uC78F\uC792\uC793\uC795\uC799\uC79B", 4, "\uC7A2\uC7A7", 4, "\uC7AE\uC7AF\uC7B1\uC7B2\uC7B3\uC7B5\uC7B6\uC7B7"],
      ["a041", "\uC7B8\uC7B9\uC7BA\uC7BB\uC7BE\uC7C2", 5, "\uC7CA\uC7CB\uC7CD\uC7CF\uC7D1", 6, "\uC7D9\uC7DA\uC7DB\uC7DC"],
      ["a061", "\uC7DE", 5, "\uC7E5\uC7E6\uC7E7\uC7E9\uC7EA\uC7EB\uC7ED", 13],
      ["a081", "\uC7FB", 4, "\uC802\uC803\uC805\uC806\uC807\uC809\uC80B", 4, "\uC812\uC814\uC817", 4, "\uC81E\uC81F\uC821\uC822\uC823\uC825", 6, "\uC82E\uC830\uC832", 5, "\uC839\uC83A\uC83B\uC83D\uC83E\uC83F\uC841", 6, "\uC84A\uC84B\uC84E", 5, "\uC855", 26, "\uC872\uC873\uC875\uC876\uC877\uC879\uC87B", 4, "\uC882\uC884\uC888\uC889\uC88A\uC88E", 5, "\uC895", 7, "\uC89E\uC8A0\uC8A2\uC8A3\uC8A4"],
      ["a141", "\uC8A5\uC8A6\uC8A7\uC8A9", 18, "\uC8BE\uC8BF\uC8C0\uC8C1"],
      ["a161", "\uC8C2\uC8C3\uC8C5\uC8C6\uC8C7\uC8C9\uC8CA\uC8CB\uC8CD", 6, "\uC8D6\uC8D8\uC8DA", 5, "\uC8E2\uC8E3\uC8E5"],
      ["a181", "\uC8E6", 14, "\uC8F6", 5, "\uC8FE\uC8FF\uC901\uC902\uC903\uC907", 4, "\uC90E\u3000\u3001\u3002\xB7\u2025\u2026\xA8\u3003\xAD\u2015\u2225\uFF3C\u223C\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 9, "\xB1\xD7\xF7\u2260\u2264\u2265\u221E\u2234\xB0\u2032\u2033\u2103\u212B\uFFE0\uFFE1\uFFE5\u2642\u2640\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\xA7\u203B\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u2192\u2190\u2191\u2193\u2194\u3013\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229\u2227\u2228\uFFE2"],
      ["a241", "\uC910\uC912", 5, "\uC919", 18],
      ["a261", "\uC92D", 6, "\uC935", 18],
      ["a281", "\uC948", 7, "\uC952\uC953\uC955\uC956\uC957\uC959", 6, "\uC962\uC964", 7, "\uC96D\uC96E\uC96F\u21D2\u21D4\u2200\u2203\xB4\uFF5E\u02C7\u02D8\u02DD\u02DA\u02D9\xB8\u02DB\xA1\xBF\u02D0\u222E\u2211\u220F\xA4\u2109\u2030\u25C1\u25C0\u25B7\u25B6\u2664\u2660\u2661\u2665\u2667\u2663\u2299\u25C8\u25A3\u25D0\u25D1\u2592\u25A4\u25A5\u25A8\u25A7\u25A6\u25A9\u2668\u260F\u260E\u261C\u261E\xB6\u2020\u2021\u2195\u2197\u2199\u2196\u2198\u266D\u2669\u266A\u266C\u327F\u321C\u2116\u33C7\u2122\u33C2\u33D8\u2121\u20AC\xAE"],
      ["a341", "\uC971\uC972\uC973\uC975", 6, "\uC97D", 10, "\uC98A\uC98B\uC98D\uC98E\uC98F"],
      ["a361", "\uC991", 6, "\uC99A\uC99C\uC99E", 16],
      ["a381", "\uC9AF", 16, "\uC9C2\uC9C3\uC9C5\uC9C6\uC9C9\uC9CB", 4, "\uC9D2\uC9D4\uC9D7\uC9D8\uC9DB\uFF01", 58, "\uFFE6\uFF3D", 32, "\uFFE3"],
      ["a441", "\uC9DE\uC9DF\uC9E1\uC9E3\uC9E5\uC9E6\uC9E8\uC9E9\uC9EA\uC9EB\uC9EE\uC9F2", 5, "\uC9FA\uC9FB\uC9FD\uC9FE\uC9FF\uCA01\uCA02\uCA03\uCA04"],
      ["a461", "\uCA05\uCA06\uCA07\uCA0A\uCA0E", 5, "\uCA15\uCA16\uCA17\uCA19", 12],
      ["a481", "\uCA26\uCA27\uCA28\uCA2A", 28, "\u3131", 93],
      ["a541", "\uCA47", 4, "\uCA4E\uCA4F\uCA51\uCA52\uCA53\uCA55", 6, "\uCA5E\uCA62", 5, "\uCA69\uCA6A"],
      ["a561", "\uCA6B", 17, "\uCA7E", 5, "\uCA85\uCA86"],
      ["a581", "\uCA87", 16, "\uCA99", 14, "\u2170", 9],
      ["a5b0", "\u2160", 9],
      ["a5c1", "\u0391", 16, "\u03A3", 6],
      ["a5e1", "\u03B1", 16, "\u03C3", 6],
      ["a641", "\uCAA8", 19, "\uCABE\uCABF\uCAC1\uCAC2\uCAC3\uCAC5"],
      ["a661", "\uCAC6", 5, "\uCACE\uCAD0\uCAD2\uCAD4\uCAD5\uCAD6\uCAD7\uCADA", 5, "\uCAE1", 6],
      ["a681", "\uCAE8\uCAE9\uCAEA\uCAEB\uCAED", 6, "\uCAF5", 18, "\uCB09\uCB0A\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542\u2512\u2511\u251A\u2519\u2516\u2515\u250E\u250D\u251E\u251F\u2521\u2522\u2526\u2527\u2529\u252A\u252D\u252E\u2531\u2532\u2535\u2536\u2539\u253A\u253D\u253E\u2540\u2541\u2543", 7],
      ["a741", "\uCB0B", 4, "\uCB11\uCB12\uCB13\uCB15\uCB16\uCB17\uCB19", 6, "\uCB22", 7],
      ["a761", "\uCB2A", 22, "\uCB42\uCB43\uCB44"],
      ["a781", "\uCB45\uCB46\uCB47\uCB4A\uCB4B\uCB4D\uCB4E\uCB4F\uCB51", 6, "\uCB5A\uCB5B\uCB5C\uCB5E", 5, "\uCB65", 7, "\u3395\u3396\u3397\u2113\u3398\u33C4\u33A3\u33A4\u33A5\u33A6\u3399", 9, "\u33CA\u338D\u338E\u338F\u33CF\u3388\u3389\u33C8\u33A7\u33A8\u33B0", 9, "\u3380", 4, "\u33BA", 5, "\u3390", 4, "\u2126\u33C0\u33C1\u338A\u338B\u338C\u33D6\u33C5\u33AD\u33AE\u33AF\u33DB\u33A9\u33AA\u33AB\u33AC\u33DD\u33D0\u33D3\u33C3\u33C9\u33DC\u33C6"],
      ["a841", "\uCB6D", 10, "\uCB7A", 14],
      ["a861", "\uCB89", 18, "\uCB9D", 6],
      ["a881", "\uCBA4", 19, "\uCBB9", 11, "\xC6\xD0\xAA\u0126"],
      ["a8a6", "\u0132"],
      ["a8a8", "\u013F\u0141\xD8\u0152\xBA\xDE\u0166\u014A"],
      ["a8b1", "\u3260", 27, "\u24D0", 25, "\u2460", 14, "\xBD\u2153\u2154\xBC\xBE\u215B\u215C\u215D\u215E"],
      ["a941", "\uCBC5", 14, "\uCBD5", 10],
      ["a961", "\uCBE0\uCBE1\uCBE2\uCBE3\uCBE5\uCBE6\uCBE8\uCBEA", 18],
      ["a981", "\uCBFD", 14, "\uCC0E\uCC0F\uCC11\uCC12\uCC13\uCC15", 6, "\uCC1E\uCC1F\uCC20\uCC23\uCC24\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0140\u0142\xF8\u0153\xDF\xFE\u0167\u014B\u0149\u3200", 27, "\u249C", 25, "\u2474", 14, "\xB9\xB2\xB3\u2074\u207F\u2081\u2082\u2083\u2084"],
      ["aa41", "\uCC25\uCC26\uCC2A\uCC2B\uCC2D\uCC2F\uCC31", 6, "\uCC3A\uCC3F", 4, "\uCC46\uCC47\uCC49\uCC4A\uCC4B\uCC4D\uCC4E"],
      ["aa61", "\uCC4F", 4, "\uCC56\uCC5A", 5, "\uCC61\uCC62\uCC63\uCC65\uCC67\uCC69", 6, "\uCC71\uCC72"],
      ["aa81", "\uCC73\uCC74\uCC76", 29, "\u3041", 82],
      ["ab41", "\uCC94\uCC95\uCC96\uCC97\uCC9A\uCC9B\uCC9D\uCC9E\uCC9F\uCCA1", 6, "\uCCAA\uCCAE", 5, "\uCCB6\uCCB7\uCCB9"],
      ["ab61", "\uCCBA\uCCBB\uCCBD", 6, "\uCCC6\uCCC8\uCCCA", 5, "\uCCD1\uCCD2\uCCD3\uCCD5", 5],
      ["ab81", "\uCCDB", 8, "\uCCE5", 6, "\uCCED\uCCEE\uCCEF\uCCF1", 12, "\u30A1", 85],
      ["ac41", "\uCCFE\uCCFF\uCD00\uCD02", 5, "\uCD0A\uCD0B\uCD0D\uCD0E\uCD0F\uCD11", 6, "\uCD1A\uCD1C\uCD1E\uCD1F\uCD20"],
      ["ac61", "\uCD21\uCD22\uCD23\uCD25\uCD26\uCD27\uCD29\uCD2A\uCD2B\uCD2D", 11, "\uCD3A", 4],
      ["ac81", "\uCD3F", 28, "\uCD5D\uCD5E\uCD5F\u0410", 5, "\u0401\u0416", 25],
      ["acd1", "\u0430", 5, "\u0451\u0436", 25],
      ["ad41", "\uCD61\uCD62\uCD63\uCD65", 6, "\uCD6E\uCD70\uCD72", 5, "\uCD79", 7],
      ["ad61", "\uCD81", 6, "\uCD89", 10, "\uCD96\uCD97\uCD99\uCD9A\uCD9B\uCD9D\uCD9E\uCD9F"],
      ["ad81", "\uCDA0\uCDA1\uCDA2\uCDA3\uCDA6\uCDA8\uCDAA", 5, "\uCDB1", 18, "\uCDC5"],
      ["ae41", "\uCDC6", 5, "\uCDCD\uCDCE\uCDCF\uCDD1", 16],
      ["ae61", "\uCDE2", 5, "\uCDE9\uCDEA\uCDEB\uCDED\uCDEE\uCDEF\uCDF1", 6, "\uCDFA\uCDFC\uCDFE", 4],
      ["ae81", "\uCE03\uCE05\uCE06\uCE07\uCE09\uCE0A\uCE0B\uCE0D", 6, "\uCE15\uCE16\uCE17\uCE18\uCE1A", 5, "\uCE22\uCE23\uCE25\uCE26\uCE27\uCE29\uCE2A\uCE2B"],
      ["af41", "\uCE2C\uCE2D\uCE2E\uCE2F\uCE32\uCE34\uCE36", 19],
      ["af61", "\uCE4A", 13, "\uCE5A\uCE5B\uCE5D\uCE5E\uCE62", 5, "\uCE6A\uCE6C"],
      ["af81", "\uCE6E", 5, "\uCE76\uCE77\uCE79\uCE7A\uCE7B\uCE7D", 6, "\uCE86\uCE88\uCE8A", 5, "\uCE92\uCE93\uCE95\uCE96\uCE97\uCE99"],
      ["b041", "\uCE9A", 5, "\uCEA2\uCEA6", 5, "\uCEAE", 12],
      ["b061", "\uCEBB", 5, "\uCEC2", 19],
      ["b081", "\uCED6", 13, "\uCEE6\uCEE7\uCEE9\uCEEA\uCEED", 6, "\uCEF6\uCEFA", 5, "\uAC00\uAC01\uAC04\uAC07\uAC08\uAC09\uAC0A\uAC10", 7, "\uAC19", 4, "\uAC20\uAC24\uAC2C\uAC2D\uAC2F\uAC30\uAC31\uAC38\uAC39\uAC3C\uAC40\uAC4B\uAC4D\uAC54\uAC58\uAC5C\uAC70\uAC71\uAC74\uAC77\uAC78\uAC7A\uAC80\uAC81\uAC83\uAC84\uAC85\uAC86\uAC89\uAC8A\uAC8B\uAC8C\uAC90\uAC94\uAC9C\uAC9D\uAC9F\uACA0\uACA1\uACA8\uACA9\uACAA\uACAC\uACAF\uACB0\uACB8\uACB9\uACBB\uACBC\uACBD\uACC1\uACC4\uACC8\uACCC\uACD5\uACD7\uACE0\uACE1\uACE4\uACE7\uACE8\uACEA\uACEC\uACEF\uACF0\uACF1\uACF3\uACF5\uACF6\uACFC\uACFD\uAD00\uAD04\uAD06"],
      ["b141", "\uCF02\uCF03\uCF05\uCF06\uCF07\uCF09", 6, "\uCF12\uCF14\uCF16", 5, "\uCF1D\uCF1E\uCF1F\uCF21\uCF22\uCF23"],
      ["b161", "\uCF25", 6, "\uCF2E\uCF32", 5, "\uCF39", 11],
      ["b181", "\uCF45", 14, "\uCF56\uCF57\uCF59\uCF5A\uCF5B\uCF5D", 6, "\uCF66\uCF68\uCF6A\uCF6B\uCF6C\uAD0C\uAD0D\uAD0F\uAD11\uAD18\uAD1C\uAD20\uAD29\uAD2C\uAD2D\uAD34\uAD35\uAD38\uAD3C\uAD44\uAD45\uAD47\uAD49\uAD50\uAD54\uAD58\uAD61\uAD63\uAD6C\uAD6D\uAD70\uAD73\uAD74\uAD75\uAD76\uAD7B\uAD7C\uAD7D\uAD7F\uAD81\uAD82\uAD88\uAD89\uAD8C\uAD90\uAD9C\uAD9D\uADA4\uADB7\uADC0\uADC1\uADC4\uADC8\uADD0\uADD1\uADD3\uADDC\uADE0\uADE4\uADF8\uADF9\uADFC\uADFF\uAE00\uAE01\uAE08\uAE09\uAE0B\uAE0D\uAE14\uAE30\uAE31\uAE34\uAE37\uAE38\uAE3A\uAE40\uAE41\uAE43\uAE45\uAE46\uAE4A\uAE4C\uAE4D\uAE4E\uAE50\uAE54\uAE56\uAE5C\uAE5D\uAE5F\uAE60\uAE61\uAE65\uAE68\uAE69\uAE6C\uAE70\uAE78"],
      ["b241", "\uCF6D\uCF6E\uCF6F\uCF72\uCF73\uCF75\uCF76\uCF77\uCF79", 6, "\uCF81\uCF82\uCF83\uCF84\uCF86", 5, "\uCF8D"],
      ["b261", "\uCF8E", 18, "\uCFA2", 5, "\uCFA9"],
      ["b281", "\uCFAA", 5, "\uCFB1", 18, "\uCFC5", 6, "\uAE79\uAE7B\uAE7C\uAE7D\uAE84\uAE85\uAE8C\uAEBC\uAEBD\uAEBE\uAEC0\uAEC4\uAECC\uAECD\uAECF\uAED0\uAED1\uAED8\uAED9\uAEDC\uAEE8\uAEEB\uAEED\uAEF4\uAEF8\uAEFC\uAF07\uAF08\uAF0D\uAF10\uAF2C\uAF2D\uAF30\uAF32\uAF34\uAF3C\uAF3D\uAF3F\uAF41\uAF42\uAF43\uAF48\uAF49\uAF50\uAF5C\uAF5D\uAF64\uAF65\uAF79\uAF80\uAF84\uAF88\uAF90\uAF91\uAF95\uAF9C\uAFB8\uAFB9\uAFBC\uAFC0\uAFC7\uAFC8\uAFC9\uAFCB\uAFCD\uAFCE\uAFD4\uAFDC\uAFE8\uAFE9\uAFF0\uAFF1\uAFF4\uAFF8\uB000\uB001\uB004\uB00C\uB010\uB014\uB01C\uB01D\uB028\uB044\uB045\uB048\uB04A\uB04C\uB04E\uB053\uB054\uB055\uB057\uB059"],
      ["b341", "\uCFCC", 19, "\uCFE2\uCFE3\uCFE5\uCFE6\uCFE7\uCFE9"],
      ["b361", "\uCFEA", 5, "\uCFF2\uCFF4\uCFF6", 5, "\uCFFD\uCFFE\uCFFF\uD001\uD002\uD003\uD005", 5],
      ["b381", "\uD00B", 5, "\uD012", 5, "\uD019", 19, "\uB05D\uB07C\uB07D\uB080\uB084\uB08C\uB08D\uB08F\uB091\uB098\uB099\uB09A\uB09C\uB09F\uB0A0\uB0A1\uB0A2\uB0A8\uB0A9\uB0AB", 4, "\uB0B1\uB0B3\uB0B4\uB0B5\uB0B8\uB0BC\uB0C4\uB0C5\uB0C7\uB0C8\uB0C9\uB0D0\uB0D1\uB0D4\uB0D8\uB0E0\uB0E5\uB108\uB109\uB10B\uB10C\uB110\uB112\uB113\uB118\uB119\uB11B\uB11C\uB11D\uB123\uB124\uB125\uB128\uB12C\uB134\uB135\uB137\uB138\uB139\uB140\uB141\uB144\uB148\uB150\uB151\uB154\uB155\uB158\uB15C\uB160\uB178\uB179\uB17C\uB180\uB182\uB188\uB189\uB18B\uB18D\uB192\uB193\uB194\uB198\uB19C\uB1A8\uB1CC\uB1D0\uB1D4\uB1DC\uB1DD"],
      ["b441", "\uD02E", 5, "\uD036\uD037\uD039\uD03A\uD03B\uD03D", 6, "\uD046\uD048\uD04A", 5],
      ["b461", "\uD051\uD052\uD053\uD055\uD056\uD057\uD059", 6, "\uD061", 10, "\uD06E\uD06F"],
      ["b481", "\uD071\uD072\uD073\uD075", 6, "\uD07E\uD07F\uD080\uD082", 18, "\uB1DF\uB1E8\uB1E9\uB1EC\uB1F0\uB1F9\uB1FB\uB1FD\uB204\uB205\uB208\uB20B\uB20C\uB214\uB215\uB217\uB219\uB220\uB234\uB23C\uB258\uB25C\uB260\uB268\uB269\uB274\uB275\uB27C\uB284\uB285\uB289\uB290\uB291\uB294\uB298\uB299\uB29A\uB2A0\uB2A1\uB2A3\uB2A5\uB2A6\uB2AA\uB2AC\uB2B0\uB2B4\uB2C8\uB2C9\uB2CC\uB2D0\uB2D2\uB2D8\uB2D9\uB2DB\uB2DD\uB2E2\uB2E4\uB2E5\uB2E6\uB2E8\uB2EB", 4, "\uB2F3\uB2F4\uB2F5\uB2F7", 4, "\uB2FF\uB300\uB301\uB304\uB308\uB310\uB311\uB313\uB314\uB315\uB31C\uB354\uB355\uB356\uB358\uB35B\uB35C\uB35E\uB35F\uB364\uB365"],
      ["b541", "\uD095", 14, "\uD0A6\uD0A7\uD0A9\uD0AA\uD0AB\uD0AD", 5],
      ["b561", "\uD0B3\uD0B6\uD0B8\uD0BA", 5, "\uD0C2\uD0C3\uD0C5\uD0C6\uD0C7\uD0CA", 5, "\uD0D2\uD0D6", 4],
      ["b581", "\uD0DB\uD0DE\uD0DF\uD0E1\uD0E2\uD0E3\uD0E5", 6, "\uD0EE\uD0F2", 5, "\uD0F9", 11, "\uB367\uB369\uB36B\uB36E\uB370\uB371\uB374\uB378\uB380\uB381\uB383\uB384\uB385\uB38C\uB390\uB394\uB3A0\uB3A1\uB3A8\uB3AC\uB3C4\uB3C5\uB3C8\uB3CB\uB3CC\uB3CE\uB3D0\uB3D4\uB3D5\uB3D7\uB3D9\uB3DB\uB3DD\uB3E0\uB3E4\uB3E8\uB3FC\uB410\uB418\uB41C\uB420\uB428\uB429\uB42B\uB434\uB450\uB451\uB454\uB458\uB460\uB461\uB463\uB465\uB46C\uB480\uB488\uB49D\uB4A4\uB4A8\uB4AC\uB4B5\uB4B7\uB4B9\uB4C0\uB4C4\uB4C8\uB4D0\uB4D5\uB4DC\uB4DD\uB4E0\uB4E3\uB4E4\uB4E6\uB4EC\uB4ED\uB4EF\uB4F1\uB4F8\uB514\uB515\uB518\uB51B\uB51C\uB524\uB525\uB527\uB528\uB529\uB52A\uB530\uB531\uB534\uB538"],
      ["b641", "\uD105", 7, "\uD10E", 17],
      ["b661", "\uD120", 15, "\uD132\uD133\uD135\uD136\uD137\uD139\uD13B\uD13C\uD13D\uD13E"],
      ["b681", "\uD13F\uD142\uD146", 5, "\uD14E\uD14F\uD151\uD152\uD153\uD155", 6, "\uD15E\uD160\uD162", 5, "\uD169\uD16A\uD16B\uD16D\uB540\uB541\uB543\uB544\uB545\uB54B\uB54C\uB54D\uB550\uB554\uB55C\uB55D\uB55F\uB560\uB561\uB5A0\uB5A1\uB5A4\uB5A8\uB5AA\uB5AB\uB5B0\uB5B1\uB5B3\uB5B4\uB5B5\uB5BB\uB5BC\uB5BD\uB5C0\uB5C4\uB5CC\uB5CD\uB5CF\uB5D0\uB5D1\uB5D8\uB5EC\uB610\uB611\uB614\uB618\uB625\uB62C\uB634\uB648\uB664\uB668\uB69C\uB69D\uB6A0\uB6A4\uB6AB\uB6AC\uB6B1\uB6D4\uB6F0\uB6F4\uB6F8\uB700\uB701\uB705\uB728\uB729\uB72C\uB72F\uB730\uB738\uB739\uB73B\uB744\uB748\uB74C\uB754\uB755\uB760\uB764\uB768\uB770\uB771\uB773\uB775\uB77C\uB77D\uB780\uB784\uB78C\uB78D\uB78F\uB790\uB791\uB792\uB796\uB797"],
      ["b741", "\uD16E", 13, "\uD17D", 6, "\uD185\uD186\uD187\uD189\uD18A"],
      ["b761", "\uD18B", 20, "\uD1A2\uD1A3\uD1A5\uD1A6\uD1A7"],
      ["b781", "\uD1A9", 6, "\uD1B2\uD1B4\uD1B6\uD1B7\uD1B8\uD1B9\uD1BB\uD1BD\uD1BE\uD1BF\uD1C1", 14, "\uB798\uB799\uB79C\uB7A0\uB7A8\uB7A9\uB7AB\uB7AC\uB7AD\uB7B4\uB7B5\uB7B8\uB7C7\uB7C9\uB7EC\uB7ED\uB7F0\uB7F4\uB7FC\uB7FD\uB7FF\uB800\uB801\uB807\uB808\uB809\uB80C\uB810\uB818\uB819\uB81B\uB81D\uB824\uB825\uB828\uB82C\uB834\uB835\uB837\uB838\uB839\uB840\uB844\uB851\uB853\uB85C\uB85D\uB860\uB864\uB86C\uB86D\uB86F\uB871\uB878\uB87C\uB88D\uB8A8\uB8B0\uB8B4\uB8B8\uB8C0\uB8C1\uB8C3\uB8C5\uB8CC\uB8D0\uB8D4\uB8DD\uB8DF\uB8E1\uB8E8\uB8E9\uB8EC\uB8F0\uB8F8\uB8F9\uB8FB\uB8FD\uB904\uB918\uB920\uB93C\uB93D\uB940\uB944\uB94C\uB94F\uB951\uB958\uB959\uB95C\uB960\uB968\uB969"],
      ["b841", "\uD1D0", 7, "\uD1D9", 17],
      ["b861", "\uD1EB", 8, "\uD1F5\uD1F6\uD1F7\uD1F9", 13],
      ["b881", "\uD208\uD20A", 5, "\uD211", 24, "\uB96B\uB96D\uB974\uB975\uB978\uB97C\uB984\uB985\uB987\uB989\uB98A\uB98D\uB98E\uB9AC\uB9AD\uB9B0\uB9B4\uB9BC\uB9BD\uB9BF\uB9C1\uB9C8\uB9C9\uB9CC\uB9CE", 4, "\uB9D8\uB9D9\uB9DB\uB9DD\uB9DE\uB9E1\uB9E3\uB9E4\uB9E5\uB9E8\uB9EC\uB9F4\uB9F5\uB9F7\uB9F8\uB9F9\uB9FA\uBA00\uBA01\uBA08\uBA15\uBA38\uBA39\uBA3C\uBA40\uBA42\uBA48\uBA49\uBA4B\uBA4D\uBA4E\uBA53\uBA54\uBA55\uBA58\uBA5C\uBA64\uBA65\uBA67\uBA68\uBA69\uBA70\uBA71\uBA74\uBA78\uBA83\uBA84\uBA85\uBA87\uBA8C\uBAA8\uBAA9\uBAAB\uBAAC\uBAB0\uBAB2\uBAB8\uBAB9\uBABB\uBABD\uBAC4\uBAC8\uBAD8\uBAD9\uBAFC"],
      ["b941", "\uD22A\uD22B\uD22E\uD22F\uD231\uD232\uD233\uD235", 6, "\uD23E\uD240\uD242", 5, "\uD249\uD24A\uD24B\uD24C"],
      ["b961", "\uD24D", 14, "\uD25D", 6, "\uD265\uD266\uD267\uD268"],
      ["b981", "\uD269", 22, "\uD282\uD283\uD285\uD286\uD287\uD289\uD28A\uD28B\uD28C\uBB00\uBB04\uBB0D\uBB0F\uBB11\uBB18\uBB1C\uBB20\uBB29\uBB2B\uBB34\uBB35\uBB36\uBB38\uBB3B\uBB3C\uBB3D\uBB3E\uBB44\uBB45\uBB47\uBB49\uBB4D\uBB4F\uBB50\uBB54\uBB58\uBB61\uBB63\uBB6C\uBB88\uBB8C\uBB90\uBBA4\uBBA8\uBBAC\uBBB4\uBBB7\uBBC0\uBBC4\uBBC8\uBBD0\uBBD3\uBBF8\uBBF9\uBBFC\uBBFF\uBC00\uBC02\uBC08\uBC09\uBC0B\uBC0C\uBC0D\uBC0F\uBC11\uBC14", 4, "\uBC1B", 4, "\uBC24\uBC25\uBC27\uBC29\uBC2D\uBC30\uBC31\uBC34\uBC38\uBC40\uBC41\uBC43\uBC44\uBC45\uBC49\uBC4C\uBC4D\uBC50\uBC5D\uBC84\uBC85\uBC88\uBC8B\uBC8C\uBC8E\uBC94\uBC95\uBC97"],
      ["ba41", "\uD28D\uD28E\uD28F\uD292\uD293\uD294\uD296", 5, "\uD29D\uD29E\uD29F\uD2A1\uD2A2\uD2A3\uD2A5", 6, "\uD2AD"],
      ["ba61", "\uD2AE\uD2AF\uD2B0\uD2B2", 5, "\uD2BA\uD2BB\uD2BD\uD2BE\uD2C1\uD2C3", 4, "\uD2CA\uD2CC", 5],
      ["ba81", "\uD2D2\uD2D3\uD2D5\uD2D6\uD2D7\uD2D9\uD2DA\uD2DB\uD2DD", 6, "\uD2E6", 9, "\uD2F2\uD2F3\uD2F5\uD2F6\uD2F7\uD2F9\uD2FA\uBC99\uBC9A\uBCA0\uBCA1\uBCA4\uBCA7\uBCA8\uBCB0\uBCB1\uBCB3\uBCB4\uBCB5\uBCBC\uBCBD\uBCC0\uBCC4\uBCCD\uBCCF\uBCD0\uBCD1\uBCD5\uBCD8\uBCDC\uBCF4\uBCF5\uBCF6\uBCF8\uBCFC\uBD04\uBD05\uBD07\uBD09\uBD10\uBD14\uBD24\uBD2C\uBD40\uBD48\uBD49\uBD4C\uBD50\uBD58\uBD59\uBD64\uBD68\uBD80\uBD81\uBD84\uBD87\uBD88\uBD89\uBD8A\uBD90\uBD91\uBD93\uBD95\uBD99\uBD9A\uBD9C\uBDA4\uBDB0\uBDB8\uBDD4\uBDD5\uBDD8\uBDDC\uBDE9\uBDF0\uBDF4\uBDF8\uBE00\uBE03\uBE05\uBE0C\uBE0D\uBE10\uBE14\uBE1C\uBE1D\uBE1F\uBE44\uBE45\uBE48\uBE4C\uBE4E\uBE54\uBE55\uBE57\uBE59\uBE5A\uBE5B\uBE60\uBE61\uBE64"],
      ["bb41", "\uD2FB", 4, "\uD302\uD304\uD306", 5, "\uD30F\uD311\uD312\uD313\uD315\uD317", 4, "\uD31E\uD322\uD323"],
      ["bb61", "\uD324\uD326\uD327\uD32A\uD32B\uD32D\uD32E\uD32F\uD331", 6, "\uD33A\uD33E", 5, "\uD346\uD347\uD348\uD349"],
      ["bb81", "\uD34A", 31, "\uBE68\uBE6A\uBE70\uBE71\uBE73\uBE74\uBE75\uBE7B\uBE7C\uBE7D\uBE80\uBE84\uBE8C\uBE8D\uBE8F\uBE90\uBE91\uBE98\uBE99\uBEA8\uBED0\uBED1\uBED4\uBED7\uBED8\uBEE0\uBEE3\uBEE4\uBEE5\uBEEC\uBF01\uBF08\uBF09\uBF18\uBF19\uBF1B\uBF1C\uBF1D\uBF40\uBF41\uBF44\uBF48\uBF50\uBF51\uBF55\uBF94\uBFB0\uBFC5\uBFCC\uBFCD\uBFD0\uBFD4\uBFDC\uBFDF\uBFE1\uC03C\uC051\uC058\uC05C\uC060\uC068\uC069\uC090\uC091\uC094\uC098\uC0A0\uC0A1\uC0A3\uC0A5\uC0AC\uC0AD\uC0AF\uC0B0\uC0B3\uC0B4\uC0B5\uC0B6\uC0BC\uC0BD\uC0BF\uC0C0\uC0C1\uC0C5\uC0C8\uC0C9\uC0CC\uC0D0\uC0D8\uC0D9\uC0DB\uC0DC\uC0DD\uC0E4"],
      ["bc41", "\uD36A", 17, "\uD37E\uD37F\uD381\uD382\uD383\uD385\uD386\uD387"],
      ["bc61", "\uD388\uD389\uD38A\uD38B\uD38E\uD392", 5, "\uD39A\uD39B\uD39D\uD39E\uD39F\uD3A1", 6, "\uD3AA\uD3AC\uD3AE"],
      ["bc81", "\uD3AF", 4, "\uD3B5\uD3B6\uD3B7\uD3B9\uD3BA\uD3BB\uD3BD", 6, "\uD3C6\uD3C7\uD3CA", 5, "\uD3D1", 5, "\uC0E5\uC0E8\uC0EC\uC0F4\uC0F5\uC0F7\uC0F9\uC100\uC104\uC108\uC110\uC115\uC11C", 4, "\uC123\uC124\uC126\uC127\uC12C\uC12D\uC12F\uC130\uC131\uC136\uC138\uC139\uC13C\uC140\uC148\uC149\uC14B\uC14C\uC14D\uC154\uC155\uC158\uC15C\uC164\uC165\uC167\uC168\uC169\uC170\uC174\uC178\uC185\uC18C\uC18D\uC18E\uC190\uC194\uC196\uC19C\uC19D\uC19F\uC1A1\uC1A5\uC1A8\uC1A9\uC1AC\uC1B0\uC1BD\uC1C4\uC1C8\uC1CC\uC1D4\uC1D7\uC1D8\uC1E0\uC1E4\uC1E8\uC1F0\uC1F1\uC1F3\uC1FC\uC1FD\uC200\uC204\uC20C\uC20D\uC20F\uC211\uC218\uC219\uC21C\uC21F\uC220\uC228\uC229\uC22B\uC22D"],
      ["bd41", "\uD3D7\uD3D9", 7, "\uD3E2\uD3E4", 7, "\uD3EE\uD3EF\uD3F1\uD3F2\uD3F3\uD3F5\uD3F6\uD3F7"],
      ["bd61", "\uD3F8\uD3F9\uD3FA\uD3FB\uD3FE\uD400\uD402", 5, "\uD409", 13],
      ["bd81", "\uD417", 5, "\uD41E", 25, "\uC22F\uC231\uC232\uC234\uC248\uC250\uC251\uC254\uC258\uC260\uC265\uC26C\uC26D\uC270\uC274\uC27C\uC27D\uC27F\uC281\uC288\uC289\uC290\uC298\uC29B\uC29D\uC2A4\uC2A5\uC2A8\uC2AC\uC2AD\uC2B4\uC2B5\uC2B7\uC2B9\uC2DC\uC2DD\uC2E0\uC2E3\uC2E4\uC2EB\uC2EC\uC2ED\uC2EF\uC2F1\uC2F6\uC2F8\uC2F9\uC2FB\uC2FC\uC300\uC308\uC309\uC30C\uC30D\uC313\uC314\uC315\uC318\uC31C\uC324\uC325\uC328\uC329\uC345\uC368\uC369\uC36C\uC370\uC372\uC378\uC379\uC37C\uC37D\uC384\uC388\uC38C\uC3C0\uC3D8\uC3D9\uC3DC\uC3DF\uC3E0\uC3E2\uC3E8\uC3E9\uC3ED\uC3F4\uC3F5\uC3F8\uC408\uC410\uC424\uC42C\uC430"],
      ["be41", "\uD438", 7, "\uD441\uD442\uD443\uD445", 14],
      ["be61", "\uD454", 7, "\uD45D\uD45E\uD45F\uD461\uD462\uD463\uD465", 7, "\uD46E\uD470\uD471\uD472"],
      ["be81", "\uD473", 4, "\uD47A\uD47B\uD47D\uD47E\uD481\uD483", 4, "\uD48A\uD48C\uD48E", 5, "\uD495", 8, "\uC434\uC43C\uC43D\uC448\uC464\uC465\uC468\uC46C\uC474\uC475\uC479\uC480\uC494\uC49C\uC4B8\uC4BC\uC4E9\uC4F0\uC4F1\uC4F4\uC4F8\uC4FA\uC4FF\uC500\uC501\uC50C\uC510\uC514\uC51C\uC528\uC529\uC52C\uC530\uC538\uC539\uC53B\uC53D\uC544\uC545\uC548\uC549\uC54A\uC54C\uC54D\uC54E\uC553\uC554\uC555\uC557\uC558\uC559\uC55D\uC55E\uC560\uC561\uC564\uC568\uC570\uC571\uC573\uC574\uC575\uC57C\uC57D\uC580\uC584\uC587\uC58C\uC58D\uC58F\uC591\uC595\uC597\uC598\uC59C\uC5A0\uC5A9\uC5B4\uC5B5\uC5B8\uC5B9\uC5BB\uC5BC\uC5BD\uC5BE\uC5C4", 6, "\uC5CC\uC5CE"],
      ["bf41", "\uD49E", 10, "\uD4AA", 14],
      ["bf61", "\uD4B9", 18, "\uD4CD\uD4CE\uD4CF\uD4D1\uD4D2\uD4D3\uD4D5"],
      ["bf81", "\uD4D6", 5, "\uD4DD\uD4DE\uD4E0", 7, "\uD4E9\uD4EA\uD4EB\uD4ED\uD4EE\uD4EF\uD4F1", 6, "\uD4F9\uD4FA\uD4FC\uC5D0\uC5D1\uC5D4\uC5D8\uC5E0\uC5E1\uC5E3\uC5E5\uC5EC\uC5ED\uC5EE\uC5F0\uC5F4\uC5F6\uC5F7\uC5FC", 5, "\uC605\uC606\uC607\uC608\uC60C\uC610\uC618\uC619\uC61B\uC61C\uC624\uC625\uC628\uC62C\uC62D\uC62E\uC630\uC633\uC634\uC635\uC637\uC639\uC63B\uC640\uC641\uC644\uC648\uC650\uC651\uC653\uC654\uC655\uC65C\uC65D\uC660\uC66C\uC66F\uC671\uC678\uC679\uC67C\uC680\uC688\uC689\uC68B\uC68D\uC694\uC695\uC698\uC69C\uC6A4\uC6A5\uC6A7\uC6A9\uC6B0\uC6B1\uC6B4\uC6B8\uC6B9\uC6BA\uC6C0\uC6C1\uC6C3\uC6C5\uC6CC\uC6CD\uC6D0\uC6D4\uC6DC\uC6DD\uC6E0\uC6E1\uC6E8"],
      ["c041", "\uD4FE", 5, "\uD505\uD506\uD507\uD509\uD50A\uD50B\uD50D", 6, "\uD516\uD518", 5],
      ["c061", "\uD51E", 25],
      ["c081", "\uD538\uD539\uD53A\uD53B\uD53E\uD53F\uD541\uD542\uD543\uD545", 6, "\uD54E\uD550\uD552", 5, "\uD55A\uD55B\uD55D\uD55E\uD55F\uD561\uD562\uD563\uC6E9\uC6EC\uC6F0\uC6F8\uC6F9\uC6FD\uC704\uC705\uC708\uC70C\uC714\uC715\uC717\uC719\uC720\uC721\uC724\uC728\uC730\uC731\uC733\uC735\uC737\uC73C\uC73D\uC740\uC744\uC74A\uC74C\uC74D\uC74F\uC751", 7, "\uC75C\uC760\uC768\uC76B\uC774\uC775\uC778\uC77C\uC77D\uC77E\uC783\uC784\uC785\uC787\uC788\uC789\uC78A\uC78E\uC790\uC791\uC794\uC796\uC797\uC798\uC79A\uC7A0\uC7A1\uC7A3\uC7A4\uC7A5\uC7A6\uC7AC\uC7AD\uC7B0\uC7B4\uC7BC\uC7BD\uC7BF\uC7C0\uC7C1\uC7C8\uC7C9\uC7CC\uC7CE\uC7D0\uC7D8\uC7DD\uC7E4\uC7E8\uC7EC\uC800\uC801\uC804\uC808\uC80A"],
      ["c141", "\uD564\uD566\uD567\uD56A\uD56C\uD56E", 5, "\uD576\uD577\uD579\uD57A\uD57B\uD57D", 6, "\uD586\uD58A\uD58B"],
      ["c161", "\uD58C\uD58D\uD58E\uD58F\uD591", 19, "\uD5A6\uD5A7"],
      ["c181", "\uD5A8", 31, "\uC810\uC811\uC813\uC815\uC816\uC81C\uC81D\uC820\uC824\uC82C\uC82D\uC82F\uC831\uC838\uC83C\uC840\uC848\uC849\uC84C\uC84D\uC854\uC870\uC871\uC874\uC878\uC87A\uC880\uC881\uC883\uC885\uC886\uC887\uC88B\uC88C\uC88D\uC894\uC89D\uC89F\uC8A1\uC8A8\uC8BC\uC8BD\uC8C4\uC8C8\uC8CC\uC8D4\uC8D5\uC8D7\uC8D9\uC8E0\uC8E1\uC8E4\uC8F5\uC8FC\uC8FD\uC900\uC904\uC905\uC906\uC90C\uC90D\uC90F\uC911\uC918\uC92C\uC934\uC950\uC951\uC954\uC958\uC960\uC961\uC963\uC96C\uC970\uC974\uC97C\uC988\uC989\uC98C\uC990\uC998\uC999\uC99B\uC99D\uC9C0\uC9C1\uC9C4\uC9C7\uC9C8\uC9CA\uC9D0\uC9D1\uC9D3"],
      ["c241", "\uD5CA\uD5CB\uD5CD\uD5CE\uD5CF\uD5D1\uD5D3", 4, "\uD5DA\uD5DC\uD5DE", 5, "\uD5E6\uD5E7\uD5E9\uD5EA\uD5EB\uD5ED\uD5EE"],
      ["c261", "\uD5EF", 4, "\uD5F6\uD5F8\uD5FA", 5, "\uD602\uD603\uD605\uD606\uD607\uD609", 6, "\uD612"],
      ["c281", "\uD616", 5, "\uD61D\uD61E\uD61F\uD621\uD622\uD623\uD625", 7, "\uD62E", 9, "\uD63A\uD63B\uC9D5\uC9D6\uC9D9\uC9DA\uC9DC\uC9DD\uC9E0\uC9E2\uC9E4\uC9E7\uC9EC\uC9ED\uC9EF\uC9F0\uC9F1\uC9F8\uC9F9\uC9FC\uCA00\uCA08\uCA09\uCA0B\uCA0C\uCA0D\uCA14\uCA18\uCA29\uCA4C\uCA4D\uCA50\uCA54\uCA5C\uCA5D\uCA5F\uCA60\uCA61\uCA68\uCA7D\uCA84\uCA98\uCABC\uCABD\uCAC0\uCAC4\uCACC\uCACD\uCACF\uCAD1\uCAD3\uCAD8\uCAD9\uCAE0\uCAEC\uCAF4\uCB08\uCB10\uCB14\uCB18\uCB20\uCB21\uCB41\uCB48\uCB49\uCB4C\uCB50\uCB58\uCB59\uCB5D\uCB64\uCB78\uCB79\uCB9C\uCBB8\uCBD4\uCBE4\uCBE7\uCBE9\uCC0C\uCC0D\uCC10\uCC14\uCC1C\uCC1D\uCC21\uCC22\uCC27\uCC28\uCC29\uCC2C\uCC2E\uCC30\uCC38\uCC39\uCC3B"],
      ["c341", "\uD63D\uD63E\uD63F\uD641\uD642\uD643\uD644\uD646\uD647\uD64A\uD64C\uD64E\uD64F\uD650\uD652\uD653\uD656\uD657\uD659\uD65A\uD65B\uD65D", 4],
      ["c361", "\uD662", 4, "\uD668\uD66A", 5, "\uD672\uD673\uD675", 11],
      ["c381", "\uD681\uD682\uD684\uD686", 5, "\uD68E\uD68F\uD691\uD692\uD693\uD695", 7, "\uD69E\uD6A0\uD6A2", 5, "\uD6A9\uD6AA\uCC3C\uCC3D\uCC3E\uCC44\uCC45\uCC48\uCC4C\uCC54\uCC55\uCC57\uCC58\uCC59\uCC60\uCC64\uCC66\uCC68\uCC70\uCC75\uCC98\uCC99\uCC9C\uCCA0\uCCA8\uCCA9\uCCAB\uCCAC\uCCAD\uCCB4\uCCB5\uCCB8\uCCBC\uCCC4\uCCC5\uCCC7\uCCC9\uCCD0\uCCD4\uCCE4\uCCEC\uCCF0\uCD01\uCD08\uCD09\uCD0C\uCD10\uCD18\uCD19\uCD1B\uCD1D\uCD24\uCD28\uCD2C\uCD39\uCD5C\uCD60\uCD64\uCD6C\uCD6D\uCD6F\uCD71\uCD78\uCD88\uCD94\uCD95\uCD98\uCD9C\uCDA4\uCDA5\uCDA7\uCDA9\uCDB0\uCDC4\uCDCC\uCDD0\uCDE8\uCDEC\uCDF0\uCDF8\uCDF9\uCDFB\uCDFD\uCE04\uCE08\uCE0C\uCE14\uCE19\uCE20\uCE21\uCE24\uCE28\uCE30\uCE31\uCE33\uCE35"],
      ["c441", "\uD6AB\uD6AD\uD6AE\uD6AF\uD6B1", 7, "\uD6BA\uD6BC", 7, "\uD6C6\uD6C7\uD6C9\uD6CA\uD6CB"],
      ["c461", "\uD6CD\uD6CE\uD6CF\uD6D0\uD6D2\uD6D3\uD6D5\uD6D6\uD6D8\uD6DA", 5, "\uD6E1\uD6E2\uD6E3\uD6E5\uD6E6\uD6E7\uD6E9", 4],
      ["c481", "\uD6EE\uD6EF\uD6F1\uD6F2\uD6F3\uD6F4\uD6F6", 5, "\uD6FE\uD6FF\uD701\uD702\uD703\uD705", 11, "\uD712\uD713\uD714\uCE58\uCE59\uCE5C\uCE5F\uCE60\uCE61\uCE68\uCE69\uCE6B\uCE6D\uCE74\uCE75\uCE78\uCE7C\uCE84\uCE85\uCE87\uCE89\uCE90\uCE91\uCE94\uCE98\uCEA0\uCEA1\uCEA3\uCEA4\uCEA5\uCEAC\uCEAD\uCEC1\uCEE4\uCEE5\uCEE8\uCEEB\uCEEC\uCEF4\uCEF5\uCEF7\uCEF8\uCEF9\uCF00\uCF01\uCF04\uCF08\uCF10\uCF11\uCF13\uCF15\uCF1C\uCF20\uCF24\uCF2C\uCF2D\uCF2F\uCF30\uCF31\uCF38\uCF54\uCF55\uCF58\uCF5C\uCF64\uCF65\uCF67\uCF69\uCF70\uCF71\uCF74\uCF78\uCF80\uCF85\uCF8C\uCFA1\uCFA8\uCFB0\uCFC4\uCFE0\uCFE1\uCFE4\uCFE8\uCFF0\uCFF1\uCFF3\uCFF5\uCFFC\uD000\uD004\uD011\uD018\uD02D\uD034\uD035\uD038\uD03C"],
      ["c541", "\uD715\uD716\uD717\uD71A\uD71B\uD71D\uD71E\uD71F\uD721", 6, "\uD72A\uD72C\uD72E", 5, "\uD736\uD737\uD739"],
      ["c561", "\uD73A\uD73B\uD73D", 6, "\uD745\uD746\uD748\uD74A", 5, "\uD752\uD753\uD755\uD75A", 4],
      ["c581", "\uD75F\uD762\uD764\uD766\uD767\uD768\uD76A\uD76B\uD76D\uD76E\uD76F\uD771\uD772\uD773\uD775", 6, "\uD77E\uD77F\uD780\uD782", 5, "\uD78A\uD78B\uD044\uD045\uD047\uD049\uD050\uD054\uD058\uD060\uD06C\uD06D\uD070\uD074\uD07C\uD07D\uD081\uD0A4\uD0A5\uD0A8\uD0AC\uD0B4\uD0B5\uD0B7\uD0B9\uD0C0\uD0C1\uD0C4\uD0C8\uD0C9\uD0D0\uD0D1\uD0D3\uD0D4\uD0D5\uD0DC\uD0DD\uD0E0\uD0E4\uD0EC\uD0ED\uD0EF\uD0F0\uD0F1\uD0F8\uD10D\uD130\uD131\uD134\uD138\uD13A\uD140\uD141\uD143\uD144\uD145\uD14C\uD14D\uD150\uD154\uD15C\uD15D\uD15F\uD161\uD168\uD16C\uD17C\uD184\uD188\uD1A0\uD1A1\uD1A4\uD1A8\uD1B0\uD1B1\uD1B3\uD1B5\uD1BA\uD1BC\uD1C0\uD1D8\uD1F4\uD1F8\uD207\uD209\uD210\uD22C\uD22D\uD230\uD234\uD23C\uD23D\uD23F\uD241\uD248\uD25C"],
      ["c641", "\uD78D\uD78E\uD78F\uD791", 6, "\uD79A\uD79C\uD79E", 5],
      ["c6a1", "\uD264\uD280\uD281\uD284\uD288\uD290\uD291\uD295\uD29C\uD2A0\uD2A4\uD2AC\uD2B1\uD2B8\uD2B9\uD2BC\uD2BF\uD2C0\uD2C2\uD2C8\uD2C9\uD2CB\uD2D4\uD2D8\uD2DC\uD2E4\uD2E5\uD2F0\uD2F1\uD2F4\uD2F8\uD300\uD301\uD303\uD305\uD30C\uD30D\uD30E\uD310\uD314\uD316\uD31C\uD31D\uD31F\uD320\uD321\uD325\uD328\uD329\uD32C\uD330\uD338\uD339\uD33B\uD33C\uD33D\uD344\uD345\uD37C\uD37D\uD380\uD384\uD38C\uD38D\uD38F\uD390\uD391\uD398\uD399\uD39C\uD3A0\uD3A8\uD3A9\uD3AB\uD3AD\uD3B4\uD3B8\uD3BC\uD3C4\uD3C5\uD3C8\uD3C9\uD3D0\uD3D8\uD3E1\uD3E3\uD3EC\uD3ED\uD3F0\uD3F4\uD3FC\uD3FD\uD3FF\uD401"],
      ["c7a1", "\uD408\uD41D\uD440\uD444\uD45C\uD460\uD464\uD46D\uD46F\uD478\uD479\uD47C\uD47F\uD480\uD482\uD488\uD489\uD48B\uD48D\uD494\uD4A9\uD4CC\uD4D0\uD4D4\uD4DC\uD4DF\uD4E8\uD4EC\uD4F0\uD4F8\uD4FB\uD4FD\uD504\uD508\uD50C\uD514\uD515\uD517\uD53C\uD53D\uD540\uD544\uD54C\uD54D\uD54F\uD551\uD558\uD559\uD55C\uD560\uD565\uD568\uD569\uD56B\uD56D\uD574\uD575\uD578\uD57C\uD584\uD585\uD587\uD588\uD589\uD590\uD5A5\uD5C8\uD5C9\uD5CC\uD5D0\uD5D2\uD5D8\uD5D9\uD5DB\uD5DD\uD5E4\uD5E5\uD5E8\uD5EC\uD5F4\uD5F5\uD5F7\uD5F9\uD600\uD601\uD604\uD608\uD610\uD611\uD613\uD614\uD615\uD61C\uD620"],
      ["c8a1", "\uD624\uD62D\uD638\uD639\uD63C\uD640\uD645\uD648\uD649\uD64B\uD64D\uD651\uD654\uD655\uD658\uD65C\uD667\uD669\uD670\uD671\uD674\uD683\uD685\uD68C\uD68D\uD690\uD694\uD69D\uD69F\uD6A1\uD6A8\uD6AC\uD6B0\uD6B9\uD6BB\uD6C4\uD6C5\uD6C8\uD6CC\uD6D1\uD6D4\uD6D7\uD6D9\uD6E0\uD6E4\uD6E8\uD6F0\uD6F5\uD6FC\uD6FD\uD700\uD704\uD711\uD718\uD719\uD71C\uD720\uD728\uD729\uD72B\uD72D\uD734\uD735\uD738\uD73C\uD744\uD747\uD749\uD750\uD751\uD754\uD756\uD757\uD758\uD759\uD760\uD761\uD763\uD765\uD769\uD76C\uD770\uD774\uD77C\uD77D\uD781\uD788\uD789\uD78C\uD790\uD798\uD799\uD79B\uD79D"],
      ["caa1", "\u4F3D\u4F73\u5047\u50F9\u52A0\u53EF\u5475\u54E5\u5609\u5AC1\u5BB6\u6687\u67B6\u67B7\u67EF\u6B4C\u73C2\u75C2\u7A3C\u82DB\u8304\u8857\u8888\u8A36\u8CC8\u8DCF\u8EFB\u8FE6\u99D5\u523B\u5374\u5404\u606A\u6164\u6BBC\u73CF\u811A\u89BA\u89D2\u95A3\u4F83\u520A\u58BE\u5978\u59E6\u5E72\u5E79\u61C7\u63C0\u6746\u67EC\u687F\u6F97\u764E\u770B\u78F5\u7A08\u7AFF\u7C21\u809D\u826E\u8271\u8AEB\u9593\u4E6B\u559D\u66F7\u6E34\u78A3\u7AED\u845B\u8910\u874E\u97A8\u52D8\u574E\u582A\u5D4C\u611F\u61BE\u6221\u6562\u67D1\u6A44\u6E1B\u7518\u75B3\u76E3\u77B0\u7D3A\u90AF\u9451\u9452\u9F95"],
      ["cba1", "\u5323\u5CAC\u7532\u80DB\u9240\u9598\u525B\u5808\u59DC\u5CA1\u5D17\u5EB7\u5F3A\u5F4A\u6177\u6C5F\u757A\u7586\u7CE0\u7D73\u7DB1\u7F8C\u8154\u8221\u8591\u8941\u8B1B\u92FC\u964D\u9C47\u4ECB\u4EF7\u500B\u51F1\u584F\u6137\u613E\u6168\u6539\u69EA\u6F11\u75A5\u7686\u76D6\u7B87\u82A5\u84CB\uF900\u93A7\u958B\u5580\u5BA2\u5751\uF901\u7CB3\u7FB9\u91B5\u5028\u53BB\u5C45\u5DE8\u62D2\u636E\u64DA\u64E7\u6E20\u70AC\u795B\u8DDD\u8E1E\uF902\u907D\u9245\u92F8\u4E7E\u4EF6\u5065\u5DFE\u5EFA\u6106\u6957\u8171\u8654\u8E47\u9375\u9A2B\u4E5E\u5091\u6770\u6840\u5109\u528D\u5292\u6AA2"],
      ["cca1", "\u77BC\u9210\u9ED4\u52AB\u602F\u8FF2\u5048\u61A9\u63ED\u64CA\u683C\u6A84\u6FC0\u8188\u89A1\u9694\u5805\u727D\u72AC\u7504\u7D79\u7E6D\u80A9\u898B\u8B74\u9063\u9D51\u6289\u6C7A\u6F54\u7D50\u7F3A\u8A23\u517C\u614A\u7B9D\u8B19\u9257\u938C\u4EAC\u4FD3\u501E\u50BE\u5106\u52C1\u52CD\u537F\u5770\u5883\u5E9A\u5F91\u6176\u61AC\u64CE\u656C\u666F\u66BB\u66F4\u6897\u6D87\u7085\u70F1\u749F\u74A5\u74CA\u75D9\u786C\u78EC\u7ADF\u7AF6\u7D45\u7D93\u8015\u803F\u811B\u8396\u8B66\u8F15\u9015\u93E1\u9803\u9838\u9A5A\u9BE8\u4FC2\u5553\u583A\u5951\u5B63\u5C46\u60B8\u6212\u6842\u68B0"],
      ["cda1", "\u68E8\u6EAA\u754C\u7678\u78CE\u7A3D\u7CFB\u7E6B\u7E7C\u8A08\u8AA1\u8C3F\u968E\u9DC4\u53E4\u53E9\u544A\u5471\u56FA\u59D1\u5B64\u5C3B\u5EAB\u62F7\u6537\u6545\u6572\u66A0\u67AF\u69C1\u6CBD\u75FC\u7690\u777E\u7A3F\u7F94\u8003\u80A1\u818F\u82E6\u82FD\u83F0\u85C1\u8831\u88B4\u8AA5\uF903\u8F9C\u932E\u96C7\u9867\u9AD8\u9F13\u54ED\u659B\u66F2\u688F\u7A40\u8C37\u9D60\u56F0\u5764\u5D11\u6606\u68B1\u68CD\u6EFE\u7428\u889E\u9BE4\u6C68\uF904\u9AA8\u4F9B\u516C\u5171\u529F\u5B54\u5DE5\u6050\u606D\u62F1\u63A7\u653B\u73D9\u7A7A\u86A3\u8CA2\u978F\u4E32\u5BE1\u6208\u679C\u74DC"],
      ["cea1", "\u79D1\u83D3\u8A87\u8AB2\u8DE8\u904E\u934B\u9846\u5ED3\u69E8\u85FF\u90ED\uF905\u51A0\u5B98\u5BEC\u6163\u68FA\u6B3E\u704C\u742F\u74D8\u7BA1\u7F50\u83C5\u89C0\u8CAB\u95DC\u9928\u522E\u605D\u62EC\u9002\u4F8A\u5149\u5321\u58D9\u5EE3\u66E0\u6D38\u709A\u72C2\u73D6\u7B50\u80F1\u945B\u5366\u639B\u7F6B\u4E56\u5080\u584A\u58DE\u602A\u6127\u62D0\u69D0\u9B41\u5B8F\u7D18\u80B1\u8F5F\u4EA4\u50D1\u54AC\u55AC\u5B0C\u5DA0\u5DE7\u652A\u654E\u6821\u6A4B\u72E1\u768E\u77EF\u7D5E\u7FF9\u81A0\u854E\u86DF\u8F03\u8F4E\u90CA\u9903\u9A55\u9BAB\u4E18\u4E45\u4E5D\u4EC7\u4FF1\u5177\u52FE"],
      ["cfa1", "\u5340\u53E3\u53E5\u548E\u5614\u5775\u57A2\u5BC7\u5D87\u5ED0\u61FC\u62D8\u6551\u67B8\u67E9\u69CB\u6B50\u6BC6\u6BEC\u6C42\u6E9D\u7078\u72D7\u7396\u7403\u77BF\u77E9\u7A76\u7D7F\u8009\u81FC\u8205\u820A\u82DF\u8862\u8B33\u8CFC\u8EC0\u9011\u90B1\u9264\u92B6\u99D2\u9A45\u9CE9\u9DD7\u9F9C\u570B\u5C40\u83CA\u97A0\u97AB\u9EB4\u541B\u7A98\u7FA4\u88D9\u8ECD\u90E1\u5800\u5C48\u6398\u7A9F\u5BAE\u5F13\u7A79\u7AAE\u828E\u8EAC\u5026\u5238\u52F8\u5377\u5708\u62F3\u6372\u6B0A\u6DC3\u7737\u53A5\u7357\u8568\u8E76\u95D5\u673A\u6AC3\u6F70\u8A6D\u8ECC\u994B\uF906\u6677\u6B78\u8CB4"],
      ["d0a1", "\u9B3C\uF907\u53EB\u572D\u594E\u63C6\u69FB\u73EA\u7845\u7ABA\u7AC5\u7CFE\u8475\u898F\u8D73\u9035\u95A8\u52FB\u5747\u7547\u7B60\u83CC\u921E\uF908\u6A58\u514B\u524B\u5287\u621F\u68D8\u6975\u9699\u50C5\u52A4\u52E4\u61C3\u65A4\u6839\u69FF\u747E\u7B4B\u82B9\u83EB\u89B2\u8B39\u8FD1\u9949\uF909\u4ECA\u5997\u64D2\u6611\u6A8E\u7434\u7981\u79BD\u82A9\u887E\u887F\u895F\uF90A\u9326\u4F0B\u53CA\u6025\u6271\u6C72\u7D1A\u7D66\u4E98\u5162\u77DC\u80AF\u4F01\u4F0E\u5176\u5180\u55DC\u5668\u573B\u57FA\u57FC\u5914\u5947\u5993\u5BC4\u5C90\u5D0E\u5DF1\u5E7E\u5FCC\u6280\u65D7\u65E3"],
      ["d1a1", "\u671E\u671F\u675E\u68CB\u68C4\u6A5F\u6B3A\u6C23\u6C7D\u6C82\u6DC7\u7398\u7426\u742A\u7482\u74A3\u7578\u757F\u7881\u78EF\u7941\u7947\u7948\u797A\u7B95\u7D00\u7DBA\u7F88\u8006\u802D\u808C\u8A18\u8B4F\u8C48\u8D77\u9321\u9324\u98E2\u9951\u9A0E\u9A0F\u9A65\u9E92\u7DCA\u4F76\u5409\u62EE\u6854\u91D1\u55AB\u513A\uF90B\uF90C\u5A1C\u61E6\uF90D\u62CF\u62FF\uF90E", 5, "\u90A3\uF914", 4, "\u8AFE\uF919\uF91A\uF91B\uF91C\u6696\uF91D\u7156\uF91E\uF91F\u96E3\uF920\u634F\u637A\u5357\uF921\u678F\u6960\u6E73\uF922\u7537\uF923\uF924\uF925"],
      ["d2a1", "\u7D0D\uF926\uF927\u8872\u56CA\u5A18\uF928", 4, "\u4E43\uF92D\u5167\u5948\u67F0\u8010\uF92E\u5973\u5E74\u649A\u79CA\u5FF5\u606C\u62C8\u637B\u5BE7\u5BD7\u52AA\uF92F\u5974\u5F29\u6012\uF930\uF931\uF932\u7459\uF933", 5, "\u99D1\uF939", 10, "\u6FC3\uF944\uF945\u81BF\u8FB2\u60F1\uF946\uF947\u8166\uF948\uF949\u5C3F\uF94A", 7, "\u5AE9\u8A25\u677B\u7D10\uF952", 5, "\u80FD\uF958\uF959\u5C3C\u6CE5\u533F\u6EBA\u591A\u8336"],
      ["d3a1", "\u4E39\u4EB6\u4F46\u55AE\u5718\u58C7\u5F56\u65B7\u65E6\u6A80\u6BB5\u6E4D\u77ED\u7AEF\u7C1E\u7DDE\u86CB\u8892\u9132\u935B\u64BB\u6FBE\u737A\u75B8\u9054\u5556\u574D\u61BA\u64D4\u66C7\u6DE1\u6E5B\u6F6D\u6FB9\u75F0\u8043\u81BD\u8541\u8983\u8AC7\u8B5A\u931F\u6C93\u7553\u7B54\u8E0F\u905D\u5510\u5802\u5858\u5E62\u6207\u649E\u68E0\u7576\u7CD6\u87B3\u9EE8\u4EE3\u5788\u576E\u5927\u5C0D\u5CB1\u5E36\u5F85\u6234\u64E1\u73B3\u81FA\u888B\u8CB8\u968A\u9EDB\u5B85\u5FB7\u60B3\u5012\u5200\u5230\u5716\u5835\u5857\u5C0E\u5C60\u5CF6\u5D8B\u5EA6\u5F92\u60BC\u6311\u6389\u6417\u6843"],
      ["d4a1", "\u68F9\u6AC2\u6DD8\u6E21\u6ED4\u6FE4\u71FE\u76DC\u7779\u79B1\u7A3B\u8404\u89A9\u8CED\u8DF3\u8E48\u9003\u9014\u9053\u90FD\u934D\u9676\u97DC\u6BD2\u7006\u7258\u72A2\u7368\u7763\u79BF\u7BE4\u7E9B\u8B80\u58A9\u60C7\u6566\u65FD\u66BE\u6C8C\u711E\u71C9\u8C5A\u9813\u4E6D\u7A81\u4EDD\u51AC\u51CD\u52D5\u540C\u61A7\u6771\u6850\u68DF\u6D1E\u6F7C\u75BC\u77B3\u7AE5\u80F4\u8463\u9285\u515C\u6597\u675C\u6793\u75D8\u7AC7\u8373\uF95A\u8C46\u9017\u982D\u5C6F\u81C0\u829A\u9041\u906F\u920D\u5F97\u5D9D\u6A59\u71C8\u767B\u7B49\u85E4\u8B04\u9127\u9A30\u5587\u61F6\uF95B\u7669\u7F85"],
      ["d5a1", "\u863F\u87BA\u88F8\u908F\uF95C\u6D1B\u70D9\u73DE\u7D61\u843D\uF95D\u916A\u99F1\uF95E\u4E82\u5375\u6B04\u6B12\u703E\u721B\u862D\u9E1E\u524C\u8FA3\u5D50\u64E5\u652C\u6B16\u6FEB\u7C43\u7E9C\u85CD\u8964\u89BD\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u7405\u746F\u8782\u90DE\u4F86\u5D0D\u5FA0\u840A\u51B7\u63A0\u7565\u4EAE\u5006\u5169\u51C9\u6881\u6A11\u7CAE\u7CB1\u7CE7\u826F\u8AD2\u8F1B\u91CF\u4FB6\u5137\u52F5\u5442\u5EEC\u616E\u623E\u65C5\u6ADA\u6FFE\u792A\u85DC\u8823\u95AD\u9A62\u9A6A\u9E97\u9ECE\u529B\u66C6\u6B77\u701D\u792B\u8F62\u9742\u6190\u6200\u6523\u6F23"],
      ["d6a1", "\u7149\u7489\u7DF4\u806F\u84EE\u8F26\u9023\u934A\u51BD\u5217\u52A3\u6D0C\u70C8\u88C2\u5EC9\u6582\u6BAE\u6FC2\u7C3E\u7375\u4EE4\u4F36\u56F9\uF95F\u5CBA\u5DBA\u601C\u73B2\u7B2D\u7F9A\u7FCE\u8046\u901E\u9234\u96F6\u9748\u9818\u9F61\u4F8B\u6FA7\u79AE\u91B4\u96B7\u52DE\uF960\u6488\u64C4\u6AD3\u6F5E\u7018\u7210\u76E7\u8001\u8606\u865C\u8DEF\u8F05\u9732\u9B6F\u9DFA\u9E75\u788C\u797F\u7DA0\u83C9\u9304\u9E7F\u9E93\u8AD6\u58DF\u5F04\u6727\u7027\u74CF\u7C60\u807E\u5121\u7028\u7262\u78CA\u8CC2\u8CDA\u8CF4\u96F7\u4E86\u50DA\u5BEE\u5ED6\u6599\u71CE\u7642\u77AD\u804A\u84FC"],
      ["d7a1", "\u907C\u9B27\u9F8D\u58D8\u5A41\u5C62\u6A13\u6DDA\u6F0F\u763B\u7D2F\u7E37\u851E\u8938\u93E4\u964B\u5289\u65D2\u67F3\u69B4\u6D41\u6E9C\u700F\u7409\u7460\u7559\u7624\u786B\u8B2C\u985E\u516D\u622E\u9678\u4F96\u502B\u5D19\u6DEA\u7DB8\u8F2A\u5F8B\u6144\u6817\uF961\u9686\u52D2\u808B\u51DC\u51CC\u695E\u7A1C\u7DBE\u83F1\u9675\u4FDA\u5229\u5398\u540F\u550E\u5C65\u60A7\u674E\u68A8\u6D6C\u7281\u72F8\u7406\u7483\uF962\u75E2\u7C6C\u7F79\u7FB8\u8389\u88CF\u88E1\u91CC\u91D0\u96E2\u9BC9\u541D\u6F7E\u71D0\u7498\u85FA\u8EAA\u96A3\u9C57\u9E9F\u6797\u6DCB\u7433\u81E8\u9716\u782C"],
      ["d8a1", "\u7ACB\u7B20\u7C92\u6469\u746A\u75F2\u78BC\u78E8\u99AC\u9B54\u9EBB\u5BDE\u5E55\u6F20\u819C\u83AB\u9088\u4E07\u534D\u5A29\u5DD2\u5F4E\u6162\u633D\u6669\u66FC\u6EFF\u6F2B\u7063\u779E\u842C\u8513\u883B\u8F13\u9945\u9C3B\u551C\u62B9\u672B\u6CAB\u8309\u896A\u977A\u4EA1\u5984\u5FD8\u5FD9\u671B\u7DB2\u7F54\u8292\u832B\u83BD\u8F1E\u9099\u57CB\u59B9\u5A92\u5BD0\u6627\u679A\u6885\u6BCF\u7164\u7F75\u8CB7\u8CE3\u9081\u9B45\u8108\u8C8A\u964C\u9A40\u9EA5\u5B5F\u6C13\u731B\u76F2\u76DF\u840C\u51AA\u8993\u514D\u5195\u52C9\u68C9\u6C94\u7704\u7720\u7DBF\u7DEC\u9762\u9EB5\u6EC5"],
      ["d9a1", "\u8511\u51A5\u540D\u547D\u660E\u669D\u6927\u6E9F\u76BF\u7791\u8317\u84C2\u879F\u9169\u9298\u9CF4\u8882\u4FAE\u5192\u52DF\u59C6\u5E3D\u6155\u6478\u6479\u66AE\u67D0\u6A21\u6BCD\u6BDB\u725F\u7261\u7441\u7738\u77DB\u8017\u82BC\u8305\u8B00\u8B28\u8C8C\u6728\u6C90\u7267\u76EE\u7766\u7A46\u9DA9\u6B7F\u6C92\u5922\u6726\u8499\u536F\u5893\u5999\u5EDF\u63CF\u6634\u6773\u6E3A\u732B\u7AD7\u82D7\u9328\u52D9\u5DEB\u61AE\u61CB\u620A\u62C7\u64AB\u65E0\u6959\u6B66\u6BCB\u7121\u73F7\u755D\u7E46\u821E\u8302\u856A\u8AA3\u8CBF\u9727\u9D61\u58A8\u9ED8\u5011\u520E\u543B\u554F\u6587"],
      ["daa1", "\u6C76\u7D0A\u7D0B\u805E\u868A\u9580\u96EF\u52FF\u6C95\u7269\u5473\u5A9A\u5C3E\u5D4B\u5F4C\u5FAE\u672A\u68B6\u6963\u6E3C\u6E44\u7709\u7C73\u7F8E\u8587\u8B0E\u8FF7\u9761\u9EF4\u5CB7\u60B6\u610D\u61AB\u654F\u65FB\u65FC\u6C11\u6CEF\u739F\u73C9\u7DE1\u9594\u5BC6\u871C\u8B10\u525D\u535A\u62CD\u640F\u64B2\u6734\u6A38\u6CCA\u73C0\u749E\u7B94\u7C95\u7E1B\u818A\u8236\u8584\u8FEB\u96F9\u99C1\u4F34\u534A\u53CD\u53DB\u62CC\u642C\u6500\u6591\u69C3\u6CEE\u6F58\u73ED\u7554\u7622\u76E4\u76FC\u78D0\u78FB\u792C\u7D46\u822C\u87E0\u8FD4\u9812\u98EF\u52C3\u62D4\u64A5\u6E24\u6F51"],
      ["dba1", "\u767C\u8DCB\u91B1\u9262\u9AEE\u9B43\u5023\u508D\u574A\u59A8\u5C28\u5E47\u5F77\u623F\u653E\u65B9\u65C1\u6609\u678B\u699C\u6EC2\u78C5\u7D21\u80AA\u8180\u822B\u82B3\u84A1\u868C\u8A2A\u8B17\u90A6\u9632\u9F90\u500D\u4FF3\uF963\u57F9\u5F98\u62DC\u6392\u676F\u6E43\u7119\u76C3\u80CC\u80DA\u88F4\u88F5\u8919\u8CE0\u8F29\u914D\u966A\u4F2F\u4F70\u5E1B\u67CF\u6822\u767D\u767E\u9B44\u5E61\u6A0A\u7169\u71D4\u756A\uF964\u7E41\u8543\u85E9\u98DC\u4F10\u7B4F\u7F70\u95A5\u51E1\u5E06\u68B5\u6C3E\u6C4E\u6CDB\u72AF\u7BC4\u8303\u6CD5\u743A\u50FB\u5288\u58C1\u64D8\u6A97\u74A7\u7656"],
      ["dca1", "\u78A7\u8617\u95E2\u9739\uF965\u535E\u5F01\u8B8A\u8FA8\u8FAF\u908A\u5225\u77A5\u9C49\u9F08\u4E19\u5002\u5175\u5C5B\u5E77\u661E\u663A\u67C4\u68C5\u70B3\u7501\u75C5\u79C9\u7ADD\u8F27\u9920\u9A08\u4FDD\u5821\u5831\u5BF6\u666E\u6B65\u6D11\u6E7A\u6F7D\u73E4\u752B\u83E9\u88DC\u8913\u8B5C\u8F14\u4F0F\u50D5\u5310\u535C\u5B93\u5FA9\u670D\u798F\u8179\u832F\u8514\u8907\u8986\u8F39\u8F3B\u99A5\u9C12\u672C\u4E76\u4FF8\u5949\u5C01\u5CEF\u5CF0\u6367\u68D2\u70FD\u71A2\u742B\u7E2B\u84EC\u8702\u9022\u92D2\u9CF3\u4E0D\u4ED8\u4FEF\u5085\u5256\u526F\u5426\u5490\u57E0\u592B\u5A66"],
      ["dda1", "\u5B5A\u5B75\u5BCC\u5E9C\uF966\u6276\u6577\u65A7\u6D6E\u6EA5\u7236\u7B26\u7C3F\u7F36\u8150\u8151\u819A\u8240\u8299\u83A9\u8A03\u8CA0\u8CE6\u8CFB\u8D74\u8DBA\u90E8\u91DC\u961C\u9644\u99D9\u9CE7\u5317\u5206\u5429\u5674\u58B3\u5954\u596E\u5FFF\u61A4\u626E\u6610\u6C7E\u711A\u76C6\u7C89\u7CDE\u7D1B\u82AC\u8CC1\u96F0\uF967\u4F5B\u5F17\u5F7F\u62C2\u5D29\u670B\u68DA\u787C\u7E43\u9D6C\u4E15\u5099\u5315\u532A\u5351\u5983\u5A62\u5E87\u60B2\u618A\u6249\u6279\u6590\u6787\u69A7\u6BD4\u6BD6\u6BD7\u6BD8\u6CB8\uF968\u7435\u75FA\u7812\u7891\u79D5\u79D8\u7C83\u7DCB\u7FE1\u80A5"],
      ["dea1", "\u813E\u81C2\u83F2\u871A\u88E8\u8AB9\u8B6C\u8CBB\u9119\u975E\u98DB\u9F3B\u56AC\u5B2A\u5F6C\u658C\u6AB3\u6BAF\u6D5C\u6FF1\u7015\u725D\u73AD\u8CA7\u8CD3\u983B\u6191\u6C37\u8058\u9A01\u4E4D\u4E8B\u4E9B\u4ED5\u4F3A\u4F3C\u4F7F\u4FDF\u50FF\u53F2\u53F8\u5506\u55E3\u56DB\u58EB\u5962\u5A11\u5BEB\u5BFA\u5C04\u5DF3\u5E2B\u5F99\u601D\u6368\u659C\u65AF\u67F6\u67FB\u68AD\u6B7B\u6C99\u6CD7\u6E23\u7009\u7345\u7802\u793E\u7940\u7960\u79C1\u7BE9\u7D17\u7D72\u8086\u820D\u838E\u84D1\u86C7\u88DF\u8A50\u8A5E\u8B1D\u8CDC\u8D66\u8FAD\u90AA\u98FC\u99DF\u9E9D\u524A\uF969\u6714\uF96A"],
      ["dfa1", "\u5098\u522A\u5C71\u6563\u6C55\u73CA\u7523\u759D\u7B97\u849C\u9178\u9730\u4E77\u6492\u6BBA\u715E\u85A9\u4E09\uF96B\u6749\u68EE\u6E17\u829F\u8518\u886B\u63F7\u6F81\u9212\u98AF\u4E0A\u50B7\u50CF\u511F\u5546\u55AA\u5617\u5B40\u5C19\u5CE0\u5E38\u5E8A\u5EA0\u5EC2\u60F3\u6851\u6A61\u6E58\u723D\u7240\u72C0\u76F8\u7965\u7BB1\u7FD4\u88F3\u89F4\u8A73\u8C61\u8CDE\u971C\u585E\u74BD\u8CFD\u55C7\uF96C\u7A61\u7D22\u8272\u7272\u751F\u7525\uF96D\u7B19\u5885\u58FB\u5DBC\u5E8F\u5EB6\u5F90\u6055\u6292\u637F\u654D\u6691\u66D9\u66F8\u6816\u68F2\u7280\u745E\u7B6E\u7D6E\u7DD6\u7F72"],
      ["e0a1", "\u80E5\u8212\u85AF\u897F\u8A93\u901D\u92E4\u9ECD\u9F20\u5915\u596D\u5E2D\u60DC\u6614\u6673\u6790\u6C50\u6DC5\u6F5F\u77F3\u78A9\u84C6\u91CB\u932B\u4ED9\u50CA\u5148\u5584\u5B0B\u5BA3\u6247\u657E\u65CB\u6E32\u717D\u7401\u7444\u7487\u74BF\u766C\u79AA\u7DDA\u7E55\u7FA8\u817A\u81B3\u8239\u861A\u87EC\u8A75\u8DE3\u9078\u9291\u9425\u994D\u9BAE\u5368\u5C51\u6954\u6CC4\u6D29\u6E2B\u820C\u859B\u893B\u8A2D\u8AAA\u96EA\u9F67\u5261\u66B9\u6BB2\u7E96\u87FE\u8D0D\u9583\u965D\u651D\u6D89\u71EE\uF96E\u57CE\u59D3\u5BAC\u6027\u60FA\u6210\u661F\u665F\u7329\u73F9\u76DB\u7701\u7B6C"],
      ["e1a1", "\u8056\u8072\u8165\u8AA0\u9192\u4E16\u52E2\u6B72\u6D17\u7A05\u7B39\u7D30\uF96F\u8CB0\u53EC\u562F\u5851\u5BB5\u5C0F\u5C11\u5DE2\u6240\u6383\u6414\u662D\u68B3\u6CBC\u6D88\u6EAF\u701F\u70A4\u71D2\u7526\u758F\u758E\u7619\u7B11\u7BE0\u7C2B\u7D20\u7D39\u852C\u856D\u8607\u8A34\u900D\u9061\u90B5\u92B7\u97F6\u9A37\u4FD7\u5C6C\u675F\u6D91\u7C9F\u7E8C\u8B16\u8D16\u901F\u5B6B\u5DFD\u640D\u84C0\u905C\u98E1\u7387\u5B8B\u609A\u677E\u6DDE\u8A1F\u8AA6\u9001\u980C\u5237\uF970\u7051\u788E\u9396\u8870\u91D7\u4FEE\u53D7\u55FD\u56DA\u5782\u58FD\u5AC2\u5B88\u5CAB\u5CC0\u5E25\u6101"],
      ["e2a1", "\u620D\u624B\u6388\u641C\u6536\u6578\u6A39\u6B8A\u6C34\u6D19\u6F31\u71E7\u72E9\u7378\u7407\u74B2\u7626\u7761\u79C0\u7A57\u7AEA\u7CB9\u7D8F\u7DAC\u7E61\u7F9E\u8129\u8331\u8490\u84DA\u85EA\u8896\u8AB0\u8B90\u8F38\u9042\u9083\u916C\u9296\u92B9\u968B\u96A7\u96A8\u96D6\u9700\u9808\u9996\u9AD3\u9B1A\u53D4\u587E\u5919\u5B70\u5BBF\u6DD1\u6F5A\u719F\u7421\u74B9\u8085\u83FD\u5DE1\u5F87\u5FAA\u6042\u65EC\u6812\u696F\u6A53\u6B89\u6D35\u6DF3\u73E3\u76FE\u77AC\u7B4D\u7D14\u8123\u821C\u8340\u84F4\u8563\u8A62\u8AC4\u9187\u931E\u9806\u99B4\u620C\u8853\u8FF0\u9265\u5D07\u5D27"],
      ["e3a1", "\u5D69\u745F\u819D\u8768\u6FD5\u62FE\u7FD2\u8936\u8972\u4E1E\u4E58\u50E7\u52DD\u5347\u627F\u6607\u7E69\u8805\u965E\u4F8D\u5319\u5636\u59CB\u5AA4\u5C38\u5C4E\u5C4D\u5E02\u5F11\u6043\u65BD\u662F\u6642\u67BE\u67F4\u731C\u77E2\u793A\u7FC5\u8494\u84CD\u8996\u8A66\u8A69\u8AE1\u8C55\u8C7A\u57F4\u5BD4\u5F0F\u606F\u62ED\u690D\u6B96\u6E5C\u7184\u7BD2\u8755\u8B58\u8EFE\u98DF\u98FE\u4F38\u4F81\u4FE1\u547B\u5A20\u5BB8\u613C\u65B0\u6668\u71FC\u7533\u795E\u7D33\u814E\u81E3\u8398\u85AA\u85CE\u8703\u8A0A\u8EAB\u8F9B\uF971\u8FC5\u5931\u5BA4\u5BE6\u6089\u5BE9\u5C0B\u5FC3\u6C81"],
      ["e4a1", "\uF972\u6DF1\u700B\u751A\u82AF\u8AF6\u4EC0\u5341\uF973\u96D9\u6C0F\u4E9E\u4FC4\u5152\u555E\u5A25\u5CE8\u6211\u7259\u82BD\u83AA\u86FE\u8859\u8A1D\u963F\u96C5\u9913\u9D09\u9D5D\u580A\u5CB3\u5DBD\u5E44\u60E1\u6115\u63E1\u6A02\u6E25\u9102\u9354\u984E\u9C10\u9F77\u5B89\u5CB8\u6309\u664F\u6848\u773C\u96C1\u978D\u9854\u9B9F\u65A1\u8B01\u8ECB\u95BC\u5535\u5CA9\u5DD6\u5EB5\u6697\u764C\u83F4\u95C7\u58D3\u62BC\u72CE\u9D28\u4EF0\u592E\u600F\u663B\u6B83\u79E7\u9D26\u5393\u54C0\u57C3\u5D16\u611B\u66D6\u6DAF\u788D\u827E\u9698\u9744\u5384\u627C\u6396\u6DB2\u7E0A\u814B\u984D"],
      ["e5a1", "\u6AFB\u7F4C\u9DAF\u9E1A\u4E5F\u503B\u51B6\u591C\u60F9\u63F6\u6930\u723A\u8036\uF974\u91CE\u5F31\uF975\uF976\u7D04\u82E5\u846F\u84BB\u85E5\u8E8D\uF977\u4F6F\uF978\uF979\u58E4\u5B43\u6059\u63DA\u6518\u656D\u6698\uF97A\u694A\u6A23\u6D0B\u7001\u716C\u75D2\u760D\u79B3\u7A70\uF97B\u7F8A\uF97C\u8944\uF97D\u8B93\u91C0\u967D\uF97E\u990A\u5704\u5FA1\u65BC\u6F01\u7600\u79A6\u8A9E\u99AD\u9B5A\u9F6C\u5104\u61B6\u6291\u6A8D\u81C6\u5043\u5830\u5F66\u7109\u8A00\u8AFA\u5B7C\u8616\u4FFA\u513C\u56B4\u5944\u63A9\u6DF9\u5DAA\u696D\u5186\u4E88\u4F59\uF97F\uF980\uF981\u5982\uF982"],
      ["e6a1", "\uF983\u6B5F\u6C5D\uF984\u74B5\u7916\uF985\u8207\u8245\u8339\u8F3F\u8F5D\uF986\u9918\uF987\uF988\uF989\u4EA6\uF98A\u57DF\u5F79\u6613\uF98B\uF98C\u75AB\u7E79\u8B6F\uF98D\u9006\u9A5B\u56A5\u5827\u59F8\u5A1F\u5BB4\uF98E\u5EF6\uF98F\uF990\u6350\u633B\uF991\u693D\u6C87\u6CBF\u6D8E\u6D93\u6DF5\u6F14\uF992\u70DF\u7136\u7159\uF993\u71C3\u71D5\uF994\u784F\u786F\uF995\u7B75\u7DE3\uF996\u7E2F\uF997\u884D\u8EDF\uF998\uF999\uF99A\u925B\uF99B\u9CF6\uF99C\uF99D\uF99E\u6085\u6D85\uF99F\u71B1\uF9A0\uF9A1\u95B1\u53AD\uF9A2\uF9A3\uF9A4\u67D3\uF9A5\u708E\u7130\u7430\u8276\u82D2"],
      ["e7a1", "\uF9A6\u95BB\u9AE5\u9E7D\u66C4\uF9A7\u71C1\u8449\uF9A8\uF9A9\u584B\uF9AA\uF9AB\u5DB8\u5F71\uF9AC\u6620\u668E\u6979\u69AE\u6C38\u6CF3\u6E36\u6F41\u6FDA\u701B\u702F\u7150\u71DF\u7370\uF9AD\u745B\uF9AE\u74D4\u76C8\u7A4E\u7E93\uF9AF\uF9B0\u82F1\u8A60\u8FCE\uF9B1\u9348\uF9B2\u9719\uF9B3\uF9B4\u4E42\u502A\uF9B5\u5208\u53E1\u66F3\u6C6D\u6FCA\u730A\u777F\u7A62\u82AE\u85DD\u8602\uF9B6\u88D4\u8A63\u8B7D\u8C6B\uF9B7\u92B3\uF9B8\u9713\u9810\u4E94\u4F0D\u4FC9\u50B2\u5348\u543E\u5433\u55DA\u5862\u58BA\u5967\u5A1B\u5BE4\u609F\uF9B9\u61CA\u6556\u65FF\u6664\u68A7\u6C5A\u6FB3"],
      ["e8a1", "\u70CF\u71AC\u7352\u7B7D\u8708\u8AA4\u9C32\u9F07\u5C4B\u6C83\u7344\u7389\u923A\u6EAB\u7465\u761F\u7A69\u7E15\u860A\u5140\u58C5\u64C1\u74EE\u7515\u7670\u7FC1\u9095\u96CD\u9954\u6E26\u74E6\u7AA9\u7AAA\u81E5\u86D9\u8778\u8A1B\u5A49\u5B8C\u5B9B\u68A1\u6900\u6D63\u73A9\u7413\u742C\u7897\u7DE9\u7FEB\u8118\u8155\u839E\u8C4C\u962E\u9811\u66F0\u5F80\u65FA\u6789\u6C6A\u738B\u502D\u5A03\u6B6A\u77EE\u5916\u5D6C\u5DCD\u7325\u754F\uF9BA\uF9BB\u50E5\u51F9\u582F\u592D\u5996\u59DA\u5BE5\uF9BC\uF9BD\u5DA2\u62D7\u6416\u6493\u64FE\uF9BE\u66DC\uF9BF\u6A48\uF9C0\u71FF\u7464\uF9C1"],
      ["e9a1", "\u7A88\u7AAF\u7E47\u7E5E\u8000\u8170\uF9C2\u87EF\u8981\u8B20\u9059\uF9C3\u9080\u9952\u617E\u6B32\u6D74\u7E1F\u8925\u8FB1\u4FD1\u50AD\u5197\u52C7\u57C7\u5889\u5BB9\u5EB8\u6142\u6995\u6D8C\u6E67\u6EB6\u7194\u7462\u7528\u752C\u8073\u8338\u84C9\u8E0A\u9394\u93DE\uF9C4\u4E8E\u4F51\u5076\u512A\u53C8\u53CB\u53F3\u5B87\u5BD3\u5C24\u611A\u6182\u65F4\u725B\u7397\u7440\u76C2\u7950\u7991\u79B9\u7D06\u7FBD\u828B\u85D5\u865E\u8FC2\u9047\u90F5\u91EA\u9685\u96E8\u96E9\u52D6\u5F67\u65ED\u6631\u682F\u715C\u7A36\u90C1\u980A\u4E91\uF9C5\u6A52\u6B9E\u6F90\u7189\u8018\u82B8\u8553"],
      ["eaa1", "\u904B\u9695\u96F2\u97FB\u851A\u9B31\u4E90\u718A\u96C4\u5143\u539F\u54E1\u5713\u5712\u57A3\u5A9B\u5AC4\u5BC3\u6028\u613F\u63F4\u6C85\u6D39\u6E72\u6E90\u7230\u733F\u7457\u82D1\u8881\u8F45\u9060\uF9C6\u9662\u9858\u9D1B\u6708\u8D8A\u925E\u4F4D\u5049\u50DE\u5371\u570D\u59D4\u5A01\u5C09\u6170\u6690\u6E2D\u7232\u744B\u7DEF\u80C3\u840E\u8466\u853F\u875F\u885B\u8918\u8B02\u9055\u97CB\u9B4F\u4E73\u4F91\u5112\u516A\uF9C7\u552F\u55A9\u5B7A\u5BA5\u5E7C\u5E7D\u5EBE\u60A0\u60DF\u6108\u6109\u63C4\u6538\u6709\uF9C8\u67D4\u67DA\uF9C9\u6961\u6962\u6CB9\u6D27\uF9CA\u6E38\uF9CB"],
      ["eba1", "\u6FE1\u7336\u7337\uF9CC\u745C\u7531\uF9CD\u7652\uF9CE\uF9CF\u7DAD\u81FE\u8438\u88D5\u8A98\u8ADB\u8AED\u8E30\u8E42\u904A\u903E\u907A\u9149\u91C9\u936E\uF9D0\uF9D1\u5809\uF9D2\u6BD3\u8089\u80B2\uF9D3\uF9D4\u5141\u596B\u5C39\uF9D5\uF9D6\u6F64\u73A7\u80E4\u8D07\uF9D7\u9217\u958F\uF9D8\uF9D9\uF9DA\uF9DB\u807F\u620E\u701C\u7D68\u878D\uF9DC\u57A0\u6069\u6147\u6BB7\u8ABE\u9280\u96B1\u4E59\u541F\u6DEB\u852D\u9670\u97F3\u98EE\u63D6\u6CE3\u9091\u51DD\u61C9\u81BA\u9DF9\u4F9D\u501A\u5100\u5B9C\u610F\u61FF\u64EC\u6905\u6BC5\u7591\u77E3\u7FA9\u8264\u858F\u87FB\u8863\u8ABC"],
      ["eca1", "\u8B70\u91AB\u4E8C\u4EE5\u4F0A\uF9DD\uF9DE\u5937\u59E8\uF9DF\u5DF2\u5F1B\u5F5B\u6021\uF9E0\uF9E1\uF9E2\uF9E3\u723E\u73E5\uF9E4\u7570\u75CD\uF9E5\u79FB\uF9E6\u800C\u8033\u8084\u82E1\u8351\uF9E7\uF9E8\u8CBD\u8CB3\u9087\uF9E9\uF9EA\u98F4\u990C\uF9EB\uF9EC\u7037\u76CA\u7FCA\u7FCC\u7FFC\u8B1A\u4EBA\u4EC1\u5203\u5370\uF9ED\u54BD\u56E0\u59FB\u5BC5\u5F15\u5FCD\u6E6E\uF9EE\uF9EF\u7D6A\u8335\uF9F0\u8693\u8A8D\uF9F1\u976D\u9777\uF9F2\uF9F3\u4E00\u4F5A\u4F7E\u58F9\u65E5\u6EA2\u9038\u93B0\u99B9\u4EFB\u58EC\u598A\u59D9\u6041\uF9F4\uF9F5\u7A14\uF9F6\u834F\u8CC3\u5165\u5344"],
      ["eda1", "\uF9F7\uF9F8\uF9F9\u4ECD\u5269\u5B55\u82BF\u4ED4\u523A\u54A8\u59C9\u59FF\u5B50\u5B57\u5B5C\u6063\u6148\u6ECB\u7099\u716E\u7386\u74F7\u75B5\u78C1\u7D2B\u8005\u81EA\u8328\u8517\u85C9\u8AEE\u8CC7\u96CC\u4F5C\u52FA\u56BC\u65AB\u6628\u707C\u70B8\u7235\u7DBD\u828D\u914C\u96C0\u9D72\u5B71\u68E7\u6B98\u6F7A\u76DE\u5C91\u66AB\u6F5B\u7BB4\u7C2A\u8836\u96DC\u4E08\u4ED7\u5320\u5834\u58BB\u58EF\u596C\u5C07\u5E33\u5E84\u5F35\u638C\u66B2\u6756\u6A1F\u6AA3\u6B0C\u6F3F\u7246\uF9FA\u7350\u748B\u7AE0\u7CA7\u8178\u81DF\u81E7\u838A\u846C\u8523\u8594\u85CF\u88DD\u8D13\u91AC\u9577"],
      ["eea1", "\u969C\u518D\u54C9\u5728\u5BB0\u624D\u6750\u683D\u6893\u6E3D\u6ED3\u707D\u7E21\u88C1\u8CA1\u8F09\u9F4B\u9F4E\u722D\u7B8F\u8ACD\u931A\u4F47\u4F4E\u5132\u5480\u59D0\u5E95\u62B5\u6775\u696E\u6A17\u6CAE\u6E1A\u72D9\u732A\u75BD\u7BB8\u7D35\u82E7\u83F9\u8457\u85F7\u8A5B\u8CAF\u8E87\u9019\u90B8\u96CE\u9F5F\u52E3\u540A\u5AE1\u5BC2\u6458\u6575\u6EF4\u72C4\uF9FB\u7684\u7A4D\u7B1B\u7C4D\u7E3E\u7FDF\u837B\u8B2B\u8CCA\u8D64\u8DE1\u8E5F\u8FEA\u8FF9\u9069\u93D1\u4F43\u4F7A\u50B3\u5168\u5178\u524D\u526A\u5861\u587C\u5960\u5C08\u5C55\u5EDB\u609B\u6230\u6813\u6BBF\u6C08\u6FB1"],
      ["efa1", "\u714E\u7420\u7530\u7538\u7551\u7672\u7B4C\u7B8B\u7BAD\u7BC6\u7E8F\u8A6E\u8F3E\u8F49\u923F\u9293\u9322\u942B\u96FB\u985A\u986B\u991E\u5207\u622A\u6298\u6D59\u7664\u7ACA\u7BC0\u7D76\u5360\u5CBE\u5E97\u6F38\u70B9\u7C98\u9711\u9B8E\u9EDE\u63A5\u647A\u8776\u4E01\u4E95\u4EAD\u505C\u5075\u5448\u59C3\u5B9A\u5E40\u5EAD\u5EF7\u5F81\u60C5\u633A\u653F\u6574\u65CC\u6676\u6678\u67FE\u6968\u6A89\u6B63\u6C40\u6DC0\u6DE8\u6E1F\u6E5E\u701E\u70A1\u738E\u73FD\u753A\u775B\u7887\u798E\u7A0B\u7A7D\u7CBE\u7D8E\u8247\u8A02\u8AEA\u8C9E\u912D\u914A\u91D8\u9266\u92CC\u9320\u9706\u9756"],
      ["f0a1", "\u975C\u9802\u9F0E\u5236\u5291\u557C\u5824\u5E1D\u5F1F\u608C\u63D0\u68AF\u6FDF\u796D\u7B2C\u81CD\u85BA\u88FD\u8AF8\u8E44\u918D\u9664\u969B\u973D\u984C\u9F4A\u4FCE\u5146\u51CB\u52A9\u5632\u5F14\u5F6B\u63AA\u64CD\u65E9\u6641\u66FA\u66F9\u671D\u689D\u68D7\u69FD\u6F15\u6F6E\u7167\u71E5\u722A\u74AA\u773A\u7956\u795A\u79DF\u7A20\u7A95\u7C97\u7CDF\u7D44\u7E70\u8087\u85FB\u86A4\u8A54\u8ABF\u8D99\u8E81\u9020\u906D\u91E3\u963B\u96D5\u9CE5\u65CF\u7C07\u8DB3\u93C3\u5B58\u5C0A\u5352\u62D9\u731D\u5027\u5B97\u5F9E\u60B0\u616B\u68D5\u6DD9\u742E\u7A2E\u7D42\u7D9C\u7E31\u816B"],
      ["f1a1", "\u8E2A\u8E35\u937E\u9418\u4F50\u5750\u5DE6\u5EA7\u632B\u7F6A\u4E3B\u4F4F\u4F8F\u505A\u59DD\u80C4\u546A\u5468\u55FE\u594F\u5B99\u5DDE\u5EDA\u665D\u6731\u67F1\u682A\u6CE8\u6D32\u6E4A\u6F8D\u70B7\u73E0\u7587\u7C4C\u7D02\u7D2C\u7DA2\u821F\u86DB\u8A3B\u8A85\u8D70\u8E8A\u8F33\u9031\u914E\u9152\u9444\u99D0\u7AF9\u7CA5\u4FCA\u5101\u51C6\u57C8\u5BEF\u5CFB\u6659\u6A3D\u6D5A\u6E96\u6FEC\u710C\u756F\u7AE3\u8822\u9021\u9075\u96CB\u99FF\u8301\u4E2D\u4EF2\u8846\u91CD\u537D\u6ADB\u696B\u6C41\u847A\u589E\u618E\u66FE\u62EF\u70DD\u7511\u75C7\u7E52\u84B8\u8B49\u8D08\u4E4B\u53EA"],
      ["f2a1", "\u54AB\u5730\u5740\u5FD7\u6301\u6307\u646F\u652F\u65E8\u667A\u679D\u67B3\u6B62\u6C60\u6C9A\u6F2C\u77E5\u7825\u7949\u7957\u7D19\u80A2\u8102\u81F3\u829D\u82B7\u8718\u8A8C\uF9FC\u8D04\u8DBE\u9072\u76F4\u7A19\u7A37\u7E54\u8077\u5507\u55D4\u5875\u632F\u6422\u6649\u664B\u686D\u699B\u6B84\u6D25\u6EB1\u73CD\u7468\u74A1\u755B\u75B9\u76E1\u771E\u778B\u79E6\u7E09\u7E1D\u81FB\u852F\u8897\u8A3A\u8CD1\u8EEB\u8FB0\u9032\u93AD\u9663\u9673\u9707\u4F84\u53F1\u59EA\u5AC9\u5E19\u684E\u74C6\u75BE\u79E9\u7A92\u81A3\u86ED\u8CEA\u8DCC\u8FED\u659F\u6715\uF9FD\u57F7\u6F57\u7DDD\u8F2F"],
      ["f3a1", "\u93F6\u96C6\u5FB5\u61F2\u6F84\u4E14\u4F98\u501F\u53C9\u55DF\u5D6F\u5DEE\u6B21\u6B64\u78CB\u7B9A\uF9FE\u8E49\u8ECA\u906E\u6349\u643E\u7740\u7A84\u932F\u947F\u9F6A\u64B0\u6FAF\u71E6\u74A8\u74DA\u7AC4\u7C12\u7E82\u7CB2\u7E98\u8B9A\u8D0A\u947D\u9910\u994C\u5239\u5BDF\u64E6\u672D\u7D2E\u50ED\u53C3\u5879\u6158\u6159\u61FA\u65AC\u7AD9\u8B92\u8B96\u5009\u5021\u5275\u5531\u5A3C\u5EE0\u5F70\u6134\u655E\u660C\u6636\u66A2\u69CD\u6EC4\u6F32\u7316\u7621\u7A93\u8139\u8259\u83D6\u84BC\u50B5\u57F0\u5BC0\u5BE8\u5F69\u63A1\u7826\u7DB5\u83DC\u8521\u91C7\u91F5\u518A\u67F5\u7B56"],
      ["f4a1", "\u8CAC\u51C4\u59BB\u60BD\u8655\u501C\uF9FF\u5254\u5C3A\u617D\u621A\u62D3\u64F2\u65A5\u6ECC\u7620\u810A\u8E60\u965F\u96BB\u4EDF\u5343\u5598\u5929\u5DDD\u64C5\u6CC9\u6DFA\u7394\u7A7F\u821B\u85A6\u8CE4\u8E10\u9077\u91E7\u95E1\u9621\u97C6\u51F8\u54F2\u5586\u5FB9\u64A4\u6F88\u7DB4\u8F1F\u8F4D\u9435\u50C9\u5C16\u6CBE\u6DFB\u751B\u77BB\u7C3D\u7C64\u8A79\u8AC2\u581E\u59BE\u5E16\u6377\u7252\u758A\u776B\u8ADC\u8CBC\u8F12\u5EF3\u6674\u6DF8\u807D\u83C1\u8ACB\u9751\u9BD6\uFA00\u5243\u66FF\u6D95\u6EEF\u7DE0\u8AE6\u902E\u905E\u9AD4\u521D\u527F\u54E8\u6194\u6284\u62DB\u68A2"],
      ["f5a1", "\u6912\u695A\u6A35\u7092\u7126\u785D\u7901\u790E\u79D2\u7A0D\u8096\u8278\u82D5\u8349\u8549\u8C82\u8D85\u9162\u918B\u91AE\u4FC3\u56D1\u71ED\u77D7\u8700\u89F8\u5BF8\u5FD6\u6751\u90A8\u53E2\u585A\u5BF5\u60A4\u6181\u6460\u7E3D\u8070\u8525\u9283\u64AE\u50AC\u5D14\u6700\u589C\u62BD\u63A8\u690E\u6978\u6A1E\u6E6B\u76BA\u79CB\u82BB\u8429\u8ACF\u8DA8\u8FFD\u9112\u914B\u919C\u9310\u9318\u939A\u96DB\u9A36\u9C0D\u4E11\u755C\u795D\u7AFA\u7B51\u7BC9\u7E2E\u84C4\u8E59\u8E74\u8EF8\u9010\u6625\u693F\u7443\u51FA\u672E\u9EDC\u5145\u5FE0\u6C96\u87F2\u885D\u8877\u60B4\u81B5\u8403"],
      ["f6a1", "\u8D05\u53D6\u5439\u5634\u5A36\u5C31\u708A\u7FE0\u805A\u8106\u81ED\u8DA3\u9189\u9A5F\u9DF2\u5074\u4EC4\u53A0\u60FB\u6E2C\u5C64\u4F88\u5024\u55E4\u5CD9\u5E5F\u6065\u6894\u6CBB\u6DC4\u71BE\u75D4\u75F4\u7661\u7A1A\u7A49\u7DC7\u7DFB\u7F6E\u81F4\u86A9\u8F1C\u96C9\u99B3\u9F52\u5247\u52C5\u98ED\u89AA\u4E03\u67D2\u6F06\u4FB5\u5BE2\u6795\u6C88\u6D78\u741B\u7827\u91DD\u937C\u87C4\u79E4\u7A31\u5FEB\u4ED6\u54A4\u553E\u58AE\u59A5\u60F0\u6253\u62D6\u6736\u6955\u8235\u9640\u99B1\u99DD\u502C\u5353\u5544\u577C\uFA01\u6258\uFA02\u64E2\u666B\u67DD\u6FC1\u6FEF\u7422\u7438\u8A17"],
      ["f7a1", "\u9438\u5451\u5606\u5766\u5F48\u619A\u6B4E\u7058\u70AD\u7DBB\u8A95\u596A\u812B\u63A2\u7708\u803D\u8CAA\u5854\u642D\u69BB\u5B95\u5E11\u6E6F\uFA03\u8569\u514C\u53F0\u592A\u6020\u614B\u6B86\u6C70\u6CF0\u7B1E\u80CE\u82D4\u8DC6\u90B0\u98B1\uFA04\u64C7\u6FA4\u6491\u6504\u514E\u5410\u571F\u8A0E\u615F\u6876\uFA05\u75DB\u7B52\u7D71\u901A\u5806\u69CC\u817F\u892A\u9000\u9839\u5078\u5957\u59AC\u6295\u900F\u9B2A\u615D\u7279\u95D6\u5761\u5A46\u5DF4\u628A\u64AD\u64FA\u6777\u6CE2\u6D3E\u722C\u7436\u7834\u7F77\u82AD\u8DDB\u9817\u5224\u5742\u677F\u7248\u74E3\u8CA9\u8FA6\u9211"],
      ["f8a1", "\u962A\u516B\u53ED\u634C\u4F69\u5504\u6096\u6557\u6C9B\u6D7F\u724C\u72FD\u7A17\u8987\u8C9D\u5F6D\u6F8E\u70F9\u81A8\u610E\u4FBF\u504F\u6241\u7247\u7BC7\u7DE8\u7FE9\u904D\u97AD\u9A19\u8CB6\u576A\u5E73\u67B0\u840D\u8A55\u5420\u5B16\u5E63\u5EE2\u5F0A\u6583\u80BA\u853D\u9589\u965B\u4F48\u5305\u530D\u530F\u5486\u54FA\u5703\u5E03\u6016\u629B\u62B1\u6355\uFA06\u6CE1\u6D66\u75B1\u7832\u80DE\u812F\u82DE\u8461\u84B2\u888D\u8912\u900B\u92EA\u98FD\u9B91\u5E45\u66B4\u66DD\u7011\u7206\uFA07\u4FF5\u527D\u5F6A\u6153\u6753\u6A19\u6F02\u74E2\u7968\u8868\u8C79\u98C7\u98C4\u9A43"],
      ["f9a1", "\u54C1\u7A1F\u6953\u8AF7\u8C4A\u98A8\u99AE\u5F7C\u62AB\u75B2\u76AE\u88AB\u907F\u9642\u5339\u5F3C\u5FC5\u6CCC\u73CC\u7562\u758B\u7B46\u82FE\u999D\u4E4F\u903C\u4E0B\u4F55\u53A6\u590F\u5EC8\u6630\u6CB3\u7455\u8377\u8766\u8CC0\u9050\u971E\u9C15\u58D1\u5B78\u8650\u8B14\u9DB4\u5BD2\u6068\u608D\u65F1\u6C57\u6F22\u6FA3\u701A\u7F55\u7FF0\u9591\u9592\u9650\u97D3\u5272\u8F44\u51FD\u542B\u54B8\u5563\u558A\u6ABB\u6DB5\u7DD8\u8266\u929C\u9677\u9E79\u5408\u54C8\u76D2\u86E4\u95A4\u95D4\u965C\u4EA2\u4F09\u59EE\u5AE6\u5DF7\u6052\u6297\u676D\u6841\u6C86\u6E2F\u7F38\u809B\u822A"],
      ["faa1", "\uFA08\uFA09\u9805\u4EA5\u5055\u54B3\u5793\u595A\u5B69\u5BB3\u61C8\u6977\u6D77\u7023\u87F9\u89E3\u8A72\u8AE7\u9082\u99ED\u9AB8\u52BE\u6838\u5016\u5E78\u674F\u8347\u884C\u4EAB\u5411\u56AE\u73E6\u9115\u97FF\u9909\u9957\u9999\u5653\u589F\u865B\u8A31\u61B2\u6AF6\u737B\u8ED2\u6B47\u96AA\u9A57\u5955\u7200\u8D6B\u9769\u4FD4\u5CF4\u5F26\u61F8\u665B\u6CEB\u70AB\u7384\u73B9\u73FE\u7729\u774D\u7D43\u7D62\u7E23\u8237\u8852\uFA0A\u8CE2\u9249\u986F\u5B51\u7A74\u8840\u9801\u5ACC\u4FE0\u5354\u593E\u5CFD\u633E\u6D79\u72F9\u8105\u8107\u83A2\u92CF\u9830\u4EA8\u5144\u5211\u578B"],
      ["fba1", "\u5F62\u6CC2\u6ECE\u7005\u7050\u70AF\u7192\u73E9\u7469\u834A\u87A2\u8861\u9008\u90A2\u93A3\u99A8\u516E\u5F57\u60E0\u6167\u66B3\u8559\u8E4A\u91AF\u978B\u4E4E\u4E92\u547C\u58D5\u58FA\u597D\u5CB5\u5F27\u6236\u6248\u660A\u6667\u6BEB\u6D69\u6DCF\u6E56\u6EF8\u6F94\u6FE0\u6FE9\u705D\u72D0\u7425\u745A\u74E0\u7693\u795C\u7CCA\u7E1E\u80E1\u82A6\u846B\u84BF\u864E\u865F\u8774\u8B77\u8C6A\u93AC\u9800\u9865\u60D1\u6216\u9177\u5A5A\u660F\u6DF7\u6E3E\u743F\u9B42\u5FFD\u60DA\u7B0F\u54C4\u5F18\u6C5E\u6CD3\u6D2A\u70D8\u7D05\u8679\u8A0C\u9D3B\u5316\u548C\u5B05\u6A3A\u706B\u7575"],
      ["fca1", "\u798D\u79BE\u82B1\u83EF\u8A71\u8B41\u8CA8\u9774\uFA0B\u64F4\u652B\u78BA\u78BB\u7A6B\u4E38\u559A\u5950\u5BA6\u5E7B\u60A3\u63DB\u6B61\u6665\u6853\u6E19\u7165\u74B0\u7D08\u9084\u9A69\u9C25\u6D3B\u6ED1\u733E\u8C41\u95CA\u51F0\u5E4C\u5FA8\u604D\u60F6\u6130\u614C\u6643\u6644\u69A5\u6CC1\u6E5F\u6EC9\u6F62\u714C\u749C\u7687\u7BC1\u7C27\u8352\u8757\u9051\u968D\u9EC3\u532F\u56DE\u5EFB\u5F8A\u6062\u6094\u61F7\u6666\u6703\u6A9C\u6DEE\u6FAE\u7070\u736A\u7E6A\u81BE\u8334\u86D4\u8AA8\u8CC4\u5283\u7372\u5B96\u6A6B\u9404\u54EE\u5686\u5B5D\u6548\u6585\u66C9\u689F\u6D8D\u6DC6"],
      ["fda1", "\u723B\u80B4\u9175\u9A4D\u4FAF\u5019\u539A\u540E\u543C\u5589\u55C5\u5E3F\u5F8C\u673D\u7166\u73DD\u9005\u52DB\u52F3\u5864\u58CE\u7104\u718F\u71FB\u85B0\u8A13\u6688\u85A8\u55A7\u6684\u714A\u8431\u5349\u5599\u6BC1\u5F59\u5FBD\u63EE\u6689\u7147\u8AF1\u8F1D\u9EBE\u4F11\u643A\u70CB\u7566\u8667\u6064\u8B4E\u9DF8\u5147\u51F6\u5308\u6D36\u80F8\u9ED1\u6615\u6B23\u7098\u75D5\u5403\u5C79\u7D07\u8A16\u6B20\u6B3D\u6B46\u5438\u6070\u6D3D\u7FD5\u8208\u50D6\u51DE\u559C\u566B\u56CD\u59EC\u5B09\u5E0C\u6199\u6198\u6231\u665E\u66E6\u7199\u71B9\u71BA\u72A7\u79A7\u7A00\u7FB2\u8A70"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp950.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["a140", "\u3000\uFF0C\u3001\u3002\uFF0E\u2027\uFF1B\uFF1A\uFF1F\uFF01\uFE30\u2026\u2025\uFE50\uFE51\uFE52\xB7\uFE54\uFE55\uFE56\uFE57\uFF5C\u2013\uFE31\u2014\uFE33\u2574\uFE34\uFE4F\uFF08\uFF09\uFE35\uFE36\uFF5B\uFF5D\uFE37\uFE38\u3014\u3015\uFE39\uFE3A\u3010\u3011\uFE3B\uFE3C\u300A\u300B\uFE3D\uFE3E\u3008\u3009\uFE3F\uFE40\u300C\u300D\uFE41\uFE42\u300E\u300F\uFE43\uFE44\uFE59\uFE5A"],
      ["a1a1", "\uFE5B\uFE5C\uFE5D\uFE5E\u2018\u2019\u201C\u201D\u301D\u301E\u2035\u2032\uFF03\uFF06\uFF0A\u203B\xA7\u3003\u25CB\u25CF\u25B3\u25B2\u25CE\u2606\u2605\u25C7\u25C6\u25A1\u25A0\u25BD\u25BC\u32A3\u2105\xAF\uFFE3\uFF3F\u02CD\uFE49\uFE4A\uFE4D\uFE4E\uFE4B\uFE4C\uFE5F\uFE60\uFE61\uFF0B\uFF0D\xD7\xF7\xB1\u221A\uFF1C\uFF1E\uFF1D\u2266\u2267\u2260\u221E\u2252\u2261\uFE62", 4, "\uFF5E\u2229\u222A\u22A5\u2220\u221F\u22BF\u33D2\u33D1\u222B\u222E\u2235\u2234\u2640\u2642\u2295\u2299\u2191\u2193\u2190\u2192\u2196\u2197\u2199\u2198\u2225\u2223\uFF0F"],
      ["a240", "\uFF3C\u2215\uFE68\uFF04\uFFE5\u3012\uFFE0\uFFE1\uFF05\uFF20\u2103\u2109\uFE69\uFE6A\uFE6B\u33D5\u339C\u339D\u339E\u33CE\u33A1\u338E\u338F\u33C4\xB0\u5159\u515B\u515E\u515D\u5161\u5163\u55E7\u74E9\u7CCE\u2581", 7, "\u258F\u258E\u258D\u258C\u258B\u258A\u2589\u253C\u2534\u252C\u2524\u251C\u2594\u2500\u2502\u2595\u250C\u2510\u2514\u2518\u256D"],
      ["a2a1", "\u256E\u2570\u256F\u2550\u255E\u256A\u2561\u25E2\u25E3\u25E5\u25E4\u2571\u2572\u2573\uFF10", 9, "\u2160", 9, "\u3021", 8, "\u5341\u5344\u5345\uFF21", 25, "\uFF41", 21],
      ["a340", "\uFF57\uFF58\uFF59\uFF5A\u0391", 16, "\u03A3", 6, "\u03B1", 16, "\u03C3", 6, "\u3105", 10],
      ["a3a1", "\u3110", 25, "\u02D9\u02C9\u02CA\u02C7\u02CB"],
      ["a3e1", "\u20AC"],
      ["a440", "\u4E00\u4E59\u4E01\u4E03\u4E43\u4E5D\u4E86\u4E8C\u4EBA\u513F\u5165\u516B\u51E0\u5200\u5201\u529B\u5315\u5341\u535C\u53C8\u4E09\u4E0B\u4E08\u4E0A\u4E2B\u4E38\u51E1\u4E45\u4E48\u4E5F\u4E5E\u4E8E\u4EA1\u5140\u5203\u52FA\u5343\u53C9\u53E3\u571F\u58EB\u5915\u5927\u5973\u5B50\u5B51\u5B53\u5BF8\u5C0F\u5C22\u5C38\u5C71\u5DDD\u5DE5\u5DF1\u5DF2\u5DF3\u5DFE\u5E72\u5EFE\u5F0B\u5F13\u624D"],
      ["a4a1", "\u4E11\u4E10\u4E0D\u4E2D\u4E30\u4E39\u4E4B\u5C39\u4E88\u4E91\u4E95\u4E92\u4E94\u4EA2\u4EC1\u4EC0\u4EC3\u4EC6\u4EC7\u4ECD\u4ECA\u4ECB\u4EC4\u5143\u5141\u5167\u516D\u516E\u516C\u5197\u51F6\u5206\u5207\u5208\u52FB\u52FE\u52FF\u5316\u5339\u5348\u5347\u5345\u535E\u5384\u53CB\u53CA\u53CD\u58EC\u5929\u592B\u592A\u592D\u5B54\u5C11\u5C24\u5C3A\u5C6F\u5DF4\u5E7B\u5EFF\u5F14\u5F15\u5FC3\u6208\u6236\u624B\u624E\u652F\u6587\u6597\u65A4\u65B9\u65E5\u66F0\u6708\u6728\u6B20\u6B62\u6B79\u6BCB\u6BD4\u6BDB\u6C0F\u6C34\u706B\u722A\u7236\u723B\u7247\u7259\u725B\u72AC\u738B\u4E19"],
      ["a540", "\u4E16\u4E15\u4E14\u4E18\u4E3B\u4E4D\u4E4F\u4E4E\u4EE5\u4ED8\u4ED4\u4ED5\u4ED6\u4ED7\u4EE3\u4EE4\u4ED9\u4EDE\u5145\u5144\u5189\u518A\u51AC\u51F9\u51FA\u51F8\u520A\u52A0\u529F\u5305\u5306\u5317\u531D\u4EDF\u534A\u5349\u5361\u5360\u536F\u536E\u53BB\u53EF\u53E4\u53F3\u53EC\u53EE\u53E9\u53E8\u53FC\u53F8\u53F5\u53EB\u53E6\u53EA\u53F2\u53F1\u53F0\u53E5\u53ED\u53FB\u56DB\u56DA\u5916"],
      ["a5a1", "\u592E\u5931\u5974\u5976\u5B55\u5B83\u5C3C\u5DE8\u5DE7\u5DE6\u5E02\u5E03\u5E73\u5E7C\u5F01\u5F18\u5F17\u5FC5\u620A\u6253\u6254\u6252\u6251\u65A5\u65E6\u672E\u672C\u672A\u672B\u672D\u6B63\u6BCD\u6C11\u6C10\u6C38\u6C41\u6C40\u6C3E\u72AF\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7529\u7530\u7531\u7532\u7533\u758B\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79BE\u7A74\u7ACB\u4E1E\u4E1F\u4E52\u4E53\u4E69\u4E99\u4EA4\u4EA6\u4EA5\u4EFF\u4F09\u4F19\u4F0A\u4F15\u4F0D\u4F10\u4F11\u4F0F\u4EF2\u4EF6\u4EFB\u4EF0\u4EF3\u4EFD\u4F01\u4F0B\u5149\u5147\u5146\u5148\u5168"],
      ["a640", "\u5171\u518D\u51B0\u5217\u5211\u5212\u520E\u5216\u52A3\u5308\u5321\u5320\u5370\u5371\u5409\u540F\u540C\u540A\u5410\u5401\u540B\u5404\u5411\u540D\u5408\u5403\u540E\u5406\u5412\u56E0\u56DE\u56DD\u5733\u5730\u5728\u572D\u572C\u572F\u5729\u5919\u591A\u5937\u5938\u5984\u5978\u5983\u597D\u5979\u5982\u5981\u5B57\u5B58\u5B87\u5B88\u5B85\u5B89\u5BFA\u5C16\u5C79\u5DDE\u5E06\u5E76\u5E74"],
      ["a6a1", "\u5F0F\u5F1B\u5FD9\u5FD6\u620E\u620C\u620D\u6210\u6263\u625B\u6258\u6536\u65E9\u65E8\u65EC\u65ED\u66F2\u66F3\u6709\u673D\u6734\u6731\u6735\u6B21\u6B64\u6B7B\u6C16\u6C5D\u6C57\u6C59\u6C5F\u6C60\u6C50\u6C55\u6C61\u6C5B\u6C4D\u6C4E\u7070\u725F\u725D\u767E\u7AF9\u7C73\u7CF8\u7F36\u7F8A\u7FBD\u8001\u8003\u800C\u8012\u8033\u807F\u8089\u808B\u808C\u81E3\u81EA\u81F3\u81FC\u820C\u821B\u821F\u826E\u8272\u827E\u866B\u8840\u884C\u8863\u897F\u9621\u4E32\u4EA8\u4F4D\u4F4F\u4F47\u4F57\u4F5E\u4F34\u4F5B\u4F55\u4F30\u4F50\u4F51\u4F3D\u4F3A\u4F38\u4F43\u4F54\u4F3C\u4F46\u4F63"],
      ["a740", "\u4F5C\u4F60\u4F2F\u4F4E\u4F36\u4F59\u4F5D\u4F48\u4F5A\u514C\u514B\u514D\u5175\u51B6\u51B7\u5225\u5224\u5229\u522A\u5228\u52AB\u52A9\u52AA\u52AC\u5323\u5373\u5375\u541D\u542D\u541E\u543E\u5426\u544E\u5427\u5446\u5443\u5433\u5448\u5442\u541B\u5429\u544A\u5439\u543B\u5438\u542E\u5435\u5436\u5420\u543C\u5440\u5431\u542B\u541F\u542C\u56EA\u56F0\u56E4\u56EB\u574A\u5751\u5740\u574D"],
      ["a7a1", "\u5747\u574E\u573E\u5750\u574F\u573B\u58EF\u593E\u599D\u5992\u59A8\u599E\u59A3\u5999\u5996\u598D\u59A4\u5993\u598A\u59A5\u5B5D\u5B5C\u5B5A\u5B5B\u5B8C\u5B8B\u5B8F\u5C2C\u5C40\u5C41\u5C3F\u5C3E\u5C90\u5C91\u5C94\u5C8C\u5DEB\u5E0C\u5E8F\u5E87\u5E8A\u5EF7\u5F04\u5F1F\u5F64\u5F62\u5F77\u5F79\u5FD8\u5FCC\u5FD7\u5FCD\u5FF1\u5FEB\u5FF8\u5FEA\u6212\u6211\u6284\u6297\u6296\u6280\u6276\u6289\u626D\u628A\u627C\u627E\u6279\u6273\u6292\u626F\u6298\u626E\u6295\u6293\u6291\u6286\u6539\u653B\u6538\u65F1\u66F4\u675F\u674E\u674F\u6750\u6751\u675C\u6756\u675E\u6749\u6746\u6760"],
      ["a840", "\u6753\u6757\u6B65\u6BCF\u6C42\u6C5E\u6C99\u6C81\u6C88\u6C89\u6C85\u6C9B\u6C6A\u6C7A\u6C90\u6C70\u6C8C\u6C68\u6C96\u6C92\u6C7D\u6C83\u6C72\u6C7E\u6C74\u6C86\u6C76\u6C8D\u6C94\u6C98\u6C82\u7076\u707C\u707D\u7078\u7262\u7261\u7260\u72C4\u72C2\u7396\u752C\u752B\u7537\u7538\u7682\u76EF\u77E3\u79C1\u79C0\u79BF\u7A76\u7CFB\u7F55\u8096\u8093\u809D\u8098\u809B\u809A\u80B2\u826F\u8292"],
      ["a8a1", "\u828B\u828D\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FC2\u8FC6\u8FC5\u8FC4\u5DE1\u9091\u90A2\u90AA\u90A6\u90A3\u9149\u91C6\u91CC\u9632\u962E\u9631\u962A\u962C\u4E26\u4E56\u4E73\u4E8B\u4E9B\u4E9E\u4EAB\u4EAC\u4F6F\u4F9D\u4F8D\u4F73\u4F7F\u4F6C\u4F9B\u4F8B\u4F86\u4F83\u4F70\u4F75\u4F88\u4F69\u4F7B\u4F96\u4F7E\u4F8F\u4F91\u4F7A\u5154\u5152\u5155\u5169\u5177\u5176\u5178\u51BD\u51FD\u523B\u5238\u5237\u523A\u5230\u522E\u5236\u5241\u52BE\u52BB\u5352\u5354\u5353\u5351\u5366\u5377\u5378\u5379\u53D6\u53D4\u53D7\u5473\u5475"],
      ["a940", "\u5496\u5478\u5495\u5480\u547B\u5477\u5484\u5492\u5486\u547C\u5490\u5471\u5476\u548C\u549A\u5462\u5468\u548B\u547D\u548E\u56FA\u5783\u5777\u576A\u5769\u5761\u5766\u5764\u577C\u591C\u5949\u5947\u5948\u5944\u5954\u59BE\u59BB\u59D4\u59B9\u59AE\u59D1\u59C6\u59D0\u59CD\u59CB\u59D3\u59CA\u59AF\u59B3\u59D2\u59C5\u5B5F\u5B64\u5B63\u5B97\u5B9A\u5B98\u5B9C\u5B99\u5B9B\u5C1A\u5C48\u5C45"],
      ["a9a1", "\u5C46\u5CB7\u5CA1\u5CB8\u5CA9\u5CAB\u5CB1\u5CB3\u5E18\u5E1A\u5E16\u5E15\u5E1B\u5E11\u5E78\u5E9A\u5E97\u5E9C\u5E95\u5E96\u5EF6\u5F26\u5F27\u5F29\u5F80\u5F81\u5F7F\u5F7C\u5FDD\u5FE0\u5FFD\u5FF5\u5FFF\u600F\u6014\u602F\u6035\u6016\u602A\u6015\u6021\u6027\u6029\u602B\u601B\u6216\u6215\u623F\u623E\u6240\u627F\u62C9\u62CC\u62C4\u62BF\u62C2\u62B9\u62D2\u62DB\u62AB\u62D3\u62D4\u62CB\u62C8\u62A8\u62BD\u62BC\u62D0\u62D9\u62C7\u62CD\u62B5\u62DA\u62B1\u62D8\u62D6\u62D7\u62C6\u62AC\u62CE\u653E\u65A7\u65BC\u65FA\u6614\u6613\u660C\u6606\u6602\u660E\u6600\u660F\u6615\u660A"],
      ["aa40", "\u6607\u670D\u670B\u676D\u678B\u6795\u6771\u679C\u6773\u6777\u6787\u679D\u6797\u676F\u6770\u677F\u6789\u677E\u6790\u6775\u679A\u6793\u677C\u676A\u6772\u6B23\u6B66\u6B67\u6B7F\u6C13\u6C1B\u6CE3\u6CE8\u6CF3\u6CB1\u6CCC\u6CE5\u6CB3\u6CBD\u6CBE\u6CBC\u6CE2\u6CAB\u6CD5\u6CD3\u6CB8\u6CC4\u6CB9\u6CC1\u6CAE\u6CD7\u6CC5\u6CF1\u6CBF\u6CBB\u6CE1\u6CDB\u6CCA\u6CAC\u6CEF\u6CDC\u6CD6\u6CE0"],
      ["aaa1", "\u7095\u708E\u7092\u708A\u7099\u722C\u722D\u7238\u7248\u7267\u7269\u72C0\u72CE\u72D9\u72D7\u72D0\u73A9\u73A8\u739F\u73AB\u73A5\u753D\u759D\u7599\u759A\u7684\u76C2\u76F2\u76F4\u77E5\u77FD\u793E\u7940\u7941\u79C9\u79C8\u7A7A\u7A79\u7AFA\u7CFE\u7F54\u7F8C\u7F8B\u8005\u80BA\u80A5\u80A2\u80B1\u80A1\u80AB\u80A9\u80B4\u80AA\u80AF\u81E5\u81FE\u820D\u82B3\u829D\u8299\u82AD\u82BD\u829F\u82B9\u82B1\u82AC\u82A5\u82AF\u82B8\u82A3\u82B0\u82BE\u82B7\u864E\u8671\u521D\u8868\u8ECB\u8FCE\u8FD4\u8FD1\u90B5\u90B8\u90B1\u90B6\u91C7\u91D1\u9577\u9580\u961C\u9640\u963F\u963B\u9644"],
      ["ab40", "\u9642\u96B9\u96E8\u9752\u975E\u4E9F\u4EAD\u4EAE\u4FE1\u4FB5\u4FAF\u4FBF\u4FE0\u4FD1\u4FCF\u4FDD\u4FC3\u4FB6\u4FD8\u4FDF\u4FCA\u4FD7\u4FAE\u4FD0\u4FC4\u4FC2\u4FDA\u4FCE\u4FDE\u4FB7\u5157\u5192\u5191\u51A0\u524E\u5243\u524A\u524D\u524C\u524B\u5247\u52C7\u52C9\u52C3\u52C1\u530D\u5357\u537B\u539A\u53DB\u54AC\u54C0\u54A8\u54CE\u54C9\u54B8\u54A6\u54B3\u54C7\u54C2\u54BD\u54AA\u54C1"],
      ["aba1", "\u54C4\u54C8\u54AF\u54AB\u54B1\u54BB\u54A9\u54A7\u54BF\u56FF\u5782\u578B\u57A0\u57A3\u57A2\u57CE\u57AE\u5793\u5955\u5951\u594F\u594E\u5950\u59DC\u59D8\u59FF\u59E3\u59E8\u5A03\u59E5\u59EA\u59DA\u59E6\u5A01\u59FB\u5B69\u5BA3\u5BA6\u5BA4\u5BA2\u5BA5\u5C01\u5C4E\u5C4F\u5C4D\u5C4B\u5CD9\u5CD2\u5DF7\u5E1D\u5E25\u5E1F\u5E7D\u5EA0\u5EA6\u5EFA\u5F08\u5F2D\u5F65\u5F88\u5F85\u5F8A\u5F8B\u5F87\u5F8C\u5F89\u6012\u601D\u6020\u6025\u600E\u6028\u604D\u6070\u6068\u6062\u6046\u6043\u606C\u606B\u606A\u6064\u6241\u62DC\u6316\u6309\u62FC\u62ED\u6301\u62EE\u62FD\u6307\u62F1\u62F7"],
      ["ac40", "\u62EF\u62EC\u62FE\u62F4\u6311\u6302\u653F\u6545\u65AB\u65BD\u65E2\u6625\u662D\u6620\u6627\u662F\u661F\u6628\u6631\u6624\u66F7\u67FF\u67D3\u67F1\u67D4\u67D0\u67EC\u67B6\u67AF\u67F5\u67E9\u67EF\u67C4\u67D1\u67B4\u67DA\u67E5\u67B8\u67CF\u67DE\u67F3\u67B0\u67D9\u67E2\u67DD\u67D2\u6B6A\u6B83\u6B86\u6BB5\u6BD2\u6BD7\u6C1F\u6CC9\u6D0B\u6D32\u6D2A\u6D41\u6D25\u6D0C\u6D31\u6D1E\u6D17"],
      ["aca1", "\u6D3B\u6D3D\u6D3E\u6D36\u6D1B\u6CF5\u6D39\u6D27\u6D38\u6D29\u6D2E\u6D35\u6D0E\u6D2B\u70AB\u70BA\u70B3\u70AC\u70AF\u70AD\u70B8\u70AE\u70A4\u7230\u7272\u726F\u7274\u72E9\u72E0\u72E1\u73B7\u73CA\u73BB\u73B2\u73CD\u73C0\u73B3\u751A\u752D\u754F\u754C\u754E\u754B\u75AB\u75A4\u75A5\u75A2\u75A3\u7678\u7686\u7687\u7688\u76C8\u76C6\u76C3\u76C5\u7701\u76F9\u76F8\u7709\u770B\u76FE\u76FC\u7707\u77DC\u7802\u7814\u780C\u780D\u7946\u7949\u7948\u7947\u79B9\u79BA\u79D1\u79D2\u79CB\u7A7F\u7A81\u7AFF\u7AFD\u7C7D\u7D02\u7D05\u7D00\u7D09\u7D07\u7D04\u7D06\u7F38\u7F8E\u7FBF\u8004"],
      ["ad40", "\u8010\u800D\u8011\u8036\u80D6\u80E5\u80DA\u80C3\u80C4\u80CC\u80E1\u80DB\u80CE\u80DE\u80E4\u80DD\u81F4\u8222\u82E7\u8303\u8305\u82E3\u82DB\u82E6\u8304\u82E5\u8302\u8309\u82D2\u82D7\u82F1\u8301\u82DC\u82D4\u82D1\u82DE\u82D3\u82DF\u82EF\u8306\u8650\u8679\u867B\u867A\u884D\u886B\u8981\u89D4\u8A08\u8A02\u8A03\u8C9E\u8CA0\u8D74\u8D73\u8DB4\u8ECD\u8ECC\u8FF0\u8FE6\u8FE2\u8FEA\u8FE5"],
      ["ada1", "\u8FED\u8FEB\u8FE4\u8FE8\u90CA\u90CE\u90C1\u90C3\u914B\u914A\u91CD\u9582\u9650\u964B\u964C\u964D\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u4E58\u4EB3\u500C\u500D\u5023\u4FEF\u5026\u5025\u4FF8\u5029\u5016\u5006\u503C\u501F\u501A\u5012\u5011\u4FFA\u5000\u5014\u5028\u4FF1\u5021\u500B\u5019\u5018\u4FF3\u4FEE\u502D\u502A\u4FFE\u502B\u5009\u517C\u51A4\u51A5\u51A2\u51CD\u51CC\u51C6\u51CB\u5256\u525C\u5254\u525B\u525D\u532A\u537F\u539F\u539D\u53DF\u54E8\u5510\u5501\u5537\u54FC\u54E5\u54F2\u5506\u54FA\u5514\u54E9\u54ED\u54E1\u5509\u54EE\u54EA"],
      ["ae40", "\u54E6\u5527\u5507\u54FD\u550F\u5703\u5704\u57C2\u57D4\u57CB\u57C3\u5809\u590F\u5957\u5958\u595A\u5A11\u5A18\u5A1C\u5A1F\u5A1B\u5A13\u59EC\u5A20\u5A23\u5A29\u5A25\u5A0C\u5A09\u5B6B\u5C58\u5BB0\u5BB3\u5BB6\u5BB4\u5BAE\u5BB5\u5BB9\u5BB8\u5C04\u5C51\u5C55\u5C50\u5CED\u5CFD\u5CFB\u5CEA\u5CE8\u5CF0\u5CF6\u5D01\u5CF4\u5DEE\u5E2D\u5E2B\u5EAB\u5EAD\u5EA7\u5F31\u5F92\u5F91\u5F90\u6059"],
      ["aea1", "\u6063\u6065\u6050\u6055\u606D\u6069\u606F\u6084\u609F\u609A\u608D\u6094\u608C\u6085\u6096\u6247\u62F3\u6308\u62FF\u634E\u633E\u632F\u6355\u6342\u6346\u634F\u6349\u633A\u6350\u633D\u632A\u632B\u6328\u634D\u634C\u6548\u6549\u6599\u65C1\u65C5\u6642\u6649\u664F\u6643\u6652\u664C\u6645\u6641\u66F8\u6714\u6715\u6717\u6821\u6838\u6848\u6846\u6853\u6839\u6842\u6854\u6829\u68B3\u6817\u684C\u6851\u683D\u67F4\u6850\u6840\u683C\u6843\u682A\u6845\u6813\u6818\u6841\u6B8A\u6B89\u6BB7\u6C23\u6C27\u6C28\u6C26\u6C24\u6CF0\u6D6A\u6D95\u6D88\u6D87\u6D66\u6D78\u6D77\u6D59\u6D93"],
      ["af40", "\u6D6C\u6D89\u6D6E\u6D5A\u6D74\u6D69\u6D8C\u6D8A\u6D79\u6D85\u6D65\u6D94\u70CA\u70D8\u70E4\u70D9\u70C8\u70CF\u7239\u7279\u72FC\u72F9\u72FD\u72F8\u72F7\u7386\u73ED\u7409\u73EE\u73E0\u73EA\u73DE\u7554\u755D\u755C\u755A\u7559\u75BE\u75C5\u75C7\u75B2\u75B3\u75BD\u75BC\u75B9\u75C2\u75B8\u768B\u76B0\u76CA\u76CD\u76CE\u7729\u771F\u7720\u7728\u77E9\u7830\u7827\u7838\u781D\u7834\u7837"],
      ["afa1", "\u7825\u782D\u7820\u781F\u7832\u7955\u7950\u7960\u795F\u7956\u795E\u795D\u7957\u795A\u79E4\u79E3\u79E7\u79DF\u79E6\u79E9\u79D8\u7A84\u7A88\u7AD9\u7B06\u7B11\u7C89\u7D21\u7D17\u7D0B\u7D0A\u7D20\u7D22\u7D14\u7D10\u7D15\u7D1A\u7D1C\u7D0D\u7D19\u7D1B\u7F3A\u7F5F\u7F94\u7FC5\u7FC1\u8006\u8018\u8015\u8019\u8017\u803D\u803F\u80F1\u8102\u80F0\u8105\u80ED\u80F4\u8106\u80F8\u80F3\u8108\u80FD\u810A\u80FC\u80EF\u81ED\u81EC\u8200\u8210\u822A\u822B\u8228\u822C\u82BB\u832B\u8352\u8354\u834A\u8338\u8350\u8349\u8335\u8334\u834F\u8332\u8339\u8336\u8317\u8340\u8331\u8328\u8343"],
      ["b040", "\u8654\u868A\u86AA\u8693\u86A4\u86A9\u868C\u86A3\u869C\u8870\u8877\u8881\u8882\u887D\u8879\u8A18\u8A10\u8A0E\u8A0C\u8A15\u8A0A\u8A17\u8A13\u8A16\u8A0F\u8A11\u8C48\u8C7A\u8C79\u8CA1\u8CA2\u8D77\u8EAC\u8ED2\u8ED4\u8ECF\u8FB1\u9001\u9006\u8FF7\u9000\u8FFA\u8FF4\u9003\u8FFD\u9005\u8FF8\u9095\u90E1\u90DD\u90E2\u9152\u914D\u914C\u91D8\u91DD\u91D7\u91DC\u91D9\u9583\u9662\u9663\u9661"],
      ["b0a1", "\u965B\u965D\u9664\u9658\u965E\u96BB\u98E2\u99AC\u9AA8\u9AD8\u9B25\u9B32\u9B3C\u4E7E\u507A\u507D\u505C\u5047\u5043\u504C\u505A\u5049\u5065\u5076\u504E\u5055\u5075\u5074\u5077\u504F\u500F\u506F\u506D\u515C\u5195\u51F0\u526A\u526F\u52D2\u52D9\u52D8\u52D5\u5310\u530F\u5319\u533F\u5340\u533E\u53C3\u66FC\u5546\u556A\u5566\u5544\u555E\u5561\u5543\u554A\u5531\u5556\u554F\u5555\u552F\u5564\u5538\u552E\u555C\u552C\u5563\u5533\u5541\u5557\u5708\u570B\u5709\u57DF\u5805\u580A\u5806\u57E0\u57E4\u57FA\u5802\u5835\u57F7\u57F9\u5920\u5962\u5A36\u5A41\u5A49\u5A66\u5A6A\u5A40"],
      ["b140", "\u5A3C\u5A62\u5A5A\u5A46\u5A4A\u5B70\u5BC7\u5BC5\u5BC4\u5BC2\u5BBF\u5BC6\u5C09\u5C08\u5C07\u5C60\u5C5C\u5C5D\u5D07\u5D06\u5D0E\u5D1B\u5D16\u5D22\u5D11\u5D29\u5D14\u5D19\u5D24\u5D27\u5D17\u5DE2\u5E38\u5E36\u5E33\u5E37\u5EB7\u5EB8\u5EB6\u5EB5\u5EBE\u5F35\u5F37\u5F57\u5F6C\u5F69\u5F6B\u5F97\u5F99\u5F9E\u5F98\u5FA1\u5FA0\u5F9C\u607F\u60A3\u6089\u60A0\u60A8\u60CB\u60B4\u60E6\u60BD"],
      ["b1a1", "\u60C5\u60BB\u60B5\u60DC\u60BC\u60D8\u60D5\u60C6\u60DF\u60B8\u60DA\u60C7\u621A\u621B\u6248\u63A0\u63A7\u6372\u6396\u63A2\u63A5\u6377\u6367\u6398\u63AA\u6371\u63A9\u6389\u6383\u639B\u636B\u63A8\u6384\u6388\u6399\u63A1\u63AC\u6392\u638F\u6380\u637B\u6369\u6368\u637A\u655D\u6556\u6551\u6559\u6557\u555F\u654F\u6558\u6555\u6554\u659C\u659B\u65AC\u65CF\u65CB\u65CC\u65CE\u665D\u665A\u6664\u6668\u6666\u665E\u66F9\u52D7\u671B\u6881\u68AF\u68A2\u6893\u68B5\u687F\u6876\u68B1\u68A7\u6897\u68B0\u6883\u68C4\u68AD\u6886\u6885\u6894\u689D\u68A8\u689F\u68A1\u6882\u6B32\u6BBA"],
      ["b240", "\u6BEB\u6BEC\u6C2B\u6D8E\u6DBC\u6DF3\u6DD9\u6DB2\u6DE1\u6DCC\u6DE4\u6DFB\u6DFA\u6E05\u6DC7\u6DCB\u6DAF\u6DD1\u6DAE\u6DDE\u6DF9\u6DB8\u6DF7\u6DF5\u6DC5\u6DD2\u6E1A\u6DB5\u6DDA\u6DEB\u6DD8\u6DEA\u6DF1\u6DEE\u6DE8\u6DC6\u6DC4\u6DAA\u6DEC\u6DBF\u6DE6\u70F9\u7109\u710A\u70FD\u70EF\u723D\u727D\u7281\u731C\u731B\u7316\u7313\u7319\u7387\u7405\u740A\u7403\u7406\u73FE\u740D\u74E0\u74F6"],
      ["b2a1", "\u74F7\u751C\u7522\u7565\u7566\u7562\u7570\u758F\u75D4\u75D5\u75B5\u75CA\u75CD\u768E\u76D4\u76D2\u76DB\u7737\u773E\u773C\u7736\u7738\u773A\u786B\u7843\u784E\u7965\u7968\u796D\u79FB\u7A92\u7A95\u7B20\u7B28\u7B1B\u7B2C\u7B26\u7B19\u7B1E\u7B2E\u7C92\u7C97\u7C95\u7D46\u7D43\u7D71\u7D2E\u7D39\u7D3C\u7D40\u7D30\u7D33\u7D44\u7D2F\u7D42\u7D32\u7D31\u7F3D\u7F9E\u7F9A\u7FCC\u7FCE\u7FD2\u801C\u804A\u8046\u812F\u8116\u8123\u812B\u8129\u8130\u8124\u8202\u8235\u8237\u8236\u8239\u838E\u839E\u8398\u8378\u83A2\u8396\u83BD\u83AB\u8392\u838A\u8393\u8389\u83A0\u8377\u837B\u837C"],
      ["b340", "\u8386\u83A7\u8655\u5F6A\u86C7\u86C0\u86B6\u86C4\u86B5\u86C6\u86CB\u86B1\u86AF\u86C9\u8853\u889E\u8888\u88AB\u8892\u8896\u888D\u888B\u8993\u898F\u8A2A\u8A1D\u8A23\u8A25\u8A31\u8A2D\u8A1F\u8A1B\u8A22\u8C49\u8C5A\u8CA9\u8CAC\u8CAB\u8CA8\u8CAA\u8CA7\u8D67\u8D66\u8DBE\u8DBA\u8EDB\u8EDF\u9019\u900D\u901A\u9017\u9023\u901F\u901D\u9010\u9015\u901E\u9020\u900F\u9022\u9016\u901B\u9014"],
      ["b3a1", "\u90E8\u90ED\u90FD\u9157\u91CE\u91F5\u91E6\u91E3\u91E7\u91ED\u91E9\u9589\u966A\u9675\u9673\u9678\u9670\u9674\u9676\u9677\u966C\u96C0\u96EA\u96E9\u7AE0\u7ADF\u9802\u9803\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u50A2\u508D\u5085\u5099\u5091\u5080\u5096\u5098\u509A\u6700\u51F1\u5272\u5274\u5275\u5269\u52DE\u52DD\u52DB\u535A\u53A5\u557B\u5580\u55A7\u557C\u558A\u559D\u5598\u5582\u559C\u55AA\u5594\u5587\u558B\u5583\u55B3\u55AE\u559F\u553E\u55B2\u559A\u55BB\u55AC\u55B1\u557E\u5589\u55AB\u5599\u570D\u582F\u582A\u5834\u5824\u5830\u5831\u5821\u581D\u5820\u58F9\u58FA\u5960"],
      ["b440", "\u5A77\u5A9A\u5A7F\u5A92\u5A9B\u5AA7\u5B73\u5B71\u5BD2\u5BCC\u5BD3\u5BD0\u5C0A\u5C0B\u5C31\u5D4C\u5D50\u5D34\u5D47\u5DFD\u5E45\u5E3D\u5E40\u5E43\u5E7E\u5ECA\u5EC1\u5EC2\u5EC4\u5F3C\u5F6D\u5FA9\u5FAA\u5FA8\u60D1\u60E1\u60B2\u60B6\u60E0\u611C\u6123\u60FA\u6115\u60F0\u60FB\u60F4\u6168\u60F1\u610E\u60F6\u6109\u6100\u6112\u621F\u6249\u63A3\u638C\u63CF\u63C0\u63E9\u63C9\u63C6\u63CD"],
      ["b4a1", "\u63D2\u63E3\u63D0\u63E1\u63D6\u63ED\u63EE\u6376\u63F4\u63EA\u63DB\u6452\u63DA\u63F9\u655E\u6566\u6562\u6563\u6591\u6590\u65AF\u666E\u6670\u6674\u6676\u666F\u6691\u667A\u667E\u6677\u66FE\u66FF\u671F\u671D\u68FA\u68D5\u68E0\u68D8\u68D7\u6905\u68DF\u68F5\u68EE\u68E7\u68F9\u68D2\u68F2\u68E3\u68CB\u68CD\u690D\u6912\u690E\u68C9\u68DA\u696E\u68FB\u6B3E\u6B3A\u6B3D\u6B98\u6B96\u6BBC\u6BEF\u6C2E\u6C2F\u6C2C\u6E2F\u6E38\u6E54\u6E21\u6E32\u6E67\u6E4A\u6E20\u6E25\u6E23\u6E1B\u6E5B\u6E58\u6E24\u6E56\u6E6E\u6E2D\u6E26\u6E6F\u6E34\u6E4D\u6E3A\u6E2C\u6E43\u6E1D\u6E3E\u6ECB"],
      ["b540", "\u6E89\u6E19\u6E4E\u6E63\u6E44\u6E72\u6E69\u6E5F\u7119\u711A\u7126\u7130\u7121\u7136\u716E\u711C\u724C\u7284\u7280\u7336\u7325\u7334\u7329\u743A\u742A\u7433\u7422\u7425\u7435\u7436\u7434\u742F\u741B\u7426\u7428\u7525\u7526\u756B\u756A\u75E2\u75DB\u75E3\u75D9\u75D8\u75DE\u75E0\u767B\u767C\u7696\u7693\u76B4\u76DC\u774F\u77ED\u785D\u786C\u786F\u7A0D\u7A08\u7A0B\u7A05\u7A00\u7A98"],
      ["b5a1", "\u7A97\u7A96\u7AE5\u7AE3\u7B49\u7B56\u7B46\u7B50\u7B52\u7B54\u7B4D\u7B4B\u7B4F\u7B51\u7C9F\u7CA5\u7D5E\u7D50\u7D68\u7D55\u7D2B\u7D6E\u7D72\u7D61\u7D66\u7D62\u7D70\u7D73\u5584\u7FD4\u7FD5\u800B\u8052\u8085\u8155\u8154\u814B\u8151\u814E\u8139\u8146\u813E\u814C\u8153\u8174\u8212\u821C\u83E9\u8403\u83F8\u840D\u83E0\u83C5\u840B\u83C1\u83EF\u83F1\u83F4\u8457\u840A\u83F0\u840C\u83CC\u83FD\u83F2\u83CA\u8438\u840E\u8404\u83DC\u8407\u83D4\u83DF\u865B\u86DF\u86D9\u86ED\u86D4\u86DB\u86E4\u86D0\u86DE\u8857\u88C1\u88C2\u88B1\u8983\u8996\u8A3B\u8A60\u8A55\u8A5E\u8A3C\u8A41"],
      ["b640", "\u8A54\u8A5B\u8A50\u8A46\u8A34\u8A3A\u8A36\u8A56\u8C61\u8C82\u8CAF\u8CBC\u8CB3\u8CBD\u8CC1\u8CBB\u8CC0\u8CB4\u8CB7\u8CB6\u8CBF\u8CB8\u8D8A\u8D85\u8D81\u8DCE\u8DDD\u8DCB\u8DDA\u8DD1\u8DCC\u8DDB\u8DC6\u8EFB\u8EF8\u8EFC\u8F9C\u902E\u9035\u9031\u9038\u9032\u9036\u9102\u90F5\u9109\u90FE\u9163\u9165\u91CF\u9214\u9215\u9223\u9209\u921E\u920D\u9210\u9207\u9211\u9594\u958F\u958B\u9591"],
      ["b6a1", "\u9593\u9592\u958E\u968A\u968E\u968B\u967D\u9685\u9686\u968D\u9672\u9684\u96C1\u96C5\u96C4\u96C6\u96C7\u96EF\u96F2\u97CC\u9805\u9806\u9808\u98E7\u98EA\u98EF\u98E9\u98F2\u98ED\u99AE\u99AD\u9EC3\u9ECD\u9ED1\u4E82\u50AD\u50B5\u50B2\u50B3\u50C5\u50BE\u50AC\u50B7\u50BB\u50AF\u50C7\u527F\u5277\u527D\u52DF\u52E6\u52E4\u52E2\u52E3\u532F\u55DF\u55E8\u55D3\u55E6\u55CE\u55DC\u55C7\u55D1\u55E3\u55E4\u55EF\u55DA\u55E1\u55C5\u55C6\u55E5\u55C9\u5712\u5713\u585E\u5851\u5858\u5857\u585A\u5854\u586B\u584C\u586D\u584A\u5862\u5852\u584B\u5967\u5AC1\u5AC9\u5ACC\u5ABE\u5ABD\u5ABC"],
      ["b740", "\u5AB3\u5AC2\u5AB2\u5D69\u5D6F\u5E4C\u5E79\u5EC9\u5EC8\u5F12\u5F59\u5FAC\u5FAE\u611A\u610F\u6148\u611F\u60F3\u611B\u60F9\u6101\u6108\u614E\u614C\u6144\u614D\u613E\u6134\u6127\u610D\u6106\u6137\u6221\u6222\u6413\u643E\u641E\u642A\u642D\u643D\u642C\u640F\u641C\u6414\u640D\u6436\u6416\u6417\u6406\u656C\u659F\u65B0\u6697\u6689\u6687\u6688\u6696\u6684\u6698\u668D\u6703\u6994\u696D"],
      ["b7a1", "\u695A\u6977\u6960\u6954\u6975\u6930\u6982\u694A\u6968\u696B\u695E\u6953\u6979\u6986\u695D\u6963\u695B\u6B47\u6B72\u6BC0\u6BBF\u6BD3\u6BFD\u6EA2\u6EAF\u6ED3\u6EB6\u6EC2\u6E90\u6E9D\u6EC7\u6EC5\u6EA5\u6E98\u6EBC\u6EBA\u6EAB\u6ED1\u6E96\u6E9C\u6EC4\u6ED4\u6EAA\u6EA7\u6EB4\u714E\u7159\u7169\u7164\u7149\u7167\u715C\u716C\u7166\u714C\u7165\u715E\u7146\u7168\u7156\u723A\u7252\u7337\u7345\u733F\u733E\u746F\u745A\u7455\u745F\u745E\u7441\u743F\u7459\u745B\u745C\u7576\u7578\u7600\u75F0\u7601\u75F2\u75F1\u75FA\u75FF\u75F4\u75F3\u76DE\u76DF\u775B\u776B\u7766\u775E\u7763"],
      ["b840", "\u7779\u776A\u776C\u775C\u7765\u7768\u7762\u77EE\u788E\u78B0\u7897\u7898\u788C\u7889\u787C\u7891\u7893\u787F\u797A\u797F\u7981\u842C\u79BD\u7A1C\u7A1A\u7A20\u7A14\u7A1F\u7A1E\u7A9F\u7AA0\u7B77\u7BC0\u7B60\u7B6E\u7B67\u7CB1\u7CB3\u7CB5\u7D93\u7D79\u7D91\u7D81\u7D8F\u7D5B\u7F6E\u7F69\u7F6A\u7F72\u7FA9\u7FA8\u7FA4\u8056\u8058\u8086\u8084\u8171\u8170\u8178\u8165\u816E\u8173\u816B"],
      ["b8a1", "\u8179\u817A\u8166\u8205\u8247\u8482\u8477\u843D\u8431\u8475\u8466\u846B\u8449\u846C\u845B\u843C\u8435\u8461\u8463\u8469\u846D\u8446\u865E\u865C\u865F\u86F9\u8713\u8708\u8707\u8700\u86FE\u86FB\u8702\u8703\u8706\u870A\u8859\u88DF\u88D4\u88D9\u88DC\u88D8\u88DD\u88E1\u88CA\u88D5\u88D2\u899C\u89E3\u8A6B\u8A72\u8A73\u8A66\u8A69\u8A70\u8A87\u8A7C\u8A63\u8AA0\u8A71\u8A85\u8A6D\u8A62\u8A6E\u8A6C\u8A79\u8A7B\u8A3E\u8A68\u8C62\u8C8A\u8C89\u8CCA\u8CC7\u8CC8\u8CC4\u8CB2\u8CC3\u8CC2\u8CC5\u8DE1\u8DDF\u8DE8\u8DEF\u8DF3\u8DFA\u8DEA\u8DE4\u8DE6\u8EB2\u8F03\u8F09\u8EFE\u8F0A"],
      ["b940", "\u8F9F\u8FB2\u904B\u904A\u9053\u9042\u9054\u903C\u9055\u9050\u9047\u904F\u904E\u904D\u9051\u903E\u9041\u9112\u9117\u916C\u916A\u9169\u91C9\u9237\u9257\u9238\u923D\u9240\u923E\u925B\u924B\u9264\u9251\u9234\u9249\u924D\u9245\u9239\u923F\u925A\u9598\u9698\u9694\u9695\u96CD\u96CB\u96C9\u96CA\u96F7\u96FB\u96F9\u96F6\u9756\u9774\u9776\u9810\u9811\u9813\u980A\u9812\u980C\u98FC\u98F4"],
      ["b9a1", "\u98FD\u98FE\u99B3\u99B1\u99B4\u9AE1\u9CE9\u9E82\u9F0E\u9F13\u9F20\u50E7\u50EE\u50E5\u50D6\u50ED\u50DA\u50D5\u50CF\u50D1\u50F1\u50CE\u50E9\u5162\u51F3\u5283\u5282\u5331\u53AD\u55FE\u5600\u561B\u5617\u55FD\u5614\u5606\u5609\u560D\u560E\u55F7\u5616\u561F\u5608\u5610\u55F6\u5718\u5716\u5875\u587E\u5883\u5893\u588A\u5879\u5885\u587D\u58FD\u5925\u5922\u5924\u596A\u5969\u5AE1\u5AE6\u5AE9\u5AD7\u5AD6\u5AD8\u5AE3\u5B75\u5BDE\u5BE7\u5BE1\u5BE5\u5BE6\u5BE8\u5BE2\u5BE4\u5BDF\u5C0D\u5C62\u5D84\u5D87\u5E5B\u5E63\u5E55\u5E57\u5E54\u5ED3\u5ED6\u5F0A\u5F46\u5F70\u5FB9\u6147"],
      ["ba40", "\u613F\u614B\u6177\u6162\u6163\u615F\u615A\u6158\u6175\u622A\u6487\u6458\u6454\u64A4\u6478\u645F\u647A\u6451\u6467\u6434\u646D\u647B\u6572\u65A1\u65D7\u65D6\u66A2\u66A8\u669D\u699C\u69A8\u6995\u69C1\u69AE\u69D3\u69CB\u699B\u69B7\u69BB\u69AB\u69B4\u69D0\u69CD\u69AD\u69CC\u69A6\u69C3\u69A3\u6B49\u6B4C\u6C33\u6F33\u6F14\u6EFE\u6F13\u6EF4\u6F29\u6F3E\u6F20\u6F2C\u6F0F\u6F02\u6F22"],
      ["baa1", "\u6EFF\u6EEF\u6F06\u6F31\u6F38\u6F32\u6F23\u6F15\u6F2B\u6F2F\u6F88\u6F2A\u6EEC\u6F01\u6EF2\u6ECC\u6EF7\u7194\u7199\u717D\u718A\u7184\u7192\u723E\u7292\u7296\u7344\u7350\u7464\u7463\u746A\u7470\u746D\u7504\u7591\u7627\u760D\u760B\u7609\u7613\u76E1\u76E3\u7784\u777D\u777F\u7761\u78C1\u789F\u78A7\u78B3\u78A9\u78A3\u798E\u798F\u798D\u7A2E\u7A31\u7AAA\u7AA9\u7AED\u7AEF\u7BA1\u7B95\u7B8B\u7B75\u7B97\u7B9D\u7B94\u7B8F\u7BB8\u7B87\u7B84\u7CB9\u7CBD\u7CBE\u7DBB\u7DB0\u7D9C\u7DBD\u7DBE\u7DA0\u7DCA\u7DB4\u7DB2\u7DB1\u7DBA\u7DA2\u7DBF\u7DB5\u7DB8\u7DAD\u7DD2\u7DC7\u7DAC"],
      ["bb40", "\u7F70\u7FE0\u7FE1\u7FDF\u805E\u805A\u8087\u8150\u8180\u818F\u8188\u818A\u817F\u8182\u81E7\u81FA\u8207\u8214\u821E\u824B\u84C9\u84BF\u84C6\u84C4\u8499\u849E\u84B2\u849C\u84CB\u84B8\u84C0\u84D3\u8490\u84BC\u84D1\u84CA\u873F\u871C\u873B\u8722\u8725\u8734\u8718\u8755\u8737\u8729\u88F3\u8902\u88F4\u88F9\u88F8\u88FD\u88E8\u891A\u88EF\u8AA6\u8A8C\u8A9E\u8AA3\u8A8D\u8AA1\u8A93\u8AA4"],
      ["bba1", "\u8AAA\u8AA5\u8AA8\u8A98\u8A91\u8A9A\u8AA7\u8C6A\u8C8D\u8C8C\u8CD3\u8CD1\u8CD2\u8D6B\u8D99\u8D95\u8DFC\u8F14\u8F12\u8F15\u8F13\u8FA3\u9060\u9058\u905C\u9063\u9059\u905E\u9062\u905D\u905B\u9119\u9118\u911E\u9175\u9178\u9177\u9174\u9278\u9280\u9285\u9298\u9296\u927B\u9293\u929C\u92A8\u927C\u9291\u95A1\u95A8\u95A9\u95A3\u95A5\u95A4\u9699\u969C\u969B\u96CC\u96D2\u9700\u977C\u9785\u97F6\u9817\u9818\u98AF\u98B1\u9903\u9905\u990C\u9909\u99C1\u9AAF\u9AB0\u9AE6\u9B41\u9B42\u9CF4\u9CF6\u9CF3\u9EBC\u9F3B\u9F4A\u5104\u5100\u50FB\u50F5\u50F9\u5102\u5108\u5109\u5105\u51DC"],
      ["bc40", "\u5287\u5288\u5289\u528D\u528A\u52F0\u53B2\u562E\u563B\u5639\u5632\u563F\u5634\u5629\u5653\u564E\u5657\u5674\u5636\u562F\u5630\u5880\u589F\u589E\u58B3\u589C\u58AE\u58A9\u58A6\u596D\u5B09\u5AFB\u5B0B\u5AF5\u5B0C\u5B08\u5BEE\u5BEC\u5BE9\u5BEB\u5C64\u5C65\u5D9D\u5D94\u5E62\u5E5F\u5E61\u5EE2\u5EDA\u5EDF\u5EDD\u5EE3\u5EE0\u5F48\u5F71\u5FB7\u5FB5\u6176\u6167\u616E\u615D\u6155\u6182"],
      ["bca1", "\u617C\u6170\u616B\u617E\u61A7\u6190\u61AB\u618E\u61AC\u619A\u61A4\u6194\u61AE\u622E\u6469\u646F\u6479\u649E\u64B2\u6488\u6490\u64B0\u64A5\u6493\u6495\u64A9\u6492\u64AE\u64AD\u64AB\u649A\u64AC\u6499\u64A2\u64B3\u6575\u6577\u6578\u66AE\u66AB\u66B4\u66B1\u6A23\u6A1F\u69E8\u6A01\u6A1E\u6A19\u69FD\u6A21\u6A13\u6A0A\u69F3\u6A02\u6A05\u69ED\u6A11\u6B50\u6B4E\u6BA4\u6BC5\u6BC6\u6F3F\u6F7C\u6F84\u6F51\u6F66\u6F54\u6F86\u6F6D\u6F5B\u6F78\u6F6E\u6F8E\u6F7A\u6F70\u6F64\u6F97\u6F58\u6ED5\u6F6F\u6F60\u6F5F\u719F\u71AC\u71B1\u71A8\u7256\u729B\u734E\u7357\u7469\u748B\u7483"],
      ["bd40", "\u747E\u7480\u757F\u7620\u7629\u761F\u7624\u7626\u7621\u7622\u769A\u76BA\u76E4\u778E\u7787\u778C\u7791\u778B\u78CB\u78C5\u78BA\u78CA\u78BE\u78D5\u78BC\u78D0\u7A3F\u7A3C\u7A40\u7A3D\u7A37\u7A3B\u7AAF\u7AAE\u7BAD\u7BB1\u7BC4\u7BB4\u7BC6\u7BC7\u7BC1\u7BA0\u7BCC\u7CCA\u7DE0\u7DF4\u7DEF\u7DFB\u7DD8\u7DEC\u7DDD\u7DE8\u7DE3\u7DDA\u7DDE\u7DE9\u7D9E\u7DD9\u7DF2\u7DF9\u7F75\u7F77\u7FAF"],
      ["bda1", "\u7FE9\u8026\u819B\u819C\u819D\u81A0\u819A\u8198\u8517\u853D\u851A\u84EE\u852C\u852D\u8513\u8511\u8523\u8521\u8514\u84EC\u8525\u84FF\u8506\u8782\u8774\u8776\u8760\u8766\u8778\u8768\u8759\u8757\u874C\u8753\u885B\u885D\u8910\u8907\u8912\u8913\u8915\u890A\u8ABC\u8AD2\u8AC7\u8AC4\u8A95\u8ACB\u8AF8\u8AB2\u8AC9\u8AC2\u8ABF\u8AB0\u8AD6\u8ACD\u8AB6\u8AB9\u8ADB\u8C4C\u8C4E\u8C6C\u8CE0\u8CDE\u8CE6\u8CE4\u8CEC\u8CED\u8CE2\u8CE3\u8CDC\u8CEA\u8CE1\u8D6D\u8D9F\u8DA3\u8E2B\u8E10\u8E1D\u8E22\u8E0F\u8E29\u8E1F\u8E21\u8E1E\u8EBA\u8F1D\u8F1B\u8F1F\u8F29\u8F26\u8F2A\u8F1C\u8F1E"],
      ["be40", "\u8F25\u9069\u906E\u9068\u906D\u9077\u9130\u912D\u9127\u9131\u9187\u9189\u918B\u9183\u92C5\u92BB\u92B7\u92EA\u92AC\u92E4\u92C1\u92B3\u92BC\u92D2\u92C7\u92F0\u92B2\u95AD\u95B1\u9704\u9706\u9707\u9709\u9760\u978D\u978B\u978F\u9821\u982B\u981C\u98B3\u990A\u9913\u9912\u9918\u99DD\u99D0\u99DF\u99DB\u99D1\u99D5\u99D2\u99D9\u9AB7\u9AEE\u9AEF\u9B27\u9B45\u9B44\u9B77\u9B6F\u9D06\u9D09"],
      ["bea1", "\u9D03\u9EA9\u9EBE\u9ECE\u58A8\u9F52\u5112\u5118\u5114\u5110\u5115\u5180\u51AA\u51DD\u5291\u5293\u52F3\u5659\u566B\u5679\u5669\u5664\u5678\u566A\u5668\u5665\u5671\u566F\u566C\u5662\u5676\u58C1\u58BE\u58C7\u58C5\u596E\u5B1D\u5B34\u5B78\u5BF0\u5C0E\u5F4A\u61B2\u6191\u61A9\u618A\u61CD\u61B6\u61BE\u61CA\u61C8\u6230\u64C5\u64C1\u64CB\u64BB\u64BC\u64DA\u64C4\u64C7\u64C2\u64CD\u64BF\u64D2\u64D4\u64BE\u6574\u66C6\u66C9\u66B9\u66C4\u66C7\u66B8\u6A3D\u6A38\u6A3A\u6A59\u6A6B\u6A58\u6A39\u6A44\u6A62\u6A61\u6A4B\u6A47\u6A35\u6A5F\u6A48\u6B59\u6B77\u6C05\u6FC2\u6FB1\u6FA1"],
      ["bf40", "\u6FC3\u6FA4\u6FC1\u6FA7\u6FB3\u6FC0\u6FB9\u6FB6\u6FA6\u6FA0\u6FB4\u71BE\u71C9\u71D0\u71D2\u71C8\u71D5\u71B9\u71CE\u71D9\u71DC\u71C3\u71C4\u7368\u749C\u74A3\u7498\u749F\u749E\u74E2\u750C\u750D\u7634\u7638\u763A\u76E7\u76E5\u77A0\u779E\u779F\u77A5\u78E8\u78DA\u78EC\u78E7\u79A6\u7A4D\u7A4E\u7A46\u7A4C\u7A4B\u7ABA\u7BD9\u7C11\u7BC9\u7BE4\u7BDB\u7BE1\u7BE9\u7BE6\u7CD5\u7CD6\u7E0A"],
      ["bfa1", "\u7E11\u7E08\u7E1B\u7E23\u7E1E\u7E1D\u7E09\u7E10\u7F79\u7FB2\u7FF0\u7FF1\u7FEE\u8028\u81B3\u81A9\u81A8\u81FB\u8208\u8258\u8259\u854A\u8559\u8548\u8568\u8569\u8543\u8549\u856D\u856A\u855E\u8783\u879F\u879E\u87A2\u878D\u8861\u892A\u8932\u8925\u892B\u8921\u89AA\u89A6\u8AE6\u8AFA\u8AEB\u8AF1\u8B00\u8ADC\u8AE7\u8AEE\u8AFE\u8B01\u8B02\u8AF7\u8AED\u8AF3\u8AF6\u8AFC\u8C6B\u8C6D\u8C93\u8CF4\u8E44\u8E31\u8E34\u8E42\u8E39\u8E35\u8F3B\u8F2F\u8F38\u8F33\u8FA8\u8FA6\u9075\u9074\u9078\u9072\u907C\u907A\u9134\u9192\u9320\u9336\u92F8\u9333\u932F\u9322\u92FC\u932B\u9304\u931A"],
      ["c040", "\u9310\u9326\u9321\u9315\u932E\u9319\u95BB\u96A7\u96A8\u96AA\u96D5\u970E\u9711\u9716\u970D\u9713\u970F\u975B\u975C\u9766\u9798\u9830\u9838\u983B\u9837\u982D\u9839\u9824\u9910\u9928\u991E\u991B\u9921\u991A\u99ED\u99E2\u99F1\u9AB8\u9ABC\u9AFB\u9AED\u9B28\u9B91\u9D15\u9D23\u9D26\u9D28\u9D12\u9D1B\u9ED8\u9ED4\u9F8D\u9F9C\u512A\u511F\u5121\u5132\u52F5\u568E\u5680\u5690\u5685\u5687"],
      ["c0a1", "\u568F\u58D5\u58D3\u58D1\u58CE\u5B30\u5B2A\u5B24\u5B7A\u5C37\u5C68\u5DBC\u5DBA\u5DBD\u5DB8\u5E6B\u5F4C\u5FBD\u61C9\u61C2\u61C7\u61E6\u61CB\u6232\u6234\u64CE\u64CA\u64D8\u64E0\u64F0\u64E6\u64EC\u64F1\u64E2\u64ED\u6582\u6583\u66D9\u66D6\u6A80\u6A94\u6A84\u6AA2\u6A9C\u6ADB\u6AA3\u6A7E\u6A97\u6A90\u6AA0\u6B5C\u6BAE\u6BDA\u6C08\u6FD8\u6FF1\u6FDF\u6FE0\u6FDB\u6FE4\u6FEB\u6FEF\u6F80\u6FEC\u6FE1\u6FE9\u6FD5\u6FEE\u6FF0\u71E7\u71DF\u71EE\u71E6\u71E5\u71ED\u71EC\u71F4\u71E0\u7235\u7246\u7370\u7372\u74A9\u74B0\u74A6\u74A8\u7646\u7642\u764C\u76EA\u77B3\u77AA\u77B0\u77AC"],
      ["c140", "\u77A7\u77AD\u77EF\u78F7\u78FA\u78F4\u78EF\u7901\u79A7\u79AA\u7A57\u7ABF\u7C07\u7C0D\u7BFE\u7BF7\u7C0C\u7BE0\u7CE0\u7CDC\u7CDE\u7CE2\u7CDF\u7CD9\u7CDD\u7E2E\u7E3E\u7E46\u7E37\u7E32\u7E43\u7E2B\u7E3D\u7E31\u7E45\u7E41\u7E34\u7E39\u7E48\u7E35\u7E3F\u7E2F\u7F44\u7FF3\u7FFC\u8071\u8072\u8070\u806F\u8073\u81C6\u81C3\u81BA\u81C2\u81C0\u81BF\u81BD\u81C9\u81BE\u81E8\u8209\u8271\u85AA"],
      ["c1a1", "\u8584\u857E\u859C\u8591\u8594\u85AF\u859B\u8587\u85A8\u858A\u8667\u87C0\u87D1\u87B3\u87D2\u87C6\u87AB\u87BB\u87BA\u87C8\u87CB\u893B\u8936\u8944\u8938\u893D\u89AC\u8B0E\u8B17\u8B19\u8B1B\u8B0A\u8B20\u8B1D\u8B04\u8B10\u8C41\u8C3F\u8C73\u8CFA\u8CFD\u8CFC\u8CF8\u8CFB\u8DA8\u8E49\u8E4B\u8E48\u8E4A\u8F44\u8F3E\u8F42\u8F45\u8F3F\u907F\u907D\u9084\u9081\u9082\u9080\u9139\u91A3\u919E\u919C\u934D\u9382\u9328\u9375\u934A\u9365\u934B\u9318\u937E\u936C\u935B\u9370\u935A\u9354\u95CA\u95CB\u95CC\u95C8\u95C6\u96B1\u96B8\u96D6\u971C\u971E\u97A0\u97D3\u9846\u98B6\u9935\u9A01"],
      ["c240", "\u99FF\u9BAE\u9BAB\u9BAA\u9BAD\u9D3B\u9D3F\u9E8B\u9ECF\u9EDE\u9EDC\u9EDD\u9EDB\u9F3E\u9F4B\u53E2\u5695\u56AE\u58D9\u58D8\u5B38\u5F5D\u61E3\u6233\u64F4\u64F2\u64FE\u6506\u64FA\u64FB\u64F7\u65B7\u66DC\u6726\u6AB3\u6AAC\u6AC3\u6ABB\u6AB8\u6AC2\u6AAE\u6AAF\u6B5F\u6B78\u6BAF\u7009\u700B\u6FFE\u7006\u6FFA\u7011\u700F\u71FB\u71FC\u71FE\u71F8\u7377\u7375\u74A7\u74BF\u7515\u7656\u7658"],
      ["c2a1", "\u7652\u77BD\u77BF\u77BB\u77BC\u790E\u79AE\u7A61\u7A62\u7A60\u7AC4\u7AC5\u7C2B\u7C27\u7C2A\u7C1E\u7C23\u7C21\u7CE7\u7E54\u7E55\u7E5E\u7E5A\u7E61\u7E52\u7E59\u7F48\u7FF9\u7FFB\u8077\u8076\u81CD\u81CF\u820A\u85CF\u85A9\u85CD\u85D0\u85C9\u85B0\u85BA\u85B9\u85A6\u87EF\u87EC\u87F2\u87E0\u8986\u89B2\u89F4\u8B28\u8B39\u8B2C\u8B2B\u8C50\u8D05\u8E59\u8E63\u8E66\u8E64\u8E5F\u8E55\u8EC0\u8F49\u8F4D\u9087\u9083\u9088\u91AB\u91AC\u91D0\u9394\u938A\u9396\u93A2\u93B3\u93AE\u93AC\u93B0\u9398\u939A\u9397\u95D4\u95D6\u95D0\u95D5\u96E2\u96DC\u96D9\u96DB\u96DE\u9724\u97A3\u97A6"],
      ["c340", "\u97AD\u97F9\u984D\u984F\u984C\u984E\u9853\u98BA\u993E\u993F\u993D\u992E\u99A5\u9A0E\u9AC1\u9B03\u9B06\u9B4F\u9B4E\u9B4D\u9BCA\u9BC9\u9BFD\u9BC8\u9BC0\u9D51\u9D5D\u9D60\u9EE0\u9F15\u9F2C\u5133\u56A5\u58DE\u58DF\u58E2\u5BF5\u9F90\u5EEC\u61F2\u61F7\u61F6\u61F5\u6500\u650F\u66E0\u66DD\u6AE5\u6ADD\u6ADA\u6AD3\u701B\u701F\u7028\u701A\u701D\u7015\u7018\u7206\u720D\u7258\u72A2\u7378"],
      ["c3a1", "\u737A\u74BD\u74CA\u74E3\u7587\u7586\u765F\u7661\u77C7\u7919\u79B1\u7A6B\u7A69\u7C3E\u7C3F\u7C38\u7C3D\u7C37\u7C40\u7E6B\u7E6D\u7E79\u7E69\u7E6A\u7F85\u7E73\u7FB6\u7FB9\u7FB8\u81D8\u85E9\u85DD\u85EA\u85D5\u85E4\u85E5\u85F7\u87FB\u8805\u880D\u87F9\u87FE\u8960\u895F\u8956\u895E\u8B41\u8B5C\u8B58\u8B49\u8B5A\u8B4E\u8B4F\u8B46\u8B59\u8D08\u8D0A\u8E7C\u8E72\u8E87\u8E76\u8E6C\u8E7A\u8E74\u8F54\u8F4E\u8FAD\u908A\u908B\u91B1\u91AE\u93E1\u93D1\u93DF\u93C3\u93C8\u93DC\u93DD\u93D6\u93E2\u93CD\u93D8\u93E4\u93D7\u93E8\u95DC\u96B4\u96E3\u972A\u9727\u9761\u97DC\u97FB\u985E"],
      ["c440", "\u9858\u985B\u98BC\u9945\u9949\u9A16\u9A19\u9B0D\u9BE8\u9BE7\u9BD6\u9BDB\u9D89\u9D61\u9D72\u9D6A\u9D6C\u9E92\u9E97\u9E93\u9EB4\u52F8\u56A8\u56B7\u56B6\u56B4\u56BC\u58E4\u5B40\u5B43\u5B7D\u5BF6\u5DC9\u61F8\u61FA\u6518\u6514\u6519\u66E6\u6727\u6AEC\u703E\u7030\u7032\u7210\u737B\u74CF\u7662\u7665\u7926\u792A\u792C\u792B\u7AC7\u7AF6\u7C4C\u7C43\u7C4D\u7CEF\u7CF0\u8FAE\u7E7D\u7E7C"],
      ["c4a1", "\u7E82\u7F4C\u8000\u81DA\u8266\u85FB\u85F9\u8611\u85FA\u8606\u860B\u8607\u860A\u8814\u8815\u8964\u89BA\u89F8\u8B70\u8B6C\u8B66\u8B6F\u8B5F\u8B6B\u8D0F\u8D0D\u8E89\u8E81\u8E85\u8E82\u91B4\u91CB\u9418\u9403\u93FD\u95E1\u9730\u98C4\u9952\u9951\u99A8\u9A2B\u9A30\u9A37\u9A35\u9C13\u9C0D\u9E79\u9EB5\u9EE8\u9F2F\u9F5F\u9F63\u9F61\u5137\u5138\u56C1\u56C0\u56C2\u5914\u5C6C\u5DCD\u61FC\u61FE\u651D\u651C\u6595\u66E9\u6AFB\u6B04\u6AFA\u6BB2\u704C\u721B\u72A7\u74D6\u74D4\u7669\u77D3\u7C50\u7E8F\u7E8C\u7FBC\u8617\u862D\u861A\u8823\u8822\u8821\u881F\u896A\u896C\u89BD\u8B74"],
      ["c540", "\u8B77\u8B7D\u8D13\u8E8A\u8E8D\u8E8B\u8F5F\u8FAF\u91BA\u942E\u9433\u9435\u943A\u9438\u9432\u942B\u95E2\u9738\u9739\u9732\u97FF\u9867\u9865\u9957\u9A45\u9A43\u9A40\u9A3E\u9ACF\u9B54\u9B51\u9C2D\u9C25\u9DAF\u9DB4\u9DC2\u9DB8\u9E9D\u9EEF\u9F19\u9F5C\u9F66\u9F67\u513C\u513B\u56C8\u56CA\u56C9\u5B7F\u5DD4\u5DD2\u5F4E\u61FF\u6524\u6B0A\u6B61\u7051\u7058\u7380\u74E4\u758A\u766E\u766C"],
      ["c5a1", "\u79B3\u7C60\u7C5F\u807E\u807D\u81DF\u8972\u896F\u89FC\u8B80\u8D16\u8D17\u8E91\u8E93\u8F61\u9148\u9444\u9451\u9452\u973D\u973E\u97C3\u97C1\u986B\u9955\u9A55\u9A4D\u9AD2\u9B1A\u9C49\u9C31\u9C3E\u9C3B\u9DD3\u9DD7\u9F34\u9F6C\u9F6A\u9F94\u56CC\u5DD6\u6200\u6523\u652B\u652A\u66EC\u6B10\u74DA\u7ACA\u7C64\u7C63\u7C65\u7E93\u7E96\u7E94\u81E2\u8638\u863F\u8831\u8B8A\u9090\u908F\u9463\u9460\u9464\u9768\u986F\u995C\u9A5A\u9A5B\u9A57\u9AD3\u9AD4\u9AD1\u9C54\u9C57\u9C56\u9DE5\u9E9F\u9EF4\u56D1\u58E9\u652C\u705E\u7671\u7672\u77D7\u7F50\u7F88\u8836\u8839\u8862\u8B93\u8B92"],
      ["c640", "\u8B96\u8277\u8D1B\u91C0\u946A\u9742\u9748\u9744\u97C6\u9870\u9A5F\u9B22\u9B58\u9C5F\u9DF9\u9DFA\u9E7C\u9E7D\u9F07\u9F77\u9F72\u5EF3\u6B16\u7063\u7C6C\u7C6E\u883B\u89C0\u8EA1\u91C1\u9472\u9470\u9871\u995E\u9AD6\u9B23\u9ECC\u7064\u77DA\u8B9A\u9477\u97C9\u9A62\u9A65\u7E9C\u8B9C\u8EAA\u91C5\u947D\u947E\u947C\u9C77\u9C78\u9EF7\u8C54\u947F\u9E1A\u7228\u9A6A\u9B31\u9E1B\u9E1E\u7C72"],
      ["c940", "\u4E42\u4E5C\u51F5\u531A\u5382\u4E07\u4E0C\u4E47\u4E8D\u56D7\uFA0C\u5C6E\u5F73\u4E0F\u5187\u4E0E\u4E2E\u4E93\u4EC2\u4EC9\u4EC8\u5198\u52FC\u536C\u53B9\u5720\u5903\u592C\u5C10\u5DFF\u65E1\u6BB3\u6BCC\u6C14\u723F\u4E31\u4E3C\u4EE8\u4EDC\u4EE9\u4EE1\u4EDD\u4EDA\u520C\u531C\u534C\u5722\u5723\u5917\u592F\u5B81\u5B84\u5C12\u5C3B\u5C74\u5C73\u5E04\u5E80\u5E82\u5FC9\u6209\u6250\u6C15"],
      ["c9a1", "\u6C36\u6C43\u6C3F\u6C3B\u72AE\u72B0\u738A\u79B8\u808A\u961E\u4F0E\u4F18\u4F2C\u4EF5\u4F14\u4EF1\u4F00\u4EF7\u4F08\u4F1D\u4F02\u4F05\u4F22\u4F13\u4F04\u4EF4\u4F12\u51B1\u5213\u5209\u5210\u52A6\u5322\u531F\u534D\u538A\u5407\u56E1\u56DF\u572E\u572A\u5734\u593C\u5980\u597C\u5985\u597B\u597E\u5977\u597F\u5B56\u5C15\u5C25\u5C7C\u5C7A\u5C7B\u5C7E\u5DDF\u5E75\u5E84\u5F02\u5F1A\u5F74\u5FD5\u5FD4\u5FCF\u625C\u625E\u6264\u6261\u6266\u6262\u6259\u6260\u625A\u6265\u65EF\u65EE\u673E\u6739\u6738\u673B\u673A\u673F\u673C\u6733\u6C18\u6C46\u6C52\u6C5C\u6C4F\u6C4A\u6C54\u6C4B"],
      ["ca40", "\u6C4C\u7071\u725E\u72B4\u72B5\u738E\u752A\u767F\u7A75\u7F51\u8278\u827C\u8280\u827D\u827F\u864D\u897E\u9099\u9097\u9098\u909B\u9094\u9622\u9624\u9620\u9623\u4F56\u4F3B\u4F62\u4F49\u4F53\u4F64\u4F3E\u4F67\u4F52\u4F5F\u4F41\u4F58\u4F2D\u4F33\u4F3F\u4F61\u518F\u51B9\u521C\u521E\u5221\u52AD\u52AE\u5309\u5363\u5372\u538E\u538F\u5430\u5437\u542A\u5454\u5445\u5419\u541C\u5425\u5418"],
      ["caa1", "\u543D\u544F\u5441\u5428\u5424\u5447\u56EE\u56E7\u56E5\u5741\u5745\u574C\u5749\u574B\u5752\u5906\u5940\u59A6\u5998\u59A0\u5997\u598E\u59A2\u5990\u598F\u59A7\u59A1\u5B8E\u5B92\u5C28\u5C2A\u5C8D\u5C8F\u5C88\u5C8B\u5C89\u5C92\u5C8A\u5C86\u5C93\u5C95\u5DE0\u5E0A\u5E0E\u5E8B\u5E89\u5E8C\u5E88\u5E8D\u5F05\u5F1D\u5F78\u5F76\u5FD2\u5FD1\u5FD0\u5FED\u5FE8\u5FEE\u5FF3\u5FE1\u5FE4\u5FE3\u5FFA\u5FEF\u5FF7\u5FFB\u6000\u5FF4\u623A\u6283\u628C\u628E\u628F\u6294\u6287\u6271\u627B\u627A\u6270\u6281\u6288\u6277\u627D\u6272\u6274\u6537\u65F0\u65F4\u65F3\u65F2\u65F5\u6745\u6747"],
      ["cb40", "\u6759\u6755\u674C\u6748\u675D\u674D\u675A\u674B\u6BD0\u6C19\u6C1A\u6C78\u6C67\u6C6B\u6C84\u6C8B\u6C8F\u6C71\u6C6F\u6C69\u6C9A\u6C6D\u6C87\u6C95\u6C9C\u6C66\u6C73\u6C65\u6C7B\u6C8E\u7074\u707A\u7263\u72BF\u72BD\u72C3\u72C6\u72C1\u72BA\u72C5\u7395\u7397\u7393\u7394\u7392\u753A\u7539\u7594\u7595\u7681\u793D\u8034\u8095\u8099\u8090\u8092\u809C\u8290\u828F\u8285\u828E\u8291\u8293"],
      ["cba1", "\u828A\u8283\u8284\u8C78\u8FC9\u8FBF\u909F\u90A1\u90A5\u909E\u90A7\u90A0\u9630\u9628\u962F\u962D\u4E33\u4F98\u4F7C\u4F85\u4F7D\u4F80\u4F87\u4F76\u4F74\u4F89\u4F84\u4F77\u4F4C\u4F97\u4F6A\u4F9A\u4F79\u4F81\u4F78\u4F90\u4F9C\u4F94\u4F9E\u4F92\u4F82\u4F95\u4F6B\u4F6E\u519E\u51BC\u51BE\u5235\u5232\u5233\u5246\u5231\u52BC\u530A\u530B\u533C\u5392\u5394\u5487\u547F\u5481\u5491\u5482\u5488\u546B\u547A\u547E\u5465\u546C\u5474\u5466\u548D\u546F\u5461\u5460\u5498\u5463\u5467\u5464\u56F7\u56F9\u576F\u5772\u576D\u576B\u5771\u5770\u5776\u5780\u5775\u577B\u5773\u5774\u5762"],
      ["cc40", "\u5768\u577D\u590C\u5945\u59B5\u59BA\u59CF\u59CE\u59B2\u59CC\u59C1\u59B6\u59BC\u59C3\u59D6\u59B1\u59BD\u59C0\u59C8\u59B4\u59C7\u5B62\u5B65\u5B93\u5B95\u5C44\u5C47\u5CAE\u5CA4\u5CA0\u5CB5\u5CAF\u5CA8\u5CAC\u5C9F\u5CA3\u5CAD\u5CA2\u5CAA\u5CA7\u5C9D\u5CA5\u5CB6\u5CB0\u5CA6\u5E17\u5E14\u5E19\u5F28\u5F22\u5F23\u5F24\u5F54\u5F82\u5F7E\u5F7D\u5FDE\u5FE5\u602D\u6026\u6019\u6032\u600B"],
      ["cca1", "\u6034\u600A\u6017\u6033\u601A\u601E\u602C\u6022\u600D\u6010\u602E\u6013\u6011\u600C\u6009\u601C\u6214\u623D\u62AD\u62B4\u62D1\u62BE\u62AA\u62B6\u62CA\u62AE\u62B3\u62AF\u62BB\u62A9\u62B0\u62B8\u653D\u65A8\u65BB\u6609\u65FC\u6604\u6612\u6608\u65FB\u6603\u660B\u660D\u6605\u65FD\u6611\u6610\u66F6\u670A\u6785\u676C\u678E\u6792\u6776\u677B\u6798\u6786\u6784\u6774\u678D\u678C\u677A\u679F\u6791\u6799\u6783\u677D\u6781\u6778\u6779\u6794\u6B25\u6B80\u6B7E\u6BDE\u6C1D\u6C93\u6CEC\u6CEB\u6CEE\u6CD9\u6CB6\u6CD4\u6CAD\u6CE7\u6CB7\u6CD0\u6CC2\u6CBA\u6CC3\u6CC6\u6CED\u6CF2"],
      ["cd40", "\u6CD2\u6CDD\u6CB4\u6C8A\u6C9D\u6C80\u6CDE\u6CC0\u6D30\u6CCD\u6CC7\u6CB0\u6CF9\u6CCF\u6CE9\u6CD1\u7094\u7098\u7085\u7093\u7086\u7084\u7091\u7096\u7082\u709A\u7083\u726A\u72D6\u72CB\u72D8\u72C9\u72DC\u72D2\u72D4\u72DA\u72CC\u72D1\u73A4\u73A1\u73AD\u73A6\u73A2\u73A0\u73AC\u739D\u74DD\u74E8\u753F\u7540\u753E\u758C\u7598\u76AF\u76F3\u76F1\u76F0\u76F5\u77F8\u77FC\u77F9\u77FB\u77FA"],
      ["cda1", "\u77F7\u7942\u793F\u79C5\u7A78\u7A7B\u7AFB\u7C75\u7CFD\u8035\u808F\u80AE\u80A3\u80B8\u80B5\u80AD\u8220\u82A0\u82C0\u82AB\u829A\u8298\u829B\u82B5\u82A7\u82AE\u82BC\u829E\u82BA\u82B4\u82A8\u82A1\u82A9\u82C2\u82A4\u82C3\u82B6\u82A2\u8670\u866F\u866D\u866E\u8C56\u8FD2\u8FCB\u8FD3\u8FCD\u8FD6\u8FD5\u8FD7\u90B2\u90B4\u90AF\u90B3\u90B0\u9639\u963D\u963C\u963A\u9643\u4FCD\u4FC5\u4FD3\u4FB2\u4FC9\u4FCB\u4FC1\u4FD4\u4FDC\u4FD9\u4FBB\u4FB3\u4FDB\u4FC7\u4FD6\u4FBA\u4FC0\u4FB9\u4FEC\u5244\u5249\u52C0\u52C2\u533D\u537C\u5397\u5396\u5399\u5398\u54BA\u54A1\u54AD\u54A5\u54CF"],
      ["ce40", "\u54C3\u830D\u54B7\u54AE\u54D6\u54B6\u54C5\u54C6\u54A0\u5470\u54BC\u54A2\u54BE\u5472\u54DE\u54B0\u57B5\u579E\u579F\u57A4\u578C\u5797\u579D\u579B\u5794\u5798\u578F\u5799\u57A5\u579A\u5795\u58F4\u590D\u5953\u59E1\u59DE\u59EE\u5A00\u59F1\u59DD\u59FA\u59FD\u59FC\u59F6\u59E4\u59F2\u59F7\u59DB\u59E9\u59F3\u59F5\u59E0\u59FE\u59F4\u59ED\u5BA8\u5C4C\u5CD0\u5CD8\u5CCC\u5CD7\u5CCB\u5CDB"],
      ["cea1", "\u5CDE\u5CDA\u5CC9\u5CC7\u5CCA\u5CD6\u5CD3\u5CD4\u5CCF\u5CC8\u5CC6\u5CCE\u5CDF\u5CF8\u5DF9\u5E21\u5E22\u5E23\u5E20\u5E24\u5EB0\u5EA4\u5EA2\u5E9B\u5EA3\u5EA5\u5F07\u5F2E\u5F56\u5F86\u6037\u6039\u6054\u6072\u605E\u6045\u6053\u6047\u6049\u605B\u604C\u6040\u6042\u605F\u6024\u6044\u6058\u6066\u606E\u6242\u6243\u62CF\u630D\u630B\u62F5\u630E\u6303\u62EB\u62F9\u630F\u630C\u62F8\u62F6\u6300\u6313\u6314\u62FA\u6315\u62FB\u62F0\u6541\u6543\u65AA\u65BF\u6636\u6621\u6632\u6635\u661C\u6626\u6622\u6633\u662B\u663A\u661D\u6634\u6639\u662E\u670F\u6710\u67C1\u67F2\u67C8\u67BA"],
      ["cf40", "\u67DC\u67BB\u67F8\u67D8\u67C0\u67B7\u67C5\u67EB\u67E4\u67DF\u67B5\u67CD\u67B3\u67F7\u67F6\u67EE\u67E3\u67C2\u67B9\u67CE\u67E7\u67F0\u67B2\u67FC\u67C6\u67ED\u67CC\u67AE\u67E6\u67DB\u67FA\u67C9\u67CA\u67C3\u67EA\u67CB\u6B28\u6B82\u6B84\u6BB6\u6BD6\u6BD8\u6BE0\u6C20\u6C21\u6D28\u6D34\u6D2D\u6D1F\u6D3C\u6D3F\u6D12\u6D0A\u6CDA\u6D33\u6D04\u6D19\u6D3A\u6D1A\u6D11\u6D00\u6D1D\u6D42"],
      ["cfa1", "\u6D01\u6D18\u6D37\u6D03\u6D0F\u6D40\u6D07\u6D20\u6D2C\u6D08\u6D22\u6D09\u6D10\u70B7\u709F\u70BE\u70B1\u70B0\u70A1\u70B4\u70B5\u70A9\u7241\u7249\u724A\u726C\u7270\u7273\u726E\u72CA\u72E4\u72E8\u72EB\u72DF\u72EA\u72E6\u72E3\u7385\u73CC\u73C2\u73C8\u73C5\u73B9\u73B6\u73B5\u73B4\u73EB\u73BF\u73C7\u73BE\u73C3\u73C6\u73B8\u73CB\u74EC\u74EE\u752E\u7547\u7548\u75A7\u75AA\u7679\u76C4\u7708\u7703\u7704\u7705\u770A\u76F7\u76FB\u76FA\u77E7\u77E8\u7806\u7811\u7812\u7805\u7810\u780F\u780E\u7809\u7803\u7813\u794A\u794C\u794B\u7945\u7944\u79D5\u79CD\u79CF\u79D6\u79CE\u7A80"],
      ["d040", "\u7A7E\u7AD1\u7B00\u7B01\u7C7A\u7C78\u7C79\u7C7F\u7C80\u7C81\u7D03\u7D08\u7D01\u7F58\u7F91\u7F8D\u7FBE\u8007\u800E\u800F\u8014\u8037\u80D8\u80C7\u80E0\u80D1\u80C8\u80C2\u80D0\u80C5\u80E3\u80D9\u80DC\u80CA\u80D5\u80C9\u80CF\u80D7\u80E6\u80CD\u81FF\u8221\u8294\u82D9\u82FE\u82F9\u8307\u82E8\u8300\u82D5\u833A\u82EB\u82D6\u82F4\u82EC\u82E1\u82F2\u82F5\u830C\u82FB\u82F6\u82F0\u82EA"],
      ["d0a1", "\u82E4\u82E0\u82FA\u82F3\u82ED\u8677\u8674\u867C\u8673\u8841\u884E\u8867\u886A\u8869\u89D3\u8A04\u8A07\u8D72\u8FE3\u8FE1\u8FEE\u8FE0\u90F1\u90BD\u90BF\u90D5\u90C5\u90BE\u90C7\u90CB\u90C8\u91D4\u91D3\u9654\u964F\u9651\u9653\u964A\u964E\u501E\u5005\u5007\u5013\u5022\u5030\u501B\u4FF5\u4FF4\u5033\u5037\u502C\u4FF6\u4FF7\u5017\u501C\u5020\u5027\u5035\u502F\u5031\u500E\u515A\u5194\u5193\u51CA\u51C4\u51C5\u51C8\u51CE\u5261\u525A\u5252\u525E\u525F\u5255\u5262\u52CD\u530E\u539E\u5526\u54E2\u5517\u5512\u54E7\u54F3\u54E4\u551A\u54FF\u5504\u5508\u54EB\u5511\u5505\u54F1"],
      ["d140", "\u550A\u54FB\u54F7\u54F8\u54E0\u550E\u5503\u550B\u5701\u5702\u57CC\u5832\u57D5\u57D2\u57BA\u57C6\u57BD\u57BC\u57B8\u57B6\u57BF\u57C7\u57D0\u57B9\u57C1\u590E\u594A\u5A19\u5A16\u5A2D\u5A2E\u5A15\u5A0F\u5A17\u5A0A\u5A1E\u5A33\u5B6C\u5BA7\u5BAD\u5BAC\u5C03\u5C56\u5C54\u5CEC\u5CFF\u5CEE\u5CF1\u5CF7\u5D00\u5CF9\u5E29\u5E28\u5EA8\u5EAE\u5EAA\u5EAC\u5F33\u5F30\u5F67\u605D\u605A\u6067"],
      ["d1a1", "\u6041\u60A2\u6088\u6080\u6092\u6081\u609D\u6083\u6095\u609B\u6097\u6087\u609C\u608E\u6219\u6246\u62F2\u6310\u6356\u632C\u6344\u6345\u6336\u6343\u63E4\u6339\u634B\u634A\u633C\u6329\u6341\u6334\u6358\u6354\u6359\u632D\u6347\u6333\u635A\u6351\u6338\u6357\u6340\u6348\u654A\u6546\u65C6\u65C3\u65C4\u65C2\u664A\u665F\u6647\u6651\u6712\u6713\u681F\u681A\u6849\u6832\u6833\u683B\u684B\u684F\u6816\u6831\u681C\u6835\u682B\u682D\u682F\u684E\u6844\u6834\u681D\u6812\u6814\u6826\u6828\u682E\u684D\u683A\u6825\u6820\u6B2C\u6B2F\u6B2D\u6B31\u6B34\u6B6D\u8082\u6B88\u6BE6\u6BE4"],
      ["d240", "\u6BE8\u6BE3\u6BE2\u6BE7\u6C25\u6D7A\u6D63\u6D64\u6D76\u6D0D\u6D61\u6D92\u6D58\u6D62\u6D6D\u6D6F\u6D91\u6D8D\u6DEF\u6D7F\u6D86\u6D5E\u6D67\u6D60\u6D97\u6D70\u6D7C\u6D5F\u6D82\u6D98\u6D2F\u6D68\u6D8B\u6D7E\u6D80\u6D84\u6D16\u6D83\u6D7B\u6D7D\u6D75\u6D90\u70DC\u70D3\u70D1\u70DD\u70CB\u7F39\u70E2\u70D7\u70D2\u70DE\u70E0\u70D4\u70CD\u70C5\u70C6\u70C7\u70DA\u70CE\u70E1\u7242\u7278"],
      ["d2a1", "\u7277\u7276\u7300\u72FA\u72F4\u72FE\u72F6\u72F3\u72FB\u7301\u73D3\u73D9\u73E5\u73D6\u73BC\u73E7\u73E3\u73E9\u73DC\u73D2\u73DB\u73D4\u73DD\u73DA\u73D7\u73D8\u73E8\u74DE\u74DF\u74F4\u74F5\u7521\u755B\u755F\u75B0\u75C1\u75BB\u75C4\u75C0\u75BF\u75B6\u75BA\u768A\u76C9\u771D\u771B\u7710\u7713\u7712\u7723\u7711\u7715\u7719\u771A\u7722\u7727\u7823\u782C\u7822\u7835\u782F\u7828\u782E\u782B\u7821\u7829\u7833\u782A\u7831\u7954\u795B\u794F\u795C\u7953\u7952\u7951\u79EB\u79EC\u79E0\u79EE\u79ED\u79EA\u79DC\u79DE\u79DD\u7A86\u7A89\u7A85\u7A8B\u7A8C\u7A8A\u7A87\u7AD8\u7B10"],
      ["d340", "\u7B04\u7B13\u7B05\u7B0F\u7B08\u7B0A\u7B0E\u7B09\u7B12\u7C84\u7C91\u7C8A\u7C8C\u7C88\u7C8D\u7C85\u7D1E\u7D1D\u7D11\u7D0E\u7D18\u7D16\u7D13\u7D1F\u7D12\u7D0F\u7D0C\u7F5C\u7F61\u7F5E\u7F60\u7F5D\u7F5B\u7F96\u7F92\u7FC3\u7FC2\u7FC0\u8016\u803E\u8039\u80FA\u80F2\u80F9\u80F5\u8101\u80FB\u8100\u8201\u822F\u8225\u8333\u832D\u8344\u8319\u8351\u8325\u8356\u833F\u8341\u8326\u831C\u8322"],
      ["d3a1", "\u8342\u834E\u831B\u832A\u8308\u833C\u834D\u8316\u8324\u8320\u8337\u832F\u8329\u8347\u8345\u834C\u8353\u831E\u832C\u834B\u8327\u8348\u8653\u8652\u86A2\u86A8\u8696\u868D\u8691\u869E\u8687\u8697\u8686\u868B\u869A\u8685\u86A5\u8699\u86A1\u86A7\u8695\u8698\u868E\u869D\u8690\u8694\u8843\u8844\u886D\u8875\u8876\u8872\u8880\u8871\u887F\u886F\u8883\u887E\u8874\u887C\u8A12\u8C47\u8C57\u8C7B\u8CA4\u8CA3\u8D76\u8D78\u8DB5\u8DB7\u8DB6\u8ED1\u8ED3\u8FFE\u8FF5\u9002\u8FFF\u8FFB\u9004\u8FFC\u8FF6\u90D6\u90E0\u90D9\u90DA\u90E3\u90DF\u90E5\u90D8\u90DB\u90D7\u90DC\u90E4\u9150"],
      ["d440", "\u914E\u914F\u91D5\u91E2\u91DA\u965C\u965F\u96BC\u98E3\u9ADF\u9B2F\u4E7F\u5070\u506A\u5061\u505E\u5060\u5053\u504B\u505D\u5072\u5048\u504D\u5041\u505B\u504A\u5062\u5015\u5045\u505F\u5069\u506B\u5063\u5064\u5046\u5040\u506E\u5073\u5057\u5051\u51D0\u526B\u526D\u526C\u526E\u52D6\u52D3\u532D\u539C\u5575\u5576\u553C\u554D\u5550\u5534\u552A\u5551\u5562\u5536\u5535\u5530\u5552\u5545"],
      ["d4a1", "\u550C\u5532\u5565\u554E\u5539\u5548\u552D\u553B\u5540\u554B\u570A\u5707\u57FB\u5814\u57E2\u57F6\u57DC\u57F4\u5800\u57ED\u57FD\u5808\u57F8\u580B\u57F3\u57CF\u5807\u57EE\u57E3\u57F2\u57E5\u57EC\u57E1\u580E\u57FC\u5810\u57E7\u5801\u580C\u57F1\u57E9\u57F0\u580D\u5804\u595C\u5A60\u5A58\u5A55\u5A67\u5A5E\u5A38\u5A35\u5A6D\u5A50\u5A5F\u5A65\u5A6C\u5A53\u5A64\u5A57\u5A43\u5A5D\u5A52\u5A44\u5A5B\u5A48\u5A8E\u5A3E\u5A4D\u5A39\u5A4C\u5A70\u5A69\u5A47\u5A51\u5A56\u5A42\u5A5C\u5B72\u5B6E\u5BC1\u5BC0\u5C59\u5D1E\u5D0B\u5D1D\u5D1A\u5D20\u5D0C\u5D28\u5D0D\u5D26\u5D25\u5D0F"],
      ["d540", "\u5D30\u5D12\u5D23\u5D1F\u5D2E\u5E3E\u5E34\u5EB1\u5EB4\u5EB9\u5EB2\u5EB3\u5F36\u5F38\u5F9B\u5F96\u5F9F\u608A\u6090\u6086\u60BE\u60B0\u60BA\u60D3\u60D4\u60CF\u60E4\u60D9\u60DD\u60C8\u60B1\u60DB\u60B7\u60CA\u60BF\u60C3\u60CD\u60C0\u6332\u6365\u638A\u6382\u637D\u63BD\u639E\u63AD\u639D\u6397\u63AB\u638E\u636F\u6387\u6390\u636E\u63AF\u6375\u639C\u636D\u63AE\u637C\u63A4\u633B\u639F"],
      ["d5a1", "\u6378\u6385\u6381\u6391\u638D\u6370\u6553\u65CD\u6665\u6661\u665B\u6659\u665C\u6662\u6718\u6879\u6887\u6890\u689C\u686D\u686E\u68AE\u68AB\u6956\u686F\u68A3\u68AC\u68A9\u6875\u6874\u68B2\u688F\u6877\u6892\u687C\u686B\u6872\u68AA\u6880\u6871\u687E\u689B\u6896\u688B\u68A0\u6889\u68A4\u6878\u687B\u6891\u688C\u688A\u687D\u6B36\u6B33\u6B37\u6B38\u6B91\u6B8F\u6B8D\u6B8E\u6B8C\u6C2A\u6DC0\u6DAB\u6DB4\u6DB3\u6E74\u6DAC\u6DE9\u6DE2\u6DB7\u6DF6\u6DD4\u6E00\u6DC8\u6DE0\u6DDF\u6DD6\u6DBE\u6DE5\u6DDC\u6DDD\u6DDB\u6DF4\u6DCA\u6DBD\u6DED\u6DF0\u6DBA\u6DD5\u6DC2\u6DCF\u6DC9"],
      ["d640", "\u6DD0\u6DF2\u6DD3\u6DFD\u6DD7\u6DCD\u6DE3\u6DBB\u70FA\u710D\u70F7\u7117\u70F4\u710C\u70F0\u7104\u70F3\u7110\u70FC\u70FF\u7106\u7113\u7100\u70F8\u70F6\u710B\u7102\u710E\u727E\u727B\u727C\u727F\u731D\u7317\u7307\u7311\u7318\u730A\u7308\u72FF\u730F\u731E\u7388\u73F6\u73F8\u73F5\u7404\u7401\u73FD\u7407\u7400\u73FA\u73FC\u73FF\u740C\u740B\u73F4\u7408\u7564\u7563\u75CE\u75D2\u75CF"],
      ["d6a1", "\u75CB\u75CC\u75D1\u75D0\u768F\u7689\u76D3\u7739\u772F\u772D\u7731\u7732\u7734\u7733\u773D\u7725\u773B\u7735\u7848\u7852\u7849\u784D\u784A\u784C\u7826\u7845\u7850\u7964\u7967\u7969\u796A\u7963\u796B\u7961\u79BB\u79FA\u79F8\u79F6\u79F7\u7A8F\u7A94\u7A90\u7B35\u7B47\u7B34\u7B25\u7B30\u7B22\u7B24\u7B33\u7B18\u7B2A\u7B1D\u7B31\u7B2B\u7B2D\u7B2F\u7B32\u7B38\u7B1A\u7B23\u7C94\u7C98\u7C96\u7CA3\u7D35\u7D3D\u7D38\u7D36\u7D3A\u7D45\u7D2C\u7D29\u7D41\u7D47\u7D3E\u7D3F\u7D4A\u7D3B\u7D28\u7F63\u7F95\u7F9C\u7F9D\u7F9B\u7FCA\u7FCB\u7FCD\u7FD0\u7FD1\u7FC7\u7FCF\u7FC9\u801F"],
      ["d740", "\u801E\u801B\u8047\u8043\u8048\u8118\u8125\u8119\u811B\u812D\u811F\u812C\u811E\u8121\u8115\u8127\u811D\u8122\u8211\u8238\u8233\u823A\u8234\u8232\u8274\u8390\u83A3\u83A8\u838D\u837A\u8373\u83A4\u8374\u838F\u8381\u8395\u8399\u8375\u8394\u83A9\u837D\u8383\u838C\u839D\u839B\u83AA\u838B\u837E\u83A5\u83AF\u8388\u8397\u83B0\u837F\u83A6\u8387\u83AE\u8376\u839A\u8659\u8656\u86BF\u86B7"],
      ["d7a1", "\u86C2\u86C1\u86C5\u86BA\u86B0\u86C8\u86B9\u86B3\u86B8\u86CC\u86B4\u86BB\u86BC\u86C3\u86BD\u86BE\u8852\u8889\u8895\u88A8\u88A2\u88AA\u889A\u8891\u88A1\u889F\u8898\u88A7\u8899\u889B\u8897\u88A4\u88AC\u888C\u8893\u888E\u8982\u89D6\u89D9\u89D5\u8A30\u8A27\u8A2C\u8A1E\u8C39\u8C3B\u8C5C\u8C5D\u8C7D\u8CA5\u8D7D\u8D7B\u8D79\u8DBC\u8DC2\u8DB9\u8DBF\u8DC1\u8ED8\u8EDE\u8EDD\u8EDC\u8ED7\u8EE0\u8EE1\u9024\u900B\u9011\u901C\u900C\u9021\u90EF\u90EA\u90F0\u90F4\u90F2\u90F3\u90D4\u90EB\u90EC\u90E9\u9156\u9158\u915A\u9153\u9155\u91EC\u91F4\u91F1\u91F3\u91F8\u91E4\u91F9\u91EA"],
      ["d840", "\u91EB\u91F7\u91E8\u91EE\u957A\u9586\u9588\u967C\u966D\u966B\u9671\u966F\u96BF\u976A\u9804\u98E5\u9997\u509B\u5095\u5094\u509E\u508B\u50A3\u5083\u508C\u508E\u509D\u5068\u509C\u5092\u5082\u5087\u515F\u51D4\u5312\u5311\u53A4\u53A7\u5591\u55A8\u55A5\u55AD\u5577\u5645\u55A2\u5593\u5588\u558F\u55B5\u5581\u55A3\u5592\u55A4\u557D\u558C\u55A6\u557F\u5595\u55A1\u558E\u570C\u5829\u5837"],
      ["d8a1", "\u5819\u581E\u5827\u5823\u5828\u57F5\u5848\u5825\u581C\u581B\u5833\u583F\u5836\u582E\u5839\u5838\u582D\u582C\u583B\u5961\u5AAF\u5A94\u5A9F\u5A7A\u5AA2\u5A9E\u5A78\u5AA6\u5A7C\u5AA5\u5AAC\u5A95\u5AAE\u5A37\u5A84\u5A8A\u5A97\u5A83\u5A8B\u5AA9\u5A7B\u5A7D\u5A8C\u5A9C\u5A8F\u5A93\u5A9D\u5BEA\u5BCD\u5BCB\u5BD4\u5BD1\u5BCA\u5BCE\u5C0C\u5C30\u5D37\u5D43\u5D6B\u5D41\u5D4B\u5D3F\u5D35\u5D51\u5D4E\u5D55\u5D33\u5D3A\u5D52\u5D3D\u5D31\u5D59\u5D42\u5D39\u5D49\u5D38\u5D3C\u5D32\u5D36\u5D40\u5D45\u5E44\u5E41\u5F58\u5FA6\u5FA5\u5FAB\u60C9\u60B9\u60CC\u60E2\u60CE\u60C4\u6114"],
      ["d940", "\u60F2\u610A\u6116\u6105\u60F5\u6113\u60F8\u60FC\u60FE\u60C1\u6103\u6118\u611D\u6110\u60FF\u6104\u610B\u624A\u6394\u63B1\u63B0\u63CE\u63E5\u63E8\u63EF\u63C3\u649D\u63F3\u63CA\u63E0\u63F6\u63D5\u63F2\u63F5\u6461\u63DF\u63BE\u63DD\u63DC\u63C4\u63D8\u63D3\u63C2\u63C7\u63CC\u63CB\u63C8\u63F0\u63D7\u63D9\u6532\u6567\u656A\u6564\u655C\u6568\u6565\u658C\u659D\u659E\u65AE\u65D0\u65D2"],
      ["d9a1", "\u667C\u666C\u667B\u6680\u6671\u6679\u666A\u6672\u6701\u690C\u68D3\u6904\u68DC\u692A\u68EC\u68EA\u68F1\u690F\u68D6\u68F7\u68EB\u68E4\u68F6\u6913\u6910\u68F3\u68E1\u6907\u68CC\u6908\u6970\u68B4\u6911\u68EF\u68C6\u6914\u68F8\u68D0\u68FD\u68FC\u68E8\u690B\u690A\u6917\u68CE\u68C8\u68DD\u68DE\u68E6\u68F4\u68D1\u6906\u68D4\u68E9\u6915\u6925\u68C7\u6B39\u6B3B\u6B3F\u6B3C\u6B94\u6B97\u6B99\u6B95\u6BBD\u6BF0\u6BF2\u6BF3\u6C30\u6DFC\u6E46\u6E47\u6E1F\u6E49\u6E88\u6E3C\u6E3D\u6E45\u6E62\u6E2B\u6E3F\u6E41\u6E5D\u6E73\u6E1C\u6E33\u6E4B\u6E40\u6E51\u6E3B\u6E03\u6E2E\u6E5E"],
      ["da40", "\u6E68\u6E5C\u6E61\u6E31\u6E28\u6E60\u6E71\u6E6B\u6E39\u6E22\u6E30\u6E53\u6E65\u6E27\u6E78\u6E64\u6E77\u6E55\u6E79\u6E52\u6E66\u6E35\u6E36\u6E5A\u7120\u711E\u712F\u70FB\u712E\u7131\u7123\u7125\u7122\u7132\u711F\u7128\u713A\u711B\u724B\u725A\u7288\u7289\u7286\u7285\u728B\u7312\u730B\u7330\u7322\u7331\u7333\u7327\u7332\u732D\u7326\u7323\u7335\u730C\u742E\u742C\u7430\u742B\u7416"],
      ["daa1", "\u741A\u7421\u742D\u7431\u7424\u7423\u741D\u7429\u7420\u7432\u74FB\u752F\u756F\u756C\u75E7\u75DA\u75E1\u75E6\u75DD\u75DF\u75E4\u75D7\u7695\u7692\u76DA\u7746\u7747\u7744\u774D\u7745\u774A\u774E\u774B\u774C\u77DE\u77EC\u7860\u7864\u7865\u785C\u786D\u7871\u786A\u786E\u7870\u7869\u7868\u785E\u7862\u7974\u7973\u7972\u7970\u7A02\u7A0A\u7A03\u7A0C\u7A04\u7A99\u7AE6\u7AE4\u7B4A\u7B3B\u7B44\u7B48\u7B4C\u7B4E\u7B40\u7B58\u7B45\u7CA2\u7C9E\u7CA8\u7CA1\u7D58\u7D6F\u7D63\u7D53\u7D56\u7D67\u7D6A\u7D4F\u7D6D\u7D5C\u7D6B\u7D52\u7D54\u7D69\u7D51\u7D5F\u7D4E\u7F3E\u7F3F\u7F65"],
      ["db40", "\u7F66\u7FA2\u7FA0\u7FA1\u7FD7\u8051\u804F\u8050\u80FE\u80D4\u8143\u814A\u8152\u814F\u8147\u813D\u814D\u813A\u81E6\u81EE\u81F7\u81F8\u81F9\u8204\u823C\u823D\u823F\u8275\u833B\u83CF\u83F9\u8423\u83C0\u83E8\u8412\u83E7\u83E4\u83FC\u83F6\u8410\u83C6\u83C8\u83EB\u83E3\u83BF\u8401\u83DD\u83E5\u83D8\u83FF\u83E1\u83CB\u83CE\u83D6\u83F5\u83C9\u8409\u840F\u83DE\u8411\u8406\u83C2\u83F3"],
      ["dba1", "\u83D5\u83FA\u83C7\u83D1\u83EA\u8413\u83C3\u83EC\u83EE\u83C4\u83FB\u83D7\u83E2\u841B\u83DB\u83FE\u86D8\u86E2\u86E6\u86D3\u86E3\u86DA\u86EA\u86DD\u86EB\u86DC\u86EC\u86E9\u86D7\u86E8\u86D1\u8848\u8856\u8855\u88BA\u88D7\u88B9\u88B8\u88C0\u88BE\u88B6\u88BC\u88B7\u88BD\u88B2\u8901\u88C9\u8995\u8998\u8997\u89DD\u89DA\u89DB\u8A4E\u8A4D\u8A39\u8A59\u8A40\u8A57\u8A58\u8A44\u8A45\u8A52\u8A48\u8A51\u8A4A\u8A4C\u8A4F\u8C5F\u8C81\u8C80\u8CBA\u8CBE\u8CB0\u8CB9\u8CB5\u8D84\u8D80\u8D89\u8DD8\u8DD3\u8DCD\u8DC7\u8DD6\u8DDC\u8DCF\u8DD5\u8DD9\u8DC8\u8DD7\u8DC5\u8EEF\u8EF7\u8EFA"],
      ["dc40", "\u8EF9\u8EE6\u8EEE\u8EE5\u8EF5\u8EE7\u8EE8\u8EF6\u8EEB\u8EF1\u8EEC\u8EF4\u8EE9\u902D\u9034\u902F\u9106\u912C\u9104\u90FF\u90FC\u9108\u90F9\u90FB\u9101\u9100\u9107\u9105\u9103\u9161\u9164\u915F\u9162\u9160\u9201\u920A\u9225\u9203\u921A\u9226\u920F\u920C\u9200\u9212\u91FF\u91FD\u9206\u9204\u9227\u9202\u921C\u9224\u9219\u9217\u9205\u9216\u957B\u958D\u958C\u9590\u9687\u967E\u9688"],
      ["dca1", "\u9689\u9683\u9680\u96C2\u96C8\u96C3\u96F1\u96F0\u976C\u9770\u976E\u9807\u98A9\u98EB\u9CE6\u9EF9\u4E83\u4E84\u4EB6\u50BD\u50BF\u50C6\u50AE\u50C4\u50CA\u50B4\u50C8\u50C2\u50B0\u50C1\u50BA\u50B1\u50CB\u50C9\u50B6\u50B8\u51D7\u527A\u5278\u527B\u527C\u55C3\u55DB\u55CC\u55D0\u55CB\u55CA\u55DD\u55C0\u55D4\u55C4\u55E9\u55BF\u55D2\u558D\u55CF\u55D5\u55E2\u55D6\u55C8\u55F2\u55CD\u55D9\u55C2\u5714\u5853\u5868\u5864\u584F\u584D\u5849\u586F\u5855\u584E\u585D\u5859\u5865\u585B\u583D\u5863\u5871\u58FC\u5AC7\u5AC4\u5ACB\u5ABA\u5AB8\u5AB1\u5AB5\u5AB0\u5ABF\u5AC8\u5ABB\u5AC6"],
      ["dd40", "\u5AB7\u5AC0\u5ACA\u5AB4\u5AB6\u5ACD\u5AB9\u5A90\u5BD6\u5BD8\u5BD9\u5C1F\u5C33\u5D71\u5D63\u5D4A\u5D65\u5D72\u5D6C\u5D5E\u5D68\u5D67\u5D62\u5DF0\u5E4F\u5E4E\u5E4A\u5E4D\u5E4B\u5EC5\u5ECC\u5EC6\u5ECB\u5EC7\u5F40\u5FAF\u5FAD\u60F7\u6149\u614A\u612B\u6145\u6136\u6132\u612E\u6146\u612F\u614F\u6129\u6140\u6220\u9168\u6223\u6225\u6224\u63C5\u63F1\u63EB\u6410\u6412\u6409\u6420\u6424"],
      ["dda1", "\u6433\u6443\u641F\u6415\u6418\u6439\u6437\u6422\u6423\u640C\u6426\u6430\u6428\u6441\u6435\u642F\u640A\u641A\u6440\u6425\u6427\u640B\u63E7\u641B\u642E\u6421\u640E\u656F\u6592\u65D3\u6686\u668C\u6695\u6690\u668B\u668A\u6699\u6694\u6678\u6720\u6966\u695F\u6938\u694E\u6962\u6971\u693F\u6945\u696A\u6939\u6942\u6957\u6959\u697A\u6948\u6949\u6935\u696C\u6933\u693D\u6965\u68F0\u6978\u6934\u6969\u6940\u696F\u6944\u6976\u6958\u6941\u6974\u694C\u693B\u694B\u6937\u695C\u694F\u6951\u6932\u6952\u692F\u697B\u693C\u6B46\u6B45\u6B43\u6B42\u6B48\u6B41\u6B9B\uFA0D\u6BFB\u6BFC"],
      ["de40", "\u6BF9\u6BF7\u6BF8\u6E9B\u6ED6\u6EC8\u6E8F\u6EC0\u6E9F\u6E93\u6E94\u6EA0\u6EB1\u6EB9\u6EC6\u6ED2\u6EBD\u6EC1\u6E9E\u6EC9\u6EB7\u6EB0\u6ECD\u6EA6\u6ECF\u6EB2\u6EBE\u6EC3\u6EDC\u6ED8\u6E99\u6E92\u6E8E\u6E8D\u6EA4\u6EA1\u6EBF\u6EB3\u6ED0\u6ECA\u6E97\u6EAE\u6EA3\u7147\u7154\u7152\u7163\u7160\u7141\u715D\u7162\u7172\u7178\u716A\u7161\u7142\u7158\u7143\u714B\u7170\u715F\u7150\u7153"],
      ["dea1", "\u7144\u714D\u715A\u724F\u728D\u728C\u7291\u7290\u728E\u733C\u7342\u733B\u733A\u7340\u734A\u7349\u7444\u744A\u744B\u7452\u7451\u7457\u7440\u744F\u7450\u744E\u7442\u7446\u744D\u7454\u74E1\u74FF\u74FE\u74FD\u751D\u7579\u7577\u6983\u75EF\u760F\u7603\u75F7\u75FE\u75FC\u75F9\u75F8\u7610\u75FB\u75F6\u75ED\u75F5\u75FD\u7699\u76B5\u76DD\u7755\u775F\u7760\u7752\u7756\u775A\u7769\u7767\u7754\u7759\u776D\u77E0\u7887\u789A\u7894\u788F\u7884\u7895\u7885\u7886\u78A1\u7883\u7879\u7899\u7880\u7896\u787B\u797C\u7982\u797D\u7979\u7A11\u7A18\u7A19\u7A12\u7A17\u7A15\u7A22\u7A13"],
      ["df40", "\u7A1B\u7A10\u7AA3\u7AA2\u7A9E\u7AEB\u7B66\u7B64\u7B6D\u7B74\u7B69\u7B72\u7B65\u7B73\u7B71\u7B70\u7B61\u7B78\u7B76\u7B63\u7CB2\u7CB4\u7CAF\u7D88\u7D86\u7D80\u7D8D\u7D7F\u7D85\u7D7A\u7D8E\u7D7B\u7D83\u7D7C\u7D8C\u7D94\u7D84\u7D7D\u7D92\u7F6D\u7F6B\u7F67\u7F68\u7F6C\u7FA6\u7FA5\u7FA7\u7FDB\u7FDC\u8021\u8164\u8160\u8177\u815C\u8169\u815B\u8162\u8172\u6721\u815E\u8176\u8167\u816F"],
      ["dfa1", "\u8144\u8161\u821D\u8249\u8244\u8240\u8242\u8245\u84F1\u843F\u8456\u8476\u8479\u848F\u848D\u8465\u8451\u8440\u8486\u8467\u8430\u844D\u847D\u845A\u8459\u8474\u8473\u845D\u8507\u845E\u8437\u843A\u8434\u847A\u8443\u8478\u8432\u8445\u8429\u83D9\u844B\u842F\u8442\u842D\u845F\u8470\u8439\u844E\u844C\u8452\u846F\u84C5\u848E\u843B\u8447\u8436\u8433\u8468\u847E\u8444\u842B\u8460\u8454\u846E\u8450\u870B\u8704\u86F7\u870C\u86FA\u86D6\u86F5\u874D\u86F8\u870E\u8709\u8701\u86F6\u870D\u8705\u88D6\u88CB\u88CD\u88CE\u88DE\u88DB\u88DA\u88CC\u88D0\u8985\u899B\u89DF\u89E5\u89E4"],
      ["e040", "\u89E1\u89E0\u89E2\u89DC\u89E6\u8A76\u8A86\u8A7F\u8A61\u8A3F\u8A77\u8A82\u8A84\u8A75\u8A83\u8A81\u8A74\u8A7A\u8C3C\u8C4B\u8C4A\u8C65\u8C64\u8C66\u8C86\u8C84\u8C85\u8CCC\u8D68\u8D69\u8D91\u8D8C\u8D8E\u8D8F\u8D8D\u8D93\u8D94\u8D90\u8D92\u8DF0\u8DE0\u8DEC\u8DF1\u8DEE\u8DD0\u8DE9\u8DE3\u8DE2\u8DE7\u8DF2\u8DEB\u8DF4\u8F06\u8EFF\u8F01\u8F00\u8F05\u8F07\u8F08\u8F02\u8F0B\u9052\u903F"],
      ["e0a1", "\u9044\u9049\u903D\u9110\u910D\u910F\u9111\u9116\u9114\u910B\u910E\u916E\u916F\u9248\u9252\u9230\u923A\u9266\u9233\u9265\u925E\u9283\u922E\u924A\u9246\u926D\u926C\u924F\u9260\u9267\u926F\u9236\u9261\u9270\u9231\u9254\u9263\u9250\u9272\u924E\u9253\u924C\u9256\u9232\u959F\u959C\u959E\u959B\u9692\u9693\u9691\u9697\u96CE\u96FA\u96FD\u96F8\u96F5\u9773\u9777\u9778\u9772\u980F\u980D\u980E\u98AC\u98F6\u98F9\u99AF\u99B2\u99B0\u99B5\u9AAD\u9AAB\u9B5B\u9CEA\u9CED\u9CE7\u9E80\u9EFD\u50E6\u50D4\u50D7\u50E8\u50F3\u50DB\u50EA\u50DD\u50E4\u50D3\u50EC\u50F0\u50EF\u50E3\u50E0"],
      ["e140", "\u51D8\u5280\u5281\u52E9\u52EB\u5330\u53AC\u5627\u5615\u560C\u5612\u55FC\u560F\u561C\u5601\u5613\u5602\u55FA\u561D\u5604\u55FF\u55F9\u5889\u587C\u5890\u5898\u5886\u5881\u587F\u5874\u588B\u587A\u5887\u5891\u588E\u5876\u5882\u5888\u587B\u5894\u588F\u58FE\u596B\u5ADC\u5AEE\u5AE5\u5AD5\u5AEA\u5ADA\u5AED\u5AEB\u5AF3\u5AE2\u5AE0\u5ADB\u5AEC\u5ADE\u5ADD\u5AD9\u5AE8\u5ADF\u5B77\u5BE0"],
      ["e1a1", "\u5BE3\u5C63\u5D82\u5D80\u5D7D\u5D86\u5D7A\u5D81\u5D77\u5D8A\u5D89\u5D88\u5D7E\u5D7C\u5D8D\u5D79\u5D7F\u5E58\u5E59\u5E53\u5ED8\u5ED1\u5ED7\u5ECE\u5EDC\u5ED5\u5ED9\u5ED2\u5ED4\u5F44\u5F43\u5F6F\u5FB6\u612C\u6128\u6141\u615E\u6171\u6173\u6152\u6153\u6172\u616C\u6180\u6174\u6154\u617A\u615B\u6165\u613B\u616A\u6161\u6156\u6229\u6227\u622B\u642B\u644D\u645B\u645D\u6474\u6476\u6472\u6473\u647D\u6475\u6466\u64A6\u644E\u6482\u645E\u645C\u644B\u6453\u6460\u6450\u647F\u643F\u646C\u646B\u6459\u6465\u6477\u6573\u65A0\u66A1\u66A0\u669F\u6705\u6704\u6722\u69B1\u69B6\u69C9"],
      ["e240", "\u69A0\u69CE\u6996\u69B0\u69AC\u69BC\u6991\u6999\u698E\u69A7\u698D\u69A9\u69BE\u69AF\u69BF\u69C4\u69BD\u69A4\u69D4\u69B9\u69CA\u699A\u69CF\u69B3\u6993\u69AA\u69A1\u699E\u69D9\u6997\u6990\u69C2\u69B5\u69A5\u69C6\u6B4A\u6B4D\u6B4B\u6B9E\u6B9F\u6BA0\u6BC3\u6BC4\u6BFE\u6ECE\u6EF5\u6EF1\u6F03\u6F25\u6EF8\u6F37\u6EFB\u6F2E\u6F09\u6F4E\u6F19\u6F1A\u6F27\u6F18\u6F3B\u6F12\u6EED\u6F0A"],
      ["e2a1", "\u6F36\u6F73\u6EF9\u6EEE\u6F2D\u6F40\u6F30\u6F3C\u6F35\u6EEB\u6F07\u6F0E\u6F43\u6F05\u6EFD\u6EF6\u6F39\u6F1C\u6EFC\u6F3A\u6F1F\u6F0D\u6F1E\u6F08\u6F21\u7187\u7190\u7189\u7180\u7185\u7182\u718F\u717B\u7186\u7181\u7197\u7244\u7253\u7297\u7295\u7293\u7343\u734D\u7351\u734C\u7462\u7473\u7471\u7475\u7472\u7467\u746E\u7500\u7502\u7503\u757D\u7590\u7616\u7608\u760C\u7615\u7611\u760A\u7614\u76B8\u7781\u777C\u7785\u7782\u776E\u7780\u776F\u777E\u7783\u78B2\u78AA\u78B4\u78AD\u78A8\u787E\u78AB\u789E\u78A5\u78A0\u78AC\u78A2\u78A4\u7998\u798A\u798B\u7996\u7995\u7994\u7993"],
      ["e340", "\u7997\u7988\u7992\u7990\u7A2B\u7A4A\u7A30\u7A2F\u7A28\u7A26\u7AA8\u7AAB\u7AAC\u7AEE\u7B88\u7B9C\u7B8A\u7B91\u7B90\u7B96\u7B8D\u7B8C\u7B9B\u7B8E\u7B85\u7B98\u5284\u7B99\u7BA4\u7B82\u7CBB\u7CBF\u7CBC\u7CBA\u7DA7\u7DB7\u7DC2\u7DA3\u7DAA\u7DC1\u7DC0\u7DC5\u7D9D\u7DCE\u7DC4\u7DC6\u7DCB\u7DCC\u7DAF\u7DB9\u7D96\u7DBC\u7D9F\u7DA6\u7DAE\u7DA9\u7DA1\u7DC9\u7F73\u7FE2\u7FE3\u7FE5\u7FDE"],
      ["e3a1", "\u8024\u805D\u805C\u8189\u8186\u8183\u8187\u818D\u818C\u818B\u8215\u8497\u84A4\u84A1\u849F\u84BA\u84CE\u84C2\u84AC\u84AE\u84AB\u84B9\u84B4\u84C1\u84CD\u84AA\u849A\u84B1\u84D0\u849D\u84A7\u84BB\u84A2\u8494\u84C7\u84CC\u849B\u84A9\u84AF\u84A8\u84D6\u8498\u84B6\u84CF\u84A0\u84D7\u84D4\u84D2\u84DB\u84B0\u8491\u8661\u8733\u8723\u8728\u876B\u8740\u872E\u871E\u8721\u8719\u871B\u8743\u872C\u8741\u873E\u8746\u8720\u8732\u872A\u872D\u873C\u8712\u873A\u8731\u8735\u8742\u8726\u8727\u8738\u8724\u871A\u8730\u8711\u88F7\u88E7\u88F1\u88F2\u88FA\u88FE\u88EE\u88FC\u88F6\u88FB"],
      ["e440", "\u88F0\u88EC\u88EB\u899D\u89A1\u899F\u899E\u89E9\u89EB\u89E8\u8AAB\u8A99\u8A8B\u8A92\u8A8F\u8A96\u8C3D\u8C68\u8C69\u8CD5\u8CCF\u8CD7\u8D96\u8E09\u8E02\u8DFF\u8E0D\u8DFD\u8E0A\u8E03\u8E07\u8E06\u8E05\u8DFE\u8E00\u8E04\u8F10\u8F11\u8F0E\u8F0D\u9123\u911C\u9120\u9122\u911F\u911D\u911A\u9124\u9121\u911B\u917A\u9172\u9179\u9173\u92A5\u92A4\u9276\u929B\u927A\u92A0\u9294\u92AA\u928D"],
      ["e4a1", "\u92A6\u929A\u92AB\u9279\u9297\u927F\u92A3\u92EE\u928E\u9282\u9295\u92A2\u927D\u9288\u92A1\u928A\u9286\u928C\u9299\u92A7\u927E\u9287\u92A9\u929D\u928B\u922D\u969E\u96A1\u96FF\u9758\u977D\u977A\u977E\u9783\u9780\u9782\u977B\u9784\u9781\u977F\u97CE\u97CD\u9816\u98AD\u98AE\u9902\u9900\u9907\u999D\u999C\u99C3\u99B9\u99BB\u99BA\u99C2\u99BD\u99C7\u9AB1\u9AE3\u9AE7\u9B3E\u9B3F\u9B60\u9B61\u9B5F\u9CF1\u9CF2\u9CF5\u9EA7\u50FF\u5103\u5130\u50F8\u5106\u5107\u50F6\u50FE\u510B\u510C\u50FD\u510A\u528B\u528C\u52F1\u52EF\u5648\u5642\u564C\u5635\u5641\u564A\u5649\u5646\u5658"],
      ["e540", "\u565A\u5640\u5633\u563D\u562C\u563E\u5638\u562A\u563A\u571A\u58AB\u589D\u58B1\u58A0\u58A3\u58AF\u58AC\u58A5\u58A1\u58FF\u5AFF\u5AF4\u5AFD\u5AF7\u5AF6\u5B03\u5AF8\u5B02\u5AF9\u5B01\u5B07\u5B05\u5B0F\u5C67\u5D99\u5D97\u5D9F\u5D92\u5DA2\u5D93\u5D95\u5DA0\u5D9C\u5DA1\u5D9A\u5D9E\u5E69\u5E5D\u5E60\u5E5C\u7DF3\u5EDB\u5EDE\u5EE1\u5F49\u5FB2\u618B\u6183\u6179\u61B1\u61B0\u61A2\u6189"],
      ["e5a1", "\u619B\u6193\u61AF\u61AD\u619F\u6192\u61AA\u61A1\u618D\u6166\u61B3\u622D\u646E\u6470\u6496\u64A0\u6485\u6497\u649C\u648F\u648B\u648A\u648C\u64A3\u649F\u6468\u64B1\u6498\u6576\u657A\u6579\u657B\u65B2\u65B3\u66B5\u66B0\u66A9\u66B2\u66B7\u66AA\u66AF\u6A00\u6A06\u6A17\u69E5\u69F8\u6A15\u69F1\u69E4\u6A20\u69FF\u69EC\u69E2\u6A1B\u6A1D\u69FE\u6A27\u69F2\u69EE\u6A14\u69F7\u69E7\u6A40\u6A08\u69E6\u69FB\u6A0D\u69FC\u69EB\u6A09\u6A04\u6A18\u6A25\u6A0F\u69F6\u6A26\u6A07\u69F4\u6A16\u6B51\u6BA5\u6BA3\u6BA2\u6BA6\u6C01\u6C00\u6BFF\u6C02\u6F41\u6F26\u6F7E\u6F87\u6FC6\u6F92"],
      ["e640", "\u6F8D\u6F89\u6F8C\u6F62\u6F4F\u6F85\u6F5A\u6F96\u6F76\u6F6C\u6F82\u6F55\u6F72\u6F52\u6F50\u6F57\u6F94\u6F93\u6F5D\u6F00\u6F61\u6F6B\u6F7D\u6F67\u6F90\u6F53\u6F8B\u6F69\u6F7F\u6F95\u6F63\u6F77\u6F6A\u6F7B\u71B2\u71AF\u719B\u71B0\u71A0\u719A\u71A9\u71B5\u719D\u71A5\u719E\u71A4\u71A1\u71AA\u719C\u71A7\u71B3\u7298\u729A\u7358\u7352\u735E\u735F\u7360\u735D\u735B\u7361\u735A\u7359"],
      ["e6a1", "\u7362\u7487\u7489\u748A\u7486\u7481\u747D\u7485\u7488\u747C\u7479\u7508\u7507\u757E\u7625\u761E\u7619\u761D\u761C\u7623\u761A\u7628\u761B\u769C\u769D\u769E\u769B\u778D\u778F\u7789\u7788\u78CD\u78BB\u78CF\u78CC\u78D1\u78CE\u78D4\u78C8\u78C3\u78C4\u78C9\u799A\u79A1\u79A0\u799C\u79A2\u799B\u6B76\u7A39\u7AB2\u7AB4\u7AB3\u7BB7\u7BCB\u7BBE\u7BAC\u7BCE\u7BAF\u7BB9\u7BCA\u7BB5\u7CC5\u7CC8\u7CCC\u7CCB\u7DF7\u7DDB\u7DEA\u7DE7\u7DD7\u7DE1\u7E03\u7DFA\u7DE6\u7DF6\u7DF1\u7DF0\u7DEE\u7DDF\u7F76\u7FAC\u7FB0\u7FAD\u7FED\u7FEB\u7FEA\u7FEC\u7FE6\u7FE8\u8064\u8067\u81A3\u819F"],
      ["e740", "\u819E\u8195\u81A2\u8199\u8197\u8216\u824F\u8253\u8252\u8250\u824E\u8251\u8524\u853B\u850F\u8500\u8529\u850E\u8509\u850D\u851F\u850A\u8527\u851C\u84FB\u852B\u84FA\u8508\u850C\u84F4\u852A\u84F2\u8515\u84F7\u84EB\u84F3\u84FC\u8512\u84EA\u84E9\u8516\u84FE\u8528\u851D\u852E\u8502\u84FD\u851E\u84F6\u8531\u8526\u84E7\u84E8\u84F0\u84EF\u84F9\u8518\u8520\u8530\u850B\u8519\u852F\u8662"],
      ["e7a1", "\u8756\u8763\u8764\u8777\u87E1\u8773\u8758\u8754\u875B\u8752\u8761\u875A\u8751\u875E\u876D\u876A\u8750\u874E\u875F\u875D\u876F\u876C\u877A\u876E\u875C\u8765\u874F\u877B\u8775\u8762\u8767\u8769\u885A\u8905\u890C\u8914\u890B\u8917\u8918\u8919\u8906\u8916\u8911\u890E\u8909\u89A2\u89A4\u89A3\u89ED\u89F0\u89EC\u8ACF\u8AC6\u8AB8\u8AD3\u8AD1\u8AD4\u8AD5\u8ABB\u8AD7\u8ABE\u8AC0\u8AC5\u8AD8\u8AC3\u8ABA\u8ABD\u8AD9\u8C3E\u8C4D\u8C8F\u8CE5\u8CDF\u8CD9\u8CE8\u8CDA\u8CDD\u8CE7\u8DA0\u8D9C\u8DA1\u8D9B\u8E20\u8E23\u8E25\u8E24\u8E2E\u8E15\u8E1B\u8E16\u8E11\u8E19\u8E26\u8E27"],
      ["e840", "\u8E14\u8E12\u8E18\u8E13\u8E1C\u8E17\u8E1A\u8F2C\u8F24\u8F18\u8F1A\u8F20\u8F23\u8F16\u8F17\u9073\u9070\u906F\u9067\u906B\u912F\u912B\u9129\u912A\u9132\u9126\u912E\u9185\u9186\u918A\u9181\u9182\u9184\u9180\u92D0\u92C3\u92C4\u92C0\u92D9\u92B6\u92CF\u92F1\u92DF\u92D8\u92E9\u92D7\u92DD\u92CC\u92EF\u92C2\u92E8\u92CA\u92C8\u92CE\u92E6\u92CD\u92D5\u92C9\u92E0\u92DE\u92E7\u92D1\u92D3"],
      ["e8a1", "\u92B5\u92E1\u92C6\u92B4\u957C\u95AC\u95AB\u95AE\u95B0\u96A4\u96A2\u96D3\u9705\u9708\u9702\u975A\u978A\u978E\u9788\u97D0\u97CF\u981E\u981D\u9826\u9829\u9828\u9820\u981B\u9827\u98B2\u9908\u98FA\u9911\u9914\u9916\u9917\u9915\u99DC\u99CD\u99CF\u99D3\u99D4\u99CE\u99C9\u99D6\u99D8\u99CB\u99D7\u99CC\u9AB3\u9AEC\u9AEB\u9AF3\u9AF2\u9AF1\u9B46\u9B43\u9B67\u9B74\u9B71\u9B66\u9B76\u9B75\u9B70\u9B68\u9B64\u9B6C\u9CFC\u9CFA\u9CFD\u9CFF\u9CF7\u9D07\u9D00\u9CF9\u9CFB\u9D08\u9D05\u9D04\u9E83\u9ED3\u9F0F\u9F10\u511C\u5113\u5117\u511A\u5111\u51DE\u5334\u53E1\u5670\u5660\u566E"],
      ["e940", "\u5673\u5666\u5663\u566D\u5672\u565E\u5677\u571C\u571B\u58C8\u58BD\u58C9\u58BF\u58BA\u58C2\u58BC\u58C6\u5B17\u5B19\u5B1B\u5B21\u5B14\u5B13\u5B10\u5B16\u5B28\u5B1A\u5B20\u5B1E\u5BEF\u5DAC\u5DB1\u5DA9\u5DA7\u5DB5\u5DB0\u5DAE\u5DAA\u5DA8\u5DB2\u5DAD\u5DAF\u5DB4\u5E67\u5E68\u5E66\u5E6F\u5EE9\u5EE7\u5EE6\u5EE8\u5EE5\u5F4B\u5FBC\u619D\u61A8\u6196\u61C5\u61B4\u61C6\u61C1\u61CC\u61BA"],
      ["e9a1", "\u61BF\u61B8\u618C\u64D7\u64D6\u64D0\u64CF\u64C9\u64BD\u6489\u64C3\u64DB\u64F3\u64D9\u6533\u657F\u657C\u65A2\u66C8\u66BE\u66C0\u66CA\u66CB\u66CF\u66BD\u66BB\u66BA\u66CC\u6723\u6A34\u6A66\u6A49\u6A67\u6A32\u6A68\u6A3E\u6A5D\u6A6D\u6A76\u6A5B\u6A51\u6A28\u6A5A\u6A3B\u6A3F\u6A41\u6A6A\u6A64\u6A50\u6A4F\u6A54\u6A6F\u6A69\u6A60\u6A3C\u6A5E\u6A56\u6A55\u6A4D\u6A4E\u6A46\u6B55\u6B54\u6B56\u6BA7\u6BAA\u6BAB\u6BC8\u6BC7\u6C04\u6C03\u6C06\u6FAD\u6FCB\u6FA3\u6FC7\u6FBC\u6FCE\u6FC8\u6F5E\u6FC4\u6FBD\u6F9E\u6FCA\u6FA8\u7004\u6FA5\u6FAE\u6FBA\u6FAC\u6FAA\u6FCF\u6FBF\u6FB8"],
      ["ea40", "\u6FA2\u6FC9\u6FAB\u6FCD\u6FAF\u6FB2\u6FB0\u71C5\u71C2\u71BF\u71B8\u71D6\u71C0\u71C1\u71CB\u71D4\u71CA\u71C7\u71CF\u71BD\u71D8\u71BC\u71C6\u71DA\u71DB\u729D\u729E\u7369\u7366\u7367\u736C\u7365\u736B\u736A\u747F\u749A\u74A0\u7494\u7492\u7495\u74A1\u750B\u7580\u762F\u762D\u7631\u763D\u7633\u763C\u7635\u7632\u7630\u76BB\u76E6\u779A\u779D\u77A1\u779C\u779B\u77A2\u77A3\u7795\u7799"],
      ["eaa1", "\u7797\u78DD\u78E9\u78E5\u78EA\u78DE\u78E3\u78DB\u78E1\u78E2\u78ED\u78DF\u78E0\u79A4\u7A44\u7A48\u7A47\u7AB6\u7AB8\u7AB5\u7AB1\u7AB7\u7BDE\u7BE3\u7BE7\u7BDD\u7BD5\u7BE5\u7BDA\u7BE8\u7BF9\u7BD4\u7BEA\u7BE2\u7BDC\u7BEB\u7BD8\u7BDF\u7CD2\u7CD4\u7CD7\u7CD0\u7CD1\u7E12\u7E21\u7E17\u7E0C\u7E1F\u7E20\u7E13\u7E0E\u7E1C\u7E15\u7E1A\u7E22\u7E0B\u7E0F\u7E16\u7E0D\u7E14\u7E25\u7E24\u7F43\u7F7B\u7F7C\u7F7A\u7FB1\u7FEF\u802A\u8029\u806C\u81B1\u81A6\u81AE\u81B9\u81B5\u81AB\u81B0\u81AC\u81B4\u81B2\u81B7\u81A7\u81F2\u8255\u8256\u8257\u8556\u8545\u856B\u854D\u8553\u8561\u8558"],
      ["eb40", "\u8540\u8546\u8564\u8541\u8562\u8544\u8551\u8547\u8563\u853E\u855B\u8571\u854E\u856E\u8575\u8555\u8567\u8560\u858C\u8566\u855D\u8554\u8565\u856C\u8663\u8665\u8664\u879B\u878F\u8797\u8793\u8792\u8788\u8781\u8796\u8798\u8779\u8787\u87A3\u8785\u8790\u8791\u879D\u8784\u8794\u879C\u879A\u8789\u891E\u8926\u8930\u892D\u892E\u8927\u8931\u8922\u8929\u8923\u892F\u892C\u891F\u89F1\u8AE0"],
      ["eba1", "\u8AE2\u8AF2\u8AF4\u8AF5\u8ADD\u8B14\u8AE4\u8ADF\u8AF0\u8AC8\u8ADE\u8AE1\u8AE8\u8AFF\u8AEF\u8AFB\u8C91\u8C92\u8C90\u8CF5\u8CEE\u8CF1\u8CF0\u8CF3\u8D6C\u8D6E\u8DA5\u8DA7\u8E33\u8E3E\u8E38\u8E40\u8E45\u8E36\u8E3C\u8E3D\u8E41\u8E30\u8E3F\u8EBD\u8F36\u8F2E\u8F35\u8F32\u8F39\u8F37\u8F34\u9076\u9079\u907B\u9086\u90FA\u9133\u9135\u9136\u9193\u9190\u9191\u918D\u918F\u9327\u931E\u9308\u931F\u9306\u930F\u937A\u9338\u933C\u931B\u9323\u9312\u9301\u9346\u932D\u930E\u930D\u92CB\u931D\u92FA\u9325\u9313\u92F9\u92F7\u9334\u9302\u9324\u92FF\u9329\u9339\u9335\u932A\u9314\u930C"],
      ["ec40", "\u930B\u92FE\u9309\u9300\u92FB\u9316\u95BC\u95CD\u95BE\u95B9\u95BA\u95B6\u95BF\u95B5\u95BD\u96A9\u96D4\u970B\u9712\u9710\u9799\u9797\u9794\u97F0\u97F8\u9835\u982F\u9832\u9924\u991F\u9927\u9929\u999E\u99EE\u99EC\u99E5\u99E4\u99F0\u99E3\u99EA\u99E9\u99E7\u9AB9\u9ABF\u9AB4\u9ABB\u9AF6\u9AFA\u9AF9\u9AF7\u9B33\u9B80\u9B85\u9B87\u9B7C\u9B7E\u9B7B\u9B82\u9B93\u9B92\u9B90\u9B7A\u9B95"],
      ["eca1", "\u9B7D\u9B88\u9D25\u9D17\u9D20\u9D1E\u9D14\u9D29\u9D1D\u9D18\u9D22\u9D10\u9D19\u9D1F\u9E88\u9E86\u9E87\u9EAE\u9EAD\u9ED5\u9ED6\u9EFA\u9F12\u9F3D\u5126\u5125\u5122\u5124\u5120\u5129\u52F4\u5693\u568C\u568D\u5686\u5684\u5683\u567E\u5682\u567F\u5681\u58D6\u58D4\u58CF\u58D2\u5B2D\u5B25\u5B32\u5B23\u5B2C\u5B27\u5B26\u5B2F\u5B2E\u5B7B\u5BF1\u5BF2\u5DB7\u5E6C\u5E6A\u5FBE\u5FBB\u61C3\u61B5\u61BC\u61E7\u61E0\u61E5\u61E4\u61E8\u61DE\u64EF\u64E9\u64E3\u64EB\u64E4\u64E8\u6581\u6580\u65B6\u65DA\u66D2\u6A8D\u6A96\u6A81\u6AA5\u6A89\u6A9F\u6A9B\u6AA1\u6A9E\u6A87\u6A93\u6A8E"],
      ["ed40", "\u6A95\u6A83\u6AA8\u6AA4\u6A91\u6A7F\u6AA6\u6A9A\u6A85\u6A8C\u6A92\u6B5B\u6BAD\u6C09\u6FCC\u6FA9\u6FF4\u6FD4\u6FE3\u6FDC\u6FED\u6FE7\u6FE6\u6FDE\u6FF2\u6FDD\u6FE2\u6FE8\u71E1\u71F1\u71E8\u71F2\u71E4\u71F0\u71E2\u7373\u736E\u736F\u7497\u74B2\u74AB\u7490\u74AA\u74AD\u74B1\u74A5\u74AF\u7510\u7511\u7512\u750F\u7584\u7643\u7648\u7649\u7647\u76A4\u76E9\u77B5\u77AB\u77B2\u77B7\u77B6"],
      ["eda1", "\u77B4\u77B1\u77A8\u77F0\u78F3\u78FD\u7902\u78FB\u78FC\u78F2\u7905\u78F9\u78FE\u7904\u79AB\u79A8\u7A5C\u7A5B\u7A56\u7A58\u7A54\u7A5A\u7ABE\u7AC0\u7AC1\u7C05\u7C0F\u7BF2\u7C00\u7BFF\u7BFB\u7C0E\u7BF4\u7C0B\u7BF3\u7C02\u7C09\u7C03\u7C01\u7BF8\u7BFD\u7C06\u7BF0\u7BF1\u7C10\u7C0A\u7CE8\u7E2D\u7E3C\u7E42\u7E33\u9848\u7E38\u7E2A\u7E49\u7E40\u7E47\u7E29\u7E4C\u7E30\u7E3B\u7E36\u7E44\u7E3A\u7F45\u7F7F\u7F7E\u7F7D\u7FF4\u7FF2\u802C\u81BB\u81C4\u81CC\u81CA\u81C5\u81C7\u81BC\u81E9\u825B\u825A\u825C\u8583\u8580\u858F\u85A7\u8595\u85A0\u858B\u85A3\u857B\u85A4\u859A\u859E"],
      ["ee40", "\u8577\u857C\u8589\u85A1\u857A\u8578\u8557\u858E\u8596\u8586\u858D\u8599\u859D\u8581\u85A2\u8582\u8588\u8585\u8579\u8576\u8598\u8590\u859F\u8668\u87BE\u87AA\u87AD\u87C5\u87B0\u87AC\u87B9\u87B5\u87BC\u87AE\u87C9\u87C3\u87C2\u87CC\u87B7\u87AF\u87C4\u87CA\u87B4\u87B6\u87BF\u87B8\u87BD\u87DE\u87B2\u8935\u8933\u893C\u893E\u8941\u8952\u8937\u8942\u89AD\u89AF\u89AE\u89F2\u89F3\u8B1E"],
      ["eea1", "\u8B18\u8B16\u8B11\u8B05\u8B0B\u8B22\u8B0F\u8B12\u8B15\u8B07\u8B0D\u8B08\u8B06\u8B1C\u8B13\u8B1A\u8C4F\u8C70\u8C72\u8C71\u8C6F\u8C95\u8C94\u8CF9\u8D6F\u8E4E\u8E4D\u8E53\u8E50\u8E4C\u8E47\u8F43\u8F40\u9085\u907E\u9138\u919A\u91A2\u919B\u9199\u919F\u91A1\u919D\u91A0\u93A1\u9383\u93AF\u9364\u9356\u9347\u937C\u9358\u935C\u9376\u9349\u9350\u9351\u9360\u936D\u938F\u934C\u936A\u9379\u9357\u9355\u9352\u934F\u9371\u9377\u937B\u9361\u935E\u9363\u9367\u9380\u934E\u9359\u95C7\u95C0\u95C9\u95C3\u95C5\u95B7\u96AE\u96B0\u96AC\u9720\u971F\u9718\u971D\u9719\u979A\u97A1\u979C"],
      ["ef40", "\u979E\u979D\u97D5\u97D4\u97F1\u9841\u9844\u984A\u9849\u9845\u9843\u9925\u992B\u992C\u992A\u9933\u9932\u992F\u992D\u9931\u9930\u9998\u99A3\u99A1\u9A02\u99FA\u99F4\u99F7\u99F9\u99F8\u99F6\u99FB\u99FD\u99FE\u99FC\u9A03\u9ABE\u9AFE\u9AFD\u9B01\u9AFC\u9B48\u9B9A\u9BA8\u9B9E\u9B9B\u9BA6\u9BA1\u9BA5\u9BA4\u9B86\u9BA2\u9BA0\u9BAF\u9D33\u9D41\u9D67\u9D36\u9D2E\u9D2F\u9D31\u9D38\u9D30"],
      ["efa1", "\u9D45\u9D42\u9D43\u9D3E\u9D37\u9D40\u9D3D\u7FF5\u9D2D\u9E8A\u9E89\u9E8D\u9EB0\u9EC8\u9EDA\u9EFB\u9EFF\u9F24\u9F23\u9F22\u9F54\u9FA0\u5131\u512D\u512E\u5698\u569C\u5697\u569A\u569D\u5699\u5970\u5B3C\u5C69\u5C6A\u5DC0\u5E6D\u5E6E\u61D8\u61DF\u61ED\u61EE\u61F1\u61EA\u61F0\u61EB\u61D6\u61E9\u64FF\u6504\u64FD\u64F8\u6501\u6503\u64FC\u6594\u65DB\u66DA\u66DB\u66D8\u6AC5\u6AB9\u6ABD\u6AE1\u6AC6\u6ABA\u6AB6\u6AB7\u6AC7\u6AB4\u6AAD\u6B5E\u6BC9\u6C0B\u7007\u700C\u700D\u7001\u7005\u7014\u700E\u6FFF\u7000\u6FFB\u7026\u6FFC\u6FF7\u700A\u7201\u71FF\u71F9\u7203\u71FD\u7376"],
      ["f040", "\u74B8\u74C0\u74B5\u74C1\u74BE\u74B6\u74BB\u74C2\u7514\u7513\u765C\u7664\u7659\u7650\u7653\u7657\u765A\u76A6\u76BD\u76EC\u77C2\u77BA\u78FF\u790C\u7913\u7914\u7909\u7910\u7912\u7911\u79AD\u79AC\u7A5F\u7C1C\u7C29\u7C19\u7C20\u7C1F\u7C2D\u7C1D\u7C26\u7C28\u7C22\u7C25\u7C30\u7E5C\u7E50\u7E56\u7E63\u7E58\u7E62\u7E5F\u7E51\u7E60\u7E57\u7E53\u7FB5\u7FB3\u7FF7\u7FF8\u8075\u81D1\u81D2"],
      ["f0a1", "\u81D0\u825F\u825E\u85B4\u85C6\u85C0\u85C3\u85C2\u85B3\u85B5\u85BD\u85C7\u85C4\u85BF\u85CB\u85CE\u85C8\u85C5\u85B1\u85B6\u85D2\u8624\u85B8\u85B7\u85BE\u8669\u87E7\u87E6\u87E2\u87DB\u87EB\u87EA\u87E5\u87DF\u87F3\u87E4\u87D4\u87DC\u87D3\u87ED\u87D8\u87E3\u87A4\u87D7\u87D9\u8801\u87F4\u87E8\u87DD\u8953\u894B\u894F\u894C\u8946\u8950\u8951\u8949\u8B2A\u8B27\u8B23\u8B33\u8B30\u8B35\u8B47\u8B2F\u8B3C\u8B3E\u8B31\u8B25\u8B37\u8B26\u8B36\u8B2E\u8B24\u8B3B\u8B3D\u8B3A\u8C42\u8C75\u8C99\u8C98\u8C97\u8CFE\u8D04\u8D02\u8D00\u8E5C\u8E62\u8E60\u8E57\u8E56\u8E5E\u8E65\u8E67"],
      ["f140", "\u8E5B\u8E5A\u8E61\u8E5D\u8E69\u8E54\u8F46\u8F47\u8F48\u8F4B\u9128\u913A\u913B\u913E\u91A8\u91A5\u91A7\u91AF\u91AA\u93B5\u938C\u9392\u93B7\u939B\u939D\u9389\u93A7\u938E\u93AA\u939E\u93A6\u9395\u9388\u9399\u939F\u938D\u93B1\u9391\u93B2\u93A4\u93A8\u93B4\u93A3\u93A5\u95D2\u95D3\u95D1\u96B3\u96D7\u96DA\u5DC2\u96DF\u96D8\u96DD\u9723\u9722\u9725\u97AC\u97AE\u97A8\u97AB\u97A4\u97AA"],
      ["f1a1", "\u97A2\u97A5\u97D7\u97D9\u97D6\u97D8\u97FA\u9850\u9851\u9852\u98B8\u9941\u993C\u993A\u9A0F\u9A0B\u9A09\u9A0D\u9A04\u9A11\u9A0A\u9A05\u9A07\u9A06\u9AC0\u9ADC\u9B08\u9B04\u9B05\u9B29\u9B35\u9B4A\u9B4C\u9B4B\u9BC7\u9BC6\u9BC3\u9BBF\u9BC1\u9BB5\u9BB8\u9BD3\u9BB6\u9BC4\u9BB9\u9BBD\u9D5C\u9D53\u9D4F\u9D4A\u9D5B\u9D4B\u9D59\u9D56\u9D4C\u9D57\u9D52\u9D54\u9D5F\u9D58\u9D5A\u9E8E\u9E8C\u9EDF\u9F01\u9F00\u9F16\u9F25\u9F2B\u9F2A\u9F29\u9F28\u9F4C\u9F55\u5134\u5135\u5296\u52F7\u53B4\u56AB\u56AD\u56A6\u56A7\u56AA\u56AC\u58DA\u58DD\u58DB\u5912\u5B3D\u5B3E\u5B3F\u5DC3\u5E70"],
      ["f240", "\u5FBF\u61FB\u6507\u6510\u650D\u6509\u650C\u650E\u6584\u65DE\u65DD\u66DE\u6AE7\u6AE0\u6ACC\u6AD1\u6AD9\u6ACB\u6ADF\u6ADC\u6AD0\u6AEB\u6ACF\u6ACD\u6ADE\u6B60\u6BB0\u6C0C\u7019\u7027\u7020\u7016\u702B\u7021\u7022\u7023\u7029\u7017\u7024\u701C\u702A\u720C\u720A\u7207\u7202\u7205\u72A5\u72A6\u72A4\u72A3\u72A1\u74CB\u74C5\u74B7\u74C3\u7516\u7660\u77C9\u77CA\u77C4\u77F1\u791D\u791B"],
      ["f2a1", "\u7921\u791C\u7917\u791E\u79B0\u7A67\u7A68\u7C33\u7C3C\u7C39\u7C2C\u7C3B\u7CEC\u7CEA\u7E76\u7E75\u7E78\u7E70\u7E77\u7E6F\u7E7A\u7E72\u7E74\u7E68\u7F4B\u7F4A\u7F83\u7F86\u7FB7\u7FFD\u7FFE\u8078\u81D7\u81D5\u8264\u8261\u8263\u85EB\u85F1\u85ED\u85D9\u85E1\u85E8\u85DA\u85D7\u85EC\u85F2\u85F8\u85D8\u85DF\u85E3\u85DC\u85D1\u85F0\u85E6\u85EF\u85DE\u85E2\u8800\u87FA\u8803\u87F6\u87F7\u8809\u880C\u880B\u8806\u87FC\u8808\u87FF\u880A\u8802\u8962\u895A\u895B\u8957\u8961\u895C\u8958\u895D\u8959\u8988\u89B7\u89B6\u89F6\u8B50\u8B48\u8B4A\u8B40\u8B53\u8B56\u8B54\u8B4B\u8B55"],
      ["f340", "\u8B51\u8B42\u8B52\u8B57\u8C43\u8C77\u8C76\u8C9A\u8D06\u8D07\u8D09\u8DAC\u8DAA\u8DAD\u8DAB\u8E6D\u8E78\u8E73\u8E6A\u8E6F\u8E7B\u8EC2\u8F52\u8F51\u8F4F\u8F50\u8F53\u8FB4\u9140\u913F\u91B0\u91AD\u93DE\u93C7\u93CF\u93C2\u93DA\u93D0\u93F9\u93EC\u93CC\u93D9\u93A9\u93E6\u93CA\u93D4\u93EE\u93E3\u93D5\u93C4\u93CE\u93C0\u93D2\u93E7\u957D\u95DA\u95DB\u96E1\u9729\u972B\u972C\u9728\u9726"],
      ["f3a1", "\u97B3\u97B7\u97B6\u97DD\u97DE\u97DF\u985C\u9859\u985D\u9857\u98BF\u98BD\u98BB\u98BE\u9948\u9947\u9943\u99A6\u99A7\u9A1A\u9A15\u9A25\u9A1D\u9A24\u9A1B\u9A22\u9A20\u9A27\u9A23\u9A1E\u9A1C\u9A14\u9AC2\u9B0B\u9B0A\u9B0E\u9B0C\u9B37\u9BEA\u9BEB\u9BE0\u9BDE\u9BE4\u9BE6\u9BE2\u9BF0\u9BD4\u9BD7\u9BEC\u9BDC\u9BD9\u9BE5\u9BD5\u9BE1\u9BDA\u9D77\u9D81\u9D8A\u9D84\u9D88\u9D71\u9D80\u9D78\u9D86\u9D8B\u9D8C\u9D7D\u9D6B\u9D74\u9D75\u9D70\u9D69\u9D85\u9D73\u9D7B\u9D82\u9D6F\u9D79\u9D7F\u9D87\u9D68\u9E94\u9E91\u9EC0\u9EFC\u9F2D\u9F40\u9F41\u9F4D\u9F56\u9F57\u9F58\u5337\u56B2"],
      ["f440", "\u56B5\u56B3\u58E3\u5B45\u5DC6\u5DC7\u5EEE\u5EEF\u5FC0\u5FC1\u61F9\u6517\u6516\u6515\u6513\u65DF\u66E8\u66E3\u66E4\u6AF3\u6AF0\u6AEA\u6AE8\u6AF9\u6AF1\u6AEE\u6AEF\u703C\u7035\u702F\u7037\u7034\u7031\u7042\u7038\u703F\u703A\u7039\u7040\u703B\u7033\u7041\u7213\u7214\u72A8\u737D\u737C\u74BA\u76AB\u76AA\u76BE\u76ED\u77CC\u77CE\u77CF\u77CD\u77F2\u7925\u7923\u7927\u7928\u7924\u7929"],
      ["f4a1", "\u79B2\u7A6E\u7A6C\u7A6D\u7AF7\u7C49\u7C48\u7C4A\u7C47\u7C45\u7CEE\u7E7B\u7E7E\u7E81\u7E80\u7FBA\u7FFF\u8079\u81DB\u81D9\u820B\u8268\u8269\u8622\u85FF\u8601\u85FE\u861B\u8600\u85F6\u8604\u8609\u8605\u860C\u85FD\u8819\u8810\u8811\u8817\u8813\u8816\u8963\u8966\u89B9\u89F7\u8B60\u8B6A\u8B5D\u8B68\u8B63\u8B65\u8B67\u8B6D\u8DAE\u8E86\u8E88\u8E84\u8F59\u8F56\u8F57\u8F55\u8F58\u8F5A\u908D\u9143\u9141\u91B7\u91B5\u91B2\u91B3\u940B\u9413\u93FB\u9420\u940F\u9414\u93FE\u9415\u9410\u9428\u9419\u940D\u93F5\u9400\u93F7\u9407\u940E\u9416\u9412\u93FA\u9409\u93F8\u940A\u93FF"],
      ["f540", "\u93FC\u940C\u93F6\u9411\u9406\u95DE\u95E0\u95DF\u972E\u972F\u97B9\u97BB\u97FD\u97FE\u9860\u9862\u9863\u985F\u98C1\u98C2\u9950\u994E\u9959\u994C\u994B\u9953\u9A32\u9A34\u9A31\u9A2C\u9A2A\u9A36\u9A29\u9A2E\u9A38\u9A2D\u9AC7\u9ACA\u9AC6\u9B10\u9B12\u9B11\u9C0B\u9C08\u9BF7\u9C05\u9C12\u9BF8\u9C40\u9C07\u9C0E\u9C06\u9C17\u9C14\u9C09\u9D9F\u9D99\u9DA4\u9D9D\u9D92\u9D98\u9D90\u9D9B"],
      ["f5a1", "\u9DA0\u9D94\u9D9C\u9DAA\u9D97\u9DA1\u9D9A\u9DA2\u9DA8\u9D9E\u9DA3\u9DBF\u9DA9\u9D96\u9DA6\u9DA7\u9E99\u9E9B\u9E9A\u9EE5\u9EE4\u9EE7\u9EE6\u9F30\u9F2E\u9F5B\u9F60\u9F5E\u9F5D\u9F59\u9F91\u513A\u5139\u5298\u5297\u56C3\u56BD\u56BE\u5B48\u5B47\u5DCB\u5DCF\u5EF1\u61FD\u651B\u6B02\u6AFC\u6B03\u6AF8\u6B00\u7043\u7044\u704A\u7048\u7049\u7045\u7046\u721D\u721A\u7219\u737E\u7517\u766A\u77D0\u792D\u7931\u792F\u7C54\u7C53\u7CF2\u7E8A\u7E87\u7E88\u7E8B\u7E86\u7E8D\u7F4D\u7FBB\u8030\u81DD\u8618\u862A\u8626\u861F\u8623\u861C\u8619\u8627\u862E\u8621\u8620\u8629\u861E\u8625"],
      ["f640", "\u8829\u881D\u881B\u8820\u8824\u881C\u882B\u884A\u896D\u8969\u896E\u896B\u89FA\u8B79\u8B78\u8B45\u8B7A\u8B7B\u8D10\u8D14\u8DAF\u8E8E\u8E8C\u8F5E\u8F5B\u8F5D\u9146\u9144\u9145\u91B9\u943F\u943B\u9436\u9429\u943D\u943C\u9430\u9439\u942A\u9437\u942C\u9440\u9431\u95E5\u95E4\u95E3\u9735\u973A\u97BF\u97E1\u9864\u98C9\u98C6\u98C0\u9958\u9956\u9A39\u9A3D\u9A46\u9A44\u9A42\u9A41\u9A3A"],
      ["f6a1", "\u9A3F\u9ACD\u9B15\u9B17\u9B18\u9B16\u9B3A\u9B52\u9C2B\u9C1D\u9C1C\u9C2C\u9C23\u9C28\u9C29\u9C24\u9C21\u9DB7\u9DB6\u9DBC\u9DC1\u9DC7\u9DCA\u9DCF\u9DBE\u9DC5\u9DC3\u9DBB\u9DB5\u9DCE\u9DB9\u9DBA\u9DAC\u9DC8\u9DB1\u9DAD\u9DCC\u9DB3\u9DCD\u9DB2\u9E7A\u9E9C\u9EEB\u9EEE\u9EED\u9F1B\u9F18\u9F1A\u9F31\u9F4E\u9F65\u9F64\u9F92\u4EB9\u56C6\u56C5\u56CB\u5971\u5B4B\u5B4C\u5DD5\u5DD1\u5EF2\u6521\u6520\u6526\u6522\u6B0B\u6B08\u6B09\u6C0D\u7055\u7056\u7057\u7052\u721E\u721F\u72A9\u737F\u74D8\u74D5\u74D9\u74D7\u766D\u76AD\u7935\u79B4\u7A70\u7A71\u7C57\u7C5C\u7C59\u7C5B\u7C5A"],
      ["f740", "\u7CF4\u7CF1\u7E91\u7F4F\u7F87\u81DE\u826B\u8634\u8635\u8633\u862C\u8632\u8636\u882C\u8828\u8826\u882A\u8825\u8971\u89BF\u89BE\u89FB\u8B7E\u8B84\u8B82\u8B86\u8B85\u8B7F\u8D15\u8E95\u8E94\u8E9A\u8E92\u8E90\u8E96\u8E97\u8F60\u8F62\u9147\u944C\u9450\u944A\u944B\u944F\u9447\u9445\u9448\u9449\u9446\u973F\u97E3\u986A\u9869\u98CB\u9954\u995B\u9A4E\u9A53\u9A54\u9A4C\u9A4F\u9A48\u9A4A"],
      ["f7a1", "\u9A49\u9A52\u9A50\u9AD0\u9B19\u9B2B\u9B3B\u9B56\u9B55\u9C46\u9C48\u9C3F\u9C44\u9C39\u9C33\u9C41\u9C3C\u9C37\u9C34\u9C32\u9C3D\u9C36\u9DDB\u9DD2\u9DDE\u9DDA\u9DCB\u9DD0\u9DDC\u9DD1\u9DDF\u9DE9\u9DD9\u9DD8\u9DD6\u9DF5\u9DD5\u9DDD\u9EB6\u9EF0\u9F35\u9F33\u9F32\u9F42\u9F6B\u9F95\u9FA2\u513D\u5299\u58E8\u58E7\u5972\u5B4D\u5DD8\u882F\u5F4F\u6201\u6203\u6204\u6529\u6525\u6596\u66EB\u6B11\u6B12\u6B0F\u6BCA\u705B\u705A\u7222\u7382\u7381\u7383\u7670\u77D4\u7C67\u7C66\u7E95\u826C\u863A\u8640\u8639\u863C\u8631\u863B\u863E\u8830\u8832\u882E\u8833\u8976\u8974\u8973\u89FE"],
      ["f840", "\u8B8C\u8B8E\u8B8B\u8B88\u8C45\u8D19\u8E98\u8F64\u8F63\u91BC\u9462\u9455\u945D\u9457\u945E\u97C4\u97C5\u9800\u9A56\u9A59\u9B1E\u9B1F\u9B20\u9C52\u9C58\u9C50\u9C4A\u9C4D\u9C4B\u9C55\u9C59\u9C4C\u9C4E\u9DFB\u9DF7\u9DEF\u9DE3\u9DEB\u9DF8\u9DE4\u9DF6\u9DE1\u9DEE\u9DE6\u9DF2\u9DF0\u9DE2\u9DEC\u9DF4\u9DF3\u9DE8\u9DED\u9EC2\u9ED0\u9EF2\u9EF3\u9F06\u9F1C\u9F38\u9F37\u9F36\u9F43\u9F4F"],
      ["f8a1", "\u9F71\u9F70\u9F6E\u9F6F\u56D3\u56CD\u5B4E\u5C6D\u652D\u66ED\u66EE\u6B13\u705F\u7061\u705D\u7060\u7223\u74DB\u74E5\u77D5\u7938\u79B7\u79B6\u7C6A\u7E97\u7F89\u826D\u8643\u8838\u8837\u8835\u884B\u8B94\u8B95\u8E9E\u8E9F\u8EA0\u8E9D\u91BE\u91BD\u91C2\u946B\u9468\u9469\u96E5\u9746\u9743\u9747\u97C7\u97E5\u9A5E\u9AD5\u9B59\u9C63\u9C67\u9C66\u9C62\u9C5E\u9C60\u9E02\u9DFE\u9E07\u9E03\u9E06\u9E05\u9E00\u9E01\u9E09\u9DFF\u9DFD\u9E04\u9EA0\u9F1E\u9F46\u9F74\u9F75\u9F76\u56D4\u652E\u65B8\u6B18\u6B19\u6B17\u6B1A\u7062\u7226\u72AA\u77D8\u77D9\u7939\u7C69\u7C6B\u7CF6\u7E9A"],
      ["f940", "\u7E98\u7E9B\u7E99\u81E0\u81E1\u8646\u8647\u8648\u8979\u897A\u897C\u897B\u89FF\u8B98\u8B99\u8EA5\u8EA4\u8EA3\u946E\u946D\u946F\u9471\u9473\u9749\u9872\u995F\u9C68\u9C6E\u9C6D\u9E0B\u9E0D\u9E10\u9E0F\u9E12\u9E11\u9EA1\u9EF5\u9F09\u9F47\u9F78\u9F7B\u9F7A\u9F79\u571E\u7066\u7C6F\u883C\u8DB2\u8EA6\u91C3\u9474\u9478\u9476\u9475\u9A60\u9C74\u9C73\u9C71\u9C75\u9E14\u9E13\u9EF6\u9F0A"],
      ["f9a1", "\u9FA4\u7068\u7065\u7CF7\u866A\u883E\u883D\u883F\u8B9E\u8C9C\u8EA9\u8EC9\u974B\u9873\u9874\u98CC\u9961\u99AB\u9A64\u9A66\u9A67\u9B24\u9E15\u9E17\u9F48\u6207\u6B1E\u7227\u864C\u8EA8\u9482\u9480\u9481\u9A69\u9A68\u9B2E\u9E19\u7229\u864B\u8B9F\u9483\u9C79\u9EB7\u7675\u9A6B\u9C7A\u9E1D\u7069\u706A\u9EA4\u9F7E\u9F49\u9F98\u7881\u92B9\u88CF\u58BB\u6052\u7CA7\u5AFA\u2554\u2566\u2557\u2560\u256C\u2563\u255A\u2569\u255D\u2552\u2564\u2555\u255E\u256A\u2561\u2558\u2567\u255B\u2553\u2565\u2556\u255F\u256B\u2562\u2559\u2568\u255C\u2551\u2550\u256D\u256E\u2570\u256F\u2593"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/big5-added.json"(exports2, module2) {
    module2.exports = [
      ["8740", "\u43F0\u4C32\u4603\u45A6\u4578\u{27267}\u4D77\u45B3\u{27CB1}\u4CE2\u{27CC5}\u3B95\u4736\u4744\u4C47\u4C40\u{242BF}\u{23617}\u{27352}\u{26E8B}\u{270D2}\u4C57\u{2A351}\u474F\u45DA\u4C85\u{27C6C}\u4D07\u4AA4\u46A1\u{26B23}\u7225\u{25A54}\u{21A63}\u{23E06}\u{23F61}\u664D\u56FB"],
      ["8767", "\u7D95\u591D\u{28BB9}\u3DF4\u9734\u{27BEF}\u5BDB\u{21D5E}\u5AA4\u3625\u{29EB0}\u5AD1\u5BB7\u5CFC\u676E\u8593\u{29945}\u7461\u749D\u3875\u{21D53}\u{2369E}\u{26021}\u3EEC"],
      ["87a1", "\u{258DE}\u3AF5\u7AFC\u9F97\u{24161}\u{2890D}\u{231EA}\u{20A8A}\u{2325E}\u430A\u8484\u9F96\u942F\u4930\u8613\u5896\u974A\u9218\u79D0\u7A32\u6660\u6A29\u889D\u744C\u7BC5\u6782\u7A2C\u524F\u9046\u34E6\u73C4\u{25DB9}\u74C6\u9FC7\u57B3\u492F\u544C\u4131\u{2368E}\u5818\u7A72\u{27B65}\u8B8F\u46AE\u{26E88}\u4181\u{25D99}\u7BAE\u{224BC}\u9FC8\u{224C1}\u{224C9}\u{224CC}\u9FC9\u8504\u{235BB}\u40B4\u9FCA\u44E1\u{2ADFF}\u62C1\u706E\u9FCB"],
      ["8840", "\u31C0", 4, "\u{2010C}\u31C5\u{200D1}\u{200CD}\u31C6\u31C7\u{200CB}\u{21FE8}\u31C8\u{200CA}\u31C9\u31CA\u31CB\u31CC\u{2010E}\u31CD\u31CE\u0100\xC1\u01CD\xC0\u0112\xC9\u011A\xC8\u014C\xD3\u01D1\xD2\u0FFF\xCA\u0304\u1EBE\u0FFF\xCA\u030C\u1EC0\xCA\u0101\xE1\u01CE\xE0\u0251\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA"],
      ["88a1", "\u01DC\xFC\u0FFF\xEA\u0304\u1EBF\u0FFF\xEA\u030C\u1EC1\xEA\u0261\u23DA\u23DB"],
      ["8940", "\u{2A3A9}\u{21145}"],
      ["8943", "\u650A"],
      ["8946", "\u4E3D\u6EDD\u9D4E\u91DF"],
      ["894c", "\u{27735}\u6491\u4F1A\u4F28\u4FA8\u5156\u5174\u519C\u51E4\u52A1\u52A8\u533B\u534E\u53D1\u53D8\u56E2\u58F0\u5904\u5907\u5932\u5934\u5B66\u5B9E\u5B9F\u5C9A\u5E86\u603B\u6589\u67FE\u6804\u6865\u6D4E\u70BC\u7535\u7EA4\u7EAC\u7EBA\u7EC7\u7ECF\u7EDF\u7F06\u7F37\u827A\u82CF\u836F\u89C6\u8BBE\u8BE2\u8F66\u8F67\u8F6E"],
      ["89a1", "\u7411\u7CFC\u7DCD\u6946\u7AC9\u5227"],
      ["89ab", "\u918C\u78B8\u915E\u80BC"],
      ["89b0", "\u8D0B\u80F6\u{209E7}"],
      ["89b5", "\u809F\u9EC7\u4CCD\u9DC9\u9E0C\u4C3E\u{29DF6}\u{2700E}\u9E0A\u{2A133}\u35C1"],
      ["89c1", "\u6E9A\u823E\u7519"],
      ["89c5", "\u4911\u9A6C\u9A8F\u9F99\u7987\u{2846C}\u{21DCA}\u{205D0}\u{22AE6}\u4E24\u4E81\u4E80\u4E87\u4EBF\u4EEB\u4F37\u344C\u4FBD\u3E48\u5003\u5088\u347D\u3493\u34A5\u5186\u5905\u51DB\u51FC\u5205\u4E89\u5279\u5290\u5327\u35C7\u53A9\u3551\u53B0\u3553\u53C2\u5423\u356D\u3572\u3681\u5493\u54A3\u54B4\u54B9\u54D0\u54EF\u5518\u5523\u5528\u3598\u553F\u35A5\u35BF\u55D7\u35C5"],
      ["8a40", "\u{27D84}\u5525"],
      ["8a43", "\u{20C42}\u{20D15}\u{2512B}\u5590\u{22CC6}\u39EC\u{20341}\u8E46\u{24DB8}\u{294E5}\u4053\u{280BE}\u777A\u{22C38}\u3A34\u47D5\u{2815D}\u{269F2}\u{24DEA}\u64DD\u{20D7C}\u{20FB4}\u{20CD5}\u{210F4}\u648D\u8E7E\u{20E96}\u{20C0B}\u{20F64}\u{22CA9}\u{28256}\u{244D3}"],
      ["8a64", "\u{20D46}\u{29A4D}\u{280E9}\u47F4\u{24EA7}\u{22CC2}\u9AB2\u3A67\u{295F4}\u3FED\u3506\u{252C7}\u{297D4}\u{278C8}\u{22D44}\u9D6E\u9815"],
      ["8a76", "\u43D9\u{260A5}\u64B4\u54E3\u{22D4C}\u{22BCA}\u{21077}\u39FB\u{2106F}"],
      ["8aa1", "\u{266DA}\u{26716}\u{279A0}\u64EA\u{25052}\u{20C43}\u8E68\u{221A1}\u{28B4C}\u{20731}"],
      ["8aac", "\u480B\u{201A9}\u3FFA\u5873\u{22D8D}"],
      ["8ab2", "\u{245C8}\u{204FC}\u{26097}\u{20F4C}\u{20D96}\u5579\u40BB\u43BA"],
      ["8abb", "\u4AB4\u{22A66}\u{2109D}\u81AA\u98F5\u{20D9C}\u6379\u39FE\u{22775}\u8DC0\u56A1\u647C\u3E43"],
      ["8ac9", "\u{2A601}\u{20E09}\u{22ACF}\u{22CC9}"],
      ["8ace", "\u{210C8}\u{239C2}\u3992\u3A06\u{2829B}\u3578\u{25E49}\u{220C7}\u5652\u{20F31}\u{22CB2}\u{29720}\u34BC\u6C3D\u{24E3B}"],
      ["8adf", "\u{27574}\u{22E8B}\u{22208}\u{2A65B}\u{28CCD}\u{20E7A}\u{20C34}\u{2681C}\u7F93\u{210CF}\u{22803}\u{22939}\u35FB\u{251E3}\u{20E8C}\u{20F8D}\u{20EAA}\u3F93\u{20F30}\u{20D47}\u{2114F}\u{20E4C}"],
      ["8af6", "\u{20EAB}\u{20BA9}\u{20D48}\u{210C0}\u{2113D}\u3FF9\u{22696}\u6432\u{20FAD}"],
      ["8b40", "\u{233F4}\u{27639}\u{22BCE}\u{20D7E}\u{20D7F}\u{22C51}\u{22C55}\u3A18\u{20E98}\u{210C7}\u{20F2E}\u{2A632}\u{26B50}\u{28CD2}\u{28D99}\u{28CCA}\u95AA\u54CC\u82C4\u55B9"],
      ["8b55", "\u{29EC3}\u9C26\u9AB6\u{2775E}\u{22DEE}\u7140\u816D\u80EC\u5C1C\u{26572}\u8134\u3797\u535F\u{280BD}\u91B6\u{20EFA}\u{20E0F}\u{20E77}\u{20EFB}\u35DD\u{24DEB}\u3609\u{20CD6}\u56AF\u{227B5}\u{210C9}\u{20E10}\u{20E78}\u{21078}\u{21148}\u{28207}\u{21455}\u{20E79}\u{24E50}\u{22DA4}\u5A54\u{2101D}\u{2101E}\u{210F5}\u{210F6}\u579C\u{20E11}"],
      ["8ba1", "\u{27694}\u{282CD}\u{20FB5}\u{20E7B}\u{2517E}\u3703\u{20FB6}\u{21180}\u{252D8}\u{2A2BD}\u{249DA}\u{2183A}\u{24177}\u{2827C}\u5899\u5268\u361A\u{2573D}\u7BB2\u5B68\u4800\u4B2C\u9F27\u49E7\u9C1F\u9B8D\u{25B74}\u{2313D}\u55FB\u35F2\u5689\u4E28\u5902\u{21BC1}\u{2F878}\u9751\u{20086}\u4E5B\u4EBB\u353E\u5C23\u5F51\u5FC4\u38FA\u624C\u6535\u6B7A\u6C35\u6C3A\u706C\u722B\u4E2C\u72AD\u{248E9}\u7F52\u793B\u7CF9\u7F53\u{2626A}\u34C1"],
      ["8bde", "\u{2634B}\u8002\u8080\u{26612}\u{26951}\u535D\u8864\u89C1\u{278B2}\u8BA0\u8D1D\u9485\u9578\u957F\u95E8\u{28E0F}\u97E6\u9875\u98CE\u98DE\u9963\u{29810}\u9C7C\u9E1F\u9EC4\u6B6F\uF907\u4E37\u{20087}\u961D\u6237\u94A2"],
      ["8c40", "\u503B\u6DFE\u{29C73}\u9FA6\u3DC9\u888F\u{2414E}\u7077\u5CF5\u4B20\u{251CD}\u3559\u{25D30}\u6122\u{28A32}\u8FA7\u91F6\u7191\u6719\u73BA\u{23281}\u{2A107}\u3C8B\u{21980}\u4B10\u78E4\u7402\u51AE\u{2870F}\u4009\u6A63\u{2A2BA}\u4223\u860F\u{20A6F}\u7A2A\u{29947}\u{28AEA}\u9755\u704D\u5324\u{2207E}\u93F4\u76D9\u{289E3}\u9FA7\u77DD\u4EA3\u4FF0\u50BC\u4E2F\u4F17\u9FA8\u5434\u7D8B\u5892\u58D0\u{21DB6}\u5E92\u5E99\u5FC2\u{22712}\u658B"],
      ["8ca1", "\u{233F9}\u6919\u6A43\u{23C63}\u6CFF"],
      ["8ca7", "\u7200\u{24505}\u738C\u3EDB\u{24A13}\u5B15\u74B9\u8B83\u{25CA4}\u{25695}\u7A93\u7BEC\u7CC3\u7E6C\u82F8\u8597\u9FA9\u8890\u9FAA\u8EB9\u9FAB\u8FCF\u855F\u99E0\u9221\u9FAC\u{28DB9}\u{2143F}\u4071\u42A2\u5A1A"],
      ["8cc9", "\u9868\u676B\u4276\u573D"],
      ["8cce", "\u85D6\u{2497B}\u82BF\u{2710D}\u4C81\u{26D74}\u5D7B\u{26B15}\u{26FBE}\u9FAD\u9FAE\u5B96\u9FAF\u66E7\u7E5B\u6E57\u79CA\u3D88\u44C3\u{23256}\u{22796}\u439A\u4536"],
      ["8ce6", "\u5CD5\u{23B1A}\u8AF9\u5C78\u3D12\u{23551}\u5D78\u9FB2\u7157\u4558\u{240EC}\u{21E23}\u4C77\u3978\u344A\u{201A4}\u{26C41}\u8ACC\u4FB4\u{20239}\u59BF\u816C\u9856\u{298FA}\u5F3B"],
      ["8d40", "\u{20B9F}"],
      ["8d42", "\u{221C1}\u{2896D}\u4102\u46BB\u{29079}\u3F07\u9FB3\u{2A1B5}\u40F8\u37D6\u46F7\u{26C46}\u417C\u{286B2}\u{273FF}\u456D\u38D4\u{2549A}\u4561\u451B\u4D89\u4C7B\u4D76\u45EA\u3FC8\u{24B0F}\u3661\u44DE\u44BD\u41ED\u5D3E\u5D48\u5D56\u3DFC\u380F\u5DA4\u5DB9\u3820\u3838\u5E42\u5EBD\u5F25\u5F83\u3908\u3914\u393F\u394D\u60D7\u613D\u5CE5\u3989\u61B7\u61B9\u61CF\u39B8\u622C\u6290\u62E5\u6318\u39F8\u56B1"],
      ["8da1", "\u3A03\u63E2\u63FB\u6407\u645A\u3A4B\u64C0\u5D15\u5621\u9F9F\u3A97\u6586\u3ABD\u65FF\u6653\u3AF2\u6692\u3B22\u6716\u3B42\u67A4\u6800\u3B58\u684A\u6884\u3B72\u3B71\u3B7B\u6909\u6943\u725C\u6964\u699F\u6985\u3BBC\u69D6\u3BDD\u6A65\u6A74\u6A71\u6A82\u3BEC\u6A99\u3BF2\u6AAB\u6AB5\u6AD4\u6AF6\u6B81\u6BC1\u6BEA\u6C75\u6CAA\u3CCB\u6D02\u6D06\u6D26\u6D81\u3CEF\u6DA4\u6DB1\u6E15\u6E18\u6E29\u6E86\u{289C0}\u6EBB\u6EE2\u6EDA\u9F7F\u6EE8\u6EE9\u6F24\u6F34\u3D46\u{23F41}\u6F81\u6FBE\u3D6A\u3D75\u71B7\u5C99\u3D8A\u702C\u3D91\u7050\u7054\u706F\u707F\u7089\u{20325}\u43C1\u35F1\u{20ED8}"],
      ["8e40", "\u{23ED7}\u57BE\u{26ED3}\u713E\u{257E0}\u364E\u69A2\u{28BE9}\u5B74\u7A49\u{258E1}\u{294D9}\u7A65\u7A7D\u{259AC}\u7ABB\u7AB0\u7AC2\u7AC3\u71D1\u{2648D}\u41CA\u7ADA\u7ADD\u7AEA\u41EF\u54B2\u{25C01}\u7B0B\u7B55\u7B29\u{2530E}\u{25CFE}\u7BA2\u7B6F\u839C\u{25BB4}\u{26C7F}\u7BD0\u8421\u7B92\u7BB8\u{25D20}\u3DAD\u{25C65}\u8492\u7BFA\u7C06\u7C35\u{25CC1}\u7C44\u7C83\u{24882}\u7CA6\u667D\u{24578}\u7CC9\u7CC7\u7CE6\u7C74\u7CF3\u7CF5\u7CCE"],
      ["8ea1", "\u7E67\u451D\u{26E44}\u7D5D\u{26ED6}\u748D\u7D89\u7DAB\u7135\u7DB3\u7DD2\u{24057}\u{26029}\u7DE4\u3D13\u7DF5\u{217F9}\u7DE5\u{2836D}\u7E1D\u{26121}\u{2615A}\u7E6E\u7E92\u432B\u946C\u7E27\u7F40\u7F41\u7F47\u7936\u{262D0}\u99E1\u7F97\u{26351}\u7FA3\u{21661}\u{20068}\u455C\u{23766}\u4503\u{2833A}\u7FFA\u{26489}\u8005\u8008\u801D\u8028\u802F\u{2A087}\u{26CC3}\u803B\u803C\u8061\u{22714}\u4989\u{26626}\u{23DE3}\u{266E8}\u6725\u80A7\u{28A48}\u8107\u811A\u58B0\u{226F6}\u6C7F\u{26498}\u{24FB8}\u64E7\u{2148A}\u8218\u{2185E}\u6A53\u{24A65}\u{24A95}\u447A\u8229\u{20B0D}\u{26A52}\u{23D7E}\u4FF9\u{214FD}\u84E2\u8362\u{26B0A}\u{249A7}\u{23530}\u{21773}\u{23DF8}\u82AA\u691B\u{2F994}\u41DB"],
      ["8f40", "\u854B\u82D0\u831A\u{20E16}\u{217B4}\u36C1\u{2317D}\u{2355A}\u827B\u82E2\u8318\u{23E8B}\u{26DA3}\u{26B05}\u{26B97}\u{235CE}\u3DBF\u831D\u55EC\u8385\u450B\u{26DA5}\u83AC\u83C1\u83D3\u347E\u{26ED4}\u6A57\u855A\u3496\u{26E42}\u{22EEF}\u8458\u{25BE4}\u8471\u3DD3\u44E4\u6AA7\u844A\u{23CB5}\u7958\u84A8\u{26B96}\u{26E77}\u{26E43}\u84DE\u840F\u8391\u44A0\u8493\u84E4\u{25C91}\u4240\u{25CC0}\u4543\u8534\u5AF2\u{26E99}\u4527\u8573\u4516\u67BF\u8616"],
      ["8fa1", "\u{28625}\u{2863B}\u85C1\u{27088}\u8602\u{21582}\u{270CD}\u{2F9B2}\u456A\u8628\u3648\u{218A2}\u53F7\u{2739A}\u867E\u8771\u{2A0F8}\u87EE\u{22C27}\u87B1\u87DA\u880F\u5661\u866C\u6856\u460F\u8845\u8846\u{275E0}\u{23DB9}\u{275E4}\u885E\u889C\u465B\u88B4\u88B5\u63C1\u88C5\u7777\u{2770F}\u8987\u898A\u89A6\u89A9\u89A7\u89BC\u{28A25}\u89E7\u{27924}\u{27ABD}\u8A9C\u7793\u91FE\u8A90\u{27A59}\u7AE9\u{27B3A}\u{23F8F}\u4713\u{27B38}\u717C\u8B0C\u8B1F\u{25430}\u{25565}\u8B3F\u8B4C\u8B4D\u8AA9\u{24A7A}\u8B90\u8B9B\u8AAF\u{216DF}\u4615\u884F\u8C9B\u{27D54}\u{27D8F}\u{2F9D4}\u3725\u{27D53}\u8CD6\u{27D98}\u{27DBD}\u8D12\u8D03\u{21910}\u8CDB\u705C\u8D11\u{24CC9}\u3ED0\u8D77"],
      ["9040", "\u8DA9\u{28002}\u{21014}\u{2498A}\u3B7C\u{281BC}\u{2710C}\u7AE7\u8EAD\u8EB6\u8EC3\u92D4\u8F19\u8F2D\u{28365}\u{28412}\u8FA5\u9303\u{2A29F}\u{20A50}\u8FB3\u492A\u{289DE}\u{2853D}\u{23DBB}\u5EF8\u{23262}\u8FF9\u{2A014}\u{286BC}\u{28501}\u{22325}\u3980\u{26ED7}\u9037\u{2853C}\u{27ABE}\u9061\u{2856C}\u{2860B}\u90A8\u{28713}\u90C4\u{286E6}\u90AE\u90FD\u9167\u3AF0\u91A9\u91C4\u7CAC\u{28933}\u{21E89}\u920E\u6C9F\u9241\u9262\u{255B9}\u92B9\u{28AC6}\u{23C9B}\u{28B0C}\u{255DB}"],
      ["90a1", "\u{20D31}\u932C\u936B\u{28AE1}\u{28BEB}\u708F\u5AC3\u{28AE2}\u{28AE5}\u4965\u9244\u{28BEC}\u{28C39}\u{28BFF}\u9373\u945B\u8EBC\u9585\u95A6\u9426\u95A0\u6FF6\u42B9\u{2267A}\u{286D8}\u{2127C}\u{23E2E}\u49DF\u6C1C\u967B\u9696\u416C\u96A3\u{26ED5}\u61DA\u96B6\u78F5\u{28AE0}\u96BD\u53CC\u49A1\u{26CB8}\u{20274}\u{26410}\u{290AF}\u{290E5}\u{24AD1}\u{21915}\u{2330A}\u9731\u8642\u9736\u4A0F\u453D\u4585\u{24AE9}\u7075\u5B41\u971B\u975C\u{291D5}\u9757\u5B4A\u{291EB}\u975F\u9425\u50D0\u{230B7}\u{230BC}\u9789\u979F\u97B1\u97BE\u97C0\u97D2\u97E0\u{2546C}\u97EE\u741C\u{29433}\u97FF\u97F5\u{2941D}\u{2797A}\u4AD1\u9834\u9833\u984B\u9866\u3B0E\u{27175}\u3D51\u{20630}\u{2415C}"],
      ["9140", "\u{25706}\u98CA\u98B7\u98C8\u98C7\u4AFF\u{26D27}\u{216D3}\u55B0\u98E1\u98E6\u98EC\u9378\u9939\u{24A29}\u4B72\u{29857}\u{29905}\u99F5\u9A0C\u9A3B\u9A10\u9A58\u{25725}\u36C4\u{290B1}\u{29BD5}\u9AE0\u9AE2\u{29B05}\u9AF4\u4C0E\u9B14\u9B2D\u{28600}\u5034\u9B34\u{269A8}\u38C3\u{2307D}\u9B50\u9B40\u{29D3E}\u5A45\u{21863}\u9B8E\u{2424B}\u9C02\u9BFF\u9C0C\u{29E68}\u9DD4\u{29FB7}\u{2A192}\u{2A1AB}\u{2A0E1}\u{2A123}\u{2A1DF}\u9D7E\u9D83\u{2A134}\u9E0E\u6888"],
      ["91a1", "\u9DC4\u{2215B}\u{2A193}\u{2A220}\u{2193B}\u{2A233}\u9D39\u{2A0B9}\u{2A2B4}\u9E90\u9E95\u9E9E\u9EA2\u4D34\u9EAA\u9EAF\u{24364}\u9EC1\u3B60\u39E5\u3D1D\u4F32\u37BE\u{28C2B}\u9F02\u9F08\u4B96\u9424\u{26DA2}\u9F17\u9F16\u9F39\u569F\u568A\u9F45\u99B8\u{2908B}\u97F2\u847F\u9F62\u9F69\u7ADC\u9F8E\u7216\u4BBE\u{24975}\u{249BB}\u7177\u{249F8}\u{24348}\u{24A51}\u739E\u{28BDA}\u{218FA}\u799F\u{2897E}\u{28E36}\u9369\u93F3\u{28A44}\u92EC\u9381\u93CB\u{2896C}\u{244B9}\u7217\u3EEB\u7772\u7A43\u70D0\u{24473}\u{243F8}\u717E\u{217EF}\u70A3\u{218BE}\u{23599}\u3EC7\u{21885}\u{2542F}\u{217F8}\u3722\u{216FB}\u{21839}\u36E1\u{21774}\u{218D1}\u{25F4B}\u3723\u{216C0}\u575B\u{24A25}\u{213FE}\u{212A8}"],
      ["9240", "\u{213C6}\u{214B6}\u8503\u{236A6}\u8503\u8455\u{24994}\u{27165}\u{23E31}\u{2555C}\u{23EFB}\u{27052}\u44F4\u{236EE}\u{2999D}\u{26F26}\u67F9\u3733\u3C15\u3DE7\u586C\u{21922}\u6810\u4057\u{2373F}\u{240E1}\u{2408B}\u{2410F}\u{26C21}\u54CB\u569E\u{266B1}\u5692\u{20FDF}\u{20BA8}\u{20E0D}\u93C6\u{28B13}\u939C\u4EF8\u512B\u3819\u{24436}\u4EBC\u{20465}\u{2037F}\u4F4B\u4F8A\u{25651}\u5A68\u{201AB}\u{203CB}\u3999\u{2030A}\u{20414}\u3435\u4F29\u{202C0}\u{28EB3}\u{20275}\u8ADA\u{2020C}\u4E98"],
      ["92a1", "\u50CD\u510D\u4FA2\u4F03\u{24A0E}\u{23E8A}\u4F42\u502E\u506C\u5081\u4FCC\u4FE5\u5058\u50FC\u5159\u515B\u515D\u515E\u6E76\u{23595}\u{23E39}\u{23EBF}\u6D72\u{21884}\u{23E89}\u51A8\u51C3\u{205E0}\u44DD\u{204A3}\u{20492}\u{20491}\u8D7A\u{28A9C}\u{2070E}\u5259\u52A4\u{20873}\u52E1\u936E\u467A\u718C\u{2438C}\u{20C20}\u{249AC}\u{210E4}\u69D1\u{20E1D}\u7479\u3EDE\u7499\u7414\u7456\u7398\u4B8E\u{24ABC}\u{2408D}\u53D0\u3584\u720F\u{240C9}\u55B4\u{20345}\u54CD\u{20BC6}\u571D\u925D\u96F4\u9366\u57DD\u578D\u577F\u363E\u58CB\u5A99\u{28A46}\u{216FA}\u{2176F}\u{21710}\u5A2C\u59B8\u928F\u5A7E\u5ACF\u5A12\u{25946}\u{219F3}\u{21861}\u{24295}\u36F5\u6D05\u7443\u5A21\u{25E83}"],
      ["9340", "\u5A81\u{28BD7}\u{20413}\u93E0\u748C\u{21303}\u7105\u4972\u9408\u{289FB}\u93BD\u37A0\u5C1E\u5C9E\u5E5E\u5E48\u{21996}\u{2197C}\u{23AEE}\u5ECD\u5B4F\u{21903}\u{21904}\u3701\u{218A0}\u36DD\u{216FE}\u36D3\u812A\u{28A47}\u{21DBA}\u{23472}\u{289A8}\u5F0C\u5F0E\u{21927}\u{217AB}\u5A6B\u{2173B}\u5B44\u8614\u{275FD}\u8860\u607E\u{22860}\u{2262B}\u5FDB\u3EB8\u{225AF}\u{225BE}\u{29088}\u{26F73}\u61C0\u{2003E}\u{20046}\u{2261B}\u6199\u6198\u6075\u{22C9B}\u{22D07}\u{246D4}\u{2914D}"],
      ["93a1", "\u6471\u{24665}\u{22B6A}\u3A29\u{22B22}\u{23450}\u{298EA}\u{22E78}\u6337\u{2A45B}\u64B6\u6331\u63D1\u{249E3}\u{22D67}\u62A4\u{22CA1}\u643B\u656B\u6972\u3BF4\u{2308E}\u{232AD}\u{24989}\u{232AB}\u550D\u{232E0}\u{218D9}\u{2943F}\u66CE\u{23289}\u{231B3}\u3AE0\u4190\u{25584}\u{28B22}\u{2558F}\u{216FC}\u{2555B}\u{25425}\u78EE\u{23103}\u{2182A}\u{23234}\u3464\u{2320F}\u{23182}\u{242C9}\u668E\u{26D24}\u666B\u4B93\u6630\u{27870}\u{21DEB}\u6663\u{232D2}\u{232E1}\u661E\u{25872}\u38D1\u{2383A}\u{237BC}\u3B99\u{237A2}\u{233FE}\u74D0\u3B96\u678F\u{2462A}\u68B6\u681E\u3BC4\u6ABE\u3863\u{237D5}\u{24487}\u6A33\u6A52\u6AC9\u6B05\u{21912}\u6511\u6898\u6A4C\u3BD7\u6A7A\u6B57\u{23FC0}\u{23C9A}\u93A0\u92F2\u{28BEA}\u{28ACB}"],
      ["9440", "\u9289\u{2801E}\u{289DC}\u9467\u6DA5\u6F0B\u{249EC}\u6D67\u{23F7F}\u3D8F\u6E04\u{2403C}\u5A3D\u6E0A\u5847\u6D24\u7842\u713B\u{2431A}\u{24276}\u70F1\u7250\u7287\u7294\u{2478F}\u{24725}\u5179\u{24AA4}\u{205EB}\u747A\u{23EF8}\u{2365F}\u{24A4A}\u{24917}\u{25FE1}\u3F06\u3EB1\u{24ADF}\u{28C23}\u{23F35}\u60A7\u3EF3\u74CC\u743C\u9387\u7437\u449F\u{26DEA}\u4551\u7583\u3F63\u{24CD9}\u{24D06}\u3F58\u7555\u7673\u{2A5C6}\u3B19\u7468\u{28ACC}\u{249AB}\u{2498E}\u3AFB"],
      ["94a1", "\u3DCD\u{24A4E}\u3EFF\u{249C5}\u{248F3}\u91FA\u5732\u9342\u{28AE3}\u{21864}\u50DF\u{25221}\u{251E7}\u7778\u{23232}\u770E\u770F\u777B\u{24697}\u{23781}\u3A5E\u{248F0}\u7438\u749B\u3EBF\u{24ABA}\u{24AC7}\u40C8\u{24A96}\u{261AE}\u9307\u{25581}\u781E\u788D\u7888\u78D2\u73D0\u7959\u{27741}\u{256E3}\u410E\u799B\u8496\u79A5\u6A2D\u{23EFA}\u7A3A\u79F4\u416E\u{216E6}\u4132\u9235\u79F1\u{20D4C}\u{2498C}\u{20299}\u{23DBA}\u{2176E}\u3597\u556B\u3570\u36AA\u{201D4}\u{20C0D}\u7AE2\u5A59\u{226F5}\u{25AAF}\u{25A9C}\u5A0D\u{2025B}\u78F0\u5A2A\u{25BC6}\u7AFE\u41F9\u7C5D\u7C6D\u4211\u{25BB3}\u{25EBC}\u{25EA6}\u7CCD\u{249F9}\u{217B0}\u7C8E\u7C7C\u7CAE\u6AB2\u7DDC\u7E07\u7DD3\u7F4E\u{26261}"],
      ["9540", "\u{2615C}\u{27B48}\u7D97\u{25E82}\u426A\u{26B75}\u{20916}\u67D6\u{2004E}\u{235CF}\u57C4\u{26412}\u{263F8}\u{24962}\u7FDD\u7B27\u{2082C}\u{25AE9}\u{25D43}\u7B0C\u{25E0E}\u99E6\u8645\u9A63\u6A1C\u{2343F}\u39E2\u{249F7}\u{265AD}\u9A1F\u{265A0}\u8480\u{27127}\u{26CD1}\u44EA\u8137\u4402\u80C6\u8109\u8142\u{267B4}\u98C3\u{26A42}\u8262\u8265\u{26A51}\u8453\u{26DA7}\u8610\u{2721B}\u5A86\u417F\u{21840}\u5B2B\u{218A1}\u5AE4\u{218D8}\u86A0\u{2F9BC}\u{23D8F}\u882D\u{27422}\u5A02"],
      ["95a1", "\u886E\u4F45\u8887\u88BF\u88E6\u8965\u894D\u{25683}\u8954\u{27785}\u{27784}\u{28BF5}\u{28BD9}\u{28B9C}\u{289F9}\u3EAD\u84A3\u46F5\u46CF\u37F2\u8A3D\u8A1C\u{29448}\u5F4D\u922B\u{24284}\u65D4\u7129\u70C4\u{21845}\u9D6D\u8C9F\u8CE9\u{27DDC}\u599A\u77C3\u59F0\u436E\u36D4\u8E2A\u8EA7\u{24C09}\u8F30\u8F4A\u42F4\u6C58\u6FBB\u{22321}\u489B\u6F79\u6E8B\u{217DA}\u9BE9\u36B5\u{2492F}\u90BB\u9097\u5571\u4906\u91BB\u9404\u{28A4B}\u4062\u{28AFC}\u9427\u{28C1D}\u{28C3B}\u84E5\u8A2B\u9599\u95A7\u9597\u9596\u{28D34}\u7445\u3EC2\u{248FF}\u{24A42}\u{243EA}\u3EE7\u{23225}\u968F\u{28EE7}\u{28E66}\u{28E65}\u3ECC\u{249ED}\u{24A78}\u{23FEE}\u7412\u746B\u3EFC\u9741\u{290B0}"],
      ["9640", "\u6847\u4A1D\u{29093}\u{257DF}\u975D\u9368\u{28989}\u{28C26}\u{28B2F}\u{263BE}\u92BA\u5B11\u8B69\u493C\u73F9\u{2421B}\u979B\u9771\u9938\u{20F26}\u5DC1\u{28BC5}\u{24AB2}\u981F\u{294DA}\u92F6\u{295D7}\u91E5\u44C0\u{28B50}\u{24A67}\u{28B64}\u98DC\u{28A45}\u3F00\u922A\u4925\u8414\u993B\u994D\u{27B06}\u3DFD\u999B\u4B6F\u99AA\u9A5C\u{28B65}\u{258C8}\u6A8F\u9A21\u5AFE\u9A2F\u{298F1}\u4B90\u{29948}\u99BC\u4BBD\u4B97\u937D\u5872\u{21302}\u5822\u{249B8}"],
      ["96a1", "\u{214E8}\u7844\u{2271F}\u{23DB8}\u68C5\u3D7D\u9458\u3927\u6150\u{22781}\u{2296B}\u6107\u9C4F\u9C53\u9C7B\u9C35\u9C10\u9B7F\u9BCF\u{29E2D}\u9B9F\u{2A1F5}\u{2A0FE}\u9D21\u4CAE\u{24104}\u9E18\u4CB0\u9D0C\u{2A1B4}\u{2A0ED}\u{2A0F3}\u{2992F}\u9DA5\u84BD\u{26E12}\u{26FDF}\u{26B82}\u85FC\u4533\u{26DA4}\u{26E84}\u{26DF0}\u8420\u85EE\u{26E00}\u{237D7}\u{26064}\u79E2\u{2359C}\u{23640}\u492D\u{249DE}\u3D62\u93DB\u92BE\u9348\u{202BF}\u78B9\u9277\u944D\u4FE4\u3440\u9064\u{2555D}\u783D\u7854\u78B6\u784B\u{21757}\u{231C9}\u{24941}\u369A\u4F72\u6FDA\u6FD9\u701E\u701E\u5414\u{241B5}\u57BB\u58F3\u578A\u9D16\u57D7\u7134\u34AF\u{241AC}\u71EB\u{26C40}\u{24F97}\u5B28\u{217B5}\u{28A49}"],
      ["9740", "\u610C\u5ACE\u5A0B\u42BC\u{24488}\u372C\u4B7B\u{289FC}\u93BB\u93B8\u{218D6}\u{20F1D}\u8472\u{26CC0}\u{21413}\u{242FA}\u{22C26}\u{243C1}\u5994\u{23DB7}\u{26741}\u7DA8\u{2615B}\u{260A4}\u{249B9}\u{2498B}\u{289FA}\u92E5\u73E2\u3EE9\u74B4\u{28B63}\u{2189F}\u3EE1\u{24AB3}\u6AD8\u73F3\u73FB\u3ED6\u{24A3E}\u{24A94}\u{217D9}\u{24A66}\u{203A7}\u{21424}\u{249E5}\u7448\u{24916}\u70A5\u{24976}\u9284\u73E6\u935F\u{204FE}\u9331\u{28ACE}\u{28A16}\u9386\u{28BE7}\u{255D5}\u4935\u{28A82}\u716B"],
      ["97a1", "\u{24943}\u{20CFF}\u56A4\u{2061A}\u{20BEB}\u{20CB8}\u5502\u79C4\u{217FA}\u7DFE\u{216C2}\u{24A50}\u{21852}\u452E\u9401\u370A\u{28AC0}\u{249AD}\u59B0\u{218BF}\u{21883}\u{27484}\u5AA1\u36E2\u{23D5B}\u36B0\u925F\u5A79\u{28A81}\u{21862}\u9374\u3CCD\u{20AB4}\u4A96\u398A\u50F4\u3D69\u3D4C\u{2139C}\u7175\u42FB\u{28218}\u6E0F\u{290E4}\u44EB\u6D57\u{27E4F}\u7067\u6CAF\u3CD6\u{23FED}\u{23E2D}\u6E02\u6F0C\u3D6F\u{203F5}\u7551\u36BC\u34C8\u4680\u3EDA\u4871\u59C4\u926E\u493E\u8F41\u{28C1C}\u{26BC0}\u5812\u57C8\u36D6\u{21452}\u70FE\u{24362}\u{24A71}\u{22FE3}\u{212B0}\u{223BD}\u68B9\u6967\u{21398}\u{234E5}\u{27BF4}\u{236DF}\u{28A83}\u{237D6}\u{233FA}\u{24C9F}\u6A1A\u{236AD}\u{26CB7}\u843E\u44DF\u44CE"],
      ["9840", "\u{26D26}\u{26D51}\u{26C82}\u{26FDE}\u6F17\u{27109}\u833D\u{2173A}\u83ED\u{26C80}\u{27053}\u{217DB}\u5989\u5A82\u{217B3}\u5A61\u5A71\u{21905}\u{241FC}\u372D\u59EF\u{2173C}\u36C7\u718E\u9390\u669A\u{242A5}\u5A6E\u5A2B\u{24293}\u6A2B\u{23EF9}\u{27736}\u{2445B}\u{242CA}\u711D\u{24259}\u{289E1}\u4FB0\u{26D28}\u5CC2\u{244CE}\u{27E4D}\u{243BD}\u6A0C\u{24256}\u{21304}\u70A6\u7133\u{243E9}\u3DA5\u6CDF\u{2F825}\u{24A4F}\u7E65\u59EB\u5D2F\u3DF3\u5F5C\u{24A5D}\u{217DF}\u7DA4\u8426"],
      ["98a1", "\u5485\u{23AFA}\u{23300}\u{20214}\u577E\u{208D5}\u{20619}\u3FE5\u{21F9E}\u{2A2B6}\u7003\u{2915B}\u5D70\u738F\u7CD3\u{28A59}\u{29420}\u4FC8\u7FE7\u72CD\u7310\u{27AF4}\u7338\u7339\u{256F6}\u7341\u7348\u3EA9\u{27B18}\u906C\u71F5\u{248F2}\u73E1\u81F6\u3ECA\u770C\u3ED1\u6CA2\u56FD\u7419\u741E\u741F\u3EE2\u3EF0\u3EF4\u3EFA\u74D3\u3F0E\u3F53\u7542\u756D\u7572\u758D\u3F7C\u75C8\u75DC\u3FC0\u764D\u3FD7\u7674\u3FDC\u767A\u{24F5C}\u7188\u5623\u8980\u5869\u401D\u7743\u4039\u6761\u4045\u35DB\u7798\u406A\u406F\u5C5E\u77BE\u77CB\u58F2\u7818\u70B9\u781C\u40A8\u7839\u7847\u7851\u7866\u8448\u{25535}\u7933\u6803\u7932\u4103"],
      ["9940", "\u4109\u7991\u7999\u8FBB\u7A06\u8FBC\u4167\u7A91\u41B2\u7ABC\u8279\u41C4\u7ACF\u7ADB\u41CF\u4E21\u7B62\u7B6C\u7B7B\u7C12\u7C1B\u4260\u427A\u7C7B\u7C9C\u428C\u7CB8\u4294\u7CED\u8F93\u70C0\u{20CCF}\u7DCF\u7DD4\u7DD0\u7DFD\u7FAE\u7FB4\u729F\u4397\u8020\u8025\u7B39\u802E\u8031\u8054\u3DCC\u57B4\u70A0\u80B7\u80E9\u43ED\u810C\u732A\u810E\u8112\u7560\u8114\u4401\u3B39\u8156\u8159\u815A"],
      ["99a1", "\u4413\u583A\u817C\u8184\u4425\u8193\u442D\u81A5\u57EF\u81C1\u81E4\u8254\u448F\u82A6\u8276\u82CA\u82D8\u82FF\u44B0\u8357\u9669\u698A\u8405\u70F5\u8464\u60E3\u8488\u4504\u84BE\u84E1\u84F8\u8510\u8538\u8552\u453B\u856F\u8570\u85E0\u4577\u8672\u8692\u86B2\u86EF\u9645\u878B\u4606\u4617\u88AE\u88FF\u8924\u8947\u8991\u{27967}\u8A29\u8A38\u8A94\u8AB4\u8C51\u8CD4\u8CF2\u8D1C\u4798\u585F\u8DC3\u47ED\u4EEE\u8E3A\u55D8\u5754\u8E71\u55F5\u8EB0\u4837\u8ECE\u8EE2\u8EE4\u8EED\u8EF2\u8FB7\u8FC1\u8FCA\u8FCC\u9033\u99C4\u48AD\u98E0\u9213\u491E\u9228\u9258\u926B\u92B1\u92AE\u92BF"],
      ["9a40", "\u92E3\u92EB\u92F3\u92F4\u92FD\u9343\u9384\u93AD\u4945\u4951\u9EBF\u9417\u5301\u941D\u942D\u943E\u496A\u9454\u9479\u952D\u95A2\u49A7\u95F4\u9633\u49E5\u67A0\u4A24\u9740\u4A35\u97B2\u97C2\u5654\u4AE4\u60E8\u98B9\u4B19\u98F1\u5844\u990E\u9919\u51B4\u991C\u9937\u9942\u995D\u9962\u4B70\u99C5\u4B9D\u9A3C\u9B0F\u7A83\u9B69\u9B81\u9BDD\u9BF1\u9BF4\u4C6D\u9C20\u376F\u{21BC2}\u9D49\u9C3A"],
      ["9aa1", "\u9EFE\u5650\u9D93\u9DBD\u9DC0\u9DFC\u94F6\u8FB6\u9E7B\u9EAC\u9EB1\u9EBD\u9EC6\u94DC\u9EE2\u9EF1\u9EF8\u7AC8\u9F44\u{20094}\u{202B7}\u{203A0}\u691A\u94C3\u59AC\u{204D7}\u5840\u94C1\u37B9\u{205D5}\u{20615}\u{20676}\u{216BA}\u5757\u7173\u{20AC2}\u{20ACD}\u{20BBF}\u546A\u{2F83B}\u{20BCB}\u549E\u{20BFB}\u{20C3B}\u{20C53}\u{20C65}\u{20C7C}\u60E7\u{20C8D}\u567A\u{20CB5}\u{20CDD}\u{20CED}\u{20D6F}\u{20DB2}\u{20DC8}\u6955\u9C2F\u87A5\u{20E04}\u{20E0E}\u{20ED7}\u{20F90}\u{20F2D}\u{20E73}\u5C20\u{20FBC}\u5E0B\u{2105C}\u{2104F}\u{21076}\u671E\u{2107B}\u{21088}\u{21096}\u3647\u{210BF}\u{210D3}\u{2112F}\u{2113B}\u5364\u84AD\u{212E3}\u{21375}\u{21336}\u8B81\u{21577}\u{21619}\u{217C3}\u{217C7}\u4E78\u70BB\u{2182D}\u{2196A}"],
      ["9b40", "\u{21A2D}\u{21A45}\u{21C2A}\u{21C70}\u{21CAC}\u{21EC8}\u62C3\u{21ED5}\u{21F15}\u7198\u6855\u{22045}\u69E9\u36C8\u{2227C}\u{223D7}\u{223FA}\u{2272A}\u{22871}\u{2294F}\u82FD\u{22967}\u{22993}\u{22AD5}\u89A5\u{22AE8}\u8FA0\u{22B0E}\u97B8\u{22B3F}\u9847\u9ABD\u{22C4C}"],
      ["9b62", "\u{22C88}\u{22CB7}\u{25BE8}\u{22D08}\u{22D12}\u{22DB7}\u{22D95}\u{22E42}\u{22F74}\u{22FCC}\u{23033}\u{23066}\u{2331F}\u{233DE}\u5FB1\u6648\u66BF\u{27A79}\u{23567}\u{235F3}\u7201\u{249BA}\u77D7\u{2361A}\u{23716}\u7E87\u{20346}\u58B5\u670E"],
      ["9ba1", "\u6918\u{23AA7}\u{27657}\u{25FE2}\u{23E11}\u{23EB9}\u{275FE}\u{2209A}\u48D0\u4AB8\u{24119}\u{28A9A}\u{242EE}\u{2430D}\u{2403B}\u{24334}\u{24396}\u{24A45}\u{205CA}\u51D2\u{20611}\u599F\u{21EA8}\u3BBE\u{23CFF}\u{24404}\u{244D6}\u5788\u{24674}\u399B\u{2472F}\u{285E8}\u{299C9}\u3762\u{221C3}\u8B5E\u{28B4E}\u99D6\u{24812}\u{248FB}\u{24A15}\u7209\u{24AC0}\u{20C78}\u5965\u{24EA5}\u{24F86}\u{20779}\u8EDA\u{2502C}\u528F\u573F\u7171\u{25299}\u{25419}\u{23F4A}\u{24AA7}\u55BC\u{25446}\u{2546E}\u{26B52}\u91D4\u3473\u{2553F}\u{27632}\u{2555E}\u4718\u{25562}\u{25566}\u{257C7}\u{2493F}\u{2585D}\u5066\u34FB\u{233CC}\u60DE\u{25903}\u477C\u{28948}\u{25AAE}\u{25B89}\u{25C06}\u{21D90}\u57A1\u7151\u6FB6\u{26102}\u{27C12}\u9056\u{261B2}\u{24F9A}\u8B62\u{26402}\u{2644A}"],
      ["9c40", "\u5D5B\u{26BF7}\u8F36\u{26484}\u{2191C}\u8AEA\u{249F6}\u{26488}\u{23FEF}\u{26512}\u4BC0\u{265BF}\u{266B5}\u{2271B}\u9465\u{257E1}\u6195\u5A27\u{2F8CD}\u4FBB\u56B9\u{24521}\u{266FC}\u4E6A\u{24934}\u9656\u6D8F\u{26CBD}\u3618\u8977\u{26799}\u{2686E}\u{26411}\u{2685E}\u71DF\u{268C7}\u7B42\u{290C0}\u{20A11}\u{26926}\u9104\u{26939}\u7A45\u9DF0\u{269FA}\u9A26\u{26A2D}\u365F\u{26469}\u{20021}\u7983\u{26A34}\u{26B5B}\u5D2C\u{23519}\u83CF\u{26B9D}\u46D0\u{26CA4}\u753B\u8865\u{26DAE}\u58B6"],
      ["9ca1", "\u371C\u{2258D}\u{2704B}\u{271CD}\u3C54\u{27280}\u{27285}\u9281\u{2217A}\u{2728B}\u9330\u{272E6}\u{249D0}\u6C39\u949F\u{27450}\u{20EF8}\u8827\u88F5\u{22926}\u{28473}\u{217B1}\u6EB8\u{24A2A}\u{21820}\u39A4\u36B9\u5C10\u79E3\u453F\u66B6\u{29CAD}\u{298A4}\u8943\u{277CC}\u{27858}\u56D6\u40DF\u{2160A}\u39A1\u{2372F}\u{280E8}\u{213C5}\u71AD\u8366\u{279DD}\u{291A8}\u5A67\u4CB7\u{270AF}\u{289AB}\u{279FD}\u{27A0A}\u{27B0B}\u{27D66}\u{2417A}\u7B43\u797E\u{28009}\u6FB5\u{2A2DF}\u6A03\u{28318}\u53A2\u{26E07}\u93BF\u6836\u975D\u{2816F}\u{28023}\u{269B5}\u{213ED}\u{2322F}\u{28048}\u5D85\u{28C30}\u{28083}\u5715\u9823\u{28949}\u5DAB\u{24988}\u65BE\u69D5\u53D2\u{24AA5}\u{23F81}\u3C11\u6736\u{28090}\u{280F4}\u{2812E}\u{21FA1}\u{2814F}"],
      ["9d40", "\u{28189}\u{281AF}\u{2821A}\u{28306}\u{2832F}\u{2838A}\u35CA\u{28468}\u{286AA}\u48FA\u63E6\u{28956}\u7808\u9255\u{289B8}\u43F2\u{289E7}\u43DF\u{289E8}\u{28B46}\u{28BD4}\u59F8\u{28C09}\u8F0B\u{28FC5}\u{290EC}\u7B51\u{29110}\u{2913C}\u3DF7\u{2915E}\u{24ACA}\u8FD0\u728F\u568B\u{294E7}\u{295E9}\u{295B0}\u{295B8}\u{29732}\u{298D1}\u{29949}\u{2996A}\u{299C3}\u{29A28}\u{29B0E}\u{29D5A}\u{29D9B}\u7E9F\u{29EF8}\u{29F23}\u4CA4\u9547\u{2A293}\u71A2\u{2A2FF}\u4D91\u9012\u{2A5CB}\u4D9C\u{20C9C}\u8FBE\u55C1"],
      ["9da1", "\u8FBA\u{224B0}\u8FB9\u{24A93}\u4509\u7E7F\u6F56\u6AB1\u4EEA\u34E4\u{28B2C}\u{2789D}\u373A\u8E80\u{217F5}\u{28024}\u{28B6C}\u{28B99}\u{27A3E}\u{266AF}\u3DEB\u{27655}\u{23CB7}\u{25635}\u{25956}\u4E9A\u{25E81}\u{26258}\u56BF\u{20E6D}\u8E0E\u5B6D\u{23E88}\u{24C9E}\u63DE\u62D0\u{217F6}\u{2187B}\u6530\u562D\u{25C4A}\u541A\u{25311}\u3DC6\u{29D98}\u4C7D\u5622\u561E\u7F49\u{25ED8}\u5975\u{23D40}\u8770\u4E1C\u{20FEA}\u{20D49}\u{236BA}\u8117\u9D5E\u8D18\u763B\u9C45\u764E\u77B9\u9345\u5432\u8148\u82F7\u5625\u8132\u8418\u80BD\u55EA\u7962\u5643\u5416\u{20E9D}\u35CE\u5605\u55F1\u66F1\u{282E2}\u362D\u7534\u55F0\u55BA\u5497\u5572\u{20C41}\u{20C96}\u5ED0\u{25148}\u{20E76}\u{22C62}"],
      ["9e40", "\u{20EA2}\u9EAB\u7D5A\u55DE\u{21075}\u629D\u976D\u5494\u8CCD\u71F6\u9176\u63FC\u63B9\u63FE\u5569\u{22B43}\u9C72\u{22EB3}\u519A\u34DF\u{20DA7}\u51A7\u544D\u551E\u5513\u7666\u8E2D\u{2688A}\u75B1\u80B6\u8804\u8786\u88C7\u81B6\u841C\u{210C1}\u44EC\u7304\u{24706}\u5B90\u830B\u{26893}\u567B\u{226F4}\u{27D2F}\u{241A3}\u{27D73}\u{26ED0}\u{272B6}\u9170\u{211D9}\u9208\u{23CFC}\u{2A6A9}\u{20EAC}\u{20EF9}\u7266\u{21CA2}\u474E\u{24FC2}\u{27FF9}\u{20FEB}\u40FA"],
      ["9ea1", "\u9C5D\u651F\u{22DA0}\u48F3\u{247E0}\u{29D7C}\u{20FEC}\u{20E0A}\u6062\u{275A3}\u{20FED}"],
      ["9ead", "\u{26048}\u{21187}\u71A3\u7E8E\u9D50\u4E1A\u4E04\u3577\u5B0D\u6CB2\u5367\u36AC\u39DC\u537D\u36A5\u{24618}\u589A\u{24B6E}\u822D\u544B\u57AA\u{25A95}\u{20979}"],
      ["9ec5", "\u3A52\u{22465}\u7374\u{29EAC}\u4D09\u9BED\u{23CFE}\u{29F30}\u4C5B\u{24FA9}\u{2959E}\u{29FDE}\u845C\u{23DB6}\u{272B2}\u{267B3}\u{23720}\u632E\u7D25\u{23EF7}\u{23E2C}\u3A2A\u9008\u52CC\u3E74\u367A\u45E9\u{2048E}\u7640\u5AF0\u{20EB6}\u787A\u{27F2E}\u58A7\u40BF\u567C\u9B8B\u5D74\u7654\u{2A434}\u9E85\u4CE1\u75F9\u37FB\u6119\u{230DA}\u{243F2}"],
      ["9ef5", "\u565D\u{212A9}\u57A7\u{24963}\u{29E06}\u5234\u{270AE}\u35AD\u6C4A\u9D7C"],
      ["9f40", "\u7C56\u9B39\u57DE\u{2176C}\u5C53\u64D3\u{294D0}\u{26335}\u{27164}\u86AD\u{20D28}\u{26D22}\u{24AE2}\u{20D71}"],
      ["9f4f", "\u51FE\u{21F0F}\u5D8E\u9703\u{21DD1}\u9E81\u904C\u7B1F\u9B02\u5CD1\u7BA3\u6268\u6335\u9AFF\u7BCF\u9B2A\u7C7E\u9B2E\u7C42\u7C86\u9C15\u7BFC\u9B09\u9F17\u9C1B\u{2493E}\u9F5A\u5573\u5BC3\u4FFD\u9E98\u4FF2\u5260\u3E06\u52D1\u5767\u5056\u59B7\u5E12\u97C8\u9DAB\u8F5C\u5469\u97B4\u9940\u97BA\u532C\u6130"],
      ["9fa1", "\u692C\u53DA\u9C0A\u9D02\u4C3B\u9641\u6980\u50A6\u7546\u{2176D}\u99DA\u5273"],
      ["9fae", "\u9159\u9681\u915C"],
      ["9fb2", "\u9151\u{28E97}\u637F\u{26D23}\u6ACA\u5611\u918E\u757A\u6285\u{203FC}\u734F\u7C70\u{25C21}\u{23CFD}"],
      ["9fc1", "\u{24919}\u76D6\u9B9D\u4E2A\u{20CD4}\u83BE\u8842"],
      ["9fc9", "\u5C4A\u69C0\u50ED\u577A\u521F\u5DF5\u4ECE\u6C31\u{201F2}\u4F39\u549C\u54DA\u529A\u8D82\u35FE\u5F0C\u35F3"],
      ["9fdb", "\u6B52\u917C\u9FA5\u9B97\u982E\u98B4\u9ABA\u9EA8\u9E84\u717A\u7B14"],
      ["9fe7", "\u6BFA\u8818\u7F78"],
      ["9feb", "\u5620\u{2A64A}\u8E77\u9F53"],
      ["9ff0", "\u8DD4\u8E4F\u9E1C\u8E01\u6282\u{2837D}\u8E28\u8E75\u7AD3\u{24A77}\u7A3E\u78D8\u6CEA\u8A67\u7607"],
      ["a040", "\u{28A5A}\u9F26\u6CCE\u87D6\u75C3\u{2A2B2}\u7853\u{2F840}\u8D0C\u72E2\u7371\u8B2D\u7302\u74F1\u8CEB\u{24ABB}\u862F\u5FBA\u88A0\u44B7"],
      ["a055", "\u{2183B}\u{26E05}"],
      ["a058", "\u8A7E\u{2251B}"],
      ["a05b", "\u60FD\u7667\u9AD7\u9D44\u936E\u9B8F\u87F5"],
      ["a063", "\u880F\u8CF7\u732C\u9721\u9BB0\u35D6\u72B2\u4C07\u7C51\u994A\u{26159}\u6159\u4C04\u9E96\u617D"],
      ["a073", "\u575F\u616F\u62A6\u6239\u62CE\u3A5C\u61E2\u53AA\u{233F5}\u6364\u6802\u35D2"],
      ["a0a1", "\u5D57\u{28BC2}\u8FDA\u{28E39}"],
      ["a0a6", "\u50D9\u{21D46}\u7906\u5332\u9638\u{20F3B}\u4065"],
      ["a0ae", "\u77FE"],
      ["a0b0", "\u7CC2\u{25F1A}\u7CDA\u7A2D\u8066\u8063\u7D4D\u7505\u74F2\u8994\u821A\u670C\u8062\u{27486}\u805B\u74F0\u8103\u7724\u8989\u{267CC}\u7553\u{26ED1}\u87A9\u87CE\u81C8\u878C\u8A49\u8CAD\u8B43\u772B\u74F8\u84DA\u3635\u69B2\u8DA6"],
      ["a0d4", "\u89A9\u7468\u6DB9\u87C1\u{24011}\u74E7\u3DDB\u7176\u60A4\u619C\u3CD1\u7162\u6077"],
      ["a0e2", "\u7F71\u{28B2D}\u7250\u60E9\u4B7E\u5220\u3C18\u{23CC7}\u{25ED7}\u{27656}\u{25531}\u{21944}\u{212FE}\u{29903}\u{26DDC}\u{270AD}\u5CC1\u{261AD}\u{28A0F}\u{23677}\u{200EE}\u{26846}\u{24F0E}\u4562\u5B1F\u{2634C}\u9F50\u9EA6\u{2626B}"],
      ["a3c0", "\u2400", 31, "\u2421"],
      ["c6a1", "\u2460", 9, "\u2474", 9, "\u2170", 9, "\u4E36\u4E3F\u4E85\u4EA0\u5182\u5196\u51AB\u52F9\u5338\u5369\u53B6\u590A\u5B80\u5DDB\u2F33\u5E7F\u5EF4\u5F50\u5F61\u6534\u65E0\u7592\u7676\u8FB5\u96B6\xA8\u02C6\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\uFF3B\uFF3D\u273D\u3041", 23],
      ["c740", "\u3059", 58, "\u30A1\u30A2\u30A3\u30A4"],
      ["c7a1", "\u30A5", 81, "\u0410", 5, "\u0401\u0416", 4],
      ["c840", "\u041B", 26, "\u0451\u0436", 25, "\u21E7\u21B8\u21B9\u31CF\u{200CC}\u4E5A\u{2008A}\u5202\u4491"],
      ["c8a1", "\u9FB0\u5188\u9FB1\u{27607}"],
      ["c8cd", "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u309B\u309C\u2E80\u2E84\u2E86\u2E87\u2E88\u2E8A\u2E8C\u2E8D\u2E95\u2E9C\u2E9D\u2EA5\u2EA7\u2EAA\u2EAC\u2EAE\u2EB6\u2EBC\u2EBE\u2EC6\u2ECA\u2ECC\u2ECD\u2ECF\u2ED6\u2ED7\u2EDE\u2EE3"],
      ["c8f5", "\u0283\u0250\u025B\u0254\u0275\u0153\xF8\u014B\u028A\u026A"],
      ["f9fe", "\uFFED"],
      ["fa40", "\u{20547}\u92DB\u{205DF}\u{23FC5}\u854C\u42B5\u73EF\u51B5\u3649\u{24942}\u{289E4}\u9344\u{219DB}\u82EE\u{23CC8}\u783C\u6744\u62DF\u{24933}\u{289AA}\u{202A0}\u{26BB3}\u{21305}\u4FAB\u{224ED}\u5008\u{26D29}\u{27A84}\u{23600}\u{24AB1}\u{22513}\u5029\u{2037E}\u5FA4\u{20380}\u{20347}\u6EDB\u{2041F}\u507D\u5101\u347A\u510E\u986C\u3743\u8416\u{249A4}\u{20487}\u5160\u{233B4}\u516A\u{20BFF}\u{220FC}\u{202E5}\u{22530}\u{2058E}\u{23233}\u{21983}\u5B82\u877D\u{205B3}\u{23C99}\u51B2\u51B8"],
      ["faa1", "\u9D34\u51C9\u51CF\u51D1\u3CDC\u51D3\u{24AA6}\u51B3\u51E2\u5342\u51ED\u83CD\u693E\u{2372D}\u5F7B\u520B\u5226\u523C\u52B5\u5257\u5294\u52B9\u52C5\u7C15\u8542\u52E0\u860D\u{26B13}\u5305\u{28ADE}\u5549\u6ED9\u{23F80}\u{20954}\u{23FEC}\u5333\u5344\u{20BE2}\u6CCB\u{21726}\u681B\u73D5\u604A\u3EAA\u38CC\u{216E8}\u71DD\u44A2\u536D\u5374\u{286AB}\u537E\u537F\u{21596}\u{21613}\u77E6\u5393\u{28A9B}\u53A0\u53AB\u53AE\u73A7\u{25772}\u3F59\u739C\u53C1\u53C5\u6C49\u4E49\u57FE\u53D9\u3AAB\u{20B8F}\u53E0\u{23FEB}\u{22DA3}\u53F6\u{20C77}\u5413\u7079\u552B\u6657\u6D5B\u546D\u{26B53}\u{20D74}\u555D\u548F\u54A4\u47A6\u{2170D}\u{20EDD}\u3DB4\u{20D4D}"],
      ["fb40", "\u{289BC}\u{22698}\u5547\u4CED\u542F\u7417\u5586\u55A9\u5605\u{218D7}\u{2403A}\u4552\u{24435}\u66B3\u{210B4}\u5637\u66CD\u{2328A}\u66A4\u66AD\u564D\u564F\u78F1\u56F1\u9787\u53FE\u5700\u56EF\u56ED\u{28B66}\u3623\u{2124F}\u5746\u{241A5}\u6C6E\u708B\u5742\u36B1\u{26C7E}\u57E6\u{21416}\u5803\u{21454}\u{24363}\u5826\u{24BF5}\u585C\u58AA\u3561\u58E0\u58DC\u{2123C}\u58FB\u5BFF\u5743\u{2A150}\u{24278}\u93D3\u35A1\u591F\u68A6\u36C3\u6E59"],
      ["fba1", "\u{2163E}\u5A24\u5553\u{21692}\u8505\u59C9\u{20D4E}\u{26C81}\u{26D2A}\u{217DC}\u59D9\u{217FB}\u{217B2}\u{26DA6}\u6D71\u{21828}\u{216D5}\u59F9\u{26E45}\u5AAB\u5A63\u36E6\u{249A9}\u5A77\u3708\u5A96\u7465\u5AD3\u{26FA1}\u{22554}\u3D85\u{21911}\u3732\u{216B8}\u5E83\u52D0\u5B76\u6588\u5B7C\u{27A0E}\u4004\u485D\u{20204}\u5BD5\u6160\u{21A34}\u{259CC}\u{205A5}\u5BF3\u5B9D\u4D10\u5C05\u{21B44}\u5C13\u73CE\u5C14\u{21CA5}\u{26B28}\u5C49\u48DD\u5C85\u5CE9\u5CEF\u5D8B\u{21DF9}\u{21E37}\u5D10\u5D18\u5D46\u{21EA4}\u5CBA\u5DD7\u82FC\u382D\u{24901}\u{22049}\u{22173}\u8287\u3836\u3BC2\u5E2E\u6A8A\u5E75\u5E7A\u{244BC}\u{20CD3}\u53A6\u4EB7\u5ED0\u53A8\u{21771}\u5E09\u5EF4\u{28482}"],
      ["fc40", "\u5EF9\u5EFB\u38A0\u5EFC\u683E\u941B\u5F0D\u{201C1}\u{2F894}\u3ADE\u48AE\u{2133A}\u5F3A\u{26888}\u{223D0}\u5F58\u{22471}\u5F63\u97BD\u{26E6E}\u5F72\u9340\u{28A36}\u5FA7\u5DB6\u3D5F\u{25250}\u{21F6A}\u{270F8}\u{22668}\u91D6\u{2029E}\u{28A29}\u6031\u6685\u{21877}\u3963\u3DC7\u3639\u5790\u{227B4}\u7971\u3E40\u609E\u60A4\u60B3\u{24982}\u{2498F}\u{27A53}\u74A4\u50E1\u5AA0\u6164\u8424\u6142\u{2F8A6}\u{26ED2}\u6181\u51F4\u{20656}\u6187\u5BAA\u{23FB7}"],
      ["fca1", "\u{2285F}\u61D3\u{28B9D}\u{2995D}\u61D0\u3932\u{22980}\u{228C1}\u6023\u615C\u651E\u638B\u{20118}\u62C5\u{21770}\u62D5\u{22E0D}\u636C\u{249DF}\u3A17\u6438\u63F8\u{2138E}\u{217FC}\u6490\u6F8A\u{22E36}\u9814\u{2408C}\u{2571D}\u64E1\u64E5\u947B\u3A66\u643A\u3A57\u654D\u6F16\u{24A28}\u{24A23}\u6585\u656D\u655F\u{2307E}\u65B5\u{24940}\u4B37\u65D1\u40D8\u{21829}\u65E0\u65E3\u5FDF\u{23400}\u6618\u{231F7}\u{231F8}\u6644\u{231A4}\u{231A5}\u664B\u{20E75}\u6667\u{251E6}\u6673\u6674\u{21E3D}\u{23231}\u{285F4}\u{231C8}\u{25313}\u77C5\u{228F7}\u99A4\u6702\u{2439C}\u{24A21}\u3B2B\u69FA\u{237C2}\u675E\u6767\u6762\u{241CD}\u{290ED}\u67D7\u44E9\u6822\u6E50\u923C\u6801\u{233E6}\u{26DA0}\u685D"],
      ["fd40", "\u{2346F}\u69E1\u6A0B\u{28ADF}\u6973\u68C3\u{235CD}\u6901\u6900\u3D32\u3A01\u{2363C}\u3B80\u67AC\u6961\u{28A4A}\u42FC\u6936\u6998\u3BA1\u{203C9}\u8363\u5090\u69F9\u{23659}\u{2212A}\u6A45\u{23703}\u6A9D\u3BF3\u67B1\u6AC8\u{2919C}\u3C0D\u6B1D\u{20923}\u60DE\u6B35\u6B74\u{227CD}\u6EB5\u{23ADB}\u{203B5}\u{21958}\u3740\u5421\u{23B5A}\u6BE1\u{23EFC}\u6BDC\u6C37\u{2248B}\u{248F1}\u{26B51}\u6C5A\u8226\u6C79\u{23DBC}\u44C5\u{23DBD}\u{241A4}\u{2490C}\u{24900}"],
      ["fda1", "\u{23CC9}\u36E5\u3CEB\u{20D32}\u9B83\u{231F9}\u{22491}\u7F8F\u6837\u{26D25}\u{26DA1}\u{26DEB}\u6D96\u6D5C\u6E7C\u6F04\u{2497F}\u{24085}\u{26E72}\u8533\u{26F74}\u51C7\u6C9C\u6E1D\u842E\u{28B21}\u6E2F\u{23E2F}\u7453\u{23F82}\u79CC\u6E4F\u5A91\u{2304B}\u6FF8\u370D\u6F9D\u{23E30}\u6EFA\u{21497}\u{2403D}\u4555\u93F0\u6F44\u6F5C\u3D4E\u6F74\u{29170}\u3D3B\u6F9F\u{24144}\u6FD3\u{24091}\u{24155}\u{24039}\u{23FF0}\u{23FB4}\u{2413F}\u51DF\u{24156}\u{24157}\u{24140}\u{261DD}\u704B\u707E\u70A7\u7081\u70CC\u70D5\u70D6\u70DF\u4104\u3DE8\u71B4\u7196\u{24277}\u712B\u7145\u5A88\u714A\u716E\u5C9C\u{24365}\u714F\u9362\u{242C1}\u712C\u{2445A}\u{24A27}\u{24A22}\u71BA\u{28BE8}\u70BD\u720E"],
      ["fe40", "\u9442\u7215\u5911\u9443\u7224\u9341\u{25605}\u722E\u7240\u{24974}\u68BD\u7255\u7257\u3E55\u{23044}\u680D\u6F3D\u7282\u732A\u732B\u{24823}\u{2882B}\u48ED\u{28804}\u7328\u732E\u73CF\u73AA\u{20C3A}\u{26A2E}\u73C9\u7449\u{241E2}\u{216E7}\u{24A24}\u6623\u36C5\u{249B7}\u{2498D}\u{249FB}\u73F7\u7415\u6903\u{24A26}\u7439\u{205C3}\u3ED7\u745C\u{228AD}\u7460\u{28EB2}\u7447\u73E4\u7476\u83B9\u746C\u3730\u7474\u93F1\u6A2C\u7482\u4953\u{24A8C}"],
      ["fea1", "\u{2415F}\u{24A79}\u{28B8F}\u5B46\u{28C03}\u{2189E}\u74C8\u{21988}\u750E\u74E9\u751E\u{28ED9}\u{21A4B}\u5BD7\u{28EAC}\u9385\u754D\u754A\u7567\u756E\u{24F82}\u3F04\u{24D13}\u758E\u745D\u759E\u75B4\u7602\u762C\u7651\u764F\u766F\u7676\u{263F5}\u7690\u81EF\u37F8\u{26911}\u{2690E}\u76A1\u76A5\u76B7\u76CC\u{26F9F}\u8462\u{2509D}\u{2517D}\u{21E1C}\u771E\u7726\u7740\u64AF\u{25220}\u7758\u{232AC}\u77AF\u{28964}\u{28968}\u{216C1}\u77F4\u7809\u{21376}\u{24A12}\u68CA\u78AF\u78C7\u78D3\u96A5\u792E\u{255E0}\u78D7\u7934\u78B1\u{2760C}\u8FB8\u8884\u{28B2B}\u{26083}\u{2261C}\u7986\u8900\u6902\u7980\u{25857}\u799D\u{27B39}\u793C\u79A9\u6E2A\u{27126}\u3EA8\u79C6\u{2910D}\u79D4"]
    ];
  }
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII + ¥ + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "\u20AC": 41699 }
      },
      "chinese": "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      // 
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [
          // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
          // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
          // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
          36457,
          36463,
          36478,
          36523,
          36532,
          36557,
          36560,
          36695,
          36713,
          36718,
          36811,
          36862,
          36973,
          36986,
          37060,
          37084,
          37105,
          37311,
          37551,
          37552,
          37553,
          37554,
          37585,
          37959,
          38090,
          38361,
          38652,
          39285,
          39798,
          39800,
          39803,
          39878,
          39902,
          39916,
          39926,
          40002,
          40019,
          40034,
          40040,
          40043,
          40055,
          40124,
          40125,
          40144,
          40279,
          40282,
          40388,
          40431,
          40443,
          40617,
          40687,
          40701,
          40800,
          40907,
          41079,
          41180,
          41183,
          36812,
          37576,
          38468,
          38637,
          // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
          41636,
          41637,
          41639,
          41638,
          41676,
          41678
        ]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "node_modules/iconv-lite/encodings/index.js"(exports2, module2) {
    "use strict";
    var modules = [
      require_internal(),
      require_utf32(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module2 = modules[i];
      for (enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports2[enc] = module2[enc];
    }
    var module2;
    var enc;
    var i;
  }
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS({
  "node_modules/iconv-lite/lib/streams.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module2.exports = function(stream_module) {
      var Transform2 = stream_module.Transform;
      function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false;
        Transform2.call(this, options);
      }
      IconvLiteEncoderStream.prototype = Object.create(Transform2.prototype, {
        constructor: { value: IconvLiteEncoderStream }
      });
      IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != "string")
          return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length)
            this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length)
            this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function(chunk) {
          chunks.push(chunk);
        });
        this.on("end", function() {
          cb(null, Buffer2.concat(chunks));
        });
        return this;
      };
      function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = "utf8";
        Transform2.call(this, options);
      }
      IconvLiteDecoderStream.prototype = Object.create(Transform2.prototype, {
        constructor: { value: IconvLiteDecoderStream }
      });
      IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
          return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length)
            this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length)
            this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function(chunk) {
          res += chunk;
        });
        this.on("end", function() {
          cb(null, res);
        });
        return this;
      };
      return {
        IconvLiteEncoderStream,
        IconvLiteDecoderStream
      };
    };
  }
});

// node_modules/iconv-lite/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/iconv-lite/lib/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "\uFFFD";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = require_encodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams = require_streams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
    if (false) {
      console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// node_modules/tedious/lib/data-types/text.js
var require_text = __commonJS({
  "node_modules/tedious/lib/data-types/text.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Text = {
      id: 35,
      type: "TEXT",
      name: "Text",
      hasTableName: true,
      declaration: function() {
        return "text";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(value.length, 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        yield value;
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports2.default = Text;
    module2.exports = Text;
  }
});

// node_modules/tedious/lib/guid-parser.js
var require_guid_parser = __commonJS({
  "node_modules/tedious/lib/guid-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.bufferToLowerCaseGuid = bufferToLowerCaseGuid;
    exports2.bufferToUpperCaseGuid = bufferToUpperCaseGuid;
    exports2.guidToArray = guidToArray;
    var UPPER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF", "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF", "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF", "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF", "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"];
    var LOWER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    function bufferToUpperCaseGuid(buffer) {
      return UPPER_CASE_MAP[buffer[3]] + UPPER_CASE_MAP[buffer[2]] + UPPER_CASE_MAP[buffer[1]] + UPPER_CASE_MAP[buffer[0]] + "-" + UPPER_CASE_MAP[buffer[5]] + UPPER_CASE_MAP[buffer[4]] + "-" + UPPER_CASE_MAP[buffer[7]] + UPPER_CASE_MAP[buffer[6]] + "-" + UPPER_CASE_MAP[buffer[8]] + UPPER_CASE_MAP[buffer[9]] + "-" + UPPER_CASE_MAP[buffer[10]] + UPPER_CASE_MAP[buffer[11]] + UPPER_CASE_MAP[buffer[12]] + UPPER_CASE_MAP[buffer[13]] + UPPER_CASE_MAP[buffer[14]] + UPPER_CASE_MAP[buffer[15]];
    }
    function bufferToLowerCaseGuid(buffer) {
      return LOWER_CASE_MAP[buffer[3]] + LOWER_CASE_MAP[buffer[2]] + LOWER_CASE_MAP[buffer[1]] + LOWER_CASE_MAP[buffer[0]] + "-" + LOWER_CASE_MAP[buffer[5]] + LOWER_CASE_MAP[buffer[4]] + "-" + LOWER_CASE_MAP[buffer[7]] + LOWER_CASE_MAP[buffer[6]] + "-" + LOWER_CASE_MAP[buffer[8]] + LOWER_CASE_MAP[buffer[9]] + "-" + LOWER_CASE_MAP[buffer[10]] + LOWER_CASE_MAP[buffer[11]] + LOWER_CASE_MAP[buffer[12]] + LOWER_CASE_MAP[buffer[13]] + LOWER_CASE_MAP[buffer[14]] + LOWER_CASE_MAP[buffer[15]];
    }
    var CHARCODEMAP = {};
    var hexDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"].map((d) => d.charCodeAt(0));
    for (let i = 0; i < hexDigits.length; i++) {
      const map = CHARCODEMAP[hexDigits[i]] = {};
      for (let j = 0; j < hexDigits.length; j++) {
        const hex = String.fromCharCode(hexDigits[i], hexDigits[j]);
        const value = parseInt(hex, 16);
        map[hexDigits[j]] = value;
      }
    }
    function guidToArray(guid) {
      return [CHARCODEMAP[guid.charCodeAt(6)][guid.charCodeAt(7)], CHARCODEMAP[guid.charCodeAt(4)][guid.charCodeAt(5)], CHARCODEMAP[guid.charCodeAt(2)][guid.charCodeAt(3)], CHARCODEMAP[guid.charCodeAt(0)][guid.charCodeAt(1)], CHARCODEMAP[guid.charCodeAt(11)][guid.charCodeAt(12)], CHARCODEMAP[guid.charCodeAt(9)][guid.charCodeAt(10)], CHARCODEMAP[guid.charCodeAt(16)][guid.charCodeAt(17)], CHARCODEMAP[guid.charCodeAt(14)][guid.charCodeAt(15)], CHARCODEMAP[guid.charCodeAt(19)][guid.charCodeAt(20)], CHARCODEMAP[guid.charCodeAt(21)][guid.charCodeAt(22)], CHARCODEMAP[guid.charCodeAt(24)][guid.charCodeAt(25)], CHARCODEMAP[guid.charCodeAt(26)][guid.charCodeAt(27)], CHARCODEMAP[guid.charCodeAt(28)][guid.charCodeAt(29)], CHARCODEMAP[guid.charCodeAt(30)][guid.charCodeAt(31)], CHARCODEMAP[guid.charCodeAt(32)][guid.charCodeAt(33)], CHARCODEMAP[guid.charCodeAt(34)][guid.charCodeAt(35)]];
    }
  }
});

// node_modules/tedious/lib/data-types/uniqueidentifier.js
var require_uniqueidentifier = __commonJS({
  "node_modules/tedious/lib/data-types/uniqueidentifier.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _guidParser = require_guid_parser();
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([16]);
    var UniqueIdentifier = {
      id: 36,
      type: "GUIDN",
      name: "UniqueIdentifier",
      declaration: function() {
        return "uniqueidentifier";
      },
      resolveLength: function() {
        return 16;
      },
      generateTypeInfo() {
        return Buffer.from([this.id, 16]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from((0, _guidParser.guidToArray)(parameter.value));
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
          throw new TypeError("Invalid GUID.");
        }
        return value;
      }
    };
    var _default = exports2.default = UniqueIdentifier;
    module2.exports = UniqueIdentifier;
  }
});

// node_modules/tedious/lib/data-types/ntext.js
var require_ntext = __commonJS({
  "node_modules/tedious/lib/data-types/ntext.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var NText = {
      id: 99,
      type: "NTEXT",
      name: "NText",
      hasTableName: true,
      declaration: function() {
        return "ntext";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Buffer.byteLength(parameter.value, "ucs2"), 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value.toString(), "ucs2");
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports2.default = NText;
    module2.exports = NText;
  }
});

// node_modules/tedious/lib/data-types/varbinary.js
var require_varbinary = __commonJS({
  "node_modules/tedious/lib/data-types/varbinary.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarBinary = {
      id: 165,
      type: "BIGVARBIN",
      name: "VarBinary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varbinary(" + length + ")";
        } else {
          return "varbinary(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (!Buffer.isBuffer(value)) {
          value = value.toString();
        }
        const length = Buffer.byteLength(value, "ucs2");
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (Buffer.isBuffer(value)) {
            yield value;
          } else {
            yield Buffer.from(value.toString(), "ucs2");
          }
        } else {
          if (!Buffer.isBuffer(value)) {
            value = value.toString();
          }
          const length = Buffer.byteLength(value, "ucs2");
          if (length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(length, 0);
            yield buffer;
            if (Buffer.isBuffer(value)) {
              yield value;
            } else {
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports2.default = VarBinary;
    module2.exports = VarBinary;
  }
});

// node_modules/tedious/lib/data-types/varchar.js
var require_varchar = __commonJS({
  "node_modules/tedious/lib/data-types/varchar.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarChar = {
      id: 167,
      type: "BIGVARCHR",
      name: "VarChar",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varchar(" + length + ")";
        } else {
          return "varchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(value.length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        if (parameter.length <= this.maximumLength) {
          yield value;
        } else {
          if (value.length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(value.length, 0);
            yield buffer;
            yield value;
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports2.default = VarChar;
    module2.exports = VarChar;
  }
});

// node_modules/tedious/lib/data-types/binary.js
var require_binary = __commonJS({
  "node_modules/tedious/lib/data-types/binary.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Binary = {
      id: 173,
      type: "BIGBinary",
      name: "Binary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        return "binary(" + length + ")";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(parameter.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value.slice(0, parameter.length !== void 0 ? Math.min(parameter.length, this.maximumLength) : this.maximumLength);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports2.default = Binary;
    module2.exports = Binary;
  }
});

// node_modules/tedious/lib/data-types/char.js
var require_char = __commonJS({
  "node_modules/tedious/lib/data-types/char.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Char = {
      id: 175,
      type: "BIGCHAR",
      name: "Char",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "char(" + length + ")";
        } else {
          return "char(" + this.maximumLength + ")";
        }
      },
      // ParameterData<any> is temporary solution. TODO: need to understand what type ParameterData<...> can be.
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value, "ascii");
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports2.default = Char;
    module2.exports = Char;
  }
});

// node_modules/tedious/lib/data-types/nvarchar.js
var require_nvarchar = __commonJS({
  "node_modules/tedious/lib/data-types/nvarchar.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var NVarChar = {
      id: 231,
      type: "NVARCHAR",
      name: "NVarChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.toString().length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "nvarchar(" + length + ")";
        } else {
          return "nvarchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          if (Buffer.isBuffer(value)) {
            return value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length * 2, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          let length;
          if (value instanceof Buffer) {
            length = value.length;
          } else {
            value = value.toString();
            length = Buffer.byteLength(value, "ucs2");
          }
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (value instanceof Buffer) {
            yield value;
          } else {
            value = value.toString();
            yield Buffer.from(value, "ucs2");
          }
        } else {
          if (value instanceof Buffer) {
            const length = value.length;
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield value;
            }
          } else {
            value = value.toString();
            const length = Buffer.byteLength(value, "ucs2");
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports2.default = NVarChar;
    module2.exports = NVarChar;
  }
});

// node_modules/tedious/lib/data-types/nchar.js
var require_nchar = __commonJS({
  "node_modules/tedious/lib/data-types/nchar.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var NChar = {
      id: 239,
      type: "NCHAR",
      name: "NChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (parameter.value != null) {
          length = value.toString().length || 1;
        } else if (parameter.value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "nchar(" + length + ")";
        } else {
          return "nchar(" + this.maximumLength + ")";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (parameter.value != null) {
          if (Buffer.isBuffer(parameter.value)) {
            return parameter.value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length * 2, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          value
        } = parameter;
        if (value instanceof Buffer) {
          const length = value.length;
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          const length = Buffer.byteLength(value.toString(), "ucs2");
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        if (value instanceof Buffer) {
          yield value;
        } else {
          yield Buffer.from(value, "ucs2");
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports2.default = NChar;
    module2.exports = NChar;
  }
});

// node_modules/tedious/lib/data-types/xml.js
var require_xml = __commonJS({
  "node_modules/tedious/lib/data-types/xml.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var XML = {
      id: 241,
      type: "XML",
      name: "Xml",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = XML;
    module2.exports = XML;
  }
});

// node_modules/tedious/lib/data-types/time.js
var require_time = __commonJS({
  "node_modules/tedious/lib/data-types/time.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Time = {
      id: 41,
      type: "TIMEN",
      name: "Time",
      declaration: function(parameter) {
        return "time(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([3]);
          case 3:
          case 4:
            return Buffer.from([4]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([5]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(16);
        const time = parameter.value;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((time.getUTCHours() * 60 + time.getUTCMinutes()) * 60 + time.getUTCSeconds()) * 1e3 + time.getUTCMilliseconds();
        } else {
          timestamp = ((time.getHours() * 60 + time.getMinutes()) * 60 + time.getSeconds()) * 1e3 + time.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, parameter.scale - 3);
        timestamp += (parameter.value.nanosecondDelta != null ? parameter.value.nanosecondDelta : 0) * Math.pow(10, parameter.scale);
        timestamp = Math.round(timestamp);
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid time.");
        }
        return value;
      }
    };
    var _default = exports2.default = Time;
    module2.exports = Time;
  }
});

// node_modules/tedious/lib/data-types/date.js
var require_date = __commonJS({
  "node_modules/tedious/lib/data-types/date.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var globalDate = global.Date;
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([3]);
    var Date2 = {
      id: 40,
      type: "DATEN",
      name: "Date",
      declaration: function() {
        return "date";
      },
      generateTypeInfo: function() {
        return Buffer.from([this.id]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        const buffer = Buffer.alloc(3);
        buffer.writeUIntLE(days, 0, 3);
        yield buffer;
      },
      // TODO: value is technically of type 'unknown'.
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof globalDate)) {
          value = new globalDate(globalDate.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = Date2;
    module2.exports = Date2;
  }
});

// node_modules/tedious/lib/data-types/datetime2.js
var require_datetime2 = __commonJS({
  "node_modules/tedious/lib/data-types/datetime2.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTime22 = {
      id: 42,
      type: "DATETIME2N",
      name: "DateTime2",
      declaration: function(parameter) {
        return "datetime2(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter, _options) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([6]);
          case 3:
          case 4:
            return Buffer.from([7]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([8]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getUTCMilliseconds();
        } else {
          timestamp = ((value.getHours() * 60 + value.getMinutes()) * 60 + value.getSeconds()) * 1e3 + value.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        yield buffer.data;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = DateTime22;
    module2.exports = DateTime22;
  }
});

// node_modules/tedious/lib/data-types/datetimeoffset.js
var require_datetimeoffset = __commonJS({
  "node_modules/tedious/lib/data-types/datetimeoffset.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTimeOffset = {
      id: 43,
      type: "DATETIMEOFFSETN",
      name: "DateTimeOffset",
      declaration: function(parameter) {
        return "datetimeoffset(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([8]);
          case 3:
          case 4:
            return Buffer.from([9]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([10]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getMilliseconds();
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        const date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        const offset = -value.getTimezoneOffset();
        buffer.writeInt16LE(offset);
        yield buffer.data;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = DateTimeOffset;
    module2.exports = DateTimeOffset;
  }
});

// node_modules/tedious/lib/data-types/udt.js
var require_udt = __commonJS({
  "node_modules/tedious/lib/data-types/udt.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var UDT = {
      id: 240,
      type: "UDTTYPE",
      name: "UDT",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = UDT;
    module2.exports = UDT;
  }
});

// node_modules/tedious/lib/data-types/tvp.js
var require_tvp = __commonJS({
  "node_modules/tedious/lib/data-types/tvp.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _errors = require_errors();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TVP_ROW_TOKEN = Buffer.from([1]);
    var TVP_END_TOKEN = Buffer.from([0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var TVP = {
      id: 243,
      type: "TVPTYPE",
      name: "TVP",
      declaration: function(parameter) {
        const value = parameter.value;
        return value.name + " readonly";
      },
      generateTypeInfo(parameter) {
        const databaseName = "";
        const schema = parameter.value?.schema ?? "";
        const typeName = parameter.value?.name ?? "";
        const bufferLength = 1 + 1 + Buffer.byteLength(databaseName, "ucs2") + 1 + Buffer.byteLength(schema, "ucs2") + 1 + Buffer.byteLength(typeName, "ucs2");
        const buffer = new _writableTrackingBuffer.default(bufferLength, "ucs2");
        buffer.writeUInt8(this.id);
        buffer.writeBVarchar(databaseName);
        buffer.writeBVarchar(schema);
        buffer.writeBVarchar(typeName);
        return buffer.data;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          columns
        } = parameter.value;
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(columns.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          yield TVP_END_TOKEN;
          yield TVP_END_TOKEN;
          return;
        }
        const {
          columns,
          rows
        } = parameter.value;
        for (let i = 0, len = columns.length; i < len; i++) {
          const column2 = columns[i];
          const buff = Buffer.alloc(6);
          buff.writeUInt32LE(0, 0);
          buff.writeUInt16LE(0, 4);
          yield buff;
          yield column2.type.generateTypeInfo(column2);
          yield Buffer.from([0]);
        }
        yield TVP_END_TOKEN;
        for (let i = 0, length = rows.length; i < length; i++) {
          yield TVP_ROW_TOKEN;
          const row = rows[i];
          for (let k = 0, len2 = row.length; k < len2; k++) {
            const column2 = columns[k];
            const value = row[k];
            let paramValue;
            try {
              paramValue = column2.type.validate(value, parameter.collation);
            } catch (error) {
              throw new _errors.InputError(`TVP column '${column2.name}' has invalid data at row index ${i}`, {
                cause: error
              });
            }
            const param = {
              value: paramValue,
              length: column2.length,
              scale: column2.scale,
              precision: column2.precision
            };
            yield column2.type.generateParameterLength(param, options);
            yield* column2.type.generateParameterData(param, options);
          }
        }
        yield TVP_END_TOKEN;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "object") {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.columns)) {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.rows)) {
          throw new TypeError("Invalid table.");
        }
        return value;
      }
    };
    var _default = exports2.default = TVP;
    module2.exports = TVP;
  }
});

// node_modules/tedious/lib/data-types/sql-variant.js
var require_sql_variant = __commonJS({
  "node_modules/tedious/lib/data-types/sql-variant.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Variant = {
      id: 98,
      type: "SSVARIANTTYPE",
      name: "Variant",
      declaration: function() {
        return "sql_variant";
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = Variant;
    module2.exports = Variant;
  }
});

// node_modules/tedious/lib/data-type.js
var require_data_type = __commonJS({
  "node_modules/tedious/lib/data-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.typeByName = exports2.TYPES = exports2.TYPE = void 0;
    var _null = _interopRequireDefault(require_null());
    var _tinyint = _interopRequireDefault(require_tinyint());
    var _bit = _interopRequireDefault(require_bit());
    var _smallint = _interopRequireDefault(require_smallint());
    var _int = _interopRequireDefault(require_int());
    var _smalldatetime = _interopRequireDefault(require_smalldatetime());
    var _real = _interopRequireDefault(require_real());
    var _money = _interopRequireDefault(require_money());
    var _datetime = _interopRequireDefault(require_datetime());
    var _float = _interopRequireDefault(require_float());
    var _decimal = _interopRequireDefault(require_decimal());
    var _numeric = _interopRequireDefault(require_numeric());
    var _smallmoney = _interopRequireDefault(require_smallmoney());
    var _bigint = _interopRequireDefault(require_bigint());
    var _image = _interopRequireDefault(require_image());
    var _text = _interopRequireDefault(require_text());
    var _uniqueidentifier = _interopRequireDefault(require_uniqueidentifier());
    var _intn = _interopRequireDefault(require_intn());
    var _ntext = _interopRequireDefault(require_ntext());
    var _bitn = _interopRequireDefault(require_bitn());
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _numericn = _interopRequireDefault(require_numericn());
    var _floatn = _interopRequireDefault(require_floatn());
    var _moneyn = _interopRequireDefault(require_moneyn());
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _varbinary = _interopRequireDefault(require_varbinary());
    var _varchar = _interopRequireDefault(require_varchar());
    var _binary = _interopRequireDefault(require_binary());
    var _char = _interopRequireDefault(require_char());
    var _nvarchar = _interopRequireDefault(require_nvarchar());
    var _nchar = _interopRequireDefault(require_nchar());
    var _xml = _interopRequireDefault(require_xml());
    var _time = _interopRequireDefault(require_time());
    var _date = _interopRequireDefault(require_date());
    var _datetime2 = _interopRequireDefault(require_datetime2());
    var _datetimeoffset = _interopRequireDefault(require_datetimeoffset());
    var _udt = _interopRequireDefault(require_udt());
    var _tvp = _interopRequireDefault(require_tvp());
    var _sqlVariant = _interopRequireDefault(require_sql_variant());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TYPE = exports2.TYPE = {
      [_null.default.id]: _null.default,
      [_tinyint.default.id]: _tinyint.default,
      [_bit.default.id]: _bit.default,
      [_smallint.default.id]: _smallint.default,
      [_int.default.id]: _int.default,
      [_smalldatetime.default.id]: _smalldatetime.default,
      [_real.default.id]: _real.default,
      [_money.default.id]: _money.default,
      [_datetime.default.id]: _datetime.default,
      [_float.default.id]: _float.default,
      [_decimal.default.id]: _decimal.default,
      [_numeric.default.id]: _numeric.default,
      [_smallmoney.default.id]: _smallmoney.default,
      [_bigint.default.id]: _bigint.default,
      [_image.default.id]: _image.default,
      [_text.default.id]: _text.default,
      [_uniqueidentifier.default.id]: _uniqueidentifier.default,
      [_intn.default.id]: _intn.default,
      [_ntext.default.id]: _ntext.default,
      [_bitn.default.id]: _bitn.default,
      [_decimaln.default.id]: _decimaln.default,
      [_numericn.default.id]: _numericn.default,
      [_floatn.default.id]: _floatn.default,
      [_moneyn.default.id]: _moneyn.default,
      [_datetimen.default.id]: _datetimen.default,
      [_varbinary.default.id]: _varbinary.default,
      [_varchar.default.id]: _varchar.default,
      [_binary.default.id]: _binary.default,
      [_char.default.id]: _char.default,
      [_nvarchar.default.id]: _nvarchar.default,
      [_nchar.default.id]: _nchar.default,
      [_xml.default.id]: _xml.default,
      [_time.default.id]: _time.default,
      [_date.default.id]: _date.default,
      [_datetime2.default.id]: _datetime2.default,
      [_datetimeoffset.default.id]: _datetimeoffset.default,
      [_udt.default.id]: _udt.default,
      [_tvp.default.id]: _tvp.default,
      [_sqlVariant.default.id]: _sqlVariant.default
    };
    var TYPES = exports2.TYPES = {
      TinyInt: _tinyint.default,
      Bit: _bit.default,
      SmallInt: _smallint.default,
      Int: _int.default,
      SmallDateTime: _smalldatetime.default,
      Real: _real.default,
      Money: _money.default,
      DateTime: _datetime.default,
      Float: _float.default,
      Decimal: _decimal.default,
      Numeric: _numeric.default,
      SmallMoney: _smallmoney.default,
      BigInt: _bigint.default,
      Image: _image.default,
      Text: _text.default,
      UniqueIdentifier: _uniqueidentifier.default,
      NText: _ntext.default,
      VarBinary: _varbinary.default,
      VarChar: _varchar.default,
      Binary: _binary.default,
      Char: _char.default,
      NVarChar: _nvarchar.default,
      NChar: _nchar.default,
      Xml: _xml.default,
      Time: _time.default,
      Date: _date.default,
      DateTime2: _datetime2.default,
      DateTimeOffset: _datetimeoffset.default,
      UDT: _udt.default,
      TVP: _tvp.default,
      Variant: _sqlVariant.default
    };
    var typeByName = exports2.typeByName = TYPES;
  }
});

// node_modules/tedious/lib/token/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/tedious/lib/token/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Result = exports2.NotEnoughDataError = void 0;
    exports2.readBVarByte = readBVarByte;
    exports2.readBVarChar = readBVarChar;
    exports2.readBigInt64LE = readBigInt64LE;
    exports2.readBigUInt64LE = readBigUInt64LE;
    exports2.readDoubleLE = readDoubleLE;
    exports2.readFloatLE = readFloatLE;
    exports2.readInt16LE = readInt16LE;
    exports2.readInt32LE = readInt32LE;
    exports2.readUInt16LE = readUInt16LE;
    exports2.readUInt24LE = readUInt24LE;
    exports2.readUInt32BE = readUInt32BE;
    exports2.readUInt32LE = readUInt32LE;
    exports2.readUInt40LE = readUInt40LE;
    exports2.readUInt8 = readUInt8;
    exports2.readUNumeric128LE = readUNumeric128LE;
    exports2.readUNumeric64LE = readUNumeric64LE;
    exports2.readUNumeric96LE = readUNumeric96LE;
    exports2.readUsVarByte = readUsVarByte;
    exports2.readUsVarChar = readUsVarChar;
    var Result = class {
      constructor(value, offset) {
        this.value = value;
        this.offset = offset;
      }
    };
    exports2.Result = Result;
    var NotEnoughDataError = class extends Error {
      constructor(byteCount) {
        super();
        __publicField(this, "byteCount");
        this.byteCount = byteCount;
      }
    };
    exports2.NotEnoughDataError = NotEnoughDataError;
    function readUInt8(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 1) {
        throw new NotEnoughDataError(offset + 1);
      }
      return new Result(buf.readUInt8(offset), offset + 1);
    }
    function readUInt16LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 2) {
        throw new NotEnoughDataError(offset + 2);
      }
      return new Result(buf.readUInt16LE(offset), offset + 2);
    }
    function readInt16LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 2) {
        throw new NotEnoughDataError(offset + 2);
      }
      return new Result(buf.readInt16LE(offset), offset + 2);
    }
    function readUInt24LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 3) {
        throw new NotEnoughDataError(offset + 3);
      }
      return new Result(buf.readUIntLE(offset, 3), offset + 3);
    }
    function readUInt32LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readUInt32LE(offset), offset + 4);
    }
    function readUInt32BE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readUInt32BE(offset), offset + 4);
    }
    function readUInt40LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 5) {
        throw new NotEnoughDataError(offset + 5);
      }
      return new Result(buf.readUIntLE(offset, 5), offset + 5);
    }
    function readInt32LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readInt32LE(offset), offset + 4);
    }
    function readBigUInt64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readBigUInt64LE(offset), offset + 8);
    }
    function readBigInt64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readBigInt64LE(offset), offset + 8);
    }
    function readFloatLE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readFloatLE(offset), offset + 4);
    }
    function readDoubleLE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readDoubleLE(offset), offset + 8);
    }
    function readBVarChar(buf, offset) {
      offset = +offset;
      let charCount;
      ({
        offset,
        value: charCount
      } = readUInt8(buf, offset));
      const byteLength = charCount * 2;
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.toString("ucs2", offset, offset + byteLength), offset + byteLength);
    }
    function readBVarByte(buf, offset) {
      offset = +offset;
      let byteLength;
      ({
        offset,
        value: byteLength
      } = readUInt8(buf, offset));
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
    }
    function readUsVarChar(buf, offset) {
      offset = +offset;
      let charCount;
      ({
        offset,
        value: charCount
      } = readUInt16LE(buf, offset));
      const byteLength = charCount * 2;
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.toString("ucs2", offset, offset + byteLength), offset + byteLength);
    }
    function readUsVarByte(buf, offset) {
      offset = +offset;
      let byteLength;
      ({
        offset,
        value: byteLength
      } = readUInt16LE(buf, offset));
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
    }
    function readUNumeric64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      const low = buf.readUInt32LE(offset);
      const high = buf.readUInt32LE(offset + 4);
      return new Result(4294967296 * high + low, offset + 8);
    }
    function readUNumeric96LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 12) {
        throw new NotEnoughDataError(offset + 12);
      }
      const dword1 = buf.readUInt32LE(offset);
      const dword2 = buf.readUInt32LE(offset + 4);
      const dword3 = buf.readUInt32LE(offset + 8);
      return new Result(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3, offset + 12);
    }
    function readUNumeric128LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 16) {
        throw new NotEnoughDataError(offset + 16);
      }
      const dword1 = buf.readUInt32LE(offset);
      const dword2 = buf.readUInt32LE(offset + 4);
      const dword3 = buf.readUInt32LE(offset + 8);
      const dword4 = buf.readUInt32LE(offset + 12);
      return new Result(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3 + 4294967296 * 4294967296 * 4294967296 * dword4, offset + 16);
    }
  }
});

// node_modules/tedious/lib/metadata-parser.js
var require_metadata_parser = __commonJS({
  "node_modules/tedious/lib/metadata-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.readCollation = readCollation;
    exports2.readMetadata = readMetadata;
    var _collation = require_collation();
    var _dataType = require_data_type();
    var _sprintfJs = require_sprintf();
    var _helpers = require_helpers2();
    function readCollation(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 5) {
        throw new _helpers.NotEnoughDataError(offset + 5);
      }
      const collation = _collation.Collation.fromBuffer(buf.slice(offset, offset + 5));
      return new _helpers.Result(collation, offset + 5);
    }
    function readSchema(buf, offset) {
      offset = +offset;
      let schemaPresent;
      ({
        offset,
        value: schemaPresent
      } = (0, _helpers.readUInt8)(buf, offset));
      if (schemaPresent !== 1) {
        return new _helpers.Result(void 0, offset);
      }
      let dbname;
      ({
        offset,
        value: dbname
      } = (0, _helpers.readBVarChar)(buf, offset));
      let owningSchema;
      ({
        offset,
        value: owningSchema
      } = (0, _helpers.readBVarChar)(buf, offset));
      let xmlSchemaCollection;
      ({
        offset,
        value: xmlSchemaCollection
      } = (0, _helpers.readUsVarChar)(buf, offset));
      return new _helpers.Result({
        dbname,
        owningSchema,
        xmlSchemaCollection
      }, offset);
    }
    function readUDTInfo(buf, offset) {
      let maxByteSize;
      ({
        offset,
        value: maxByteSize
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let dbname;
      ({
        offset,
        value: dbname
      } = (0, _helpers.readBVarChar)(buf, offset));
      let owningSchema;
      ({
        offset,
        value: owningSchema
      } = (0, _helpers.readBVarChar)(buf, offset));
      let typeName;
      ({
        offset,
        value: typeName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let assemblyName;
      ({
        offset,
        value: assemblyName
      } = (0, _helpers.readUsVarChar)(buf, offset));
      return new _helpers.Result({
        maxByteSize,
        dbname,
        owningSchema,
        typeName,
        assemblyName
      }, offset);
    }
    function readMetadata(buf, offset, options) {
      let userType;
      ({
        offset,
        value: userType
      } = (options.tdsVersion < "7_2" ? _helpers.readUInt16LE : _helpers.readUInt32LE)(buf, offset));
      let flags;
      ({
        offset,
        value: flags
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let typeNumber;
      ({
        offset,
        value: typeNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const type2 = _dataType.TYPE[typeNumber];
      if (!type2) {
        throw new Error((0, _sprintfJs.sprintf)("Unrecognised data type 0x%02X", typeNumber));
      }
      switch (type2.name) {
        case "Null":
        case "TinyInt":
        case "SmallInt":
        case "Int":
        case "BigInt":
        case "Real":
        case "Float":
        case "SmallMoney":
        case "Money":
        case "Bit":
        case "SmallDateTime":
        case "DateTime":
        case "Date":
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        case "IntN":
        case "FloatN":
        case "MoneyN":
        case "BitN":
        case "UniqueIdentifier":
        case "DateTimeN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Variant": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "VarChar":
        case "Char":
        case "NVarChar":
        case "NChar": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          let collation;
          ({
            offset,
            value: collation
          } = readCollation(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Text":
        case "NText": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          let collation;
          ({
            offset,
            value: collation
          } = readCollation(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "VarBinary":
        case "Binary": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Image": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Xml": {
          let schema;
          ({
            offset,
            value: schema
          } = readSchema(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema,
            udtInfo: void 0
          }, offset);
        }
        case "Time":
        case "DateTime2":
        case "DateTimeOffset": {
          let scale;
          ({
            offset,
            value: scale
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision: void 0,
            scale,
            dataLength: void 0,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "NumericN":
        case "DecimalN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          let precision;
          ({
            offset,
            value: precision
          } = (0, _helpers.readUInt8)(buf, offset));
          let scale;
          ({
            offset,
            value: scale
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision,
            scale,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "UDT": {
          let udtInfo;
          ({
            offset,
            value: udtInfo
          } = readUDTInfo(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type: type2,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema: void 0,
            udtInfo
          }, offset);
        }
        default:
          throw new Error((0, _sprintfJs.sprintf)("Unrecognised type %s", type2.name));
      }
    }
    function metadataParse(parser, options, callback) {
      (async () => {
        while (true) {
          let result;
          try {
            result = readMetadata(parser.buffer, parser.position, options);
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = result.offset;
          return callback(result.value);
        }
      })();
    }
    var _default = exports2.default = metadataParse;
    module2.exports = metadataParse;
    module2.exports.readCollation = readCollation;
    module2.exports.readMetadata = readMetadata;
  }
});

// node_modules/tedious/lib/token/colmetadata-token-parser.js
var require_colmetadata_token_parser = __commonJS({
  "node_modules/tedious/lib/token/colmetadata-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _metadataParser = require_metadata_parser();
    var _token = require_token();
    var _helpers = require_helpers2();
    function readTableName(buf, offset, metadata, options) {
      if (!metadata.type.hasTableName) {
        return new _helpers.Result(void 0, offset);
      }
      if (options.tdsVersion < "7_2") {
        return (0, _helpers.readUsVarChar)(buf, offset);
      }
      let numberOfTableNameParts;
      ({
        offset,
        value: numberOfTableNameParts
      } = (0, _helpers.readUInt8)(buf, offset));
      const tableName = [];
      for (let i = 0; i < numberOfTableNameParts; i++) {
        let tableNamePart;
        ({
          offset,
          value: tableNamePart
        } = (0, _helpers.readUsVarChar)(buf, offset));
        tableName.push(tableNamePart);
      }
      return new _helpers.Result(tableName, offset);
    }
    function readColumnName(buf, offset, index, metadata, options) {
      let colName;
      ({
        offset,
        value: colName
      } = (0, _helpers.readBVarChar)(buf, offset));
      if (options.columnNameReplacer) {
        return new _helpers.Result(options.columnNameReplacer(colName, index, metadata), offset);
      } else if (options.camelCaseColumns) {
        return new _helpers.Result(colName.replace(/^[A-Z]/, function(s) {
          return s.toLowerCase();
        }), offset);
      } else {
        return new _helpers.Result(colName, offset);
      }
    }
    function readColumn(buf, offset, options, index) {
      let metadata;
      ({
        offset,
        value: metadata
      } = (0, _metadataParser.readMetadata)(buf, offset, options));
      let tableName;
      ({
        offset,
        value: tableName
      } = readTableName(buf, offset, metadata, options));
      let colName;
      ({
        offset,
        value: colName
      } = readColumnName(buf, offset, index, metadata, options));
      return new _helpers.Result({
        userType: metadata.userType,
        flags: metadata.flags,
        type: metadata.type,
        collation: metadata.collation,
        precision: metadata.precision,
        scale: metadata.scale,
        udtInfo: metadata.udtInfo,
        dataLength: metadata.dataLength,
        schema: metadata.schema,
        colName,
        tableName
      }, offset);
    }
    async function colMetadataParser(parser) {
      let columnCount;
      while (true) {
        let offset;
        try {
          ({
            offset,
            value: columnCount
          } = (0, _helpers.readUInt16LE)(parser.buffer, parser.position));
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            await parser.waitForChunk();
            continue;
          }
          throw err;
        }
        parser.position = offset;
        break;
      }
      const columns = [];
      for (let i = 0; i < columnCount; i++) {
        while (true) {
          let column2;
          let offset;
          try {
            ({
              offset,
              value: column2
            } = readColumn(parser.buffer, parser.position, parser.options, i));
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = offset;
          columns.push(column2);
          break;
        }
      }
      return new _token.ColMetadataToken(columns);
    }
    var _default = exports2.default = colMetadataParser;
    module2.exports = colMetadataParser;
  }
});

// node_modules/tedious/lib/token/done-token-parser.js
var require_done_token_parser = __commonJS({
  "node_modules/tedious/lib/token/done-token-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.doneInProcParser = doneInProcParser;
    exports2.doneParser = doneParser;
    exports2.doneProcParser = doneProcParser;
    var _token = require_token();
    var _helpers = require_helpers2();
    var STATUS = {
      MORE: 1,
      ERROR: 2,
      // This bit is not yet in use by SQL Server, so is not exposed in the returned token
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    function readToken(buf, offset, options) {
      let status;
      ({
        offset,
        value: status
      } = (0, _helpers.readUInt16LE)(buf, offset));
      const more = !!(status & STATUS.MORE);
      const sqlError = !!(status & STATUS.ERROR);
      const rowCountValid = !!(status & STATUS.COUNT);
      const attention = !!(status & STATUS.ATTN);
      const serverError = !!(status & STATUS.SRVERROR);
      let curCmd;
      ({
        offset,
        value: curCmd
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let rowCount;
      ({
        offset,
        value: rowCount
      } = (options.tdsVersion < "7_2" ? _helpers.readUInt32LE : _helpers.readBigUInt64LE)(buf, offset));
      return new _helpers.Result({
        more,
        sqlError,
        attention,
        serverError,
        rowCount: rowCountValid ? Number(rowCount) : void 0,
        curCmd
      }, offset);
    }
    function doneParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneToken(value), offset);
    }
    function doneInProcParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneInProcToken(value), offset);
    }
    function doneProcParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneProcToken(value), offset);
    }
  }
});

// node_modules/tedious/lib/token/env-change-token-parser.js
var require_env_change_token_parser = __commonJS({
  "node_modules/tedious/lib/token/env-change-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _collation = require_collation();
    var _token = require_token();
    var _helpers = require_helpers2();
    var types = {
      1: {
        name: "DATABASE",
        event: "databaseChange"
      },
      2: {
        name: "LANGUAGE",
        event: "languageChange"
      },
      3: {
        name: "CHARSET",
        event: "charsetChange"
      },
      4: {
        name: "PACKET_SIZE",
        event: "packetSizeChange"
      },
      7: {
        name: "SQL_COLLATION",
        event: "sqlCollationChange"
      },
      8: {
        name: "BEGIN_TXN",
        event: "beginTransaction"
      },
      9: {
        name: "COMMIT_TXN",
        event: "commitTransaction"
      },
      10: {
        name: "ROLLBACK_TXN",
        event: "rollbackTransaction"
      },
      13: {
        name: "DATABASE_MIRRORING_PARTNER",
        event: "partnerNode"
      },
      17: {
        name: "TXN_ENDED"
      },
      18: {
        name: "RESET_CONNECTION",
        event: "resetConnection"
      },
      20: {
        name: "ROUTING_CHANGE",
        event: "routingChange"
      }
    };
    function _readNewAndOldValue(buf, offset, length, type2) {
      switch (type2.name) {
        case "DATABASE":
        case "LANGUAGE":
        case "CHARSET":
        case "PACKET_SIZE":
        case "DATABASE_MIRRORING_PARTNER": {
          let newValue;
          ({
            offset,
            value: newValue
          } = (0, _helpers.readBVarChar)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readBVarChar)(buf, offset));
          switch (type2.name) {
            case "PACKET_SIZE":
              return new _helpers.Result(new _token.PacketSizeEnvChangeToken(parseInt(newValue), parseInt(oldValue)), offset);
            case "DATABASE":
              return new _helpers.Result(new _token.DatabaseEnvChangeToken(newValue, oldValue), offset);
            case "LANGUAGE":
              return new _helpers.Result(new _token.LanguageEnvChangeToken(newValue, oldValue), offset);
            case "CHARSET":
              return new _helpers.Result(new _token.CharsetEnvChangeToken(newValue, oldValue), offset);
            case "DATABASE_MIRRORING_PARTNER":
              return new _helpers.Result(new _token.DatabaseMirroringPartnerEnvChangeToken(newValue, oldValue), offset);
          }
          throw new Error("unreachable");
        }
        case "SQL_COLLATION":
        case "BEGIN_TXN":
        case "COMMIT_TXN":
        case "ROLLBACK_TXN":
        case "RESET_CONNECTION": {
          let newValue;
          ({
            offset,
            value: newValue
          } = (0, _helpers.readBVarByte)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readBVarByte)(buf, offset));
          switch (type2.name) {
            case "SQL_COLLATION": {
              const newCollation = newValue.length ? _collation.Collation.fromBuffer(newValue) : void 0;
              const oldCollation = oldValue.length ? _collation.Collation.fromBuffer(oldValue) : void 0;
              return new _helpers.Result(new _token.CollationChangeToken(newCollation, oldCollation), offset);
            }
            case "BEGIN_TXN":
              return new _helpers.Result(new _token.BeginTransactionEnvChangeToken(newValue, oldValue), offset);
            case "COMMIT_TXN":
              return new _helpers.Result(new _token.CommitTransactionEnvChangeToken(newValue, oldValue), offset);
            case "ROLLBACK_TXN":
              return new _helpers.Result(new _token.RollbackTransactionEnvChangeToken(newValue, oldValue), offset);
            case "RESET_CONNECTION":
              return new _helpers.Result(new _token.ResetConnectionEnvChangeToken(newValue, oldValue), offset);
          }
          throw new Error("unreachable");
        }
        case "ROUTING_CHANGE": {
          let routePacket;
          ({
            offset,
            value: routePacket
          } = (0, _helpers.readUsVarByte)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readUsVarByte)(buf, offset));
          const protocol = routePacket.readUInt8(0);
          if (protocol !== 0) {
            throw new Error("Unknown protocol byte in routing change event");
          }
          const port = routePacket.readUInt16LE(1);
          const serverLen = routePacket.readUInt16LE(3);
          const server = routePacket.toString("ucs2", 5, 5 + serverLen * 2);
          const newValue = {
            protocol,
            port,
            server
          };
          return new _helpers.Result(new _token.RoutingEnvChangeToken(newValue, oldValue), offset);
        }
        default: {
          console.error("Tedious > Unsupported ENVCHANGE type " + type2.name);
          return new _helpers.Result(void 0, offset + length - 1);
        }
      }
    }
    function envChangeParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      let typeNumber;
      ({
        offset,
        value: typeNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const type2 = types[typeNumber];
      if (!type2) {
        console.error("Tedious > Unsupported ENVCHANGE type " + typeNumber);
        return new _helpers.Result(void 0, offset + tokenLength - 1);
      }
      return _readNewAndOldValue(buf, offset, tokenLength, type2);
    }
    var _default = exports2.default = envChangeParser;
    module2.exports = envChangeParser;
  }
});

// node_modules/tedious/lib/token/infoerror-token-parser.js
var require_infoerror_token_parser = __commonJS({
  "node_modules/tedious/lib/token/infoerror-token-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.errorParser = errorParser;
    exports2.infoParser = infoParser;
    var _helpers = require_helpers2();
    var _token = require_token();
    function readToken(buf, offset, options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < tokenLength + offset) {
        throw new _helpers.NotEnoughDataError(tokenLength + offset);
      }
      let number;
      ({
        offset,
        value: number
      } = (0, _helpers.readUInt32LE)(buf, offset));
      let state3;
      ({
        offset,
        value: state3
      } = (0, _helpers.readUInt8)(buf, offset));
      let clazz;
      ({
        offset,
        value: clazz
      } = (0, _helpers.readUInt8)(buf, offset));
      let message;
      ({
        offset,
        value: message
      } = (0, _helpers.readUsVarChar)(buf, offset));
      let serverName;
      ({
        offset,
        value: serverName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let procName;
      ({
        offset,
        value: procName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let lineNumber;
      ({
        offset,
        value: lineNumber
      } = options.tdsVersion < "7_2" ? (0, _helpers.readUInt16LE)(buf, offset) : (0, _helpers.readUInt32LE)(buf, offset));
      return new _helpers.Result({
        "number": number,
        "state": state3,
        "class": clazz,
        "message": message,
        "serverName": serverName,
        "procName": procName,
        "lineNumber": lineNumber
      }, offset);
    }
    function infoParser(buf, offset, options) {
      let data;
      ({
        offset,
        value: data
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.InfoMessageToken(data), offset);
    }
    function errorParser(buf, offset, options) {
      let data;
      ({
        offset,
        value: data
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.ErrorMessageToken(data), offset);
    }
  }
});

// node_modules/tedious/lib/token/fedauth-info-parser.js
var require_fedauth_info_parser = __commonJS({
  "node_modules/tedious/lib/token/fedauth-info-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _helpers = require_helpers2();
    var _token = require_token();
    var FEDAUTHINFOID = {
      STSURL: 1,
      SPN: 2
    };
    function readFedAuthInfo(data) {
      let offset = 0;
      let spn, stsurl;
      const countOfInfoIDs = data.readUInt32LE(offset);
      offset += 4;
      for (let i = 0; i < countOfInfoIDs; i++) {
        const fedauthInfoID = data.readUInt8(offset);
        offset += 1;
        const fedAuthInfoDataLen = data.readUInt32LE(offset);
        offset += 4;
        const fedAuthInfoDataOffset = data.readUInt32LE(offset);
        offset += 4;
        switch (fedauthInfoID) {
          case FEDAUTHINFOID.SPN:
            spn = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
            break;
          case FEDAUTHINFOID.STSURL:
            stsurl = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
            break;
          default:
            break;
        }
      }
      return {
        spn,
        stsurl
      };
    }
    function fedAuthInfoParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt32LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const data = buf.slice(offset, offset + tokenLength);
      offset += tokenLength;
      const {
        spn,
        stsurl
      } = readFedAuthInfo(data);
      return new _helpers.Result(new _token.FedAuthInfoToken(spn, stsurl), offset);
    }
    var _default = exports2.default = fedAuthInfoParser;
    module2.exports = fedAuthInfoParser;
  }
});

// node_modules/tedious/lib/token/feature-ext-ack-parser.js
var require_feature_ext_ack_parser = __commonJS({
  "node_modules/tedious/lib/token/feature-ext-ack-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _helpers = require_helpers2();
    var _token = require_token();
    var FEATURE_ID = {
      SESSIONRECOVERY: 1,
      FEDAUTH: 2,
      COLUMNENCRYPTION: 4,
      GLOBALTRANSACTIONS: 5,
      AZURESQLSUPPORT: 8,
      UTF8_SUPPORT: 10,
      TERMINATOR: 255
    };
    function featureExtAckParser(buf, offset, _options) {
      let fedAuth;
      let utf8Support;
      while (true) {
        let featureId;
        ({
          value: featureId,
          offset
        } = (0, _helpers.readUInt8)(buf, offset));
        if (featureId === FEATURE_ID.TERMINATOR) {
          return new _helpers.Result(new _token.FeatureExtAckToken(fedAuth, utf8Support), offset);
        }
        let featureAckDataLen;
        ({
          value: featureAckDataLen,
          offset
        } = (0, _helpers.readUInt32LE)(buf, offset));
        if (buf.length < offset + featureAckDataLen) {
          throw new _helpers.NotEnoughDataError(offset + featureAckDataLen);
        }
        const featureData = buf.slice(offset, offset + featureAckDataLen);
        offset += featureAckDataLen;
        switch (featureId) {
          case FEATURE_ID.FEDAUTH:
            fedAuth = featureData;
            break;
          case FEATURE_ID.UTF8_SUPPORT:
            utf8Support = !!featureData[0];
            break;
        }
      }
    }
    var _default = exports2.default = featureExtAckParser;
    module2.exports = featureExtAckParser;
  }
});

// node_modules/tedious/lib/token/loginack-token-parser.js
var require_loginack_token_parser = __commonJS({
  "node_modules/tedious/lib/token/loginack-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var _tdsVersions = require_tds_versions();
    var _helpers = require_helpers2();
    var interfaceTypes = {
      0: "SQL_DFLT",
      1: "SQL_TSQL"
    };
    function loginAckParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < tokenLength + offset) {
        throw new _helpers.NotEnoughDataError(tokenLength + offset);
      }
      let interfaceNumber;
      ({
        offset,
        value: interfaceNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const interfaceType = interfaceTypes[interfaceNumber];
      let tdsVersionNumber;
      ({
        offset,
        value: tdsVersionNumber
      } = (0, _helpers.readUInt32BE)(buf, offset));
      const tdsVersion = _tdsVersions.versionsByValue[tdsVersionNumber];
      let progName;
      ({
        offset,
        value: progName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let major;
      ({
        offset,
        value: major
      } = (0, _helpers.readUInt8)(buf, offset));
      let minor;
      ({
        offset,
        value: minor
      } = (0, _helpers.readUInt8)(buf, offset));
      let buildNumHi;
      ({
        offset,
        value: buildNumHi
      } = (0, _helpers.readUInt8)(buf, offset));
      let buildNumLow;
      ({
        offset,
        value: buildNumLow
      } = (0, _helpers.readUInt8)(buf, offset));
      return new _helpers.Result(new _token.LoginAckToken({
        interface: interfaceType,
        tdsVersion,
        progName,
        progVersion: {
          major,
          minor,
          buildNumHi,
          buildNumLow
        }
      }), offset);
    }
    var _default = exports2.default = loginAckParser;
    module2.exports = loginAckParser;
  }
});

// node_modules/tedious/lib/token/order-token-parser.js
var require_order_token_parser = __commonJS({
  "node_modules/tedious/lib/token/order-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var _helpers = require_helpers2();
    function orderParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const orderColumns = [];
      for (let i = 0; i < tokenLength; i += 2) {
        let column2;
        ({
          offset,
          value: column2
        } = (0, _helpers.readUInt16LE)(buf, offset));
        orderColumns.push(column2);
      }
      return new _helpers.Result(new _token.OrderToken(orderColumns), offset);
    }
    var _default = exports2.default = orderParser;
    module2.exports = orderParser;
  }
});

// node_modules/tedious/lib/token/returnstatus-token-parser.js
var require_returnstatus_token_parser = __commonJS({
  "node_modules/tedious/lib/token/returnstatus-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _helpers = require_helpers2();
    var _token = require_token();
    function returnStatusParser(buf, offset, _options) {
      let value;
      ({
        value,
        offset
      } = (0, _helpers.readInt32LE)(buf, offset));
      return new _helpers.Result(new _token.ReturnStatusToken(value), offset);
    }
    var _default = exports2.default = returnStatusParser;
    module2.exports = returnStatusParser;
  }
});

// node_modules/tedious/lib/value-parser.js
var require_value_parser = __commonJS({
  "node_modules/tedious/lib/value-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isPLPStream = isPLPStream;
    exports2.readPLPStream = readPLPStream;
    exports2.readValue = readValue;
    var _metadataParser = require_metadata_parser();
    var _dataType = require_data_type();
    var _iconvLite = _interopRequireDefault(require_lib2());
    var _sprintfJs = require_sprintf();
    var _guidParser = require_guid_parser();
    var _helpers = require_helpers2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL = (1 << 16) - 1;
    var MAX = (1 << 16) - 1;
    var THREE_AND_A_THIRD = 3 + 1 / 3;
    var MONEY_DIVISOR = 1e4;
    var PLP_NULL = 0xFFFFFFFFFFFFFFFFn;
    var UNKNOWN_PLP_LEN = 0xFFFFFFFFFFFFFFFEn;
    var DEFAULT_ENCODING = "utf8";
    function readTinyInt(buf, offset) {
      return (0, _helpers.readUInt8)(buf, offset);
    }
    function readSmallInt(buf, offset) {
      return (0, _helpers.readInt16LE)(buf, offset);
    }
    function readInt(buf, offset) {
      return (0, _helpers.readInt32LE)(buf, offset);
    }
    function readBigInt(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readBigInt64LE)(buf, offset));
      return new _helpers.Result(value.toString(), offset);
    }
    function readReal(buf, offset) {
      return (0, _helpers.readFloatLE)(buf, offset);
    }
    function readFloat(buf, offset) {
      return (0, _helpers.readDoubleLE)(buf, offset);
    }
    function readSmallMoney(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readInt32LE)(buf, offset));
      return new _helpers.Result(value / MONEY_DIVISOR, offset);
    }
    function readMoney(buf, offset) {
      let high;
      ({
        offset,
        value: high
      } = (0, _helpers.readInt32LE)(buf, offset));
      let low;
      ({
        offset,
        value: low
      } = (0, _helpers.readUInt32LE)(buf, offset));
      return new _helpers.Result((low + 4294967296 * high) / MONEY_DIVISOR, offset);
    }
    function readBit(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readUInt8)(buf, offset));
      return new _helpers.Result(!!value, offset);
    }
    function readValue(buf, offset, metadata, options) {
      const type2 = metadata.type;
      switch (type2.name) {
        case "Null":
          return new _helpers.Result(null, offset);
        case "TinyInt": {
          return readTinyInt(buf, offset);
        }
        case "SmallInt": {
          return readSmallInt(buf, offset);
        }
        case "Int": {
          return readInt(buf, offset);
        }
        case "BigInt": {
          return readBigInt(buf, offset);
        }
        case "IntN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 1:
              return readTinyInt(buf, offset);
            case 2:
              return readSmallInt(buf, offset);
            case 4:
              return readInt(buf, offset);
            case 8:
              return readBigInt(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for IntN");
          }
        }
        case "Real": {
          return readReal(buf, offset);
        }
        case "Float": {
          return readFloat(buf, offset);
        }
        case "FloatN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readReal(buf, offset);
            case 8:
              return readFloat(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for FloatN");
          }
        }
        case "SmallMoney": {
          return readSmallMoney(buf, offset);
        }
        case "Money":
          return readMoney(buf, offset);
        case "MoneyN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readSmallMoney(buf, offset);
            case 8:
              return readMoney(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for MoneyN");
          }
        }
        case "Bit": {
          return readBit(buf, offset);
        }
        case "BitN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 1:
              return readBit(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for BitN");
          }
        }
        case "VarChar":
        case "Char": {
          const codepage = metadata.collation.codepage;
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readChars(buf, offset, dataLength, codepage);
        }
        case "NVarChar":
        case "NChar": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readNChars(buf, offset, dataLength);
        }
        case "VarBinary":
        case "Binary": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readBinary(buf, offset, dataLength);
        }
        case "Text": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readChars(buf, offset, dataLength, metadata.collation.codepage);
        }
        case "NText": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readNChars(buf, offset, dataLength);
        }
        case "Image": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readBinary(buf, offset, dataLength);
        }
        case "SmallDateTime": {
          return readSmallDateTime(buf, offset, options.useUTC);
        }
        case "DateTime": {
          return readDateTime(buf, offset, options.useUTC);
        }
        case "DateTimeN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readSmallDateTime(buf, offset, options.useUTC);
            case 8:
              return readDateTime(buf, offset, options.useUTC);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for DateTimeN");
          }
        }
        case "Time": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readTime(buf, offset, dataLength, metadata.scale, options.useUTC);
        }
        case "Date": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDate(buf, offset, options.useUTC);
        }
        case "DateTime2": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDateTime2(buf, offset, dataLength, metadata.scale, options.useUTC);
        }
        case "DateTimeOffset": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDateTimeOffset(buf, offset, dataLength, metadata.scale);
        }
        case "NumericN":
        case "DecimalN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readNumeric(buf, offset, dataLength, metadata.precision, metadata.scale);
        }
        case "UniqueIdentifier": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 16:
              return readUniqueIdentifier(buf, offset, options);
            default:
              throw new Error((0, _sprintfJs.sprintf)("Unsupported guid size %d", dataLength - 1));
          }
        }
        case "Variant": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readVariant(buf, offset, options, dataLength);
        }
        default: {
          throw new Error("Invalid type!");
        }
      }
    }
    function isPLPStream(metadata) {
      switch (metadata.type.name) {
        case "VarChar":
        case "NVarChar":
        case "VarBinary": {
          return metadata.dataLength === MAX;
        }
        case "Xml": {
          return true;
        }
        case "UDT": {
          return true;
        }
      }
    }
    function readUniqueIdentifier(buf, offset, options) {
      let data;
      ({
        value: data,
        offset
      } = readBinary(buf, offset, 16));
      return new _helpers.Result(options.lowerCaseGuids ? (0, _guidParser.bufferToLowerCaseGuid)(data) : (0, _guidParser.bufferToUpperCaseGuid)(data), offset);
    }
    function readNumeric(buf, offset, dataLength, _precision, scale) {
      let sign;
      ({
        offset,
        value: sign
      } = (0, _helpers.readUInt8)(buf, offset));
      sign = sign === 1 ? 1 : -1;
      let value;
      if (dataLength === 5) {
        ({
          offset,
          value
        } = (0, _helpers.readUInt32LE)(buf, offset));
      } else if (dataLength === 9) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric64LE)(buf, offset));
      } else if (dataLength === 13) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric96LE)(buf, offset));
      } else if (dataLength === 17) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric128LE)(buf, offset));
      } else {
        throw new Error((0, _sprintfJs.sprintf)("Unsupported numeric dataLength %d", dataLength));
      }
      return new _helpers.Result(value * sign / Math.pow(10, scale), offset);
    }
    function readVariant(buf, offset, options, dataLength) {
      let baseType;
      ({
        value: baseType,
        offset
      } = (0, _helpers.readUInt8)(buf, offset));
      const type2 = _dataType.TYPE[baseType];
      let propBytes;
      ({
        value: propBytes,
        offset
      } = (0, _helpers.readUInt8)(buf, offset));
      dataLength = dataLength - propBytes - 2;
      switch (type2.name) {
        case "UniqueIdentifier":
          return readUniqueIdentifier(buf, offset, options);
        case "Bit":
          return readBit(buf, offset);
        case "TinyInt":
          return readTinyInt(buf, offset);
        case "SmallInt":
          return readSmallInt(buf, offset);
        case "Int":
          return readInt(buf, offset);
        case "BigInt":
          return readBigInt(buf, offset);
        case "SmallDateTime":
          return readSmallDateTime(buf, offset, options.useUTC);
        case "DateTime":
          return readDateTime(buf, offset, options.useUTC);
        case "Real":
          return readReal(buf, offset);
        case "Float":
          return readFloat(buf, offset);
        case "SmallMoney":
          return readSmallMoney(buf, offset);
        case "Money":
          return readMoney(buf, offset);
        case "Date":
          return readDate(buf, offset, options.useUTC);
        case "Time": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readTime(buf, offset, dataLength, scale, options.useUTC);
        }
        case "DateTime2": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readDateTime2(buf, offset, dataLength, scale, options.useUTC);
        }
        case "DateTimeOffset": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readDateTimeOffset(buf, offset, dataLength, scale);
        }
        case "VarBinary":
        case "Binary": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          return readBinary(buf, offset, dataLength);
        }
        case "NumericN":
        case "DecimalN": {
          let precision;
          ({
            value: precision,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readNumeric(buf, offset, dataLength, precision, scale);
        }
        case "VarChar":
        case "Char": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          let collation;
          ({
            value: collation,
            offset
          } = (0, _metadataParser.readCollation)(buf, offset));
          return readChars(buf, offset, dataLength, collation.codepage);
        }
        case "NVarChar":
        case "NChar": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          ({
            offset
          } = (0, _metadataParser.readCollation)(buf, offset));
          return readNChars(buf, offset, dataLength);
        }
        default:
          throw new Error("Invalid type!");
      }
    }
    function readBinary(buf, offset, dataLength) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(buf.slice(offset, offset + dataLength), offset + dataLength);
    }
    function readChars(buf, offset, dataLength, codepage) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(_iconvLite.default.decode(buf.slice(offset, offset + dataLength), codepage ?? DEFAULT_ENCODING), offset + dataLength);
    }
    function readNChars(buf, offset, dataLength) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(buf.toString("ucs2", offset, offset + dataLength), offset + dataLength);
    }
    async function readPLPStream(parser) {
      while (parser.buffer.length < parser.position + 8) {
        await parser.waitForChunk();
      }
      const expectedLength = parser.buffer.readBigUInt64LE(parser.position);
      parser.position += 8;
      if (expectedLength === PLP_NULL) {
        return null;
      }
      const chunks = [];
      let currentLength = 0;
      while (true) {
        while (parser.buffer.length < parser.position + 4) {
          await parser.waitForChunk();
        }
        const chunkLength = parser.buffer.readUInt32LE(parser.position);
        parser.position += 4;
        if (!chunkLength) {
          break;
        }
        while (parser.buffer.length < parser.position + chunkLength) {
          await parser.waitForChunk();
        }
        chunks.push(parser.buffer.slice(parser.position, parser.position + chunkLength));
        parser.position += chunkLength;
        currentLength += chunkLength;
      }
      if (expectedLength !== UNKNOWN_PLP_LEN) {
        if (currentLength !== Number(expectedLength)) {
          throw new Error("Partially Length-prefixed Bytes unmatched lengths : expected " + expectedLength + ", but got " + currentLength + " bytes");
        }
      }
      return chunks;
    }
    function readSmallDateTime(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let minutes;
      ({
        offset,
        value: minutes
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let value;
      if (useUTC) {
        value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));
      } else {
        value = new Date(1900, 0, 1 + days, 0, minutes);
      }
      return new _helpers.Result(value, offset);
    }
    function readDateTime(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readInt32LE)(buf, offset));
      let threeHundredthsOfSecond;
      ({
        offset,
        value: threeHundredthsOfSecond
      } = (0, _helpers.readInt32LE)(buf, offset));
      const milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);
      let value;
      if (useUTC) {
        value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));
      } else {
        value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);
      }
      return new _helpers.Result(value, offset);
    }
    function readTime(buf, offset, dataLength, scale, useUTC) {
      let value;
      switch (dataLength) {
        case 3: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt24LE)(buf, offset));
          break;
        }
        case 4: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt32LE)(buf, offset));
          break;
        }
        case 5: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt40LE)(buf, offset));
          break;
        }
        default: {
          throw new Error("unreachable");
        }
      }
      if (scale < 7) {
        for (let i = scale; i < 7; i++) {
          value *= 10;
        }
      }
      let date;
      if (useUTC) {
        date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 1e4));
      } else {
        date = new Date(1970, 0, 1, 0, 0, 0, value / 1e4);
      }
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: value % 1e4 / Math.pow(10, 7)
      });
      return new _helpers.Result(date, offset);
    }
    function readDate(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      if (useUTC) {
        return new _helpers.Result(new Date(Date.UTC(2e3, 0, days - 730118)), offset);
      } else {
        return new _helpers.Result(new Date(2e3, 0, days - 730118), offset);
      }
    }
    function readDateTime2(buf, offset, dataLength, scale, useUTC) {
      let time;
      ({
        offset,
        value: time
      } = readTime(buf, offset, dataLength - 3, scale, useUTC));
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      let date;
      if (useUTC) {
        date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
      } else {
        date = new Date(2e3, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
      }
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: time.nanosecondsDelta
      });
      return new _helpers.Result(date, offset);
    }
    function readDateTimeOffset(buf, offset, dataLength, scale) {
      let time;
      ({
        offset,
        value: time
      } = readTime(buf, offset, dataLength - 5, scale, true));
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      ({
        offset
      } = (0, _helpers.readUInt16LE)(buf, offset));
      const date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: time.nanosecondsDelta
      });
      return new _helpers.Result(date, offset);
    }
    module2.exports.readValue = readValue;
    module2.exports.isPLPStream = isPLPStream;
    module2.exports.readPLPStream = readPLPStream;
  }
});

// node_modules/tedious/lib/token/returnvalue-token-parser.js
var require_returnvalue_token_parser = __commonJS({
  "node_modules/tedious/lib/token/returnvalue-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var _metadataParser = require_metadata_parser();
    var _valueParser = require_value_parser();
    var _helpers = require_helpers2();
    var iconv = _interopRequireWildcard(require_lib2());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function returnParser(parser) {
      let paramName;
      let paramOrdinal;
      let metadata;
      while (true) {
        const buf = parser.buffer;
        let offset = parser.position;
        try {
          ({
            offset,
            value: paramOrdinal
          } = (0, _helpers.readUInt16LE)(buf, offset));
          ({
            offset,
            value: paramName
          } = (0, _helpers.readBVarChar)(buf, offset));
          ({
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          ({
            offset,
            value: metadata
          } = (0, _metadataParser.readMetadata)(buf, offset, parser.options));
          if (paramName.charAt(0) === "@") {
            paramName = paramName.slice(1);
          }
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            await parser.waitForChunk();
            continue;
          }
          throw err;
        }
        parser.position = offset;
        break;
      }
      let value;
      while (true) {
        const buf = parser.buffer;
        let offset = parser.position;
        if ((0, _valueParser.isPLPStream)(metadata)) {
          const chunks = await (0, _valueParser.readPLPStream)(parser);
          if (chunks === null) {
            value = chunks;
          } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
            value = Buffer.concat(chunks).toString("ucs2");
          } else if (metadata.type.name === "VarChar") {
            value = iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? "utf8");
          } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
            value = Buffer.concat(chunks);
          }
        } else {
          try {
            ({
              value,
              offset
            } = (0, _valueParser.readValue)(buf, offset, metadata, parser.options));
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = offset;
        }
        break;
      }
      return new _token.ReturnValueToken({
        paramOrdinal,
        paramName,
        metadata,
        value
      });
    }
    var _default = exports2.default = returnParser;
    module2.exports = returnParser;
  }
});

// node_modules/tedious/lib/token/row-token-parser.js
var require_row_token_parser = __commonJS({
  "node_modules/tedious/lib/token/row-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var iconv = _interopRequireWildcard(require_lib2());
    var _valueParser = require_value_parser();
    var _helpers = require_helpers2();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function rowParser(parser) {
      const columns = [];
      for (const metadata of parser.colMetadata) {
        while (true) {
          if ((0, _valueParser.isPLPStream)(metadata)) {
            const chunks = await (0, _valueParser.readPLPStream)(parser);
            if (chunks === null) {
              columns.push({
                value: chunks,
                metadata
              });
            } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
              columns.push({
                value: Buffer.concat(chunks).toString("ucs2"),
                metadata
              });
            } else if (metadata.type.name === "VarChar") {
              columns.push({
                value: iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? "utf8"),
                metadata
              });
            } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
              columns.push({
                value: Buffer.concat(chunks),
                metadata
              });
            }
          } else {
            let result;
            try {
              result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
            } catch (err) {
              if (err instanceof _helpers.NotEnoughDataError) {
                await parser.waitForChunk();
                continue;
              }
              throw err;
            }
            parser.position = result.offset;
            columns.push({
              value: result.value,
              metadata
            });
          }
          break;
        }
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column2) => {
          const colName = column2.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column2;
          }
        });
        return new _token.RowToken(columnsMap);
      } else {
        return new _token.RowToken(columns);
      }
    }
    var _default = exports2.default = rowParser;
    module2.exports = rowParser;
  }
});

// node_modules/tedious/lib/token/nbcrow-token-parser.js
var require_nbcrow_token_parser = __commonJS({
  "node_modules/tedious/lib/token/nbcrow-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var iconv = _interopRequireWildcard(require_lib2());
    var _valueParser = require_value_parser();
    var _helpers = require_helpers2();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function nbcRowParser(parser) {
      const colMetadata = parser.colMetadata;
      const columns = [];
      const bitmap = [];
      const bitmapByteLength = Math.ceil(colMetadata.length / 8);
      while (parser.buffer.length - parser.position < bitmapByteLength) {
        await parser.waitForChunk();
      }
      const bytes = parser.buffer.slice(parser.position, parser.position + bitmapByteLength);
      parser.position += bitmapByteLength;
      for (let i = 0, len = bytes.length; i < len; i++) {
        const byte = bytes[i];
        bitmap.push(byte & 1 ? true : false);
        bitmap.push(byte & 2 ? true : false);
        bitmap.push(byte & 4 ? true : false);
        bitmap.push(byte & 8 ? true : false);
        bitmap.push(byte & 16 ? true : false);
        bitmap.push(byte & 32 ? true : false);
        bitmap.push(byte & 64 ? true : false);
        bitmap.push(byte & 128 ? true : false);
      }
      for (let i = 0; i < colMetadata.length; i++) {
        const metadata = colMetadata[i];
        if (bitmap[i]) {
          columns.push({
            value: null,
            metadata
          });
          continue;
        }
        while (true) {
          if ((0, _valueParser.isPLPStream)(metadata)) {
            const chunks = await (0, _valueParser.readPLPStream)(parser);
            if (chunks === null) {
              columns.push({
                value: chunks,
                metadata
              });
            } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
              columns.push({
                value: Buffer.concat(chunks).toString("ucs2"),
                metadata
              });
            } else if (metadata.type.name === "VarChar") {
              columns.push({
                value: iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? "utf8"),
                metadata
              });
            } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
              columns.push({
                value: Buffer.concat(chunks),
                metadata
              });
            }
          } else {
            let result;
            try {
              result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
            } catch (err) {
              if (err instanceof _helpers.NotEnoughDataError) {
                await parser.waitForChunk();
                continue;
              }
              throw err;
            }
            parser.position = result.offset;
            columns.push({
              value: result.value,
              metadata
            });
          }
          break;
        }
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column2) => {
          const colName = column2.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column2;
          }
        });
        return new _token.NBCRowToken(columnsMap);
      } else {
        return new _token.NBCRowToken(columns);
      }
    }
    var _default = exports2.default = nbcRowParser;
    module2.exports = nbcRowParser;
  }
});

// node_modules/tedious/lib/token/sspi-token-parser.js
var require_sspi_token_parser = __commonJS({
  "node_modules/tedious/lib/token/sspi-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _helpers = require_helpers2();
    var _token = require_token();
    function parseChallenge(buffer) {
      const challenge = {};
      challenge.magic = buffer.slice(0, 8).toString("utf8");
      challenge.type = buffer.readInt32LE(8);
      challenge.domainLen = buffer.readInt16LE(12);
      challenge.domainMax = buffer.readInt16LE(14);
      challenge.domainOffset = buffer.readInt32LE(16);
      challenge.flags = buffer.readInt32LE(20);
      challenge.nonce = buffer.slice(24, 32);
      challenge.zeroes = buffer.slice(32, 40);
      challenge.targetLen = buffer.readInt16LE(40);
      challenge.targetMax = buffer.readInt16LE(42);
      challenge.targetOffset = buffer.readInt32LE(44);
      challenge.oddData = buffer.slice(48, 56);
      challenge.domain = buffer.slice(56, 56 + challenge.domainLen).toString("ucs2");
      challenge.target = buffer.slice(56 + challenge.domainLen, 56 + challenge.domainLen + challenge.targetLen);
      return challenge;
    }
    function sspiParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const data = buf.slice(offset, offset + tokenLength);
      offset += tokenLength;
      return new _helpers.Result(new _token.SSPIToken(parseChallenge(data), data), offset);
    }
    var _default = exports2.default = sspiParser;
    module2.exports = sspiParser;
  }
});

// node_modules/tedious/lib/token/stream-parser.js
var require_stream_parser = __commonJS({
  "node_modules/tedious/lib/token/stream-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var _colmetadataTokenParser = _interopRequireDefault(require_colmetadata_token_parser());
    var _doneTokenParser = require_done_token_parser();
    var _envChangeTokenParser = _interopRequireDefault(require_env_change_token_parser());
    var _infoerrorTokenParser = require_infoerror_token_parser();
    var _fedauthInfoParser = _interopRequireDefault(require_fedauth_info_parser());
    var _featureExtAckParser = _interopRequireDefault(require_feature_ext_ack_parser());
    var _loginackTokenParser = _interopRequireDefault(require_loginack_token_parser());
    var _orderTokenParser = _interopRequireDefault(require_order_token_parser());
    var _returnstatusTokenParser = _interopRequireDefault(require_returnstatus_token_parser());
    var _returnvalueTokenParser = _interopRequireDefault(require_returnvalue_token_parser());
    var _rowTokenParser = _interopRequireDefault(require_row_token_parser());
    var _nbcrowTokenParser = _interopRequireDefault(require_nbcrow_token_parser());
    var _sspiTokenParser = _interopRequireDefault(require_sspi_token_parser());
    var _helpers = require_helpers2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class _Parser {
      constructor(iterable, debug, options) {
        __publicField(this, "debug");
        __publicField(this, "colMetadata");
        __publicField(this, "options");
        __publicField(this, "iterator");
        __publicField(this, "buffer");
        __publicField(this, "position");
        this.debug = debug;
        this.colMetadata = [];
        this.options = options;
        this.iterator = (iterable[Symbol.asyncIterator] || iterable[Symbol.iterator]).call(iterable);
        this.buffer = Buffer.alloc(0);
        this.position = 0;
      }
      static async *parseTokens(iterable, debug, options, colMetadata = []) {
        const parser = new _Parser(iterable, debug, options);
        parser.colMetadata = colMetadata;
        while (true) {
          try {
            await parser.waitForChunk();
          } catch (err) {
            if (parser.position === parser.buffer.length) {
              return;
            }
            throw err;
          }
          while (parser.buffer.length >= parser.position + 1) {
            const type2 = parser.buffer.readUInt8(parser.position);
            parser.position += 1;
            const token = parser.readToken(type2);
            if (token !== void 0) {
              yield token;
            }
          }
        }
      }
      readToken(type2) {
        switch (type2) {
          case _token.TYPE.DONE: {
            return this.readDoneToken();
          }
          case _token.TYPE.DONEPROC: {
            return this.readDoneProcToken();
          }
          case _token.TYPE.DONEINPROC: {
            return this.readDoneInProcToken();
          }
          case _token.TYPE.ERROR: {
            return this.readErrorToken();
          }
          case _token.TYPE.INFO: {
            return this.readInfoToken();
          }
          case _token.TYPE.ENVCHANGE: {
            return this.readEnvChangeToken();
          }
          case _token.TYPE.LOGINACK: {
            return this.readLoginAckToken();
          }
          case _token.TYPE.RETURNSTATUS: {
            return this.readReturnStatusToken();
          }
          case _token.TYPE.ORDER: {
            return this.readOrderToken();
          }
          case _token.TYPE.FEDAUTHINFO: {
            return this.readFedAuthInfoToken();
          }
          case _token.TYPE.SSPI: {
            return this.readSSPIToken();
          }
          case _token.TYPE.COLMETADATA: {
            return this.readColMetadataToken();
          }
          case _token.TYPE.RETURNVALUE: {
            return this.readReturnValueToken();
          }
          case _token.TYPE.ROW: {
            return this.readRowToken();
          }
          case _token.TYPE.NBCROW: {
            return this.readNbcRowToken();
          }
          case _token.TYPE.FEATUREEXTACK: {
            return this.readFeatureExtAckToken();
          }
          default: {
            throw new Error("Unknown type: " + type2);
          }
        }
      }
      readFeatureExtAckToken() {
        let result;
        try {
          result = (0, _featureExtAckParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readFeatureExtAckToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      async readNbcRowToken() {
        return await (0, _nbcrowTokenParser.default)(this);
      }
      async readReturnValueToken() {
        return await (0, _returnvalueTokenParser.default)(this);
      }
      async readColMetadataToken() {
        const token = await (0, _colmetadataTokenParser.default)(this);
        this.colMetadata = token.columns;
        return token;
      }
      readSSPIToken() {
        let result;
        try {
          result = (0, _sspiTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readSSPIToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readFedAuthInfoToken() {
        let result;
        try {
          result = (0, _fedauthInfoParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readFedAuthInfoToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readOrderToken() {
        let result;
        try {
          result = (0, _orderTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readOrderToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readReturnStatusToken() {
        let result;
        try {
          result = (0, _returnstatusTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readReturnStatusToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readLoginAckToken() {
        let result;
        try {
          result = (0, _loginackTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readLoginAckToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readEnvChangeToken() {
        let result;
        try {
          result = (0, _envChangeTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readEnvChangeToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readRowToken() {
        return (0, _rowTokenParser.default)(this);
      }
      readInfoToken() {
        let result;
        try {
          result = (0, _infoerrorTokenParser.infoParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readInfoToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readErrorToken() {
        let result;
        try {
          result = (0, _infoerrorTokenParser.errorParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readErrorToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneInProcToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneInProcParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneInProcToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneProcToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneProcParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneProcToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      async waitForChunk() {
        const result = await this.iterator.next();
        if (result.done) {
          throw new Error("unexpected end of data");
        }
        if (this.position === this.buffer.length) {
          this.buffer = result.value;
        } else {
          this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);
        }
        this.position = 0;
      }
    };
    var _default = exports2.default = Parser;
    module2.exports = Parser;
  }
});

// node_modules/tedious/lib/token/token-stream-parser.js
var require_token_stream_parser = __commonJS({
  "node_modules/tedious/lib/token/token-stream-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Parser = void 0;
    var _events = require("events");
    var _streamParser = _interopRequireDefault(require_stream_parser());
    var _stream = require("stream");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class extends _events.EventEmitter {
      constructor(message, debug, handler, options) {
        super();
        this.debug = debug;
        this.options = options;
        this.parser = _stream.Readable.from(_streamParser.default.parseTokens(message, this.debug, this.options));
        this.parser.on("data", (token) => {
          debug.token(token);
          handler[token.handlerName](token);
        });
        this.parser.on("drain", () => {
          this.emit("drain");
        });
        this.parser.on("end", () => {
          this.emit("end");
        });
      }
      pause() {
        return this.parser.pause();
      }
      resume() {
        return this.parser.resume();
      }
    };
    exports2.Parser = Parser;
  }
});

// node_modules/tedious/lib/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/tedious/lib/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Transaction = exports2.OPERATION_TYPE = exports2.ISOLATION_LEVEL = void 0;
    exports2.assertValidIsolationLevel = assertValidIsolationLevel;
    exports2.isolationLevelByValue = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OPERATION_TYPE = exports2.OPERATION_TYPE = {
      TM_GET_DTC_ADDRESS: 0,
      TM_PROPAGATE_XACT: 1,
      TM_BEGIN_XACT: 5,
      TM_PROMOTE_XACT: 6,
      TM_COMMIT_XACT: 7,
      TM_ROLLBACK_XACT: 8,
      TM_SAVE_XACT: 9
    };
    var ISOLATION_LEVEL = exports2.ISOLATION_LEVEL = {
      NO_CHANGE: 0,
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
    var isolationLevelByValue = exports2.isolationLevelByValue = {};
    for (const name3 in ISOLATION_LEVEL) {
      const value = ISOLATION_LEVEL[name3];
      isolationLevelByValue[value] = name3;
    }
    function assertValidIsolationLevel(isolationLevel, name3) {
      if (typeof isolationLevel !== "number") {
        throw new TypeError(`The "${name3}" ${name3.includes(".") ? "property" : "argument"} must be of type number. Received type ${typeof isolationLevel} (${isolationLevel})`);
      }
      if (!Number.isInteger(isolationLevel)) {
        throw new RangeError(`The value of "${name3}" is out of range. It must be an integer. Received: ${isolationLevel}`);
      }
      if (!(isolationLevel >= 0 && isolationLevel <= 5)) {
        throw new RangeError(`The value of "${name3}" is out of range. It must be >= 0 && <= 5. Received: ${isolationLevel}`);
      }
    }
    var Transaction2 = class {
      constructor(name3, isolationLevel = ISOLATION_LEVEL.NO_CHANGE) {
        this.name = name3;
        this.isolationLevel = isolationLevel;
        this.outstandingRequestCount = 1;
      }
      beginPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ucs2");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_BEGIN_XACT);
        buffer.writeUInt8(this.isolationLevel);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Begin Transaction: name=" + this.name + ", isolationLevel=" + isolationLevelByValue[this.isolationLevel];
          }
        };
      }
      commitPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_COMMIT_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Commit Transaction: name=" + this.name;
          }
        };
      }
      rollbackPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_ROLLBACK_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Rollback Transaction: name=" + this.name;
          }
        };
      }
      savePayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_SAVE_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Save Transaction: name=" + this.name;
          }
        };
      }
      isolationLevelToTSQL() {
        switch (this.isolationLevel) {
          case ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "READ UNCOMMITTED";
          case ISOLATION_LEVEL.READ_COMMITTED:
            return "READ COMMITTED";
          case ISOLATION_LEVEL.REPEATABLE_READ:
            return "REPEATABLE READ";
          case ISOLATION_LEVEL.SERIALIZABLE:
            return "SERIALIZABLE";
          case ISOLATION_LEVEL.SNAPSHOT:
            return "SNAPSHOT";
        }
        return "";
      }
    };
    exports2.Transaction = Transaction2;
  }
});

// node_modules/tedious/lib/connector.js
var require_connector = __commonJS({
  "node_modules/tedious/lib/connector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.connectInParallel = connectInParallel;
    exports2.connectInSequence = connectInSequence;
    exports2.lookupAllAddresses = lookupAllAddresses;
    var _net = _interopRequireDefault(require("net"));
    var _nodeUrl = _interopRequireDefault(require("url"));
    var _abortError = _interopRequireDefault(require_abort_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function connectInParallel(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      return await new Promise((resolve, reject) => {
        const sockets = new Array(addresses.length);
        const errors = [];
        function onError(err) {
          errors.push(err);
          this.removeListener("error", onError);
          this.removeListener("connect", onConnect);
          this.destroy();
          if (errors.length === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            reject(new AggregateError(errors, "Could not connect (parallel)"));
          }
        }
        function onConnect() {
          signal.removeEventListener("abort", onAbort);
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            if (this === socket) {
              continue;
            }
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          resolve(this);
        }
        const onAbort = () => {
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          reject(new _abortError.default());
        };
        for (let i = 0, len = addresses.length; i < len; i++) {
          const socket = sockets[i] = _net.default.connect({
            ...options,
            host: addresses[i].address,
            family: addresses[i].family
          });
          socket.on("error", onError);
          socket.on("connect", onConnect);
        }
        signal.addEventListener("abort", onAbort, {
          once: true
        });
      });
    }
    async function connectInSequence(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const errors = [];
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      for (const address of addresses) {
        try {
          return await new Promise((resolve, reject) => {
            const socket = _net.default.connect({
              ...options,
              host: address.address,
              family: address.family
            });
            const onAbort = () => {
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(new _abortError.default());
            };
            const onError = (err) => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(err);
            };
            const onConnect = () => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              resolve(socket);
            };
            signal.addEventListener("abort", onAbort, {
              once: true
            });
            socket.on("error", onError);
            socket.on("connect", onConnect);
          });
        } catch (err) {
          if (err instanceof Error && err.name === "AbortError") {
            throw err;
          }
          errors.push(err);
          continue;
        }
      }
      throw new AggregateError(errors, "Could not connect (sequence)");
    }
    async function lookupAllAddresses(host, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      if (_net.default.isIPv6(host)) {
        return [{
          address: host,
          family: 6
        }];
      } else if (_net.default.isIPv4(host)) {
        return [{
          address: host,
          family: 4
        }];
      } else {
        return await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          signal.addEventListener("abort", onAbort);
          const domainInASCII = _nodeUrl.default.domainToASCII(host);
          lookup(domainInASCII === "" ? host : domainInASCII, {
            all: true
          }, (err, addresses) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses);
          });
        });
      }
    }
  }
});

// node_modules/tedious/lib/library.js
var require_library = __commonJS({
  "node_modules/tedious/lib/library.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.name = void 0;
    var name3 = exports2.name = "Tedious";
  }
});

// node_modules/tedious/lib/ntlm.js
var require_ntlm = __commonJS({
  "node_modules/tedious/lib/ntlm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createNTLMRequest = createNTLMRequest;
    var NTLMFlags = {
      NTLM_NegotiateUnicode: 1,
      NTLM_NegotiateOEM: 2,
      NTLM_RequestTarget: 4,
      NTLM_Unknown9: 8,
      NTLM_NegotiateSign: 16,
      NTLM_NegotiateSeal: 32,
      NTLM_NegotiateDatagram: 64,
      NTLM_NegotiateLanManagerKey: 128,
      NTLM_Unknown8: 256,
      NTLM_NegotiateNTLM: 512,
      NTLM_NegotiateNTOnly: 1024,
      NTLM_Anonymous: 2048,
      NTLM_NegotiateOemDomainSupplied: 4096,
      NTLM_NegotiateOemWorkstationSupplied: 8192,
      NTLM_Unknown6: 16384,
      NTLM_NegotiateAlwaysSign: 32768,
      NTLM_TargetTypeDomain: 65536,
      NTLM_TargetTypeServer: 131072,
      NTLM_TargetTypeShare: 262144,
      NTLM_NegotiateExtendedSecurity: 524288,
      NTLM_NegotiateIdentify: 1048576,
      NTLM_Unknown5: 2097152,
      NTLM_RequestNonNTSessionKey: 4194304,
      NTLM_NegotiateTargetInfo: 8388608,
      NTLM_Unknown4: 16777216,
      NTLM_NegotiateVersion: 33554432,
      NTLM_Unknown3: 67108864,
      NTLM_Unknown2: 134217728,
      NTLM_Unknown1: 268435456,
      NTLM_Negotiate128: 536870912,
      NTLM_NegotiateKeyExchange: 1073741824,
      NTLM_Negotiate56: 2147483648
    };
    function createNTLMRequest(options) {
      const domain = escape(options.domain.toUpperCase());
      const workstation = options.workstation ? escape(options.workstation.toUpperCase()) : "";
      let type1flags = NTLMFlags.NTLM_NegotiateUnicode + NTLMFlags.NTLM_NegotiateOEM + NTLMFlags.NTLM_RequestTarget + NTLMFlags.NTLM_NegotiateNTLM + NTLMFlags.NTLM_NegotiateOemDomainSupplied + NTLMFlags.NTLM_NegotiateOemWorkstationSupplied + NTLMFlags.NTLM_NegotiateAlwaysSign + NTLMFlags.NTLM_NegotiateVersion + NTLMFlags.NTLM_NegotiateExtendedSecurity + NTLMFlags.NTLM_Negotiate128 + NTLMFlags.NTLM_Negotiate56;
      if (workstation === "") {
        type1flags -= NTLMFlags.NTLM_NegotiateOemWorkstationSupplied;
      }
      const fixedData = Buffer.alloc(40);
      const buffers = [fixedData];
      let offset = 0;
      offset += fixedData.write("NTLMSSP", offset, 7, "ascii");
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt32LE(1, offset);
      offset = fixedData.writeUInt32LE(type1flags, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length + workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length, offset);
      offset = fixedData.writeUInt8(5, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt16LE(2195, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      fixedData.writeUInt8(15, offset);
      buffers.push(Buffer.from(workstation, "ascii"));
      buffers.push(Buffer.from(domain, "ascii"));
      return Buffer.concat(buffers);
    }
  }
});

// node_modules/tedious/lib/bulk-load-payload.js
var require_bulk_load_payload = __commonJS({
  "node_modules/tedious/lib/bulk-load-payload.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BulkLoadPayload = void 0;
    var BulkLoadPayload = class {
      constructor(bulkLoad) {
        this.bulkLoad = bulkLoad;
        this.iterator = this.bulkLoad.rowToPacketTransform[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterator;
      }
      toString(indent = "") {
        return indent + "BulkLoad";
      }
    };
    exports2.BulkLoadPayload = BulkLoadPayload;
  }
});

// node_modules/tedious/lib/special-stored-procedure.js
var require_special_stored_procedure = __commonJS({
  "node_modules/tedious/lib/special-stored-procedure.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var procedures = {
      Sp_Cursor: 1,
      Sp_CursorOpen: 2,
      Sp_CursorPrepare: 3,
      Sp_CursorExecute: 4,
      Sp_CursorPrepExec: 5,
      Sp_CursorUnprepare: 6,
      Sp_CursorFetch: 7,
      Sp_CursorOption: 8,
      Sp_CursorClose: 9,
      Sp_ExecuteSql: 10,
      Sp_Prepare: 11,
      Sp_Execute: 12,
      Sp_PrepExec: 13,
      Sp_PrepExecRpc: 14,
      Sp_Unprepare: 15
    };
    var _default = exports2.default = procedures;
    module2.exports = procedures;
  }
});

// node_modules/tedious/package.json
var require_package = __commonJS({
  "node_modules/tedious/package.json"(exports2, module2) {
    module2.exports = {
      author: "Mike D Pilsbury <mike.pilsbury@gmail.com>",
      contributors: [
        "Alex Robson",
        "Arthur Schreiber",
        "Bret Copeland <bret@atlantisflight.org> (https://github.com/bretcope)",
        "Bryan Ross <bryan@rossipedia.com> (https://github.com/rossipedia)",
        "Ciaran Jessup <ciaranj@gmail.com>",
        "Cort Fritz <cfritz@caa.com>",
        "lastonesky",
        "Patrik Simek <patrik@patriksimek.cz>",
        "Phil Dodderidge <pdodde@poyntz.com>",
        "Zach Aller"
      ],
      name: "tedious",
      description: "A TDS driver, for connecting to MS SQLServer databases.",
      keywords: [
        "sql",
        "database",
        "mssql",
        "sqlserver",
        "sql-server",
        "tds",
        "msnodesql",
        "azure"
      ],
      homepage: "https://github.com/tediousjs/tedious",
      bugs: "https://github.com/tediousjs/tedious/issues",
      license: "MIT",
      version: "18.6.1",
      main: "./lib/tedious.js",
      types: "./lib/tedious.d.ts",
      repository: {
        type: "git",
        url: "https://github.com/tediousjs/tedious.git"
      },
      engines: {
        node: ">=18"
      },
      publishConfig: {
        tag: "next",
        provenance: true
      },
      dependencies: {
        "@azure/core-auth": "^1.7.2",
        "@azure/identity": "^4.2.1",
        "@azure/keyvault-keys": "^4.4.0",
        "@js-joda/core": "^5.6.1",
        "@types/node": ">=18",
        bl: "^6.0.11",
        "iconv-lite": "^0.6.3",
        "js-md4": "^0.3.2",
        "native-duplexpair": "^1.0.0",
        "sprintf-js": "^1.1.3"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.23.9",
        "@babel/node": "^7.23.9",
        "@babel/preset-env": "^7.23.9",
        "@babel/preset-typescript": "^7.23.3",
        "@babel/register": "^7.23.7",
        "@types/async": "^3.2.24",
        "@types/bl": "^5.1.0",
        "@types/chai": "^4.3.12",
        "@types/depd": "^1.1.36",
        "@types/lru-cache": "^5.1.1",
        "@types/mocha": "^10.0.6",
        "@types/sprintf-js": "^1.1.4",
        "@typescript-eslint/eslint-plugin": "^7.0.2",
        "@typescript-eslint/parser": "^7.0.2",
        async: "^3.2.5",
        "babel-plugin-istanbul": "^6.1.1",
        chai: "^4.4.1",
        codecov: "^3.8.3",
        eslint: "^8.57.0",
        mitm: "^1.7.2",
        mocha: "^10.3.0",
        nyc: "^15.1.0",
        rimraf: "^5.0.5",
        "semantic-release": "^19.0.3",
        sinon: "^15.2.0",
        typedoc: "^0.26.5",
        typescript: "^5.5.4"
      },
      scripts: {
        docs: "typedoc",
        lint: "eslint src test --ext .js,.ts && tsc",
        test: "mocha --forbid-only test/unit test/unit/token test/unit/tracking-buffer",
        "test-integration": "mocha --forbid-only test/integration/",
        "test-all": "mocha --forbid-only test/unit/ test/unit/token/ test/unit/tracking-buffer test/integration/",
        "build:types": "tsc --project tsconfig.build-types.json",
        build: "rimraf lib && babel src --out-dir lib --extensions .js,.ts && npm run build:types",
        prepublish: "npm run build",
        "semantic-release": "semantic-release"
      },
      babel: {
        sourceMaps: "both",
        ignore: [
          "./src/**/*.d.ts"
        ],
        presets: [
          [
            "@babel/preset-env",
            {
              targets: {
                node: 18
              }
            }
          ],
          [
            "@babel/preset-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ],
        plugins: [
          [
            "@babel/transform-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ]
      },
      mocha: {
        require: "test/setup.js",
        timeout: 5e3,
        extension: [
          "js",
          "ts"
        ]
      },
      nyc: {
        sourceMap: false,
        instrument: false,
        extension: [
          ".ts"
        ]
      }
    };
  }
});

// node_modules/tedious/lib/token/handler.js
var require_handler = __commonJS({
  "node_modules/tedious/lib/token/handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UnexpectedTokenError = exports2.TokenHandler = exports2.RequestTokenHandler = exports2.Login7TokenHandler = exports2.InitialSqlTokenHandler = exports2.AttentionTokenHandler = void 0;
    var _request = _interopRequireDefault(require_request2());
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UnexpectedTokenError = class extends Error {
      constructor(handler, token) {
        super("Unexpected token `" + token.name + "` in `" + handler.constructor.name + "`");
      }
    };
    exports2.UnexpectedTokenError = UnexpectedTokenError;
    var TokenHandler = class {
      onInfoMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onErrorMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSSPI(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLanguageChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCharsetChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSqlCollationChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRoutingChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onPacketSizeChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onResetConnection(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onBeginTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCommitTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRollbackTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFedAuthInfo(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFeatureExtAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLoginAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onColMetadata(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onOrder(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRow(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnStatus(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnValue(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneInProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDone(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseMirroringPartner(token) {
        throw new UnexpectedTokenError(this, token);
      }
    };
    exports2.TokenHandler = TokenHandler;
    var InitialSqlTokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        this.connection.emit("error", new Error("Received 'columnMetadata' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onOrder(token) {
        this.connection.emit("error", new Error("Received 'order' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onRow(token) {
        this.connection.emit("error", new Error("Received 'row' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onReturnStatus(token) {
      }
      onReturnValue(token) {
      }
      onDoneProc(token) {
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports2.InitialSqlTokenHandler = InitialSqlTokenHandler;
    var Login7TokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        this.loginAckReceived = false;
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        const error = new _errors.ConnectionError(token.message, "ELOGIN");
        const isLoginErrorTransient = this.connection.transientErrorLookup.isTransientError(token.number);
        if (isLoginErrorTransient && this.connection.curTransientRetryCount !== this.connection.config.options.maxRetriesOnTransientErrors) {
          error.isTransient = true;
        }
        this.connection.loginError = error;
      }
      onSSPI(token) {
        if (token.ntlmpacket) {
          this.connection.ntlmpacket = token.ntlmpacket;
          this.connection.ntlmpacketBuffer = token.ntlmpacketBuffer;
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onFedAuthInfo(token) {
        this.fedAuthInfoToken = token;
      }
      onFeatureExtAck(token) {
        const {
          authentication
        } = this.connection.config;
        if (authentication.type === "azure-active-directory-password" || authentication.type === "azure-active-directory-access-token" || authentication.type === "azure-active-directory-msi-vm" || authentication.type === "azure-active-directory-msi-app-service" || authentication.type === "azure-active-directory-service-principal-secret" || authentication.type === "azure-active-directory-default") {
          if (token.fedAuth === void 0) {
            this.connection.loginError = new _errors.ConnectionError("Did not receive Active Directory authentication acknowledgement");
          } else if (token.fedAuth.length !== 0) {
            this.connection.loginError = new _errors.ConnectionError(`Active Directory authentication acknowledgment for ${authentication.type} authentication method includes extra data`);
          }
        } else if (token.fedAuth === void 0 && token.utf8Support === void 0) {
          this.connection.loginError = new _errors.ConnectionError("Received acknowledgement for unknown feature");
        } else if (token.fedAuth) {
          this.connection.loginError = new _errors.ConnectionError("Did not request Active Directory authentication, but received the acknowledgment");
        }
      }
      onLoginAck(token) {
        if (!token.tdsVersion) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unknown TDS version.", "ETDS");
          return;
        }
        if (!token.interface) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unsupported interface.", "EINTERFACENOTSUPP");
          return;
        }
        this.connection.config.options.tdsVersion = token.tdsVersion;
        this.loginAckReceived = true;
      }
      onRoutingChange(token) {
        const [server] = token.newValue.server.split("\\");
        this.routingData = {
          server,
          port: token.newValue.port
        };
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onDatabaseMirroringPartner(token) {
      }
    };
    exports2.Login7TokenHandler = Login7TokenHandler;
    var RequestTokenHandler = class extends TokenHandler {
      constructor(connection, request3) {
        super();
        this.connection = connection;
        this.request = request3;
        this.errors = [];
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        if (!this.request.canceled) {
          const error = new _errors.RequestError(token.message, "EREQUEST");
          error.number = token.number;
          error.state = token.state;
          error.class = token.class;
          error.serverName = token.serverName;
          error.procName = token.procName;
          error.lineNumber = token.lineNumber;
          this.errors.push(error);
          this.request.error = error;
          if (this.request instanceof _request.default && this.errors.length > 1) {
            this.request.error = new AggregateError(this.errors);
          }
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.useColumnNames) {
            const columns = /* @__PURE__ */ Object.create(null);
            for (let j = 0, len = token.columns.length; j < len; j++) {
              const col = token.columns[j];
              if (columns[col.colName] == null) {
                columns[col.colName] = col;
              }
            }
            this.request.emit("columnMetadata", columns);
          } else {
            this.request.emit("columnMetadata", token.columns);
          }
        }
      }
      onOrder(token) {
        if (!this.request.canceled) {
          this.request.emit("order", token.orderColumns);
        }
      }
      onRow(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.rowCollectionOnRequestCompletion) {
            this.request.rows.push(token.columns);
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst.push(token.columns);
          }
          this.request.emit("row", token.columns);
        }
      }
      onReturnStatus(token) {
        if (!this.request.canceled) {
          this.connection.procReturnStatusValue = token.value;
        }
      }
      onReturnValue(token) {
        if (!this.request.canceled) {
          this.request.emit("returnValue", token.paramName, token.value, token.metadata);
        }
      }
      onDoneProc(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("doneProc", token.rowCount, token.more, this.connection.procReturnStatusValue, this.request.rst);
          this.connection.procReturnStatusValue = void 0;
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDoneInProc(token) {
        if (!this.request.canceled) {
          this.request.emit("doneInProc", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDone(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("done", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports2.RequestTokenHandler = RequestTokenHandler;
    var AttentionTokenHandler = class extends TokenHandler {
      /**
       * Returns whether an attention acknowledgement was received.
       */
      constructor(connection, request3) {
        super();
        this.connection = connection;
        this.request = request3;
        this.attentionReceived = false;
      }
      onDone(token) {
        if (token.attention) {
          this.attentionReceived = true;
        }
      }
    };
    exports2.AttentionTokenHandler = AttentionTokenHandler;
  }
});

// node_modules/tedious/lib/connection.js
var require_connection = __commonJS({
  "node_modules/tedious/lib/connection.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    var _os = _interopRequireDefault(require("os"));
    var tls = _interopRequireWildcard(require("tls"));
    var net = _interopRequireWildcard(require("net"));
    var _dns = _interopRequireDefault(require("dns"));
    var _constants = _interopRequireDefault(require("constants"));
    var _stream = require("stream");
    var _identity = (init_src2(), __toCommonJS(src_exports));
    var _coreAuth = require_commonjs3();
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _debug = _interopRequireDefault(require_debug2());
    var _events = require("events");
    var _instanceLookup = require_instance_lookup();
    var _transientErrorLookup = require_transient_error_lookup();
    var _packet = require_packet();
    var _preloginPayload = _interopRequireDefault(require_prelogin_payload());
    var _login7Payload = _interopRequireDefault(require_login7_payload());
    var _ntlmPayload = _interopRequireDefault(require_ntlm_payload());
    var _request = _interopRequireDefault(require_request2());
    var _rpcrequestPayload = _interopRequireDefault(require_rpcrequest_payload());
    var _sqlbatchPayload = _interopRequireDefault(require_sqlbatch_payload());
    var _messageIo = _interopRequireDefault(require_message_io());
    var _tokenStreamParser = require_token_stream_parser();
    var _transaction = require_transaction2();
    var _errors = require_errors();
    var _connector = require_connector();
    var _library = require_library();
    var _tdsVersions = require_tds_versions();
    var _message = _interopRequireDefault(require_message());
    var _ntlm = require_ntlm();
    var _dataType = require_data_type();
    var _bulkLoadPayload = require_bulk_load_payload();
    var _specialStoredProcedure = _interopRequireDefault(require_special_stored_procedure());
    var _package = require_package();
    var _url = require("url");
    var _handler = require_handler();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var KEEP_ALIVE_INITIAL_DELAY = 30 * 1e3;
    var DEFAULT_CONNECT_TIMEOUT = 15 * 1e3;
    var DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1e3;
    var DEFAULT_CANCEL_TIMEOUT = 5 * 1e3;
    var DEFAULT_CONNECT_RETRY_INTERVAL = 500;
    var DEFAULT_PACKET_SIZE = 4 * 1024;
    var DEFAULT_TEXTSIZE = 2147483647;
    var DEFAULT_DATEFIRST = 7;
    var DEFAULT_PORT = 1433;
    var DEFAULT_TDS_VERSION = "7_4";
    var DEFAULT_LANGUAGE = "us_english";
    var DEFAULT_DATEFORMAT = "mdy";
    var CLEANUP_TYPE = {
      NORMAL: 0,
      REDIRECT: 1,
      RETRY: 2
    };
    var Connection = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * Note: be aware of the different options field:
       * 1. config.authentication.options
       * 2. config.options
       *
       * ```js
       * const { Connection } = require('tedious');
       *
       * const config = {
       *  "authentication": {
       *    ...,
       *    "options": {...}
       *  },
       *  "options": {...}
       * };
       *
       * const connection = new Connection(config);
       * ```
       *
       * @param config
       */
      constructor(config) {
        super();
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        __publicField(this, "_cancelAfterRequestSent");
        if (typeof config !== "object" || config === null) {
          throw new TypeError('The "config" argument is required and must be of type Object.');
        }
        if (typeof config.server !== "string") {
          throw new TypeError('The "config.server" property is required and must be of type string.');
        }
        this.fedAuthRequired = false;
        let authentication;
        if (config.authentication !== void 0) {
          if (typeof config.authentication !== "object" || config.authentication === null) {
            throw new TypeError('The "config.authentication" property must be of type Object.');
          }
          const type2 = config.authentication.type;
          const options = config.authentication.options === void 0 ? {} : config.authentication.options;
          if (typeof type2 !== "string") {
            throw new TypeError('The "config.authentication.type" property must be of type string.');
          }
          if (type2 !== "default" && type2 !== "ntlm" && type2 !== "token-credential" && type2 !== "azure-active-directory-password" && type2 !== "azure-active-directory-access-token" && type2 !== "azure-active-directory-msi-vm" && type2 !== "azure-active-directory-msi-app-service" && type2 !== "azure-active-directory-service-principal-secret" && type2 !== "azure-active-directory-default") {
            throw new TypeError('The "type" property must one of "default", "ntlm", "token-credential", "azure-active-directory-password", "azure-active-directory-access-token", "azure-active-directory-default", "azure-active-directory-msi-vm" or "azure-active-directory-msi-app-service" or "azure-active-directory-service-principal-secret".');
          }
          if (typeof options !== "object" || options === null) {
            throw new TypeError('The "config.authentication.options" property must be of type object.');
          }
          if (type2 === "ntlm") {
            if (typeof options.domain !== "string") {
              throw new TypeError('The "config.authentication.options.domain" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication = {
              type: "ntlm",
              options: {
                userName: options.userName,
                password: options.password,
                domain: options.domain && options.domain.toUpperCase()
              }
            };
          } else if (type2 === "token-credential") {
            if (!(0, _coreAuth.isTokenCredential)(options.credential)) {
              throw new TypeError('The "config.authentication.options.credential" property must be an instance of the token credential class.');
            }
            authentication = {
              type: "token-credential",
              options: {
                credential: options.credential
              }
            };
          } else if (type2 === "azure-active-directory-password") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            if (options.tenantId !== void 0 && typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-password",
              options: {
                userName: options.userName,
                password: options.password,
                tenantId: options.tenantId,
                clientId: options.clientId
              }
            };
          } else if (type2 === "azure-active-directory-access-token") {
            if (typeof options.token !== "string") {
              throw new TypeError('The "config.authentication.options.token" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-access-token",
              options: {
                token: options.token
              }
            };
          } else if (type2 === "azure-active-directory-msi-vm") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-msi-vm",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type2 === "azure-active-directory-default") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-default",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type2 === "azure-active-directory-msi-app-service") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-msi-app-service",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type2 === "azure-active-directory-service-principal-secret") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (typeof options.clientSecret !== "string") {
              throw new TypeError('The "config.authentication.options.clientSecret" property must be of type string.');
            }
            if (typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-service-principal-secret",
              options: {
                clientId: options.clientId,
                clientSecret: options.clientSecret,
                tenantId: options.tenantId
              }
            };
          } else {
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication = {
              type: "default",
              options: {
                userName: options.userName,
                password: options.password
              }
            };
          }
        } else {
          authentication = {
            type: "default",
            options: {
              userName: void 0,
              password: void 0
            }
          };
        }
        this.config = {
          server: config.server,
          authentication,
          options: {
            abortTransactionOnError: false,
            appName: void 0,
            camelCaseColumns: false,
            cancelTimeout: DEFAULT_CANCEL_TIMEOUT,
            columnEncryptionKeyCacheTTL: 2 * 60 * 60 * 1e3,
            // Units: milliseconds
            columnEncryptionSetting: false,
            columnNameReplacer: void 0,
            connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,
            connectTimeout: DEFAULT_CONNECT_TIMEOUT,
            connector: void 0,
            connectionIsolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            cryptoCredentialsDetails: {},
            database: void 0,
            datefirst: DEFAULT_DATEFIRST,
            dateFormat: DEFAULT_DATEFORMAT,
            debug: {
              data: false,
              packet: false,
              payload: false,
              token: false
            },
            enableAnsiNull: true,
            enableAnsiNullDefault: true,
            enableAnsiPadding: true,
            enableAnsiWarnings: true,
            enableArithAbort: true,
            enableConcatNullYieldsNull: true,
            enableCursorCloseOnCommit: null,
            enableImplicitTransactions: false,
            enableNumericRoundabort: false,
            enableQuotedIdentifier: true,
            encrypt: true,
            fallbackToDefaultDb: false,
            encryptionKeyStoreProviders: void 0,
            instanceName: void 0,
            isolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            language: DEFAULT_LANGUAGE,
            localAddress: void 0,
            maxRetriesOnTransientErrors: 3,
            multiSubnetFailover: false,
            packetSize: DEFAULT_PACKET_SIZE,
            port: DEFAULT_PORT,
            readOnlyIntent: false,
            requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,
            rowCollectionOnDone: false,
            rowCollectionOnRequestCompletion: false,
            serverName: void 0,
            serverSupportsColumnEncryption: false,
            tdsVersion: DEFAULT_TDS_VERSION,
            textsize: DEFAULT_TEXTSIZE,
            trustedServerNameAE: void 0,
            trustServerCertificate: false,
            useColumnNames: false,
            useUTC: true,
            workstationId: void 0,
            lowerCaseGuids: false
          }
        };
        if (config.options) {
          if (config.options.port && config.options.instanceName) {
            throw new Error("Port and instanceName are mutually exclusive, but " + config.options.port + " and " + config.options.instanceName + " provided");
          }
          if (config.options.abortTransactionOnError !== void 0) {
            if (typeof config.options.abortTransactionOnError !== "boolean" && config.options.abortTransactionOnError !== null) {
              throw new TypeError('The "config.options.abortTransactionOnError" property must be of type string or null.');
            }
            this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;
          }
          if (config.options.appName !== void 0) {
            if (typeof config.options.appName !== "string") {
              throw new TypeError('The "config.options.appName" property must be of type string.');
            }
            this.config.options.appName = config.options.appName;
          }
          if (config.options.camelCaseColumns !== void 0) {
            if (typeof config.options.camelCaseColumns !== "boolean") {
              throw new TypeError('The "config.options.camelCaseColumns" property must be of type boolean.');
            }
            this.config.options.camelCaseColumns = config.options.camelCaseColumns;
          }
          if (config.options.cancelTimeout !== void 0) {
            if (typeof config.options.cancelTimeout !== "number") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type number.');
            }
            this.config.options.cancelTimeout = config.options.cancelTimeout;
          }
          if (config.options.columnNameReplacer) {
            if (typeof config.options.columnNameReplacer !== "function") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type function.');
            }
            this.config.options.columnNameReplacer = config.options.columnNameReplacer;
          }
          if (config.options.connectionIsolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.connectionIsolationLevel, "config.options.connectionIsolationLevel");
            this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;
          }
          if (config.options.connectTimeout !== void 0) {
            if (typeof config.options.connectTimeout !== "number") {
              throw new TypeError('The "config.options.connectTimeout" property must be of type number.');
            }
            this.config.options.connectTimeout = config.options.connectTimeout;
          }
          if (config.options.connector !== void 0) {
            if (typeof config.options.connector !== "function") {
              throw new TypeError('The "config.options.connector" property must be a function.');
            }
            this.config.options.connector = config.options.connector;
          }
          if (config.options.cryptoCredentialsDetails !== void 0) {
            if (typeof config.options.cryptoCredentialsDetails !== "object" || config.options.cryptoCredentialsDetails === null) {
              throw new TypeError('The "config.options.cryptoCredentialsDetails" property must be of type Object.');
            }
            this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;
          }
          if (config.options.database !== void 0) {
            if (typeof config.options.database !== "string") {
              throw new TypeError('The "config.options.database" property must be of type string.');
            }
            this.config.options.database = config.options.database;
          }
          if (config.options.datefirst !== void 0) {
            if (typeof config.options.datefirst !== "number" && config.options.datefirst !== null) {
              throw new TypeError('The "config.options.datefirst" property must be of type number.');
            }
            if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {
              throw new RangeError('The "config.options.datefirst" property must be >= 1 and <= 7');
            }
            this.config.options.datefirst = config.options.datefirst;
          }
          if (config.options.dateFormat !== void 0) {
            if (typeof config.options.dateFormat !== "string" && config.options.dateFormat !== null) {
              throw new TypeError('The "config.options.dateFormat" property must be of type string or null.');
            }
            this.config.options.dateFormat = config.options.dateFormat;
          }
          if (config.options.debug) {
            if (config.options.debug.data !== void 0) {
              if (typeof config.options.debug.data !== "boolean") {
                throw new TypeError('The "config.options.debug.data" property must be of type boolean.');
              }
              this.config.options.debug.data = config.options.debug.data;
            }
            if (config.options.debug.packet !== void 0) {
              if (typeof config.options.debug.packet !== "boolean") {
                throw new TypeError('The "config.options.debug.packet" property must be of type boolean.');
              }
              this.config.options.debug.packet = config.options.debug.packet;
            }
            if (config.options.debug.payload !== void 0) {
              if (typeof config.options.debug.payload !== "boolean") {
                throw new TypeError('The "config.options.debug.payload" property must be of type boolean.');
              }
              this.config.options.debug.payload = config.options.debug.payload;
            }
            if (config.options.debug.token !== void 0) {
              if (typeof config.options.debug.token !== "boolean") {
                throw new TypeError('The "config.options.debug.token" property must be of type boolean.');
              }
              this.config.options.debug.token = config.options.debug.token;
            }
          }
          if (config.options.enableAnsiNull !== void 0) {
            if (typeof config.options.enableAnsiNull !== "boolean" && config.options.enableAnsiNull !== null) {
              throw new TypeError('The "config.options.enableAnsiNull" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNull = config.options.enableAnsiNull;
          }
          if (config.options.enableAnsiNullDefault !== void 0) {
            if (typeof config.options.enableAnsiNullDefault !== "boolean" && config.options.enableAnsiNullDefault !== null) {
              throw new TypeError('The "config.options.enableAnsiNullDefault" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;
          }
          if (config.options.enableAnsiPadding !== void 0) {
            if (typeof config.options.enableAnsiPadding !== "boolean" && config.options.enableAnsiPadding !== null) {
              throw new TypeError('The "config.options.enableAnsiPadding" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;
          }
          if (config.options.enableAnsiWarnings !== void 0) {
            if (typeof config.options.enableAnsiWarnings !== "boolean" && config.options.enableAnsiWarnings !== null) {
              throw new TypeError('The "config.options.enableAnsiWarnings" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;
          }
          if (config.options.enableArithAbort !== void 0) {
            if (typeof config.options.enableArithAbort !== "boolean" && config.options.enableArithAbort !== null) {
              throw new TypeError('The "config.options.enableArithAbort" property must be of type boolean or null.');
            }
            this.config.options.enableArithAbort = config.options.enableArithAbort;
          }
          if (config.options.enableConcatNullYieldsNull !== void 0) {
            if (typeof config.options.enableConcatNullYieldsNull !== "boolean" && config.options.enableConcatNullYieldsNull !== null) {
              throw new TypeError('The "config.options.enableConcatNullYieldsNull" property must be of type boolean or null.');
            }
            this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;
          }
          if (config.options.enableCursorCloseOnCommit !== void 0) {
            if (typeof config.options.enableCursorCloseOnCommit !== "boolean" && config.options.enableCursorCloseOnCommit !== null) {
              throw new TypeError('The "config.options.enableCursorCloseOnCommit" property must be of type boolean or null.');
            }
            this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;
          }
          if (config.options.enableImplicitTransactions !== void 0) {
            if (typeof config.options.enableImplicitTransactions !== "boolean" && config.options.enableImplicitTransactions !== null) {
              throw new TypeError('The "config.options.enableImplicitTransactions" property must be of type boolean or null.');
            }
            this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;
          }
          if (config.options.enableNumericRoundabort !== void 0) {
            if (typeof config.options.enableNumericRoundabort !== "boolean" && config.options.enableNumericRoundabort !== null) {
              throw new TypeError('The "config.options.enableNumericRoundabort" property must be of type boolean or null.');
            }
            this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;
          }
          if (config.options.enableQuotedIdentifier !== void 0) {
            if (typeof config.options.enableQuotedIdentifier !== "boolean" && config.options.enableQuotedIdentifier !== null) {
              throw new TypeError('The "config.options.enableQuotedIdentifier" property must be of type boolean or null.');
            }
            this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;
          }
          if (config.options.encrypt !== void 0) {
            if (typeof config.options.encrypt !== "boolean") {
              if (config.options.encrypt !== "strict") {
                throw new TypeError('The "encrypt" property must be set to "strict", or of type boolean.');
              }
            }
            this.config.options.encrypt = config.options.encrypt;
          }
          if (config.options.fallbackToDefaultDb !== void 0) {
            if (typeof config.options.fallbackToDefaultDb !== "boolean") {
              throw new TypeError('The "config.options.fallbackToDefaultDb" property must be of type boolean.');
            }
            this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;
          }
          if (config.options.instanceName !== void 0) {
            if (typeof config.options.instanceName !== "string") {
              throw new TypeError('The "config.options.instanceName" property must be of type string.');
            }
            this.config.options.instanceName = config.options.instanceName;
            this.config.options.port = void 0;
          }
          if (config.options.isolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.isolationLevel, "config.options.isolationLevel");
            this.config.options.isolationLevel = config.options.isolationLevel;
          }
          if (config.options.language !== void 0) {
            if (typeof config.options.language !== "string" && config.options.language !== null) {
              throw new TypeError('The "config.options.language" property must be of type string or null.');
            }
            this.config.options.language = config.options.language;
          }
          if (config.options.localAddress !== void 0) {
            if (typeof config.options.localAddress !== "string") {
              throw new TypeError('The "config.options.localAddress" property must be of type string.');
            }
            this.config.options.localAddress = config.options.localAddress;
          }
          if (config.options.multiSubnetFailover !== void 0) {
            if (typeof config.options.multiSubnetFailover !== "boolean") {
              throw new TypeError('The "config.options.multiSubnetFailover" property must be of type boolean.');
            }
            this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;
          }
          if (config.options.packetSize !== void 0) {
            if (typeof config.options.packetSize !== "number") {
              throw new TypeError('The "config.options.packetSize" property must be of type number.');
            }
            this.config.options.packetSize = config.options.packetSize;
          }
          if (config.options.port !== void 0) {
            if (typeof config.options.port !== "number") {
              throw new TypeError('The "config.options.port" property must be of type number.');
            }
            if (config.options.port <= 0 || config.options.port >= 65536) {
              throw new RangeError('The "config.options.port" property must be > 0 and < 65536');
            }
            this.config.options.port = config.options.port;
            this.config.options.instanceName = void 0;
          }
          if (config.options.readOnlyIntent !== void 0) {
            if (typeof config.options.readOnlyIntent !== "boolean") {
              throw new TypeError('The "config.options.readOnlyIntent" property must be of type boolean.');
            }
            this.config.options.readOnlyIntent = config.options.readOnlyIntent;
          }
          if (config.options.requestTimeout !== void 0) {
            if (typeof config.options.requestTimeout !== "number") {
              throw new TypeError('The "config.options.requestTimeout" property must be of type number.');
            }
            this.config.options.requestTimeout = config.options.requestTimeout;
          }
          if (config.options.maxRetriesOnTransientErrors !== void 0) {
            if (typeof config.options.maxRetriesOnTransientErrors !== "number") {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be of type number.');
            }
            if (config.options.maxRetriesOnTransientErrors < 0) {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be equal or greater than 0.');
            }
            this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;
          }
          if (config.options.connectionRetryInterval !== void 0) {
            if (typeof config.options.connectionRetryInterval !== "number") {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be of type number.');
            }
            if (config.options.connectionRetryInterval <= 0) {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be greater than 0.');
            }
            this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;
          }
          if (config.options.rowCollectionOnDone !== void 0) {
            if (typeof config.options.rowCollectionOnDone !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnDone" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;
          }
          if (config.options.rowCollectionOnRequestCompletion !== void 0) {
            if (typeof config.options.rowCollectionOnRequestCompletion !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnRequestCompletion" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;
          }
          if (config.options.tdsVersion !== void 0) {
            if (typeof config.options.tdsVersion !== "string") {
              throw new TypeError('The "config.options.tdsVersion" property must be of type string.');
            }
            this.config.options.tdsVersion = config.options.tdsVersion;
          }
          if (config.options.textsize !== void 0) {
            if (typeof config.options.textsize !== "number" && config.options.textsize !== null) {
              throw new TypeError('The "config.options.textsize" property must be of type number or null.');
            }
            if (config.options.textsize > 2147483647) {
              throw new TypeError(`The "config.options.textsize" can't be greater than 2147483647.`);
            } else if (config.options.textsize < -1) {
              throw new TypeError(`The "config.options.textsize" can't be smaller than -1.`);
            }
            this.config.options.textsize = config.options.textsize | 0;
          }
          if (config.options.trustServerCertificate !== void 0) {
            if (typeof config.options.trustServerCertificate !== "boolean") {
              throw new TypeError('The "config.options.trustServerCertificate" property must be of type boolean.');
            }
            this.config.options.trustServerCertificate = config.options.trustServerCertificate;
          }
          if (config.options.serverName !== void 0) {
            if (typeof config.options.serverName !== "string") {
              throw new TypeError('The "config.options.serverName" property must be of type string.');
            }
            this.config.options.serverName = config.options.serverName;
          }
          if (config.options.useColumnNames !== void 0) {
            if (typeof config.options.useColumnNames !== "boolean") {
              throw new TypeError('The "config.options.useColumnNames" property must be of type boolean.');
            }
            this.config.options.useColumnNames = config.options.useColumnNames;
          }
          if (config.options.useUTC !== void 0) {
            if (typeof config.options.useUTC !== "boolean") {
              throw new TypeError('The "config.options.useUTC" property must be of type boolean.');
            }
            this.config.options.useUTC = config.options.useUTC;
          }
          if (config.options.workstationId !== void 0) {
            if (typeof config.options.workstationId !== "string") {
              throw new TypeError('The "config.options.workstationId" property must be of type string.');
            }
            this.config.options.workstationId = config.options.workstationId;
          }
          if (config.options.lowerCaseGuids !== void 0) {
            if (typeof config.options.lowerCaseGuids !== "boolean") {
              throw new TypeError('The "config.options.lowerCaseGuids" property must be of type boolean.');
            }
            this.config.options.lowerCaseGuids = config.options.lowerCaseGuids;
          }
        }
        this.secureContextOptions = this.config.options.cryptoCredentialsDetails;
        if (this.secureContextOptions.secureOptions === void 0) {
          this.secureContextOptions = Object.create(this.secureContextOptions, {
            secureOptions: {
              value: _constants.default.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
            }
          });
        }
        this.debug = this.createDebug();
        this.inTransaction = false;
        this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])];
        this.transactionDepth = 0;
        this.isSqlBatch = false;
        this.closed = false;
        this.messageBuffer = Buffer.alloc(0);
        this.curTransientRetryCount = 0;
        this.transientErrorLookup = new _transientErrorLookup.TransientErrorLookup();
        this.state = this.STATE.INITIALIZED;
        this._cancelAfterRequestSent = () => {
          this.messageIo.sendMessage(_packet.TYPE.ATTENTION);
          this.createCancelTimer();
        };
      }
      connect(connectListener) {
        if (this.state !== this.STATE.INITIALIZED) {
          throw new _errors.ConnectionError("`.connect` can not be called on a Connection in `" + this.state.name + "` state.");
        }
        if (connectListener) {
          const onConnect = (err) => {
            this.removeListener("error", onError);
            connectListener(err);
          };
          const onError = (err) => {
            this.removeListener("connect", onConnect);
            connectListener(err);
          };
          this.once("connect", onConnect);
          this.once("error", onError);
        }
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * The server has reported that the charset has changed.
       */
      /**
       * The attempt to connect and validate has completed.
       */
      /**
       * The server has reported that the active database has changed.
       * This may be as a result of a successful login, or a `use` statement.
       */
      /**
       * A debug message is available. It may be logged or ignored.
       */
      /**
       * Internal error occurs.
       */
      /**
       * The server has issued an error message.
       */
      /**
       * The connection has ended.
       *
       * This may be as a result of the client calling [[close]], the server
       * closing the connection, or a network error.
       */
      /**
       * The server has issued an information message.
       */
      /**
       * The server has reported that the language has changed.
       */
      /**
       * The connection was reset.
       */
      /**
       * A secure connection has been established.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * Closes the connection to the database.
       *
       * The [[Event_end]] will be emitted once the connection has been closed.
       */
      close() {
        this.transitionTo(this.STATE.FINAL);
      }
      /**
       * @private
       */
      initialiseConnection() {
        const signal = this.createConnectTimer();
        if (this.config.options.port) {
          return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
        } else {
          return (0, _instanceLookup.instanceLookup)({
            server: this.config.server,
            instanceName: this.config.options.instanceName,
            timeout: this.config.options.connectTimeout,
            signal
          }).then((port) => {
            process.nextTick(() => {
              this.connectOnPort(port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
            });
          }, (err) => {
            this.clearConnectTimer();
            if (signal.aborted) {
              return;
            }
            process.nextTick(() => {
              this.emit("connect", new _errors.ConnectionError(err.message, "EINSTLOOKUP", {
                cause: err
              }));
            });
          });
        }
      }
      /**
       * @private
       */
      cleanupConnection(cleanupType) {
        if (!this.closed) {
          this.clearConnectTimer();
          this.clearRequestTimer();
          this.clearRetryTimer();
          this.closeConnection();
          if (cleanupType === CLEANUP_TYPE.REDIRECT) {
            this.emit("rerouting");
          } else if (cleanupType !== CLEANUP_TYPE.RETRY) {
            process.nextTick(() => {
              this.emit("end");
            });
          }
          const request3 = this.request;
          if (request3) {
            const err = new _errors.RequestError("Connection closed before request completed.", "ECLOSE");
            request3.callback(err);
            this.request = void 0;
          }
          this.closed = true;
          this.loginError = void 0;
        }
      }
      /**
       * @private
       */
      createDebug() {
        const debug = new _debug.default(this.config.options.debug);
        debug.on("debug", (message) => {
          this.emit("debug", message);
        });
        return debug;
      }
      /**
       * @private
       */
      createTokenStreamParser(message, handler) {
        return new _tokenStreamParser.Parser(message, this.debug, handler, this.config.options);
      }
      socketHandlingForSendPreLogin(socket) {
        socket.on("error", (error) => {
          this.socketError(error);
        });
        socket.on("close", () => {
          this.socketClose();
        });
        socket.on("end", () => {
          this.socketEnd();
        });
        socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);
        this.messageIo = new _messageIo.default(socket, this.config.options.packetSize, this.debug);
        this.messageIo.on("secure", (cleartext) => {
          this.emit("secure", cleartext);
        });
        this.socket = socket;
        this.closed = false;
        this.debug.log("connected to " + this.config.server + ":" + this.config.options.port);
        this.sendPreLogin();
        this.transitionTo(this.STATE.SENT_PRELOGIN);
      }
      wrapWithTls(socket, signal) {
        signal.throwIfAborted();
        return new Promise((resolve, reject) => {
          const secureContext = tls.createSecureContext(this.secureContextOptions);
          const serverName = !net.isIP(this.config.server) ? this.config.server : "";
          const encryptOptions = {
            host: this.config.server,
            socket,
            ALPNProtocols: ["tds/8.0"],
            secureContext,
            servername: this.config.options.serverName ? this.config.options.serverName : serverName
          };
          const encryptsocket = tls.connect(encryptOptions);
          const onAbort = () => {
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(signal.reason);
          };
          const onError = (err) => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(err);
          };
          const onConnect = () => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            resolve(encryptsocket);
          };
          signal.addEventListener("abort", onAbort, {
            once: true
          });
          encryptsocket.on("error", onError);
          encryptsocket.on("secureConnect", onConnect);
        });
      }
      connectOnPort(port, multiSubnetFailover, signal, customConnector) {
        const connectOpts = {
          host: this.routingData ? this.routingData.server : this.config.server,
          port: this.routingData ? this.routingData.port : port,
          localAddress: this.config.options.localAddress
        };
        const connect = customConnector || (multiSubnetFailover ? _connector.connectInParallel : _connector.connectInSequence);
        (async () => {
          let socket = await connect(connectOpts, _dns.default.lookup, signal);
          if (this.config.options.encrypt === "strict") {
            try {
              socket = await this.wrapWithTls(socket, signal);
            } catch (err) {
              socket.end();
              throw err;
            }
          }
          this.socketHandlingForSendPreLogin(socket);
        })().catch((err) => {
          this.clearConnectTimer();
          if (signal.aborted) {
            return;
          }
          process.nextTick(() => {
            this.socketError(err);
          });
        });
      }
      /**
       * @private
       */
      closeConnection() {
        if (this.socket) {
          this.socket.destroy();
        }
      }
      /**
       * @private
       */
      createConnectTimer() {
        const controller = new AbortController();
        this.connectTimer = setTimeout(() => {
          controller.abort();
          this.connectTimeout();
        }, this.config.options.connectTimeout);
        return controller.signal;
      }
      /**
       * @private
       */
      createCancelTimer() {
        this.clearCancelTimer();
        const timeout = this.config.options.cancelTimeout;
        if (timeout > 0) {
          this.cancelTimer = setTimeout(() => {
            this.cancelTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRequestTimer() {
        this.clearRequestTimer();
        const request3 = this.request;
        const timeout = request3.timeout !== void 0 ? request3.timeout : this.config.options.requestTimeout;
        if (timeout) {
          this.requestTimer = setTimeout(() => {
            this.requestTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRetryTimer() {
        this.clearRetryTimer();
        this.retryTimer = setTimeout(() => {
          this.retryTimeout();
        }, this.config.options.connectionRetryInterval);
      }
      /**
       * @private
       */
      connectTimeout() {
        const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
        const server = this.routingData ? this.routingData.server : this.config.server;
        const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
        const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
        const message = `Failed to connect to ${server}${port}${routingMessage} in ${this.config.options.connectTimeout}ms`;
        this.debug.log(message);
        this.emit("connect", new _errors.ConnectionError(message, "ETIMEOUT"));
        this.connectTimer = void 0;
        this.dispatchEvent("connectTimeout");
      }
      /**
       * @private
       */
      cancelTimeout() {
        const message = `Failed to cancel request in ${this.config.options.cancelTimeout}ms`;
        this.debug.log(message);
        this.dispatchEvent("socketError", new _errors.ConnectionError(message, "ETIMEOUT"));
      }
      /**
       * @private
       */
      requestTimeout() {
        this.requestTimer = void 0;
        const request3 = this.request;
        request3.cancel();
        const timeout = request3.timeout !== void 0 ? request3.timeout : this.config.options.requestTimeout;
        const message = "Timeout: Request failed to complete in " + timeout + "ms";
        request3.error = new _errors.RequestError(message, "ETIMEOUT");
      }
      /**
       * @private
       */
      retryTimeout() {
        this.retryTimer = void 0;
        this.emit("retry");
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * @private
       */
      clearConnectTimer() {
        if (this.connectTimer) {
          clearTimeout(this.connectTimer);
          this.connectTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearCancelTimer() {
        if (this.cancelTimer) {
          clearTimeout(this.cancelTimer);
          this.cancelTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRequestTimer() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
          this.requestTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRetryTimer() {
        if (this.retryTimer) {
          clearTimeout(this.retryTimer);
          this.retryTimer = void 0;
        }
      }
      /**
       * @private
       */
      transitionTo(newState) {
        if (this.state === newState) {
          this.debug.log("State is already " + newState.name);
          return;
        }
        if (this.state && this.state.exit) {
          this.state.exit.call(this, newState);
        }
        this.debug.log("State change: " + (this.state ? this.state.name : "undefined") + " -> " + newState.name);
        this.state = newState;
        if (this.state.enter) {
          this.state.enter.apply(this);
        }
      }
      /**
       * @private
       */
      getEventHandler(eventName) {
        const handler = this.state.events[eventName];
        if (!handler) {
          throw new Error(`No event '${eventName}' in state '${this.state.name}'`);
        }
        return handler;
      }
      /**
       * @private
       */
      dispatchEvent(eventName, ...args) {
        const handler = this.state.events[eventName];
        if (handler) {
          handler.apply(this, args);
        } else {
          this.emit("error", new Error(`No event '${eventName}' in state '${this.state.name}'`));
          this.close();
        }
      }
      /**
       * @private
       */
      socketError(error) {
        if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {
          const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
          const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
          const message = `Failed to connect to ${server}${port}${routingMessage} - ${error.message}`;
          this.debug.log(message);
          this.emit("connect", new _errors.ConnectionError(message, "ESOCKET", {
            cause: error
          }));
        } else {
          const message = `Connection lost - ${error.message}`;
          this.debug.log(message);
          this.emit("error", new _errors.ConnectionError(message, "ESOCKET", {
            cause: error
          }));
        }
        this.dispatchEvent("socketError", error);
      }
      /**
       * @private
       */
      socketEnd() {
        this.debug.log("socket ended");
        if (this.state !== this.STATE.FINAL) {
          const error = new Error("socket hang up");
          error.code = "ECONNRESET";
          this.socketError(error);
        }
      }
      /**
       * @private
       */
      socketClose() {
        this.debug.log("connection to " + this.config.server + ":" + this.config.options.port + " closed");
        if (this.state === this.STATE.REROUTING) {
          this.debug.log("Rerouting to " + this.routingData.server + ":" + this.routingData.port);
          this.dispatchEvent("reconnect");
        } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? this.routingData.port : this.config.options.port;
          this.debug.log("Retry after transient failure connecting to " + server + ":" + port);
          this.dispatchEvent("retry");
        } else {
          this.transitionTo(this.STATE.FINAL);
        }
      }
      /**
       * @private
       */
      sendPreLogin() {
        const [, major, minor, build] = /^(\d+)\.(\d+)\.(\d+)/.exec(_package.version) ?? ["0.0.0", "0", "0", "0"];
        const payload = new _preloginPayload.default({
          // If encrypt setting is set to 'strict', then we should have already done the encryption before calling
          // this function. Therefore, the encrypt will be set to false here.
          // Otherwise, we will set encrypt here based on the encrypt Boolean value from the configuration.
          encrypt: typeof this.config.options.encrypt === "boolean" && this.config.options.encrypt,
          version: {
            major: Number(major),
            minor: Number(minor),
            build: Number(build),
            subbuild: 0
          }
        });
        this.messageIo.sendMessage(_packet.TYPE.PRELOGIN, payload.data);
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendLogin7Packet() {
        const payload = new _login7Payload.default({
          tdsVersion: _tdsVersions.versions[this.config.options.tdsVersion],
          packetSize: this.config.options.packetSize,
          clientProgVer: 0,
          clientPid: process.pid,
          connectionId: 0,
          clientTimeZone: (/* @__PURE__ */ new Date()).getTimezoneOffset(),
          clientLcid: 1033
        });
        const {
          authentication
        } = this.config;
        switch (authentication.type) {
          case "azure-active-directory-password":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "default"
            };
            break;
          case "azure-active-directory-access-token":
            payload.fedAuth = {
              type: "SECURITYTOKEN",
              echo: this.fedAuthRequired,
              fedAuthToken: authentication.options.token
            };
            break;
          case "token-credential":
          case "azure-active-directory-msi-vm":
          case "azure-active-directory-default":
          case "azure-active-directory-msi-app-service":
          case "azure-active-directory-service-principal-secret":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "integrated"
            };
            break;
          case "ntlm":
            payload.sspi = (0, _ntlm.createNTLMRequest)({
              domain: authentication.options.domain
            });
            break;
          default:
            payload.userName = authentication.options.userName;
            payload.password = authentication.options.password;
        }
        payload.hostname = this.config.options.workstationId || _os.default.hostname();
        payload.serverName = this.routingData ? this.routingData.server : this.config.server;
        payload.appName = this.config.options.appName || "Tedious";
        payload.libraryName = _library.name;
        payload.language = this.config.options.language;
        payload.database = this.config.options.database;
        payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);
        payload.readOnlyIntent = this.config.options.readOnlyIntent;
        payload.initDbFatal = !this.config.options.fallbackToDefaultDb;
        this.routingData = void 0;
        this.messageIo.sendMessage(_packet.TYPE.LOGIN7, payload.toBuffer());
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendFedAuthTokenMessage(token) {
        const accessTokenLen = Buffer.byteLength(token, "ucs2");
        const data = Buffer.alloc(8 + accessTokenLen);
        let offset = 0;
        offset = data.writeUInt32LE(accessTokenLen + 4, offset);
        offset = data.writeUInt32LE(accessTokenLen, offset);
        data.write(token, offset, "ucs2");
        this.messageIo.sendMessage(_packet.TYPE.FEDAUTH_TOKEN, data);
        this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
      }
      /**
       * @private
       */
      sendInitialSql() {
        const payload = new _sqlbatchPayload.default(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);
        const message = new _message.default({
          type: _packet.TYPE.SQL_BATCH
        });
        this.messageIo.outgoingMessageStream.write(message);
        _stream.Readable.from(payload).pipe(message);
      }
      /**
       * @private
       */
      getInitialSql() {
        const options = [];
        if (this.config.options.enableAnsiNull === true) {
          options.push("set ansi_nulls on");
        } else if (this.config.options.enableAnsiNull === false) {
          options.push("set ansi_nulls off");
        }
        if (this.config.options.enableAnsiNullDefault === true) {
          options.push("set ansi_null_dflt_on on");
        } else if (this.config.options.enableAnsiNullDefault === false) {
          options.push("set ansi_null_dflt_on off");
        }
        if (this.config.options.enableAnsiPadding === true) {
          options.push("set ansi_padding on");
        } else if (this.config.options.enableAnsiPadding === false) {
          options.push("set ansi_padding off");
        }
        if (this.config.options.enableAnsiWarnings === true) {
          options.push("set ansi_warnings on");
        } else if (this.config.options.enableAnsiWarnings === false) {
          options.push("set ansi_warnings off");
        }
        if (this.config.options.enableArithAbort === true) {
          options.push("set arithabort on");
        } else if (this.config.options.enableArithAbort === false) {
          options.push("set arithabort off");
        }
        if (this.config.options.enableConcatNullYieldsNull === true) {
          options.push("set concat_null_yields_null on");
        } else if (this.config.options.enableConcatNullYieldsNull === false) {
          options.push("set concat_null_yields_null off");
        }
        if (this.config.options.enableCursorCloseOnCommit === true) {
          options.push("set cursor_close_on_commit on");
        } else if (this.config.options.enableCursorCloseOnCommit === false) {
          options.push("set cursor_close_on_commit off");
        }
        if (this.config.options.datefirst !== null) {
          options.push(`set datefirst ${this.config.options.datefirst}`);
        }
        if (this.config.options.dateFormat !== null) {
          options.push(`set dateformat ${this.config.options.dateFormat}`);
        }
        if (this.config.options.enableImplicitTransactions === true) {
          options.push("set implicit_transactions on");
        } else if (this.config.options.enableImplicitTransactions === false) {
          options.push("set implicit_transactions off");
        }
        if (this.config.options.language !== null) {
          options.push(`set language ${this.config.options.language}`);
        }
        if (this.config.options.enableNumericRoundabort === true) {
          options.push("set numeric_roundabort on");
        } else if (this.config.options.enableNumericRoundabort === false) {
          options.push("set numeric_roundabort off");
        }
        if (this.config.options.enableQuotedIdentifier === true) {
          options.push("set quoted_identifier on");
        } else if (this.config.options.enableQuotedIdentifier === false) {
          options.push("set quoted_identifier off");
        }
        if (this.config.options.textsize !== null) {
          options.push(`set textsize ${this.config.options.textsize}`);
        }
        if (this.config.options.connectionIsolationLevel !== null) {
          options.push(`set transaction isolation level ${this.getIsolationLevelText(this.config.options.connectionIsolationLevel)}`);
        }
        if (this.config.options.abortTransactionOnError === true) {
          options.push("set xact_abort on");
        } else if (this.config.options.abortTransactionOnError === false) {
          options.push("set xact_abort off");
        }
        return options.join("\n");
      }
      /**
       * @private
       */
      processedInitialSql() {
        this.clearConnectTimer();
        this.emit("connect");
      }
      /**
       * Execute the SQL batch represented by [[Request]].
       * There is no param support, and unlike [[Request.execSql]],
       * it is not likely that SQL Server will reuse the execution plan it generates for the SQL.
       *
       * In almost all cases, [[Request.execSql]] will be a better choice.
       *
       * @param request A [[Request]] object representing the request.
       */
      execSqlBatch(request3) {
        this.makeRequest(request3, _packet.TYPE.SQL_BATCH, new _sqlbatchPayload.default(request3.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));
      }
      /**
       *  Execute the SQL represented by [[Request]].
       *
       * As `sp_executesql` is used to execute the SQL, if the same SQL is executed multiples times
       * using this function, the SQL Server query optimizer is likely to reuse the execution plan it generates
       * for the first execution. This may also result in SQL server treating the request like a stored procedure
       * which can result in the [[Event_doneInProc]] or [[Event_doneProc]] events being emitted instead of the
       * [[Event_done]] event you might expect. Using [[execSqlBatch]] will prevent this from occurring but may have a negative performance impact.
       *
       * Beware of the way that scoping rules apply, and how they may [affect local temp tables](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)
       * If you're running in to scoping issues, then [[execSqlBatch]] may be a better choice.
       * See also [issue #24](https://github.com/pekim/tedious/issues/24)
       *
       * @param request A [[Request]] object representing the request.
       */
      execSql(request3) {
        try {
          request3.validateParameters(this.databaseCollation);
        } catch (error) {
          request3.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request3.callback(error);
          });
          return;
        }
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "statement",
          value: request3.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        if (request3.parameters.length) {
          parameters.push({
            type: _dataType.TYPES.NVarChar,
            name: "params",
            value: request3.makeParamsParameter(request3.parameters),
            output: false,
            length: void 0,
            precision: void 0,
            scale: void 0
          });
          parameters.push(...request3.parameters);
        }
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_ExecuteSql, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Creates a new BulkLoad instance.
       *
       * @param table The name of the table to bulk-insert into.
       * @param options A set of bulk load options.
       */
      newBulkLoad(table, callbackOrOptions, callback) {
        let options;
        if (callback === void 0) {
          callback = callbackOrOptions;
          options = {};
        } else {
          options = callbackOrOptions;
        }
        if (typeof options !== "object") {
          throw new TypeError('"options" argument must be an object');
        }
        return new _bulkLoad.default(table, this.databaseCollation, this.config.options, options, callback);
      }
      /**
       * Execute a [[BulkLoad]].
       *
       * ```js
       * // We want to perform a bulk load into a table with the following format:
       * // CREATE TABLE employees (first_name nvarchar(255), last_name nvarchar(255), day_of_birth date);
       *
       * const bulkLoad = connection.newBulkLoad('employees', (err, rowCount) => {
       *   // ...
       * });
       *
       * // First, we need to specify the columns that we want to write to,
       * // and their definitions. These definitions must match the actual table,
       * // otherwise the bulk load will fail.
       * bulkLoad.addColumn('first_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('last_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('date_of_birth', TYPES.Date, { nullable: false });
       *
       * // Execute a bulk load with a predefined list of rows.
       * //
       * // Note that these rows are held in memory until the
       * // bulk load was performed, so if you need to write a large
       * // number of rows (e.g. by reading from a CSV file),
       * // passing an `AsyncIterable` is advisable to keep memory usage low.
       * connection.execBulkLoad(bulkLoad, [
       *   { 'first_name': 'Steve', 'last_name': 'Jobs', 'day_of_birth': new Date('02-24-1955') },
       *   { 'first_name': 'Bill', 'last_name': 'Gates', 'day_of_birth': new Date('10-28-1955') }
       * ]);
       * ```
       *
       * @param bulkLoad A previously created [[BulkLoad]].
       * @param rows A [[Iterable]] or [[AsyncIterable]] that contains the rows that should be bulk loaded.
       */
      execBulkLoad(bulkLoad, rows) {
        bulkLoad.executionStarted = true;
        if (rows) {
          if (bulkLoad.streamingMode) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that was put in streaming mode.");
          }
          if (bulkLoad.firstRowWritten) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that already has rows written to it.");
          }
          const rowStream = _stream.Readable.from(rows);
          rowStream.on("error", (err) => {
            bulkLoad.rowToPacketTransform.destroy(err);
          });
          bulkLoad.rowToPacketTransform.on("error", (err) => {
            rowStream.destroy(err);
          });
          rowStream.pipe(bulkLoad.rowToPacketTransform);
        } else if (!bulkLoad.streamingMode) {
          bulkLoad.rowToPacketTransform.end();
        }
        const onCancel = () => {
          request3.cancel();
        };
        const payload = new _bulkLoadPayload.BulkLoadPayload(bulkLoad);
        const request3 = new _request.default(bulkLoad.getBulkInsertSql(), (error) => {
          bulkLoad.removeListener("cancel", onCancel);
          if (error) {
            if (error.code === "UNKNOWN") {
              error.message += " This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.";
            }
            bulkLoad.error = error;
            bulkLoad.callback(error);
            return;
          }
          this.makeRequest(bulkLoad, _packet.TYPE.BULK_LOAD, payload);
        });
        bulkLoad.once("cancel", onCancel);
        this.execSqlBatch(request3);
      }
      /**
       * Prepare the SQL represented by the request.
       *
       * The request can then be used in subsequent calls to
       * [[execute]] and [[unprepare]]
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type. Parameter values are ignored.
       */
      prepare(request3) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          value: void 0,
          output: true,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "params",
          value: request3.parameters.length ? request3.makeParamsParameter(request3.parameters) : null,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "stmt",
          value: request3.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        request3.preparing = true;
        request3.on("returnValue", (name3, value) => {
          if (name3 === "handle") {
            request3.handle = value;
          } else {
            request3.error = new _errors.RequestError(`Tedious > Unexpected output parameter ${name3} from sp_prepare`);
          }
        });
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Prepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Release the SQL Server resources associated with a previously prepared request.
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type.
       *   Parameter values are ignored.
       */
      unprepare(request3) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          // TODO: Abort if `request.handle` is not set
          value: request3.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Unprepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Execute previously prepared SQL, using the supplied parameters.
       *
       * @param request A previously prepared [[Request]].
       * @param parameters  An object whose names correspond to the names of
       *   parameters that were added to the [[Request]] before it was prepared.
       *   The object's values are passed as the parameters' values when the
       *   request is executed.
       */
      execute(request3, parameters) {
        const executeParameters = [];
        executeParameters.push({
          type: _dataType.TYPES.Int,
          name: "",
          // TODO: Abort if `request.handle` is not set
          value: request3.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        try {
          for (let i = 0, len = request3.parameters.length; i < len; i++) {
            const parameter = request3.parameters[i];
            executeParameters.push({
              ...parameter,
              value: parameter.type.validate(parameters ? parameters[parameter.name] : null, this.databaseCollation)
            });
          }
        } catch (error) {
          request3.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request3.callback(error);
          });
          return;
        }
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Execute, executeParameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Call a stored procedure represented by [[Request]].
       *
       * @param request A [[Request]] object representing the request.
       */
      callProcedure(request3) {
        try {
          request3.validateParameters(this.databaseCollation);
        } catch (error) {
          request3.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request3.callback(error);
          });
          return;
        }
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request3.sqlTextOrProcedure, request3.parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Start a transaction.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`
       *   is present.
       * @param isolationLevel The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      beginTransaction(callback, name3 = "", isolationLevel = this.config.options.isolationLevel) {
        (0, _transaction.assertValidIsolationLevel)(isolationLevel, "isolationLevel");
        const transaction = new _transaction.Transaction(name3, isolationLevel);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SET TRANSACTION ISOLATION LEVEL " + transaction.isolationLevelToTSQL() + ";BEGIN TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            if (this.transactionDepth === 1) {
              this.inTransaction = true;
            }
            callback(err);
          }));
        }
        const request3 = new _request.default(void 0, (err) => {
          return callback(err, this.currentTransactionDescriptor());
        });
        return this.makeRequest(request3, _packet.TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Commit a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`is present.
       */
      commitTransaction(callback, name3 = "") {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("COMMIT TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request3 = new _request.default(void 0, callback);
        return this.makeRequest(request3, _packet.TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Rollback a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      rollbackTransaction(callback, name3 = "") {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("ROLLBACK TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request3 = new _request.default(void 0, callback);
        return this.makeRequest(request3, _packet.TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Set a savepoint within a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.\
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      saveTransaction(callback, name3) {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SAVE TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            callback(err);
          }));
        }
        const request3 = new _request.default(void 0, callback);
        return this.makeRequest(request3, _packet.TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));
      }
      /**
       * Run the given callback after starting a transaction, and commit or
       * rollback the transaction afterwards.
       *
       * This is a helper that employs [[beginTransaction]], [[commitTransaction]],
       * [[rollbackTransaction]], and [[saveTransaction]] to greatly simplify the
       * use of database transactions and automatically handle transaction nesting.
       *
       * @param cb
       * @param isolationLevel
       *   The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      transaction(cb, isolationLevel) {
        if (typeof cb !== "function") {
          throw new TypeError("`cb` must be a function");
        }
        const useSavepoint = this.inTransaction;
        const name3 = "_tedious_" + _crypto.default.randomBytes(10).toString("hex");
        const txDone = (err, done, ...args) => {
          if (err) {
            if (this.inTransaction && this.state === this.STATE.LOGGED_IN) {
              this.rollbackTransaction((txErr) => {
                done(txErr || err, ...args);
              }, name3);
            } else {
              done(err, ...args);
            }
          } else if (useSavepoint) {
            if (this.config.options.tdsVersion < "7_2") {
              this.transactionDepth--;
            }
            done(null, ...args);
          } else {
            this.commitTransaction((txErr) => {
              done(txErr, ...args);
            }, name3);
          }
        };
        if (useSavepoint) {
          return this.saveTransaction((err) => {
            if (err) {
              return cb(err);
            }
            if (isolationLevel) {
              return this.execSqlBatch(new _request.default("SET transaction isolation level " + this.getIsolationLevelText(isolationLevel), (err2) => {
                return cb(err2, txDone);
              }));
            } else {
              return cb(null, txDone);
            }
          }, name3);
        } else {
          return this.beginTransaction((err) => {
            if (err) {
              return cb(err);
            }
            return cb(null, txDone);
          }, name3, isolationLevel);
        }
      }
      /**
       * @private
       */
      makeRequest(request3, packetType, payload) {
        if (this.state !== this.STATE.LOGGED_IN) {
          const message = "Requests can only be made in the " + this.STATE.LOGGED_IN.name + " state, not the " + this.state.name + " state";
          this.debug.log(message);
          request3.callback(new _errors.RequestError(message, "EINVALIDSTATE"));
        } else if (request3.canceled) {
          process.nextTick(() => {
            request3.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
          });
        } else {
          if (packetType === _packet.TYPE.SQL_BATCH) {
            this.isSqlBatch = true;
          } else {
            this.isSqlBatch = false;
          }
          this.request = request3;
          request3.connection = this;
          request3.rowCount = 0;
          request3.rows = [];
          request3.rst = [];
          const onCancel = () => {
            payloadStream.unpipe(message);
            payloadStream.destroy(new _errors.RequestError("Canceled.", "ECANCEL"));
            message.ignore = true;
            message.end();
            if (request3 instanceof _request.default && request3.paused) {
              request3.resume();
            }
          };
          request3.once("cancel", onCancel);
          this.createRequestTimer();
          const message = new _message.default({
            type: packetType,
            resetConnection: this.resetConnectionOnNextRequest
          });
          this.messageIo.outgoingMessageStream.write(message);
          this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);
          message.once("finish", () => {
            request3.removeListener("cancel", onCancel);
            request3.once("cancel", this._cancelAfterRequestSent);
            this.resetConnectionOnNextRequest = false;
            this.debug.payload(function() {
              return payload.toString("  ");
            });
          });
          const payloadStream = _stream.Readable.from(payload);
          payloadStream.once("error", (error) => {
            payloadStream.unpipe(message);
            request3.error ?? (request3.error = error);
            message.ignore = true;
            message.end();
          });
          payloadStream.pipe(message);
        }
      }
      /**
       * Cancel currently executed request.
       */
      cancel() {
        if (!this.request) {
          return false;
        }
        if (this.request.canceled) {
          return false;
        }
        this.request.cancel();
        return true;
      }
      /**
       * Reset the connection to its initial state.
       * Can be useful for connection pool implementations.
       *
       * @param callback
       */
      reset(callback) {
        const request3 = new _request.default(this.getInitialSql(), (err) => {
          if (this.config.options.tdsVersion < "7_2") {
            this.inTransaction = false;
          }
          callback(err);
        });
        this.resetConnectionOnNextRequest = true;
        this.execSqlBatch(request3);
      }
      /**
       * @private
       */
      currentTransactionDescriptor() {
        return this.transactionDescriptors[this.transactionDescriptors.length - 1];
      }
      /**
       * @private
       */
      getIsolationLevelText(isolationLevel) {
        switch (isolationLevel) {
          case _transaction.ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "read uncommitted";
          case _transaction.ISOLATION_LEVEL.REPEATABLE_READ:
            return "repeatable read";
          case _transaction.ISOLATION_LEVEL.SERIALIZABLE:
            return "serializable";
          case _transaction.ISOLATION_LEVEL.SNAPSHOT:
            return "snapshot";
          default:
            return "read committed";
        }
      }
    };
    function isTransientError(error) {
      if (error instanceof AggregateError) {
        error = error.errors[0];
      }
      return error instanceof _errors.ConnectionError && !!error.isTransient;
    }
    var _default = exports2.default = Connection;
    module2.exports = Connection;
    Connection.prototype.STATE = {
      INITIALIZED: {
        name: "Initialized",
        events: {}
      },
      CONNECTING: {
        name: "Connecting",
        enter: function() {
          this.initialiseConnection();
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_PRELOGIN: {
        name: "SentPrelogin",
        enter: function() {
          (async () => {
            let messageBuffer = Buffer.alloc(0);
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            for await (const data of message) {
              messageBuffer = Buffer.concat([messageBuffer, data]);
            }
            const preloginPayload = new _preloginPayload.default(messageBuffer);
            this.debug.payload(function() {
              return preloginPayload.toString("  ");
            });
            if (preloginPayload.fedAuthRequired === 1) {
              this.fedAuthRequired = true;
            }
            if ("strict" !== this.config.options.encrypt && (preloginPayload.encryptionString === "ON" || preloginPayload.encryptionString === "REQ")) {
              if (!this.config.options.encrypt) {
                this.emit("connect", new _errors.ConnectionError("Server requires encryption, set 'encrypt' config option to true.", "EENCRYPT"));
                return this.close();
              }
              try {
                this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);
                await this.messageIo.startTls(this.secureContextOptions, this.config.options.serverName ? this.config.options.serverName : this.routingData?.server ?? this.config.server, this.config.options.trustServerCertificate);
              } catch (err) {
                return this.socketError(err);
              }
            }
            this.sendLogin7Packet();
            const {
              authentication
            } = this.config;
            switch (authentication.type) {
              case "token-credential":
              case "azure-active-directory-password":
              case "azure-active-directory-msi-vm":
              case "azure-active-directory-msi-app-service":
              case "azure-active-directory-service-principal-secret":
              case "azure-active-directory-default":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);
                break;
              case "ntlm":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);
                break;
              default:
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
                break;
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      REROUTING: {
        name: "ReRouting",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.REDIRECT);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          reconnect: function() {
            this.transitionTo(this.STATE.CONNECTING);
          }
        }
      },
      TRANSIENT_FAILURE_RETRY: {
        name: "TRANSIENT_FAILURE_RETRY",
        enter: function() {
          this.curTransientRetryCount++;
          this.cleanupConnection(CLEANUP_TYPE.RETRY);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          retry: function() {
            this.createRetryTimer();
          }
        }
      },
      SENT_TLSSSLNEGOTIATION: {
        name: "SentTLSSSLNegotiation",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_STANDARD_LOGIN: {
        name: "SentLogin7WithStandardLogin",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_NTLM: {
        name: "SentLogin7WithNTLMLogin",
        enter: function() {
          (async () => {
            while (true) {
              let message;
              try {
                message = await this.messageIo.readMessage();
              } catch (err) {
                return this.socketError(err);
              }
              const handler = new _handler.Login7TokenHandler(this);
              const tokenStreamParser = this.createTokenStreamParser(message, handler);
              await (0, _events.once)(tokenStreamParser, "end");
              if (handler.loginAckReceived) {
                if (handler.routingData) {
                  this.routingData = handler.routingData;
                  return this.transitionTo(this.STATE.REROUTING);
                } else {
                  return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
                }
              } else if (this.ntlmpacket) {
                const authentication = this.config.authentication;
                const payload = new _ntlmPayload.default({
                  domain: authentication.options.domain,
                  userName: authentication.options.userName,
                  password: authentication.options.password,
                  ntlmpacket: this.ntlmpacket
                });
                this.messageIo.sendMessage(_packet.TYPE.NTLMAUTH_PKT, payload.data);
                this.debug.payload(function() {
                  return payload.toString("  ");
                });
                this.ntlmpacket = void 0;
              } else if (this.loginError) {
                if (isTransientError(this.loginError)) {
                  this.debug.log("Initiating retry on transient error");
                  return this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
                } else {
                  this.emit("connect", this.loginError);
                  return this.transitionTo(this.STATE.FINAL);
                }
              } else {
                this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
                return this.transitionTo(this.STATE.FINAL);
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_FEDAUTH: {
        name: "SentLogin7Withfedauth",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
              return;
            }
            const fedAuthInfoToken = handler.fedAuthInfoToken;
            if (fedAuthInfoToken && fedAuthInfoToken.stsurl && fedAuthInfoToken.spn) {
              const authentication = this.config.authentication;
              const tokenScope = new _url.URL("/.default", fedAuthInfoToken.spn).toString();
              let credentials;
              switch (authentication.type) {
                case "token-credential":
                  credentials = authentication.options.credential;
                  break;
                case "azure-active-directory-password":
                  credentials = new _identity.UsernamePasswordCredential(authentication.options.tenantId ?? "common", authentication.options.clientId, authentication.options.userName, authentication.options.password);
                  break;
                case "azure-active-directory-msi-vm":
                case "azure-active-directory-msi-app-service":
                  const msiArgs = authentication.options.clientId ? [authentication.options.clientId, {}] : [{}];
                  credentials = new _identity.ManagedIdentityCredential(...msiArgs);
                  break;
                case "azure-active-directory-default":
                  const args = authentication.options.clientId ? {
                    managedIdentityClientId: authentication.options.clientId
                  } : {};
                  credentials = new _identity.DefaultAzureCredential(args);
                  break;
                case "azure-active-directory-service-principal-secret":
                  credentials = new _identity.ClientSecretCredential(authentication.options.tenantId, authentication.options.clientId, authentication.options.clientSecret);
                  break;
              }
              let tokenResponse;
              try {
                tokenResponse = await credentials.getToken(tokenScope);
              } catch (err) {
                this.loginError = new AggregateError([new _errors.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH"), err]);
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
                return;
              }
              if (tokenResponse === null) {
                this.loginError = new AggregateError([new _errors.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH")]);
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
                return;
              }
              this.sendFedAuthTokenMessage(tokenResponse.token);
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN_SENDING_INITIAL_SQL: {
        name: "LoggedInSendingInitialSql",
        enter: function() {
          (async () => {
            this.sendInitialSql();
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.InitialSqlTokenHandler(this));
            await (0, _events.once)(tokenStreamParser, "end");
            this.transitionTo(this.STATE.LOGGED_IN);
            this.processedInitialSql();
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function socketError() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN: {
        name: "LoggedIn",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_CLIENT_REQUEST: {
        name: "SentClientRequest",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            this.clearRequestTimer();
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.RequestTokenHandler(this, this.request));
            if (this.request?.canceled && this.cancelTimer) {
              return this.transitionTo(this.STATE.SENT_ATTENTION);
            }
            const onResume = () => {
              tokenStreamParser.resume();
            };
            const onPause = () => {
              tokenStreamParser.pause();
              this.request?.once("resume", onResume);
            };
            this.request?.on("pause", onPause);
            if (this.request instanceof _request.default && this.request.paused) {
              onPause();
            }
            const onCancel = () => {
              tokenStreamParser.removeListener("end", onEndOfMessage);
              if (this.request instanceof _request.default && this.request.paused) {
                this.request.resume();
              }
              this.request?.removeListener("pause", onPause);
              this.request?.removeListener("resume", onResume);
              this.transitionTo(this.STATE.SENT_ATTENTION);
            };
            const onEndOfMessage = () => {
              this.request?.removeListener("cancel", this._cancelAfterRequestSent);
              this.request?.removeListener("cancel", onCancel);
              this.request?.removeListener("pause", onPause);
              this.request?.removeListener("resume", onResume);
              this.transitionTo(this.STATE.LOGGED_IN);
              const sqlRequest = this.request;
              this.request = void 0;
              if (this.config.options.tdsVersion < "7_2" && sqlRequest.error && this.isSqlBatch) {
                this.inTransaction = false;
              }
              sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);
            };
            tokenStreamParser.once("end", onEndOfMessage);
            this.request?.once("cancel", onCancel);
          })();
        },
        exit: function(nextState) {
          this.clearRequestTimer();
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      SENT_ATTENTION: {
        name: "SentAttention",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.AttentionTokenHandler(this, this.request);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.attentionReceived) {
              this.clearCancelTimer();
              const sqlRequest = this.request;
              this.request = void 0;
              this.transitionTo(this.STATE.LOGGED_IN);
              if (sqlRequest.error && sqlRequest.error instanceof _errors.RequestError && sqlRequest.error.code === "ETIMEOUT") {
                sqlRequest.callback(sqlRequest.error);
              } else {
                sqlRequest.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      FINAL: {
        name: "Final",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.NORMAL);
        },
        events: {
          connectTimeout: function() {
          },
          message: function() {
          },
          socketError: function() {
          }
        }
      }
    };
  }
});

// node_modules/tedious/lib/tedious.js
var require_tedious = __commonJS({
  "node_modules/tedious/lib/tedious.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BulkLoad", {
      enumerable: true,
      get: function() {
        return _bulkLoad.default;
      }
    });
    Object.defineProperty(exports2, "Connection", {
      enumerable: true,
      get: function() {
        return _connection.default;
      }
    });
    Object.defineProperty(exports2, "ConnectionError", {
      enumerable: true,
      get: function() {
        return _errors.ConnectionError;
      }
    });
    Object.defineProperty(exports2, "ISOLATION_LEVEL", {
      enumerable: true,
      get: function() {
        return _transaction.ISOLATION_LEVEL;
      }
    });
    Object.defineProperty(exports2, "Request", {
      enumerable: true,
      get: function() {
        return _request.default;
      }
    });
    Object.defineProperty(exports2, "RequestError", {
      enumerable: true,
      get: function() {
        return _errors.RequestError;
      }
    });
    Object.defineProperty(exports2, "TDS_VERSION", {
      enumerable: true,
      get: function() {
        return _tdsVersions.versions;
      }
    });
    Object.defineProperty(exports2, "TYPES", {
      enumerable: true,
      get: function() {
        return _dataType.TYPES;
      }
    });
    exports2.connect = connect;
    exports2.library = void 0;
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _connection = _interopRequireDefault(require_connection());
    var _request = _interopRequireDefault(require_request2());
    var _library = require_library();
    var _errors = require_errors();
    var _dataType = require_data_type();
    var _transaction = require_transaction2();
    var _tdsVersions = require_tds_versions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var library = exports2.library = {
      name: _library.name
    };
    function connect(config, connectListener) {
      const connection = new _connection.default(config);
      connection.connect(connectListener);
      return connection;
    }
  }
});

// node_modules/mssql/lib/tedious/connection-pool.js
var require_connection_pool2 = __commonJS({
  "node_modules/mssql/lib/tedious/connection-pool.js"(exports2, module2) {
    "use strict";
    var tds = require_tedious();
    var debug = require_src()("mssql:tedi");
    var BaseConnectionPool = require_connection_pool();
    var { IDS } = require_utils2();
    var shared = require_shared();
    var ConnectionError = require_connection_error();
    var ConnectionPool = class extends BaseConnectionPool {
      _config() {
        const cfg = {
          server: this.config.server,
          options: Object.assign({
            encrypt: typeof this.config.encrypt === "boolean" ? this.config.encrypt : true,
            trustServerCertificate: typeof this.config.trustServerCertificate === "boolean" ? this.config.trustServerCertificate : false
          }, this.config.options),
          authentication: Object.assign({
            type: this.config.domain !== void 0 ? "ntlm" : this.config.authentication_type !== void 0 ? this.config.authentication_type : "default",
            options: Object.entries({
              userName: this.config.user,
              password: this.config.password,
              domain: this.config.domain,
              clientId: this.config.clientId,
              clientSecret: this.config.clientSecret,
              tenantId: this.config.tenantId,
              token: this.config.token,
              msiEndpoint: this.config.msiEndpoint,
              msiSecret: this.config.msiSecret
            }).reduce((acc, [key, val]) => {
              if (typeof val !== "undefined") {
                return { ...acc, [key]: val };
              }
              return acc;
            }, {})
          }, this.config.authentication)
        };
        cfg.options.database = cfg.options.database || this.config.database;
        cfg.options.port = cfg.options.port || this.config.port;
        cfg.options.connectTimeout = cfg.options.connectTimeout ?? this.config.connectionTimeout ?? this.config.timeout ?? 15e3;
        cfg.options.requestTimeout = cfg.options.requestTimeout ?? this.config.requestTimeout ?? this.config.timeout ?? 15e3;
        cfg.options.tdsVersion = cfg.options.tdsVersion || "7_4";
        cfg.options.rowCollectionOnDone = cfg.options.rowCollectionOnDone || false;
        cfg.options.rowCollectionOnRequestCompletion = cfg.options.rowCollectionOnRequestCompletion || false;
        cfg.options.useColumnNames = cfg.options.useColumnNames || false;
        cfg.options.appName = cfg.options.appName || "node-mssql";
        if (cfg.options.instanceName)
          delete cfg.options.port;
        if (isNaN(cfg.options.requestTimeout))
          cfg.options.requestTimeout = 15e3;
        if (cfg.options.requestTimeout === Infinity || cfg.options.requestTimeout < 0)
          cfg.options.requestTimeout = 0;
        if (!cfg.options.debug && this.config.debug) {
          cfg.options.debug = {
            packet: true,
            token: true,
            data: true,
            payload: true
          };
        }
        return cfg;
      }
      _poolCreate() {
        return new shared.Promise((resolve, reject) => {
          const resolveOnce = (v) => {
            resolve(v);
            resolve = reject = () => {
            };
          };
          const rejectOnce = (e) => {
            reject(e);
            resolve = reject = () => {
            };
          };
          let tedious;
          try {
            tedious = new tds.Connection(this._config());
          } catch (err) {
            rejectOnce(err);
            return;
          }
          tedious.connect((err) => {
            if (err) {
              err = new ConnectionError(err);
              return rejectOnce(err);
            }
            debug("connection(%d): established", IDS.get(tedious));
            this.collation = tedious.databaseCollation;
            resolveOnce(tedious);
          });
          IDS.add(tedious, "Connection");
          debug("pool(%d): connection #%d created", IDS.get(this), IDS.get(tedious));
          debug("connection(%d): establishing", IDS.get(tedious));
          tedious.on("end", () => {
            const err = new ConnectionError("The connection ended without ever completing the connection");
            rejectOnce(err);
          });
          tedious.on("error", (err) => {
            if (err.code === "ESOCKET") {
              tedious.hasError = true;
            } else {
              this.emit("error", err);
            }
            rejectOnce(err);
          });
          if (this.config.debug) {
            tedious.on("debug", this.emit.bind(this, "debug", tedious));
          }
          if (typeof this.config.beforeConnect === "function") {
            this.config.beforeConnect(tedious);
          }
        });
      }
      _poolValidate(tedious) {
        if (tedious && !tedious.closed && !tedious.hasError) {
          return !this.config.validateConnection || new shared.Promise((resolve) => {
            const req = new tds.Request("SELECT 1;", (err) => {
              resolve(!err);
            });
            tedious.execSql(req);
          });
        }
        return false;
      }
      _poolDestroy(tedious) {
        return new shared.Promise((resolve, reject) => {
          if (!tedious) {
            resolve();
            return;
          }
          debug("connection(%d): destroying", IDS.get(tedious));
          if (tedious.closed) {
            debug("connection(%d): already closed", IDS.get(tedious));
            resolve();
          } else {
            tedious.once("end", () => {
              debug("connection(%d): destroyed", IDS.get(tedious));
              resolve();
            });
            tedious.close();
          }
        });
      }
    };
    module2.exports = ConnectionPool;
  }
});

// node_modules/mssql/lib/tedious/transaction.js
var require_transaction3 = __commonJS({
  "node_modules/mssql/lib/tedious/transaction.js"(exports2, module2) {
    "use strict";
    var debug = require_src()("mssql:tedi");
    var BaseTransaction = require_transaction();
    var { IDS } = require_utils2();
    var TransactionError = require_transaction_error();
    var Transaction2 = class extends BaseTransaction {
      constructor(parent) {
        super(parent);
        this._abort = () => {
          if (!this._rollbackRequested) {
            const pc = this._acquiredConnection;
            setImmediate(this.parent.release.bind(this.parent), pc);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            this._aborted = true;
            this.emit("rollback", true);
          }
        };
      }
      _begin(isolationLevel, callback) {
        super._begin(isolationLevel, (err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): begin", IDS.get(this));
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            this._acquiredConnection = connection;
            this._acquiredConnection.on("rollbackTransaction", this._abort);
            this._acquiredConfig = config;
            connection.beginTransaction((err3) => {
              if (err3)
                err3 = new TransactionError(err3);
              debug("transaction(%d): begun", IDS.get(this));
              callback(err3);
            }, this.name, this.isolationLevel);
          });
        });
      }
      _commit(callback) {
        super._commit((err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): commit", IDS.get(this));
          this._acquiredConnection.commitTransaction((err2) => {
            if (err2)
              err2 = new TransactionError(err2);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this.parent.release(this._acquiredConnection);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            if (!err2)
              debug("transaction(%d): commited", IDS.get(this));
            callback(err2);
          });
        });
      }
      _rollback(callback) {
        super._rollback((err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): rollback", IDS.get(this));
          this._acquiredConnection.rollbackTransaction((err2) => {
            if (err2)
              err2 = new TransactionError(err2);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this.parent.release(this._acquiredConnection);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            if (!err2)
              debug("transaction(%d): rolled back", IDS.get(this));
            callback(err2);
          });
        });
      }
    };
    module2.exports = Transaction2;
  }
});

// node_modules/mssql/lib/udt.js
var require_udt2 = __commonJS({
  "node_modules/mssql/lib/udt.js"(exports2, module2) {
    "use strict";
    var Point = class {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.z = null;
        this.m = null;
      }
    };
    var parsePoints = (buffer, count, isGeometryPoint) => {
      const points = [];
      if (count < 1) {
        return points;
      }
      if (isGeometryPoint) {
        for (let i = 1; i <= count; i++) {
          const point = new Point();
          points.push(point);
          point.x = buffer.readDoubleLE(buffer.position);
          point.y = buffer.readDoubleLE(buffer.position + 8);
          buffer.position += 16;
        }
      } else {
        for (let i = 1; i <= count; i++) {
          const point = new Point();
          points.push(point);
          point.lat = buffer.readDoubleLE(buffer.position);
          point.lng = buffer.readDoubleLE(buffer.position + 8);
          point.x = point.lat;
          point.y = point.lng;
          buffer.position += 16;
        }
      }
      return points;
    };
    var parseZ = (buffer, points) => {
      if (points < 1) {
        return;
      }
      points.forEach((point) => {
        point.z = buffer.readDoubleLE(buffer.position);
        buffer.position += 8;
      });
    };
    var parseM = (buffer, points) => {
      if (points < 1) {
        return;
      }
      points.forEach((point) => {
        point.m = buffer.readDoubleLE(buffer.position);
        buffer.position += 8;
      });
    };
    var parseFigures = (buffer, count, properties) => {
      const figures = [];
      if (count < 1) {
        return figures;
      }
      if (properties.P) {
        figures.push({
          attribute: 1,
          pointOffset: 0
        });
      } else if (properties.L) {
        figures.push({
          attribute: 1,
          pointOffset: 0
        });
      } else {
        for (let i = 1; i <= count; i++) {
          figures.push({
            attribute: buffer.readUInt8(buffer.position),
            pointOffset: buffer.readInt32LE(buffer.position + 1)
          });
          buffer.position += 5;
        }
      }
      return figures;
    };
    var parseShapes = (buffer, count, properties) => {
      const shapes = [];
      if (count < 1) {
        return shapes;
      }
      if (properties.P) {
        shapes.push({
          parentOffset: -1,
          figureOffset: 0,
          type: 1
        });
      } else if (properties.L) {
        shapes.push({
          parentOffset: -1,
          figureOffset: 0,
          type: 2
        });
      } else {
        for (let i = 1; i <= count; i++) {
          shapes.push({
            parentOffset: buffer.readInt32LE(buffer.position),
            figureOffset: buffer.readInt32LE(buffer.position + 4),
            type: buffer.readUInt8(buffer.position + 8)
          });
          buffer.position += 9;
        }
      }
      return shapes;
    };
    var parseSegments = (buffer, count) => {
      const segments = [];
      if (count < 1) {
        return segments;
      }
      for (let i = 1; i <= count; i++) {
        segments.push({ type: buffer.readUInt8(buffer.position) });
        buffer.position++;
      }
      return segments;
    };
    var parseGeography = (buffer, isUsingGeometryPoints) => {
      const srid = buffer.readInt32LE(0);
      if (srid === -1) {
        return null;
      }
      const value = {
        srid,
        version: buffer.readUInt8(4)
      };
      const flags = buffer.readUInt8(5);
      buffer.position = 6;
      const properties = {
        Z: (flags & 1 << 0) > 0,
        M: (flags & 1 << 1) > 0,
        V: (flags & 1 << 2) > 0,
        P: (flags & 1 << 3) > 0,
        L: (flags & 1 << 4) > 0
      };
      if (value.version === 2) {
        properties.H = (flags & 1 << 3) > 0;
      }
      let numberOfPoints;
      if (properties.P) {
        numberOfPoints = 1;
      } else if (properties.L) {
        numberOfPoints = 2;
      } else {
        numberOfPoints = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints);
      if (properties.Z) {
        parseZ(buffer, value.points);
      }
      if (properties.M) {
        parseM(buffer, value.points);
      }
      let numberOfFigures;
      if (properties.P) {
        numberOfFigures = 1;
      } else if (properties.L) {
        numberOfFigures = 1;
      } else {
        numberOfFigures = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.figures = parseFigures(buffer, numberOfFigures, properties);
      let numberOfShapes;
      if (properties.P) {
        numberOfShapes = 1;
      } else if (properties.L) {
        numberOfShapes = 1;
      } else {
        numberOfShapes = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.shapes = parseShapes(buffer, numberOfShapes, properties);
      if (value.version === 2 && buffer.position < buffer.length) {
        const numberOfSegments = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
        value.segments = parseSegments(buffer, numberOfSegments);
      } else {
        value.segments = [];
      }
      return value;
    };
    module2.exports.PARSERS = {
      geography(buffer) {
        return parseGeography(
          buffer,
          /* isUsingGeometryPoints: */
          false
        );
      },
      geometry(buffer) {
        return parseGeography(
          buffer,
          /* isUsingGeometryPoints: */
          true
        );
      }
    };
  }
});

// node_modules/mssql/lib/tedious/request.js
var require_request3 = __commonJS({
  "node_modules/mssql/lib/tedious/request.js"(exports2, module2) {
    "use strict";
    var tds = require_tedious();
    var debug = require_src()("mssql:tedi");
    var BaseRequest = require_request();
    var RequestError = require_request_error();
    var { IDS, objectHasProperty: objectHasProperty2 } = require_utils2();
    var { TYPES, DECLARATIONS, declare, cast } = require_datatypes();
    var Table = require_table();
    var { PARSERS: UDT } = require_udt2();
    var { valueHandler } = require_shared();
    var JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
    var XML_COLUMN_ID = "XML_F52E2B61-18A1-11d1-B105-00805F49916B";
    var N_TYPES = {
      BitN: 104,
      DateTimeN: 111,
      DecimalN: 106,
      FloatN: 109,
      IntN: 38,
      MoneyN: 110,
      NumericN: 108
    };
    var getTediousType = function(type2) {
      switch (type2) {
        case TYPES.VarChar:
          return tds.TYPES.VarChar;
        case TYPES.NVarChar:
          return tds.TYPES.NVarChar;
        case TYPES.Text:
          return tds.TYPES.Text;
        case TYPES.Int:
          return tds.TYPES.Int;
        case TYPES.BigInt:
          return tds.TYPES.BigInt;
        case TYPES.TinyInt:
          return tds.TYPES.TinyInt;
        case TYPES.SmallInt:
          return tds.TYPES.SmallInt;
        case TYPES.Bit:
          return tds.TYPES.Bit;
        case TYPES.Float:
          return tds.TYPES.Float;
        case TYPES.Decimal:
          return tds.TYPES.Decimal;
        case TYPES.Numeric:
          return tds.TYPES.Numeric;
        case TYPES.Real:
          return tds.TYPES.Real;
        case TYPES.Money:
          return tds.TYPES.Money;
        case TYPES.SmallMoney:
          return tds.TYPES.SmallMoney;
        case TYPES.Time:
          return tds.TYPES.Time;
        case TYPES.Date:
          return tds.TYPES.Date;
        case TYPES.DateTime:
          return tds.TYPES.DateTime;
        case TYPES.DateTime2:
          return tds.TYPES.DateTime2;
        case TYPES.DateTimeOffset:
          return tds.TYPES.DateTimeOffset;
        case TYPES.SmallDateTime:
          return tds.TYPES.SmallDateTime;
        case TYPES.UniqueIdentifier:
          return tds.TYPES.UniqueIdentifier;
        case TYPES.Xml:
          return tds.TYPES.NVarChar;
        case TYPES.Char:
          return tds.TYPES.Char;
        case TYPES.NChar:
          return tds.TYPES.NChar;
        case TYPES.NText:
          return tds.TYPES.NVarChar;
        case TYPES.Image:
          return tds.TYPES.Image;
        case TYPES.Binary:
          return tds.TYPES.Binary;
        case TYPES.VarBinary:
          return tds.TYPES.VarBinary;
        case TYPES.UDT:
        case TYPES.Geography:
        case TYPES.Geometry:
          return tds.TYPES.UDT;
        case TYPES.TVP:
          return tds.TYPES.TVP;
        case TYPES.Variant:
          return tds.TYPES.Variant;
        default:
          return type2;
      }
    };
    var getMssqlType = function(type2, length) {
      if (typeof type2 !== "object")
        return void 0;
      switch (type2) {
        case tds.TYPES.Char:
          return TYPES.Char;
        case tds.TYPES.NChar:
          return TYPES.NChar;
        case tds.TYPES.VarChar:
          return TYPES.VarChar;
        case tds.TYPES.NVarChar:
          return TYPES.NVarChar;
        case tds.TYPES.Text:
          return TYPES.Text;
        case tds.TYPES.NText:
          return TYPES.NText;
        case tds.TYPES.Int:
          return TYPES.Int;
        case tds.TYPES.BigInt:
          return TYPES.BigInt;
        case tds.TYPES.TinyInt:
          return TYPES.TinyInt;
        case tds.TYPES.SmallInt:
          return TYPES.SmallInt;
        case tds.TYPES.Bit:
          return TYPES.Bit;
        case tds.TYPES.Float:
          return TYPES.Float;
        case tds.TYPES.Real:
          return TYPES.Real;
        case tds.TYPES.Money:
          return TYPES.Money;
        case tds.TYPES.SmallMoney:
          return TYPES.SmallMoney;
        case tds.TYPES.Numeric:
          return TYPES.Numeric;
        case tds.TYPES.Decimal:
          return TYPES.Decimal;
        case tds.TYPES.DateTime:
          return TYPES.DateTime;
        case tds.TYPES.Time:
          return TYPES.Time;
        case tds.TYPES.Date:
          return TYPES.Date;
        case tds.TYPES.DateTime2:
          return TYPES.DateTime2;
        case tds.TYPES.DateTimeOffset:
          return TYPES.DateTimeOffset;
        case tds.TYPES.SmallDateTime:
          return TYPES.SmallDateTime;
        case tds.TYPES.UniqueIdentifier:
          return TYPES.UniqueIdentifier;
        case tds.TYPES.Image:
          return TYPES.Image;
        case tds.TYPES.Binary:
          return TYPES.Binary;
        case tds.TYPES.VarBinary:
          return TYPES.VarBinary;
        case tds.TYPES.Xml:
          return TYPES.Xml;
        case tds.TYPES.UDT:
          return TYPES.UDT;
        case tds.TYPES.TVP:
          return TYPES.TVP;
        case tds.TYPES.Variant:
          return TYPES.Variant;
        default:
          switch (type2.id) {
            case N_TYPES.BitN:
              return TYPES.Bit;
            case N_TYPES.NumericN:
              return TYPES.Numeric;
            case N_TYPES.DecimalN:
              return TYPES.Decimal;
            case N_TYPES.IntN:
              if (length === 8)
                return TYPES.BigInt;
              if (length === 4)
                return TYPES.Int;
              if (length === 2)
                return TYPES.SmallInt;
              return TYPES.TinyInt;
            case N_TYPES.FloatN:
              if (length === 8)
                return TYPES.Float;
              return TYPES.Real;
            case N_TYPES.MoneyN:
              if (length === 8)
                return TYPES.Money;
              return TYPES.SmallMoney;
            case N_TYPES.DateTimeN:
              if (length === 8)
                return TYPES.DateTime;
              return TYPES.SmallDateTime;
          }
      }
    };
    var createColumns = function(metadata, arrayRowMode) {
      let out = {};
      if (arrayRowMode)
        out = [];
      for (let index = 0, length = metadata.length; index < length; index++) {
        const column2 = metadata[index];
        const outColumn = {
          index,
          name: column2.colName,
          length: column2.dataLength,
          type: getMssqlType(column2.type, column2.dataLength),
          scale: column2.scale,
          precision: column2.precision,
          nullable: !!(column2.flags & 1),
          caseSensitive: !!(column2.flags & 2),
          identity: !!(column2.flags & 16),
          readOnly: !(column2.flags & 12)
        };
        if (column2.udtInfo) {
          outColumn.udt = {
            name: column2.udtInfo.typeName,
            database: column2.udtInfo.dbname,
            schema: column2.udtInfo.owningSchema,
            assembly: column2.udtInfo.assemblyName
          };
          if (DECLARATIONS[column2.udtInfo.typeName]) {
            outColumn.type = DECLARATIONS[column2.udtInfo.typeName];
          }
        }
        if (arrayRowMode) {
          out.push(outColumn);
        } else {
          out[column2.colName] = outColumn;
        }
      }
      return out;
    };
    var valueCorrection = function(value, metadata) {
      const type2 = getMssqlType(metadata.type);
      if (valueHandler.has(type2)) {
        return valueHandler.get(type2)(value);
      } else if (metadata.type === tds.TYPES.UDT && value != null) {
        if (UDT[metadata.udtInfo.typeName]) {
          return UDT[metadata.udtInfo.typeName](value);
        } else {
          return value;
        }
      } else {
        return value;
      }
    };
    var parameterCorrection = function(value) {
      if (value instanceof Table) {
        const tvp = {
          name: value.name,
          schema: value.schema,
          columns: [],
          rows: value.rows
        };
        for (const col of value.columns) {
          tvp.columns.push({
            name: col.name,
            type: getTediousType(col.type),
            length: col.length,
            scale: col.scale,
            precision: col.precision
          });
        }
        return tvp;
      } else {
        return value;
      }
    };
    var Request = class extends BaseRequest {
      /*
      Execute specified sql batch.
      */
      _batch(batch, callback) {
        this._isBatch = true;
        this._query(batch, callback);
      }
      /*
      Bulk load.
      */
      _bulk(table, options, callback) {
        super._bulk(table, options, (err) => {
          if (err)
            return callback(err);
          try {
            table._makeBulk();
          } catch (e) {
            return callback(new RequestError(e, "EREQUEST"));
          }
          if (!table.name) {
            return callback(new RequestError("Table name must be specified for bulk insert.", "ENAME"));
          }
          if (table.name.charAt(0) === "@") {
            return callback(new RequestError("You can't use table variables for bulk insert.", "ENAME"));
          }
          const errors = [];
          const errorHandlers = {};
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection) => {
            const callbackWithRelease = (err3, ...args) => {
              try {
                this.parent.release(connection);
              } catch (e) {
              }
              callback(err3, ...args);
            };
            if (err2)
              return callbackWithRelease(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              return callbackWithRelease(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            const done = (err3, rowCount) => {
              if (err3 && (!errors.length || errors.length && err3.message !== errors[errors.length - 1].message)) {
                err3 = new RequestError(err3, "EREQUEST");
                if (this.stream)
                  this.emit("error", err3);
                errors.push(err3);
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                hasReturned = true;
                if (this.stream) {
                  callbackWithRelease(null, rowCount);
                } else {
                  callbackWithRelease(error, rowCount);
                }
              }
            };
            const bulk = connection.newBulkLoad(table.path, options, done);
            for (const col of table.columns) {
              bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision });
            }
            if (table.create) {
              const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;
              const req = new tds.Request(`if object_id('${objectid.replace(/'/g, "''")}') is null ${table.declare()}`, (err3) => {
                if (err3)
                  return done(err3);
                connection.execBulkLoad(bulk, table.rows);
              });
              this._setCurrentRequest(req);
              connection.execSqlBatch(req);
            } else {
              connection.execBulkLoad(bulk, table.rows);
            }
          });
        });
      }
      /*
      Execute specified sql command.
      */
      _query(command, callback) {
        super._query(command, (err) => {
          if (err)
            return callback(err);
          const recordsets = [];
          const recordsetcolumns = [];
          const errors = [];
          const errorHandlers = {};
          const output = {};
          const rowsAffected = [];
          let columns = {};
          let recordset = [];
          let batchLastRow = null;
          let batchHasOutput = false;
          let isChunkedRecordset = false;
          let chunksBuffer = null;
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            let row;
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              this.parent.release(connection);
              return callback(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            debug("request(%d): query", IDS.get(this), command);
            const req = new tds.Request(command, (err3) => {
              (err3?.errors ? err3.errors : [err3]).forEach((e, i, { length }) => {
                if (e && (!errors.length || errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message)) {
                  e = new RequestError(e, "EREQUEST");
                  if (this.stream)
                    this.emit("error", e);
                  errors.push(e);
                }
              });
              if (batchHasOutput) {
                if (!this.stream)
                  batchLastRow = recordsets.pop()[0];
                for (const name3 in batchLastRow) {
                  const value = batchLastRow[name3];
                  if (name3 !== "___return___") {
                    output[name3] = value;
                  }
                }
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                this.parent.release(connection);
                hasReturned = true;
                if (error) {
                  debug("request(%d): failed", IDS.get(this), error);
                } else {
                  debug("request(%d): completed", IDS.get(this));
                }
                if (this.stream) {
                  callback(null, null, output, rowsAffected, recordsetcolumns);
                } else {
                  callback(error, recordsets, output, rowsAffected, recordsetcolumns);
                }
              }
            });
            this._setCurrentRequest(req);
            req.on("columnMetadata", (metadata) => {
              columns = createColumns(metadata, this.arrayRowMode);
              isChunkedRecordset = false;
              if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
                isChunkedRecordset = true;
                chunksBuffer = [];
              }
              if (this.stream) {
                if (this._isBatch) {
                  if (!columns.___return___) {
                    this.emit("recordset", columns);
                  }
                } else {
                  this.emit("recordset", columns);
                }
              }
              if (this.arrayRowMode)
                recordsetcolumns.push(columns);
            });
            const doneHandler = (rowCount, more) => {
              if (rowCount != null) {
                rowsAffected.push(rowCount);
                if (this.stream) {
                  this.emit("rowsaffected", rowCount);
                }
              }
              if (Object.keys(columns).length === 0)
                return;
              if (isChunkedRecordset) {
                const concatenatedChunks = chunksBuffer.join("");
                if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
                  try {
                    if (concatenatedChunks === "") {
                      row = null;
                    } else {
                      row = JSON.parse(concatenatedChunks);
                    }
                  } catch (ex) {
                    row = null;
                    const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                    if (this.stream)
                      this.emit("error", ex2);
                    errors.push(ex2);
                  }
                } else {
                  row = {};
                  row[Object.keys(columns)[0]] = concatenatedChunks;
                }
                chunksBuffer = null;
                if (this.stream) {
                  this.emit("row", row);
                } else {
                  recordset.push(row);
                }
              }
              if (!this.stream) {
                Object.defineProperty(recordset, "columns", {
                  enumerable: false,
                  configurable: true,
                  value: columns
                });
                Object.defineProperty(recordset, "toTable", {
                  enumerable: false,
                  configurable: true,
                  value(name3) {
                    return Table.fromRecordset(this, name3);
                  }
                });
                recordsets.push(recordset);
              }
              recordset = [];
              columns = {};
            };
            req.on("doneInProc", doneHandler);
            req.on("done", doneHandler);
            req.on("returnValue", (parameterName, value, metadata) => {
              output[parameterName] = value;
            });
            req.on("row", (columns2) => {
              if (!recordset)
                recordset = [];
              if (isChunkedRecordset) {
                return chunksBuffer.push(columns2[0].value);
              }
              if (this.arrayRowMode) {
                row = [];
              } else {
                row = {};
              }
              for (const col of columns2) {
                col.value = valueCorrection(col.value, col.metadata);
                if (this.arrayRowMode) {
                  row.push(col.value);
                } else {
                  const exi = row[col.metadata.colName];
                  if (exi !== void 0) {
                    if (exi instanceof Array) {
                      exi.push(col.value);
                    } else {
                      row[col.metadata.colName] = [exi, col.value];
                    }
                  } else {
                    row[col.metadata.colName] = col.value;
                  }
                }
              }
              if (this.stream) {
                if (this._isBatch) {
                  if (row.___return___) {
                    batchLastRow = row;
                  } else {
                    this.emit("row", row);
                  }
                } else {
                  this.emit("row", row);
                }
              } else {
                recordset.push(row);
              }
            });
            if (this._isBatch) {
              if (Object.keys(this.parameters).length) {
                for (const name3 in this.parameters) {
                  if (!objectHasProperty2(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  try {
                    param.value = getTediousType(param.type).validate(param.value, this.parent.collation);
                  } catch (e) {
                    e.message = `Validation failed for parameter '${name3}'. ${e.message}`;
                    const err3 = new RequestError(e, "EPARAM");
                    this.parent.release(connection);
                    return callback(err3);
                  }
                }
                const declarations = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty2(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  declarations.push(`@${name3} ${declare(param.type, param)}`);
                }
                const assigns = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty2(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  assigns.push(`@${name3} = ${cast(param.value, param.type, param)}`);
                }
                const selects = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty2(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  if (param.io === 2) {
                    selects.push(`@${name3} as [${name3}]`);
                  }
                }
                batchHasOutput = selects.length > 0;
                req.sqlTextOrProcedure = `declare ${declarations.join(", ")};select ${assigns.join(", ")};${req.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(", ")}` : ""}`;
              }
            } else {
              for (const name3 in this.parameters) {
                if (!objectHasProperty2(this.parameters, name3)) {
                  continue;
                }
                const param = this.parameters[name3];
                if (param.io === 1) {
                  req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
                } else {
                  req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
                }
              }
            }
            try {
              connection[this._isBatch ? "execSqlBatch" : "execSql"](req);
            } catch (error) {
              handleError(true, connection, error);
            }
          });
        });
      }
      /*
      Execute stored procedure with specified parameters.
      */
      _execute(procedure, callback) {
        super._execute(procedure, (err) => {
          if (err)
            return callback(err);
          const recordsets = [];
          const recordsetcolumns = [];
          const errors = [];
          const errorHandlers = {};
          const output = {};
          const rowsAffected = [];
          let columns = {};
          let recordset = [];
          let returnValue = 0;
          let isChunkedRecordset = false;
          let chunksBuffer = null;
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            let row;
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              this.parent.release(connection);
              return callback(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            if (debug.enabled) {
              const params = Object.keys(this.parameters).map((k) => this.parameters[k]);
              const logValue = (s) => typeof s === "string" && s.length > 50 ? s.substring(0, 47) + "..." : s;
              const logName = (param) => param.name + " [sql." + param.type.name + "]";
              const logParams = {};
              params.forEach((p) => {
                logParams[logName(p)] = logValue(p.value);
              });
              debug("request(%d): execute %s %O", IDS.get(this), procedure, logParams);
            }
            const req = new tds.Request(procedure, (err3) => {
              if (err3 && (!errors.length || errors.length && err3.message !== errors[errors.length - 1].message)) {
                err3 = new RequestError(err3, "EREQUEST");
                if (this.stream)
                  this.emit("error", err3);
                errors.push(err3);
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                this.parent.release(connection);
                hasReturned = true;
                if (error) {
                  debug("request(%d): failed", IDS.get(this), error);
                } else {
                  debug("request(%d): complete", IDS.get(this));
                }
                if (this.stream) {
                  callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);
                } else {
                  callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);
                }
              }
            });
            this._setCurrentRequest(req);
            req.on("columnMetadata", (metadata) => {
              columns = createColumns(metadata, this.arrayRowMode);
              isChunkedRecordset = false;
              if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
                isChunkedRecordset = true;
                chunksBuffer = [];
              }
              if (this.stream)
                this.emit("recordset", columns);
              if (this.arrayRowMode)
                recordsetcolumns.push(columns);
            });
            req.on("row", (columns2) => {
              if (!recordset)
                recordset = [];
              if (isChunkedRecordset) {
                return chunksBuffer.push(columns2[0].value);
              }
              if (this.arrayRowMode) {
                row = [];
              } else {
                row = {};
              }
              for (const col of columns2) {
                col.value = valueCorrection(col.value, col.metadata);
                if (this.arrayRowMode) {
                  row.push(col.value);
                } else {
                  const exi = row[col.metadata.colName];
                  if (exi != null) {
                    if (exi instanceof Array) {
                      exi.push(col.value);
                    } else {
                      row[col.metadata.colName] = [exi, col.value];
                    }
                  } else {
                    row[col.metadata.colName] = col.value;
                  }
                }
              }
              if (this.stream) {
                this.emit("row", row);
              } else {
                recordset.push(row);
              }
            });
            req.on("doneInProc", (rowCount, more) => {
              if (rowCount != null) {
                rowsAffected.push(rowCount);
                if (this.stream) {
                  this.emit("rowsaffected", rowCount);
                }
              }
              if (Object.keys(columns).length === 0)
                return;
              if (isChunkedRecordset) {
                if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
                  try {
                    if (chunksBuffer.length === 0) {
                      row = null;
                    } else {
                      row = JSON.parse(chunksBuffer.join(""));
                    }
                  } catch (ex) {
                    row = null;
                    const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                    if (this.stream)
                      this.emit("error", ex2);
                    errors.push(ex2);
                  }
                } else {
                  row = {};
                  row[Object.keys(columns)[0]] = chunksBuffer.join("");
                }
                chunksBuffer = null;
                if (this.stream) {
                  this.emit("row", row);
                } else {
                  recordset.push(row);
                }
              }
              if (!this.stream) {
                Object.defineProperty(recordset, "columns", {
                  enumerable: false,
                  configurable: true,
                  value: columns
                });
                Object.defineProperty(recordset, "toTable", {
                  enumerable: false,
                  configurable: true,
                  value(name3) {
                    return Table.fromRecordset(this, name3);
                  }
                });
                recordsets.push(recordset);
              }
              recordset = [];
              columns = {};
            });
            req.on("doneProc", (rowCount, more, returnStatus) => {
              returnValue = returnStatus;
            });
            req.on("returnValue", (parameterName, value, metadata) => {
              output[parameterName] = value;
            });
            for (const name3 in this.parameters) {
              if (!objectHasProperty2(this.parameters, name3)) {
                continue;
              }
              const param = this.parameters[name3];
              if (param.io === 1) {
                req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
              } else {
                req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
              }
            }
            connection.callProcedure(req);
          });
        });
      }
      _pause() {
        super._pause();
        if (this._currentRequest) {
          this._currentRequest.pause();
        }
      }
      _resume() {
        super._resume();
        if (this._currentRequest) {
          this._currentRequest.resume();
        }
      }
    };
    module2.exports = Request;
  }
});

// node_modules/mssql/lib/tedious/index.js
var require_tedious2 = __commonJS({
  "node_modules/mssql/lib/tedious/index.js"(exports2, module2) {
    "use strict";
    var base = require_base();
    var ConnectionPool = require_connection_pool2();
    var Transaction2 = require_transaction3();
    var Request = require_request3();
    module2.exports = Object.assign({
      ConnectionPool,
      Transaction: Transaction2,
      Request,
      PreparedStatement: base.PreparedStatement
    }, base.exports);
    Object.defineProperty(module2.exports, "Promise", {
      enumerable: true,
      get: () => {
        return base.Promise;
      },
      set: (value) => {
        base.Promise = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: base.valueHandler,
      writable: false,
      configurable: false
    });
    base.driver.name = "tedious";
    base.driver.ConnectionPool = ConnectionPool;
    base.driver.Transaction = Transaction2;
    base.driver.Request = Request;
  }
});

// node_modules/mssql/index.js
var require_mssql = __commonJS({
  "node_modules/mssql/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_tedious2();
  }
});

// src/index.ts
var src_exports2 = {};
__export(src_exports2, {
  Migration: () => Migration,
  Model: () => Model,
  ModelDeleteQueryBuilder: () => ModelDeleteQueryBuilder,
  ModelUpdateQueryBuilder: () => ModelUpdateQueryBuilder,
  Redis: () => RedisDataSource,
  RedisOptions: () => import_ioredis2.RedisOptions,
  Relation: () => Relation,
  SqlDataSource: () => SqlDataSource,
  belongsTo: () => belongsTo,
  column: () => column,
  default: () => src_default,
  getModelColumns: () => getModelColumns,
  getPrimaryKey: () => getPrimaryKey,
  getRelations: () => getRelations,
  hasMany: () => hasMany,
  hasOne: () => hasOne
});
module.exports = __toCommonJS(src_exports2);
var import_reflect_metadata3 = require("reflect-metadata");

// src/Datasource.ts
var import_dotenv = __toESM(require("dotenv"));
import_dotenv.default.config();
var DataSource = class {
  constructor(input) {
    if (this.type === "redis") {
      this.handleRedisSource(input);
      return;
    }
    this.handleSqlSource(input);
  }
  handleRedisSource(input) {
    this.type = "redis";
    this.host = input?.host || process.env.REDIS_HOST;
    this.port = +input?.port || +process.env.REDIS_PORT;
    this.logs = Boolean(input?.logs) || Boolean(process.env.REDIS_LOGS) || false;
    if (!this.port) {
      this.port = 6379;
    }
    if (![this.host].some((connectionDetail) => !connectionDetail)) {
      throw new Error(
        "Missing connection details in the envs or in the connection details"
      );
    }
  }
  handleSqlSource(input) {
    this.type = input?.type || process.env.DB_TYPE;
    this.host = input?.host || process.env.DB_HOST;
    this.port = +input?.port || +process.env.DB_PORT;
    this.username = input?.username || process.env.DB_USER;
    this.password = input?.password || process.env.DB_PASSWORD;
    this.database = input?.database || process.env.DB_DATABASE;
    this.logs = Boolean(input?.logs) || Boolean(process.env.DB_LOGS) || false;
    if (!this.port) {
      switch (this.type) {
        case "mysql":
        case "mariadb":
          this.port = 3306;
          break;
        case "postgres":
          this.port = 5432;
        case "redis":
          this.port = 6379;
        case "sqlite":
          break;
        default:
          throw new Error(
            "Database type not provided in the envs nor in the connection details"
          );
      }
    }
  }
};

// src/Sql/Migrations/Migration.ts
var import_path = __toESM(require("path"));

// src/Sql/Migrations/Schema/Schema.ts
var import_dotenv2 = __toESM(require("dotenv"));

// src/Sql/Resources/Migration/CREATETABLE.ts
var createTableTemplate = {
  createTableIfNotExists: (table, dbType) => {
    switch (dbType) {
      case "mysql":
      case "mariadb":
        return `CREATE TABLE IF NOT EXISTS \`${table}\` (
`;
      case "postgres":
        return `CREATE TABLE IF NOT EXISTS "${table}" (
`;
      case "sqlite":
        return `CREATE TABLE IF NOT EXISTS "${table}" (
`;
      default:
        throw new Error("Unsupported database type");
    }
  },
  createTable: (table, dbType) => {
    switch (dbType) {
      case "mysql":
      case "mariadb":
        return `CREATE TABLE \`${table}\` (
`;
      case "postgres":
        return `CREATE TABLE "${table}" (
`;
      case "sqlite":
        return `CREATE TABLE "${table}" (
`;
      default:
        throw new Error("Unsupported database type");
    }
  },
  createTableEnd: "\n);"
};
var CREATETABLE_default = createTableTemplate;

// src/Logger.ts
var import_winston = __toESM(require("winston"));
var colors = {
  info: "\x1B[32m",
  warn: "\x1B[33m",
  error: "\x1B[31m"
};
var logFormat = import_winston.default.format.combine(
  import_winston.default.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  import_winston.default.format.printf(({ level, message, timestamp }) => {
    const color = colors[level] || "\x1B[0m";
    return `${timestamp} ${color}${level}\x1B[0m: ${color}${message}\x1B[0m`;
  })
);
var consoleTransport = new import_winston.default.transports.Console();
var fileTransport = new import_winston.default.transports.File({ filename: "logfile.log" });
var logger = import_winston.default.createLogger({
  format: logFormat,
  transports: [consoleTransport, fileTransport]
});
function log(query, logs, params) {
  if (!logs) {
    return;
  }
  if (params && params.length) {
    params.forEach((param, index) => {
      let formattedParam = null;
      if (typeof param === "string") {
        formattedParam = `'${param}'`;
      } else if (typeof param === "object" && param !== null && Object.keys(param).length > 0) {
        formattedParam = `'${JSON.stringify(param)}'`;
      } else {
        formattedParam = param;
      }
      query = query.replace(/\?/, formattedParam);
      const pgPlaceholder = new RegExp(`\\$${index + 1}`, "g");
      query = query.replace(pgPlaceholder, formattedParam);
      const queryParameters = query.match(/@(\w+)/g);
      if (queryParameters) {
        query = query.replace(queryParameters[0], formattedParam);
      }
    });
  }
  logger.info("\n" + query);
}
function queryError(error) {
  logger.error("Query Failed ", error);
}
var Logger_default = logger;

// src/Sql/Migrations/Columns/CreateTable/ColumnOptionsBuilder.ts
var ColumnOptionsBuilder = class _ColumnOptionsBuilder {
  constructor(table, queryStatements, partialQuery, sqlType, columnName = "", columnReferences = []) {
    this.table = table;
    this.queryStatements = queryStatements;
    this.partialQuery = partialQuery;
    this.sqlType = sqlType;
    this.columnName = columnName;
    this.columnReferences = columnReferences;
  }
  /**
   * @description Makes the column nullable
   */
  nullable() {
    this.partialQuery += " NULL";
    return new _ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName,
      this.columnReferences
    );
  }
  default(value) {
    this.partialQuery += ` DEFAULT ${value}`;
    return new _ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName,
      this.columnReferences
    );
  }
  /**
   * @description Makes the column unsigned allowing only positive values
   */
  unsigned() {
    this.partialQuery += " UNSIGNED";
    return new _ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName,
      this.columnReferences
    );
  }
  /**
   * @description Makes the column not nullable
   */
  notNullable() {
    this.partialQuery += " NOT NULL";
    return new _ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName,
      this.columnReferences
    );
  }
  /**
   * @description Makes the column the primary key
   */
  primary() {
    this.partialQuery += " PRIMARY KEY";
    return new _ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName,
      this.columnReferences
    );
  }
  /**
   * @description Adds an unique constraint
   */
  unique() {
    this.partialQuery += " UNIQUE";
    return new _ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName,
      this.columnReferences
    );
  }
  /**
   * @description Adds an auto increment - only for mysql
   */
  autoIncrement() {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.partialQuery += " AUTO_INCREMENT";
        return new _ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType
        );
      case "postgres":
        throw new Error("Auto Increment not supported for PostgreSQL");
      case "sqlite":
        throw new Error("Auto Increment not supported for SQLite");
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  /**
   * @description Adds a foreign key with a specific constraint
   * @param table
   * @param column
   */
  references(table, column2) {
    this.columnReferences?.push({ table, column: column2 });
    return new _ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName,
      this.columnReferences
    );
  }
  /**
   * @description Chains a new column creation
   */
  newColumn() {
    this.partialQuery += ",\n";
    return new ColumnTypeBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType
    );
  }
  /**
   * @description Commits the column creation - if omitted, the migration will be run empty
   */
  commit() {
    if (this.columnReferences.length) {
      this.columnReferences.forEach((reference) => {
        switch (this.sqlType) {
          case "mysql":
          case "mariadb":
            this.partialQuery += `,
CONSTRAINT fk_${this.table}_${this.columnName} FOREIGN KEY (${this.columnName}) REFERENCES ${reference.table}(${reference.column})`;
            break;
          case "postgres":
            this.partialQuery += `,
CONSTRAINT fk_${this.table}_${this.columnName} FOREIGN KEY (${this.columnName}) REFERENCES ${reference.table}(${reference.column})`;
            break;
          case "sqlite":
            this.partialQuery += `,
FOREIGN KEY (${this.columnName}) REFERENCES ${reference.table}(${reference.column})`;
            break;
          default:
            throw new Error("Unsupported SQL type");
        }
      });
    }
    this.partialQuery += "\n";
    this.partialQuery += ");";
    this.queryStatements.push(this.partialQuery);
  }
};

// src/Sql/Migrations/Columns/CreateTable/ColumnTypeBuilder.ts
var ColumnTypeBuilder = class {
  constructor(table, queryStatements, partialQuery, sqlType) {
    this.table = table;
    this.queryStatements = queryStatements;
    this.partialQuery = partialQuery;
    this.sqlType = sqlType;
    this.columnName = "";
  }
  string(name3, length = 255) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} VARCHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} VARCHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "mssql":
        this.columnName = name3;
        this.partialQuery += `${name3} NVARCHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  varchar(name3, length = 255) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} VARCHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} VARCHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "mssql":
        this.columnName = name3;
        this.partialQuery += `${name3} NVARCHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  // TODO: finish mssql integration
  uuid(name3) {
    switch (this.sqlType) {
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} UUID`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} CHAR(36)`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        Logger_default.warn("SQLite does not support UUID, using text instead");
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  tinytext(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} TINYTEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  mediumtext(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} MEDIUMTEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  longtext(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} LONGTEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  binary(name3, length = 255) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} BINARY(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} BYTEA`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} BLOB(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  enum(name3, values) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} ENUM('${values.join("', '")}')`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT CHECK(${name3} IN ('${values.join(
          "', '"
        )}'))`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} CHECK(${name3} IN ('${values.join(
          "', '"
        )}'))`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  text(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} TEXT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  char(name3, length = 255) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} CHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} CHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} CHAR(${length})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  tinyint(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} TINYINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} SMALLINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} TINYINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  smallint(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} SMALLINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} SMALLINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} SMALLINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  mediumint(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} MEDIUMINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} INTEGER`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} MEDIUMINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  /**
   * @description If using mysql, it will automatically add INT AUTO_INCREMENT
   * @param name
   */
  serial(name3) {
    if (this.sqlType === `mysql` || this.sqlType === `mariadb`) {
      this.columnName = name3;
      this.partialQuery += `${name3} INT AUTO_INCREMENT`;
      return new ColumnOptionsBuilder(
        this.table,
        this.queryStatements,
        this.partialQuery,
        this.sqlType,
        this.columnName
      );
    }
    if (this.sqlType === `sqlite`) {
      this.columnName = name3;
      this.partialQuery += `${name3} INTEGER AUTOINCREMENT`;
      return new ColumnOptionsBuilder(
        this.table,
        this.queryStatements,
        this.partialQuery,
        this.sqlType,
        this.columnName
      );
    }
    this.columnName = name3;
    this.partialQuery += `${name3} SERIAL`;
    return new ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName
    );
  }
  /**
   * @description If not using postgres, it will automatically be converted in BIGINT AUTO_INCREMENT
   * @description If using sqlite, it will automatically be converted in INTEGER PRIMARY KEY AUTOINCREMENT
   * @param name
   */
  bigSerial(name3) {
    if (this.sqlType === `mysql` || this.sqlType === `mariadb`) {
      this.columnName = name3;
      this.partialQuery += `${name3} BIGINT AUTO_INCREMENT`;
      return new ColumnOptionsBuilder(
        this.table,
        this.queryStatements,
        this.partialQuery,
        this.sqlType,
        this.columnName
      );
    }
    if (this.sqlType === `sqlite`) {
      this.columnName = name3;
      this.partialQuery += `${name3} INTEGER PRIMARY KEY AUTOINCREMENT`;
      return new ColumnOptionsBuilder(
        this.table,
        this.queryStatements,
        this.partialQuery,
        this.sqlType,
        this.columnName
      );
    }
    this.columnName = name3;
    this.partialQuery += `${name3} BIGSERIAL`;
    return new ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName
    );
  }
  integer(name3, length) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} INT ${length ? `(${length})` : ""}`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} INTEGER ${length ? `(${length})` : ""}`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} INTEGER ${length ? `(${length})` : ""}`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  bigInteger(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} BIGINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} BIGINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} BIGINT`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  /**
   * @description Alias for integer
   * @param name
   * @returns ColumnOptionsBuilder
   */
  int(name3) {
    return this.integer(name3);
  }
  /**
   * @description Alias for bigInteger
   * @param name
   * @returns ColumnOptionsBuilder
   */
  bigint(name3) {
    return this.bigInteger(name3);
  }
  float(name3, options = {
    precision: 10,
    scale: 2
  }) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} FLOAT(${options.precision}, ${options.scale})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} REAL`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} REAL`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  decimal(name3, options = {
    precision: 10,
    scale: 2
  }) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} DECIMAL(${options.precision}, ${options.scale})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} DECIMAL(${options.precision}, ${options.scale})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} DECIMAL(${options.precision}, ${options.scale})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  double(name3, options = {
    precision: 10,
    scale: 2
  }) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} DOUBLE(${options.precision}, ${options.scale})`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} DOUBLE PRECISION`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        this.columnName = name3;
        this.partialQuery += `${name3} REAL`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  boolean(name3) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name3;
        this.partialQuery += `${name3} BOOLEAN`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "postgres":
        this.columnName = name3;
        this.partialQuery += `${name3} BOOLEAN`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      case "sqlite":
        Logger_default.warn(
          "SQLite does not support boolean columns, using integer instead"
        );
        this.columnName = name3;
        this.partialQuery += `${name3} INTEGER CHECK(${name3} IN (0, 1))`;
        return new ColumnOptionsBuilder(
          this.table,
          this.queryStatements,
          this.partialQuery,
          this.sqlType,
          this.columnName
        );
      default:
        throw new Error("Unsupported SQL type");
    }
  }
  date(name3, options) {
    if (this.sqlType === "sqlite") {
      Logger_default.warn("SQLite does not support date columns, using text instead");
      this.columnName = name3;
      this.partialQuery += `${name3} TEXT`;
      return new ColumnOptionsBuilder(
        this.table,
        this.queryStatements,
        this.partialQuery,
        this.sqlType,
        this.columnName
      );
    }
    this.columnName = name3;
    this.partialQuery += `${name3} DATE`;
    if (options && options.autoCreate) {
      this.partialQuery += " DEFAULT CURRENT_DATE";
    }
    if (options && options.autoUpdate) {
      if (this.sqlType === "postgres") {
        throw new Error(
          "Postgres does not support auto updating a date column"
        );
      }
      this.partialQuery += " ON UPDATE CURRENT_DATE";
    }
    return new ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName
    );
  }
  timestamp(name3, options) {
    if (this.sqlType === "sqlite") {
      Logger_default.warn(
        "SQLite does not support timestamp columns, using text instead"
      );
      this.columnName = name3;
      this.partialQuery += `${name3} TEXT`;
      return new ColumnOptionsBuilder(
        this.table,
        this.queryStatements,
        this.partialQuery,
        this.sqlType,
        this.columnName
      );
    }
    this.columnName = name3;
    this.partialQuery += `${name3} TIMESTAMP`;
    if (options && options.autoCreate) {
      this.partialQuery += " DEFAULT CURRENT_TIMESTAMP";
    }
    if (options && options.autoUpdate) {
      if (this.sqlType === "postgres") {
        throw new Error(
          "Postgres does not support auto updating a date column"
        );
      }
      this.partialQuery += " ON UPDATE CURRENT_TIMESTAMP";
    }
    return new ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName
    );
  }
  /**
   * @description EXPERIMENTAL
   * @param name
   */
  jsonb(name3) {
    if (this.sqlType === "sqlite") {
      throw new Error(
        "SQLite does not support jsonb columns, use text instead"
      );
    }
    this.columnName = name3;
    switch (this.sqlType) {
      case "postgres":
        this.partialQuery += `${name3} JSONB`;
        break;
      case "mariadb":
      case "mysql":
        this.partialQuery += `${name3} JSON`;
        break;
      case "sqlite":
        Logger_default.warn(
          "SQLite does not support jsonb columns, using text instead"
        );
        this.partialQuery += `${name3} TEXT`;
        break;
      default:
        throw new Error("Unsupported SQL type");
    }
    return new ColumnOptionsBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType,
      this.columnName
    );
  }
};

// src/Sql/Migrations/Columns/CreateTable/ColumnBuilderConnector.ts
var ColumnBuilderConnector = class {
  constructor(table, queryStatements, partialQuery, sqlType) {
    this.table = table;
    this.queryStatements = queryStatements;
    this.partialQuery = partialQuery;
    this.sqlType = sqlType;
  }
  newColumn() {
    return new ColumnTypeBuilder(
      this.table,
      this.queryStatements,
      this.partialQuery,
      this.sqlType
    );
  }
};

// src/Sql/Resources/Migration/DROPTABLE.ts
var dropTableTemplate = (table, ifExists, dbType) => {
  switch (dbType) {
    case "mariadb":
    case "mysql":
      return ifExists ? `DROP TABLE IF EXISTS \`${table}\`` : `DROP TABLE \`${table}\``;
    case "postgres":
      return ifExists ? `DROP TABLE IF EXISTS "${table}"` : `DROP TABLE "${table}"`;
    case "sqlite":
      return ifExists ? `DROP TABLE IF EXISTS "${table}"` : `DROP TABLE "${table}"`;
    default:
      throw new Error("Unsupported database type");
  }
};
var DROPTABLE_default = dropTableTemplate;

// src/Sql/Migrations/Columns/AlterTable/ColumnBuilderAlter.ts
var import_luxon = require("luxon");
var ColumnBuilderAlter = class {
  constructor(table, queryStatements, partialQuery, sqlType) {
    this.table = table;
    this.queryStatements = queryStatements;
    this.partialQuery = partialQuery;
    this.sqlType = sqlType;
  }
  /**
   * @description Add a new column to the table
   * @param columnName { string }
   * @param {DataType} dataType
   * @param {BaseOptions} options
   */
  addColumn(columnName, dataType, options) {
    let query = `ALTER TABLE ${this.table} ADD COLUMN `;
    const columnsBuilder = new ColumnTypeBuilder("", [], "", this.sqlType);
    switch (dataType) {
      case "uuid":
        columnsBuilder.uuid(columnName);
        break;
      case "varchar":
        columnsBuilder.varchar(columnName, options?.length);
        break;
      case "tinytext":
        columnsBuilder.tinytext(columnName);
        break;
      case "mediumtext":
        columnsBuilder.mediumtext(columnName);
        break;
      case "longtext":
        columnsBuilder.longtext(columnName);
        break;
      case "binary":
        columnsBuilder.binary(columnName, options?.length);
        break;
      case "text":
        columnsBuilder.text(columnName);
        break;
      case "char":
        columnsBuilder.char(columnName, options?.length);
        break;
      case "tinyint":
        columnsBuilder.tinyint(columnName);
        break;
      case "smallint":
        columnsBuilder.smallint(columnName);
        break;
      case "mediumint":
        columnsBuilder.mediumint(columnName);
        break;
      case "integer":
        columnsBuilder.integer(columnName, options?.length);
        break;
      case "bigint":
        columnsBuilder.bigint(columnName);
        break;
      case "float":
        const { precision: floatPrecision = 10, scale: floatScale = 2 } = options || {};
        columnsBuilder.float(columnName, {
          precision: floatPrecision,
          scale: floatScale
        });
        break;
      case "decimal":
        const { precision = 10, scale = 2 } = options || {};
        columnsBuilder.decimal(columnName, {
          precision,
          scale
        });
        break;
      case "double":
        const { precision: doublePrecision = 10, scale: doubleScale = 2 } = options || {};
        columnsBuilder.double(columnName, {
          precision: doublePrecision,
          scale: doubleScale
        });
        break;
      case "boolean":
        columnsBuilder.boolean(columnName);
        break;
      case "jsonb":
        columnsBuilder.jsonb(columnName);
        break;
      default:
        throw new Error("Unsupported data type");
    }
    query += columnsBuilder.partialQuery;
    if (options?.default !== void 0) {
      if (typeof options.default === "string") {
        query += ` DEFAULT '${options.default}'`;
      } else if (options.default instanceof Date) {
        query += ` DEFAULT '${options.default.toISOString()}'`;
      } else if (options.default instanceof import_luxon.DateTime) {
        query += ` DEFAULT '${options.default.toISO()}'`;
      } else if (typeof options.default === "object") {
        query += ` DEFAULT '${JSON.stringify(options.default)}'`;
      } else if (typeof options.default === null) {
        query += " DEFAULT NULL";
      } else {
        query += ` DEFAULT ${options.default}`;
      }
    }
    if (options?.primaryKey) {
      query += " PRIMARY KEY";
    }
    if (options?.unique) {
      query += " UNIQUE";
    }
    if (options?.references) {
      query += ` REFERENCES ${options.references.table}(${options.references.column})`;
    }
    if (options?.afterColumn) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          query += ` AFTER ${options.afterColumn}`;
          break;
        case "postgres":
          throw new Error("Postgres does not support AFTER in ALTER COLUMN");
        case "sqlite":
          throw new Error("Sqlite does not support AFTER in ALTER COLUMN");
        default:
          throw new Error("Unsupported database type");
      }
    }
    this.partialQuery = query;
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Add a new date column to the table
   * @param columnName { string }
   * @param options { DateOptions }
   */
  addDateColumn(columnName, type2, options) {
    let query = `ALTER TABLE ${this.table} ADD COLUMN ${columnName} ${type2}`;
    if (options?.autoCreate) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          query += " DEFAULT CURRENT_TIMESTAMP";
          break;
        case "postgres":
          query += " DEFAULT CURRENT_TIMESTAMP";
          break;
        case "sqlite":
          query += " DEFAULT CURRENT_TIMESTAMP";
          break;
        default:
          throw new Error("Unsupported database type");
      }
    }
    if (options?.autoUpdate) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          query += " ON UPDATE CURRENT_TIMESTAMP";
          break;
        case "postgres":
          query += " ON UPDATE CURRENT_TIMESTAMP";
          break;
        case "sqlite":
          query += " ON UPDATE CURRENT_TIMESTAMP";
          break;
        default:
          throw new Error("Unsupported database type");
      }
    }
    if (options?.notNullable) {
      query += " NOT NULL";
    }
    if (options?.default !== void 0) {
      if (typeof options.default === "string") {
        query += ` DEFAULT '${options.default}'`;
      } else if (options.default instanceof Date) {
        query += ` DEFAULT '${options.default.toISOString()}'`;
      } else {
        query += ` DEFAULT '${options.default.toISO()}'`;
      }
    }
    if (options?.afterColumn) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          query += ` AFTER ${options.afterColumn}`;
          break;
        case "postgres":
          throw new Error("Postgres does not support AFTER in ALTER COLUMN");
        case "sqlite":
          throw new Error("Sqlite does not support AFTER in ALTER COLUMN");
        default:
          throw new Error("Unsupported database type");
      }
    }
    this.partialQuery = query;
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Add a new enum column to the table
   * @param columnName { string }
   * @param values { string[] }
   * @param options { afterColumn?: string; notNullable?: boolean }
   */
  addEnumColumn(columnName, values, options) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} ADD COLUMN ${columnName} ENUM('${values.join("', '")}')`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} ADD COLUMN ${columnName} ${values[0]}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} ADD COLUMN ${columnName} ${values[0]}`;
        break;
      default:
        throw new Error("Unsupported database type");
    }
    if (options?.notNullable) {
      this.partialQuery += " NOT NULL";
    }
    if (options?.afterColumn) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          this.partialQuery += ` AFTER ${options.afterColumn}`;
          break;
        case "postgres":
          throw new Error("Postgres does not support AFTER in ALTER COLUMN");
        case "sqlite":
          throw new Error("Sqlite does not support AFTER in ALTER COLUMN");
        default:
          throw new Error("Unsupported database type");
      }
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Drops a column from the table
   * @param columnName
   */
  dropColumn(columnName) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} DROP COLUMN ${columnName}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} DROP COLUMN ${columnName}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} DROP COLUMN ${columnName}`;
        break;
      default:
        throw new Error("Unsupported database type");
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Renames a column
   * @param oldColumnName
   * @param newColumnName
   */
  renameColumn(oldColumnName, newColumnName) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} CHANGE ${oldColumnName} ${newColumnName}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} RENAME COLUMN ${oldColumnName} TO ${newColumnName}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} RENAME COLUMN ${oldColumnName} TO ${newColumnName}`;
        break;
      default:
        throw new Error("Unsupported database type");
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  modifyColumnType(columnName, newDataType, options) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} MODIFY COLUMN ${columnName} ${newDataType}${options && options.length ? `(${options.length})` : ""}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} TYPE ${newDataType}${options && options.length ? `(${options.length})` : ""}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} TYPE ${newDataType}${options && options.length ? `(${options.length})` : ""}`;
      default:
        throw new Error("Unsupported database type");
    }
    if (options?.notNullable) {
      this.partialQuery += " NOT NULL";
    }
    if (options?.default !== void 0) {
      this.partialQuery += ` DEFAULT ${options.default}`;
    }
    if (options?.primaryKey) {
      this.partialQuery += " PRIMARY KEY";
    }
    if (options?.unique) {
      this.partialQuery += " UNIQUE";
    }
    if (options?.references) {
      this.partialQuery += ` REFERENCES ${options.references.table}(${options.references.column})`;
    }
    if (options?.afterColumn) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          this.partialQuery += ` AFTER ${options.afterColumn}`;
          break;
        case "postgres":
          throw new Error("Postgres does not support AFTER in ALTER COLUMN");
        case "sqlite":
          throw new Error("Sqlite does not support AFTER in ALTER COLUMN");
        default:
          throw new Error("Unsupported database type");
      }
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Renames a table
   * @param oldtable
   * @param newtable
   */
  renameTable(oldtable, newtable) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `RENAME TABLE ${oldtable} TO ${newtable}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${oldtable} RENAME TO ${newtable}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${oldtable} RENAME TO ${newtable}`;
        break;
      default:
        throw new Error("Unsupported database type");
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Set a default value
   * @param columnName
   * @param defaultValue
   */
  setDefaultValue(columnName, defaultValue) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} SET DEFAULT ${defaultValue}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} SET DEFAULT ${defaultValue}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} SET DEFAULT ${defaultValue}`;
        break;
      default:
        throw new Error("Unsupported database type");
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Drop a default value
   * @param columnName
   */
  dropDefaultValue(columnName) {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} DROP DEFAULT`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} DROP DEFAULT`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} DROP DEFAULT`;
        break;
      default:
        throw new Error("Unsupported database type");
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Add a foreign key
   * @param columnName
   * @param options
   */
  addForeignKey(columnName, options) {
    if (!options.references) {
      throw new Error(
        "References option must be provided to add a foreign key"
      );
    }
    const fkName = `${this.table}_${columnName}_fk`;
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} ADD CONSTRAINT ${fkName} FOREIGN KEY (${columnName}) REFERENCES ${options.references.table}(${options.references.column})`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} ADD CONSTRAINT ${fkName} FOREIGN KEY (${columnName}) REFERENCES ${options.references.table}(${options.references.column})`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} ADD CONSTRAINT ${fkName} FOREIGN KEY (${columnName}) REFERENCES ${options.references.table}(${options.references.column})`;
        break;
      default:
        throw new Error("Unsupported database type");
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Drop a foreign key
   * @param columnName
   */
  dropForeignKey(columnName) {
    const fkName = `${this.table}_${columnName}_fk`;
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} DROP FOREIGN KEY ${fkName}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} DROP CONSTRAINT ${fkName}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} DROP CONSTRAINT ${fkName}`;
        break;
      default:
        throw new Error("Unsupported database type");
    }
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }
  /**
   * @description Commits the changes - if omitted, the migration will be run empty
   */
  commit() {
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
  }
};

// src/Sql/Migrations/Schema/Schema.ts
import_dotenv2.default.config();
var Schema = class {
  constructor(sqlType) {
    this.queryStatements = [];
    this.sqlType = sqlType || process.env.DB_TYPE || "mysql";
  }
  /**
   * @description Add raw query to the migration
   * @param query
   */
  rawQuery(query) {
    this.queryStatements.push(query);
  }
  createTable(table, options) {
    const partialQuery = options && options.ifNotExists ? CREATETABLE_default.createTableIfNotExists(table, this.sqlType) : CREATETABLE_default.createTable(table, this.sqlType);
    return new ColumnBuilderConnector(
      table,
      this.queryStatements,
      partialQuery,
      this.sqlType
    );
  }
  /**
   * @description Alter table
   * @param table
   * @returns ColumnBuilderAlter
   */
  alterTable(table) {
    return new ColumnBuilderAlter(
      table,
      this.queryStatements,
      "",
      this.sqlType
    );
  }
  /**
   * @description Drop table
   * @param table
   * @param ifExists
   * @returns void
   */
  dropTable(table, ifExists = false) {
    this.rawQuery(DROPTABLE_default(table, ifExists, this.sqlType));
  }
  /**
   * @description Rename table
   * @param oldtable
   * @param newtable
   * @returns void
   */
  renameTable(oldtable, newtable) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(`RENAME TABLE \`${oldtable}\` TO \`${newtable}\``);
        break;
      case "postgres":
        this.rawQuery(`ALTER TABLE "${oldtable}" RENAME TO "${newtable}"`);
        break;
      case "sqlite":
        this.rawQuery(`ALTER TABLE "${oldtable}" RENAME TO "${newtable}"`);
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Truncate table
   * @param table
   * @returns void
   */
  truncateTable(table) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(`TRUNCATE TABLE \`${table}\``);
        break;
      case "postgres":
        this.rawQuery(`TRUNCATE TABLE "${table}"`);
        break;
      case "sqlite":
        this.rawQuery(`DELETE FROM "${table}"`);
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Create index on table
   * @param table
   * @param indexName
   * @param columns
   * @param unique
   * @returns void
   */
  createIndex(table, indexName, columns, unique = false) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(
          `CREATE ${unique ? "UNIQUE" : ""} INDEX ${indexName} ON \`${table}\` (${columns.join(", ")})`
        );
        break;
      case "postgres":
        this.rawQuery(
          `CREATE ${unique ? "UNIQUE" : ""} INDEX ${indexName} ON "${table}" (${columns.join(", ")})`
        );
        break;
      case "sqlite":
        this.rawQuery(
          `CREATE ${unique ? "UNIQUE" : ""} INDEX ${indexName} ON "${table}" (${columns.join(", ")})`
        );
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Drop index on table
   * @param table
   * @param indexName
   * @returns void
   */
  dropIndex(table, indexName) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(`DROP INDEX \`${indexName}\` ON \`${table}\``);
        break;
      case "postgres":
        this.rawQuery(`DROP INDEX ${indexName}`);
        break;
      case "sqlite":
        this.rawQuery(`DROP INDEX ${indexName}`);
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Adds a primary key to a table
   * @param table
   * @param columnName
   * @param type
   * @param options
   * @returns void
   */
  addPrimaryKey(table, columns) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(
          `ALTER TABLE \`${table}\` ADD PRIMARY KEY (${columns.join(", ")})`
        );
        break;
      case "postgres":
        this.rawQuery(
          `ALTER TABLE "${table}" ADD PRIMARY KEY (${columns.join(", ")})`
        );
        break;
      case "sqlite":
        this.rawQuery(
          `ALTER TABLE "${table}" ADD PRIMARY KEY (${columns.join(", ")})`
        );
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Drops a primary key from a table
   * @param table
   * @returns void
   */
  dropPrimaryKey(table) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(`ALTER TABLE \`${table}\` DROP PRIMARY KEY`);
        break;
      case "postgres":
        this.rawQuery(`ALTER TABLE "${table}" DROP CONSTRAINT PRIMARY KEY`);
        break;
      case "sqlite":
        this.rawQuery(`ALTER TABLE "${table}" DROP PRIMARY KEY`);
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Adds a foreign key to a table
   * @param table
   * @param constraintName
   * @param columns
   * @returns void
   */
  addConstraint(table, constraintName, columns) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(
          `ALTER TABLE \`${table}\` ADD CONSTRAINT ${constraintName} FOREIGN KEY (${columns.join(
            ", "
          )}) REFERENCES ${columns[0].split("_")[0]}s(id)`
        );
        break;
      case "postgres":
        this.rawQuery(
          `ALTER TABLE "${table}" ADD CONSTRAINT ${constraintName} FOREIGN KEY (${columns.join(
            ", "
          )}) REFERENCES ${columns[0].split("_")[0]}s(id)`
        );
        break;
      case "sqlite":
        this.rawQuery(
          `ALTER TABLE "${table}" ADD CONSTRAINT ${constraintName} FOREIGN KEY (${columns.join(
            ", "
          )}) REFERENCES ${columns[0].split("_")[0]}s(id)`
        );
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Drops a cosntraint from a table
   * @param table
   * @param constraintName
   * @returns void
   */
  dropConstraint(table, constraintName) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(
          `ALTER TABLE \`${table}\` DROP FOREIGN KEY ${constraintName}`
        );
        break;
      case "postgres":
        this.rawQuery(
          `ALTER TABLE "${table}" DROP CONSTRAINT ${constraintName}`
        );
        break;
      case "sqlite":
        this.rawQuery(
          `ALTER TABLE "${table}" DROP CONSTRAINT ${constraintName}`
        );
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Adds a unique constraint to a table
   * @param table
   * @param constraintName
   * @param columns
   * @returns void
   */
  addUniqueConstraint(table, constraintName, columns) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(
          `ALTER TABLE \`${table}\` ADD CONSTRAINT ${constraintName} UNIQUE (${columns.join(
            ", "
          )})`
        );
        break;
      case "sqlite":
        this.rawQuery(
          `ALTER TABLE \`${table}\` ADD CONSTRAINT ${constraintName} UNIQUE (${columns.join(
            ", "
          )})`
        );
        break;
      case "postgres":
        this.rawQuery(
          `ALTER TABLE "${table}" ADD CONSTRAINT ${constraintName} UNIQUE (${columns.join(
            ", "
          )})`
        );
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
  /**
   * @description Drops a unique constraint from a table
   * @param table
   * @param constraintName
   * @returns void
   */
  dropUniqueConstraint(table, constraintName) {
    switch (this.sqlType) {
      case "mysql":
      case "mariadb":
        this.rawQuery(`ALTER TABLE \`${table}\` DROP INDEX ${constraintName}`);
        break;
      case "postgres":
        this.rawQuery(
          `ALTER TABLE "${table}" DROP CONSTRAINT ${constraintName}`
        );
        break;
      case "sqlite":
        this.rawQuery(
          `ALTER TABLE "${table}" DROP CONSTRAINT ${constraintName}`
        );
        break;
      default:
        throw new Error("Unsupported database type");
    }
  }
};

// src/Sql/Migrations/Migration.ts
var Migration = class {
  constructor() {
    this.migrationName = import_path.default.basename(__filename);
    this.schema = new Schema();
  }
};

// src/Sql/Models/Model.ts
var import_reflect_metadata2 = require("reflect-metadata");
var import_luxon6 = require("luxon");

// src/Sql/SqlDatasource.ts
var import_promise = __toESM(require("mysql2/promise"));
var import_pg = __toESM(require("pg"));
var import_mssql2 = __toESM(require_mssql());
var import_sqlite3 = __toESM(require("sqlite3"));

// src/CaseUtils.ts
function camelToSnakeCase(camelCase) {
  if (typeof camelCase !== "string" || !camelCase) {
    return camelCase;
  }
  if (camelCase === camelCase.toLowerCase()) {
    return camelCase;
  }
  return camelCase.replace(/([a-z0-9])([A-Z])/g, "$1_$2").toLowerCase();
}
function fromSnakeToCamelCase(snake) {
  if (typeof snake !== "string" || !snake) {
    return snake;
  }
  if (snake === snake.toUpperCase()) {
    return snake;
  }
  return snake.replace(/(_\w)/g, (x) => x[1].toUpperCase());
}
function convertCase(value, to) {
  if (to === "none") {
    return value;
  }
  if (to === "snake") {
    return camelToSnakeCase(value);
  }
  if (to === "camel") {
    return fromSnakeToCamelCase(value);
  }
  if (to instanceof RegExp) {
    return value.replace(to, (x) => x[1].toUpperCase());
  }
  return to(value);
}

// src/Sql/Resources/Query/SELECT.ts
var commonSelectMethods = [
  "*",
  "COUNT",
  "DISTINCT",
  "CONCAT",
  "GROUP_CONCAT",
  "AVG",
  "MAX",
  "MIN",
  "SUM",
  "AS",
  "CONVERT",
  "CAST",
  "CONVERT_TZ",
  "DATE_FORMAT",
  "CURDATE",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURTIME",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "EXTRACT",
  "HOUR",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "MICROSECOND",
  "MINUTE",
  "MONTH",
  "QUARTER",
  "SECOND",
  "STR_TO_DATE",
  "TIME",
  "TIMESTAMP",
  "WEEK",
  "YEAR",
  "NOW",
  "UTC_DATE",
  "UTC_TIME",
  "UTC_TIMESTAMP",
  "DATE_ADD",
  "DATE_SUB",
  "DATE",
  "DATEDIFF",
  "DATE_FORMAT",
  "DISTINCTROW"
];
var selectTemplate = (dbType, typeofModel) => {
  const table = typeofModel.table;
  const escapeIdentifier = (identifier) => {
    switch (dbType) {
      case "mysql":
      case "sqlite":
      case "mariadb":
        return `\`${identifier.replace(/`/g, "``")}\``;
      case "postgres":
        return `"${identifier.replace(/"/g, '""')}"`;
      case "mssql":
        break;
      default:
        throw new Error("Unsupported database type");
    }
  };
  return {
    selectAll: `SELECT * FROM ${table} `,
    selectById: (id) => `SELECT * FROM ${table} WHERE id = ${id}`,
    selectByIds: (ids) => {
      ids = ids.map((id) => escapeIdentifier(id));
      return `SELECT * FROM ${table} WHERE id IN (${ids.join(", ")})`;
    },
    selectColumns: (...columns) => {
      columns = columns.map((column2) => {
        const columnCase = typeofModel.databaseCaseConvention;
        let tableName = "";
        let columnName = column2;
        let alias = "";
        if (column2.toUpperCase().includes(" AS ")) {
          [columnName, alias] = column2.split(/ AS /i);
        }
        alias = convertCase(alias, columnCase);
        if (columnName.includes(".")) {
          [tableName, columnName] = columnName.split(".");
        }
        if (commonSelectMethods.includes(columnName.toUpperCase()) || columnName.includes("(")) {
          return alias ? `${columnName} AS ${alias}` : columnName;
        }
        let finalColumn = columnName;
        if (!alias) {
          const processedColumnName = escapeIdentifier(
            convertCase(columnName, columnCase)
          );
          finalColumn = tableName ? `${tableName}.${processedColumnName}` : processedColumnName;
        } else if (tableName) {
          finalColumn = `${tableName}.${columnName}`;
        }
        return alias ? `${finalColumn} AS ${alias}` : finalColumn;
      });
      return `SELECT ${columns.join(", ")} FROM ${table} `;
    },
    selectCount: `SELECT COUNT(*) FROM ${table} `,
    selectDistinct: (...columns) => {
      columns = columns.map(
        (column2) => escapeIdentifier(
          convertCase(column2, typeofModel.databaseCaseConvention)
        )
      );
      return `SELECT DISTINCT ${columns.join(", ")} FROM ${table} `;
    },
    selectSum: (column2) => `SELECT SUM(${escapeIdentifier(
      convertCase(column2, typeofModel.databaseCaseConvention)
    )}) FROM ${table} `,
    orderBy: (columns, order = "ASC") => {
      columns = columns.map((column2) => {
        let tableName = "";
        let columnName = column2;
        if (column2.includes(".")) {
          [tableName, columnName] = column2.split(".");
        }
        const processedColumnName = convertCase(
          columnName,
          typeofModel.databaseCaseConvention
        );
        return tableName ? `${tableName}.${processedColumnName}` : processedColumnName;
      });
      return ` ORDER BY ${columns.join(", ")} ${order}`;
    },
    groupBy: (...columns) => {
      columns = columns.map((column2) => {
        let tableName = "";
        let columnName = column2;
        if (column2.includes(".")) {
          [tableName, columnName] = column2.split(".");
        }
        const processedColumnName = convertCase(
          columnName,
          typeofModel.databaseCaseConvention
        );
        return tableName ? `${tableName}.${processedColumnName}` : processedColumnName;
      });
      return ` GROUP BY ${columns.join(", ")}`;
    },
    limit: (limit, preOffset) => {
      if (dbType !== "mssql") {
        return ` LIMIT ${limit}`;
      }
      if (preOffset) {
        return ` FETCH NEXT ${limit} ROWS ONLY`;
      }
      return ` OFFSET 0 ROWS FETCH NEXT ${limit} ROWS ONLY`;
    },
    offset: (offset) => {
      if (dbType !== "mssql") {
        return ` OFFSET ${offset}`;
      }
      return ` OFFSET ${offset} ROWS`;
    }
  };
};
var SELECT_default = selectTemplate;

// src/Sql/Resources/Query/WHERE.TS.ts
var whereTemplate = (dbType, typeofModel) => {
  return {
    convertPlaceHolderToValue: (query, startIndex = 1) => {
      switch (dbType) {
        case "mysql":
        case "sqlite":
        case "mariadb":
          return query.replace(/PLACEHOLDER/g, () => "?");
        case "postgres":
          let index = startIndex;
          return query.replace(/PLACEHOLDER/g, () => `$${index++}`);
        case "mssql":
          return query.replace(/PLACEHOLDER/g, () => `@p${startIndex++}`);
        default:
          throw new Error("Unsupported database type");
      }
    },
    where: (column2, value, operator = "=") => {
      let query = `
WHERE ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} ${operator} PLACEHOLDER`;
      let params = [value];
      if (typeof value === "object" && value !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = `
WHERE JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) ${operator} ?`;
            params = [value];
            break;
          case "postgres":
            query = `
WHERE ${column2}::jsonb ${operator} PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    andWhere: (column2, value, operator = "=") => {
      let query = ` AND ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} ${operator} PLACEHOLDER`;
      let params = [value];
      if (typeof value === "object" && value !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) ${operator} PLACEHOLDER`;
            break;
          case "postgres":
            query = ` AND ${column2}::jsonb ${operator} PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    orWhere: (column2, value, operator = "=") => {
      let query = ` OR ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} ${operator} PLACEHOLDER`;
      let params = [value];
      if (typeof value === "object" && value !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) ${operator} PLACEHOLDER`;
            break;
          case "postgres":
            query = ` OR ${column2}::jsonb ${operator} PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    whereNot: (column2, value) => {
      let query = `
WHERE ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} != PLACEHOLDER`;
      let params = [value];
      if (typeof value === "object" && value !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = `
WHERE JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) != PLACEHOLDER`;
            break;
          case "postgres":
            query = `
WHERE ${column2}::jsonb != PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    andWhereNot: (column2, value) => {
      let query = ` AND ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} != PLACEHOLDER`;
      let params = [value];
      if (typeof value === "object" && value !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) != PLACEHOLDER`;
            break;
          case "postgres":
            query = ` AND ${column2}::jsonb != PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    orWhereNot: (column2, value) => {
      let query = ` OR ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} != PLACEHOLDER`;
      let params = [value];
      if (typeof value === "object" && value !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) != PLACEHOLDER`;
            break;
          case "postgres":
            query = ` OR ${column2}::jsonb != PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    whereBetween: (column2, min, max) => {
      let query = `
WHERE ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} BETWEEN PLACEHOLDER AND PLACEHOLDER`;
      let params = [min, max];
      if (typeof min === "object" && min !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = `
WHERE JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) BETWEEN PLACEHOLDER AND PLACEHOLDER`;
            break;
          case "postgres":
            query = `
WHERE ${column2}::jsonb BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    andWhereBetween: (column2, min, max) => {
      let query = ` AND ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} BETWEEN PLACEHOLDER AND PLACEHOLDER`;
      let params = [min, max];
      if (typeof min === "object" && min !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) BETWEEN PLACEHOLDER AND PLACEHOLDER`;
            break;
          case "postgres":
            query = ` AND ${column2}::jsonb BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    orWhereBetween: (column2, min, max) => {
      let query = ` OR ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} BETWEEN PLACEHOLDER AND PLACEHOLDER`;
      let params = [min, max];
      if (typeof min === "object" && min !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) BETWEEN PLACEHOLDER AND PLACEHOLDER`;
            break;
          case "postgres":
            query = ` OR ${column2}::jsonb BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    whereNotBetween: (column2, min, max) => {
      let query = `
WHERE ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;
      let params = [min, max];
      if (typeof min === "object" && min !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = `
WHERE JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;
            break;
          case "postgres":
            query = `
WHERE ${column2}::jsonb NOT BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    andWhereNotBetween: (column2, min, max) => {
      let query = ` AND ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;
      let params = [min, max];
      if (typeof min === "object" && min !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;
            break;
          case "postgres":
            query = ` AND ${column2}::jsonb NOT BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    orWhereNotBetween: (column2, min, max) => {
      let query = ` OR ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;
      let params = [min, max];
      if (typeof min === "object" && min !== null) {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) NOT BETWEEN PLACEHOLDER AND PLACEHOLDER`;
            break;
          case "postgres":
            query = ` OR ${column2}::jsonb NOT BETWEEN PLACEHOLDER::jsonb AND PLACEHOLDER::jsonb`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    whereIn: (column2, values) => {
      let query = `
WHERE ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
      let params = values;
      if (values[0] && typeof values[0] === "object") {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = `
WHERE JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          case "postgres":
            query = `
WHERE ${convertCase(
              column2,
              typeofModel.databaseCaseConvention
            )}::jsonb IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    andWhereIn: (column2, values) => {
      let query = ` AND ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
      let params = values;
      if (values[0] && typeof values[0] === "object") {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          case "postgres":
            query = ` AND ${convertCase(
              column2,
              typeofModel.databaseCaseConvention
            )}::jsonb IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    orWhereIn: (column2, values) => {
      let query = ` OR ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
      let params = values;
      if (values[0] && typeof values[0] === "object") {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          case "postgres":
            query = ` OR ${convertCase(
              column2,
              typeofModel.databaseCaseConvention
            )}::jsonb IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    whereNotIn: (column2, values) => {
      let query = `
WHERE ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
      let params = values;
      if (values[0] && typeof values[0] === "object") {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = `
WHERE JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          case "postgres":
            query = `
WHERE ${convertCase(
              column2,
              typeofModel.databaseCaseConvention
            )}::jsonb NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    andWhereNotIn: (column2, values) => {
      let query = ` AND ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
      let params = values;
      if (values[0] && typeof values[0] === "object") {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` AND JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          case "postgres":
            query = ` AND ${convertCase(
              column2,
              typeofModel.databaseCaseConvention
            )}::jsonb NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    orWhereNotIn: (column2, values) => {
      let query = ` OR ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
      let params = values;
      if (values[0] && typeof values[0] === "object") {
        switch (dbType) {
          case "mariadb":
          case "mysql":
          case "sqlite":
            query = ` OR JSON_UNQUOTE(JSON_EXTRACT(${column2}, '$')) NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          case "postgres":
            query = ` OR ${convertCase(
              column2,
              typeofModel.databaseCaseConvention
            )}::jsonb NOT IN (${values.map((_2) => "PLACEHOLDER").join(", ")})`;
            break;
          default:
            throw new Error(`Unsupported database type: ${dbType}`);
        }
      }
      return {
        query,
        params
      };
    },
    whereNull: (column2) => ({
      query: `
WHERE ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IS NULL`,
      params: []
    }),
    andWhereNull: (column2) => ({
      query: ` AND ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IS NULL`,
      params: []
    }),
    orWhereNull: (column2) => ({
      query: ` OR ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IS NULL`,
      params: []
    }),
    whereNotNull: (column2) => ({
      query: `
WHERE ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IS NOT NULL`,
      params: []
    }),
    andWhereNotNull: (column2) => ({
      query: ` AND ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IS NOT NULL`,
      params: []
    }),
    orWhereNotNull: (column2) => ({
      query: ` OR ${convertCase(
        column2,
        typeofModel.databaseCaseConvention
      )} IS NOT NULL`,
      params: []
    }),
    rawWhere: (query) => ({
      query: `
WHERE ${query}`,
      params: []
    }),
    rawAndWhere: (query) => ({
      query: ` AND ${query}`,
      params: []
    }),
    rawOrWhere: (query) => ({
      query: ` OR ${query}`,
      params: []
    })
  };
};
var WHERE_TS_default = whereTemplate;

// src/Sql/Models/Relations/Relation.ts
function isRelationDefinition(originalValue) {
  if (originalValue.hasOwnProperty("type") && originalValue.hasOwnProperty("relatedModel") && originalValue.hasOwnProperty("foreignKey")) {
    return true;
  }
  return false;
}
var Relation = class {
  constructor(model, columnName, options) {
    this.model = Model;
    this.columnName = "";
    this.relatedModel = "";
    this.model = model;
    this.columnName = columnName;
    this.relatedModel = this.model.table;
    this.options = options;
  }
};

// src/Sql/Models/Relations/BelongsTo.ts
var BelongsTo = class extends Relation {
  constructor(relatedModel, columnName, foreignKey, options) {
    super(relatedModel, columnName, options);
    this.foreignKey = foreignKey;
    this.type = "belongsTo" /* belongsTo */;
  }
};

// src/Sql/Models/Relations/HasMany.ts
var HasMany = class extends Relation {
  constructor(relatedModel, columnName, foreignKey, options) {
    super(relatedModel, columnName, options);
    this.type = "hasMany" /* hasMany */;
    this.foreignKey = foreignKey;
    this.type = "hasMany" /* hasMany */;
  }
};

// src/Sql/Models/Relations/HasOne.ts
var HasOne = class extends Relation {
  constructor(relatedModel, columnName, foreignKey, options) {
    super(relatedModel, columnName, options);
    this.foreignKey = foreignKey;
    this.type = "hasOne" /* hasOne */;
  }
};

// src/Sql/Models/ModelDecorators.ts
var COLUMN_METADATA_KEY = Symbol("columns");
var DYNAMIC_COLUMN_METADATA_KEY = Symbol("dynamicColumns");
var PRIMARY_KEY_METADATA_KEY = Symbol("primaryKey");
var BOOLEAN_COLUMN_METADATA_KEY = Symbol("booleanColumns");
var RELATION_METADATA_KEY = Symbol("relations");
function column(options = { primaryKey: false, booleanColumn: false }) {
  return (target, propertyKey) => {
    if (options.primaryKey) {
      const primaryKey = Reflect.getMetadata(PRIMARY_KEY_METADATA_KEY, target);
      if (primaryKey) {
        throw new Error("Multiple primary keys are not allowed");
      }
      Reflect.defineMetadata(PRIMARY_KEY_METADATA_KEY, propertyKey, target);
    }
    if (options.booleanColumn) {
      const booleanColumns = Reflect.getMetadata(BOOLEAN_COLUMN_METADATA_KEY, target) || [];
      booleanColumns.push(propertyKey);
      Reflect.defineMetadata(
        BOOLEAN_COLUMN_METADATA_KEY,
        booleanColumns,
        target
      );
    }
    const existingColumns = Reflect.getMetadata(COLUMN_METADATA_KEY, target) || [];
    existingColumns.push(propertyKey);
    Reflect.defineMetadata(COLUMN_METADATA_KEY, existingColumns, target);
  };
}
function getModelColumns(target) {
  return Reflect.getMetadata(COLUMN_METADATA_KEY, target.prototype) || [];
}
function getModelBooleanColumns(target) {
  return Reflect.getMetadata(BOOLEAN_COLUMN_METADATA_KEY, target.prototype) || [];
}
function belongsTo(model, foreignKey, options) {
  return (target, propertyKey) => {
    const relation = {
      type: "belongsTo" /* belongsTo */,
      columnName: propertyKey,
      model,
      foreignKey,
      options
    };
    const relations = Reflect.getMetadata(RELATION_METADATA_KEY, target) || [];
    relations.push(relation);
    Reflect.defineMetadata(RELATION_METADATA_KEY, relations, target);
  };
}
function hasOne(model, foreignKey, options) {
  return (target, propertyKey) => {
    const relation = {
      type: "hasOne" /* hasOne */,
      columnName: propertyKey,
      model,
      foreignKey,
      options
    };
    const relations = Reflect.getMetadata(RELATION_METADATA_KEY, target) || [];
    relations.push(relation);
    Reflect.defineMetadata(RELATION_METADATA_KEY, relations, target);
  };
}
function hasMany(model, foreignKey, options) {
  return (target, propertyKey) => {
    const relation = {
      type: "hasMany" /* hasMany */,
      columnName: propertyKey,
      model,
      foreignKey,
      options
    };
    const relations = Reflect.getMetadata(RELATION_METADATA_KEY, target) || [];
    relations.push(relation);
    Reflect.defineMetadata(RELATION_METADATA_KEY, relations, target);
  };
}
function getRelations(target) {
  const relations = Reflect.getMetadata(RELATION_METADATA_KEY, target.prototype) || [];
  return relations.map((relation) => {
    const { type: type2, model, columnName, foreignKey, options } = relation;
    switch (type2) {
      case "belongsTo" /* belongsTo */:
        return new BelongsTo(model(), columnName, foreignKey, options);
      case "hasOne" /* hasOne */:
        return new HasOne(model(), columnName, foreignKey, options);
      case "hasMany" /* hasMany */:
        return new HasMany(model(), columnName, foreignKey, options);
      default:
        throw new Error(`Unknown relation type: ${type2}`);
    }
  });
}
function getPrimaryKey(target) {
  return Reflect.getMetadata(PRIMARY_KEY_METADATA_KEY, target.prototype);
}
function getDynamicColumns(target) {
  return Reflect.getMetadata(DYNAMIC_COLUMN_METADATA_KEY, target.prototype);
}

// src/Sql/jsonUtils.ts
function isNestedObject(value) {
  return typeof value === "object" && !Array.isArray(value) && value !== null && Object.keys(value).length > 0;
}

// src/Sql/serializer.ts
async function parseDatabaseDataIntoModelResponse(models, typeofModel, relationModels = []) {
  if (!models.length) {
    return null;
  }
  const relations = getRelations(typeofModel);
  const serializedModels = models.map((model) => {
    const serializedModel = serializeModel(model, typeofModel);
    processRelation(serializedModel, typeofModel, relations, relationModels);
    addNullModelColumns(typeofModel, serializedModel);
    return serializedModel;
  });
  return serializedModels.length === 1 ? serializedModels[0] : serializedModels;
}
function serializeModel(model, typeofModel) {
  const camelCaseModel = {};
  const booleanColumns = getModelBooleanColumns(typeofModel);
  for (const key in model) {
    if (model[key] === void 0) {
      delete model[key];
    }
    if (model.hasOwnProperty(key)) {
      if (key === "extraColumns") {
        processExtraColumns(model, key, camelCaseModel, typeofModel);
        continue;
      }
      const originalValue = model[key];
      if (originalValue == null) {
        camelCaseModel[convertCase(key, typeofModel.modelCaseConvention)] = originalValue;
        continue;
      }
      if (isRelationDefinition(originalValue)) {
        continue;
      }
      const camelCaseKey = convertCase(key, typeofModel.modelCaseConvention);
      if (isNestedObject(originalValue) && !Array.isArray(originalValue)) {
        camelCaseModel[camelCaseKey] = convertToModelCaseConvention(
          originalValue,
          typeofModel
        );
        continue;
      }
      if (Array.isArray(originalValue)) {
        continue;
      }
      if (booleanColumns.includes(camelCaseKey)) {
        camelCaseModel[camelCaseKey] = Boolean(originalValue);
        continue;
      }
      camelCaseModel[camelCaseKey] = originalValue;
    }
  }
  return camelCaseModel;
}
function addNullModelColumns(typeofModel, serializedModel) {
  const columns = getModelColumns(typeofModel);
  columns.forEach((column2) => {
    const casedColumn = convertCase(
      column2,
      typeofModel.modelCaseConvention
    );
    if (serializedModel.hasOwnProperty(column2)) {
      return;
    }
    serializedModel[casedColumn] = null;
  });
}
function processExtraColumns(model, key, camelCaseModel, typeofModel) {
  if (!Object.keys(model[key]).length) {
    return;
  }
  const extraColumns = Object.keys(model[key]).reduce(
    (acc, objKey) => {
      acc[convertCase(objKey, typeofModel.modelCaseConvention)] = model[key][objKey];
      return acc;
    },
    {}
  );
  camelCaseModel[key] = extraColumns;
}
function processRelation(serializedModel, typeofModel, relations, relationModels) {
  relations.forEach((relation) => {
    const relationModel = relationModels.find(
      (relationModel2) => relationModel2[relation.columnName]
    );
    if (!relationModel) {
      return;
    }
    const relatedModels = relationModel[relation.columnName];
    const foreignKey = convertCase(
      relation.foreignKey,
      typeofModel.modelCaseConvention
    );
    const primaryKey = convertCase(
      typeofModel.primaryKey,
      typeofModel.modelCaseConvention
    );
    switch (relation.type) {
      case "belongsTo" /* belongsTo */:
        const relatedModelMap = /* @__PURE__ */ new Map();
        relatedModels.forEach((model) => {
          relatedModelMap.set(model[primaryKey], model);
        });
        const retrievedRelatedModel = relatedModelMap.get(
          serializedModel[foreignKey]
        );
        if (retrievedRelatedModel) {
          serializedModel[relation.columnName] = serializeModel(
            retrievedRelatedModel,
            relation.model
          );
        }
        break;
      case "hasOne" /* hasOne */:
        const relatedModelMapHasOne = /* @__PURE__ */ new Map();
        relatedModels.forEach((model) => {
          relatedModelMapHasOne.set(model[foreignKey], model);
        });
        const retrievedRelatedModelHasOne = relatedModelMapHasOne.get(
          serializedModel[foreignKey]
        );
        if (retrievedRelatedModelHasOne) {
          serializedModel[relation.columnName] = serializeModel(
            retrievedRelatedModelHasOne,
            relation.model
          );
        }
        break;
      case "hasMany" /* hasMany */:
        const retrievedRelatedModels = relatedModels.filter(
          (item) => (
            // Since it's still raw data and it's not yet been converted to camel case (it will soon in the serializeModel call)m it's matched with the camel case key
            item[convertCase(
              foreignKey,
              typeofModel.databaseCaseConvention
            )] === serializedModel[primaryKey]
          )
        );
        serializedModel[relation.columnName] = retrievedRelatedModels.map(
          (model) => serializeModel(model, relation.model)
        );
        break;
      default:
        throw new Error("Relation type not supported");
    }
  });
}
function convertToModelCaseConvention(originalValue, typeofModel) {
  return Object.keys(originalValue).reduce(
    (acc, objKey) => {
      acc[convertCase(objKey, typeofModel.modelCaseConvention)] = originalValue[objKey];
      return acc;
    },
    {}
  );
}
async function addDynamicColumnsToModel(typeofModel, model, dynamicColumnsToAdd) {
  const dynamicColumns = getDynamicColumns(typeofModel);
  if (!dynamicColumns || !dynamicColumns.length) {
    return;
  }
  const dynamicColumnMap = /* @__PURE__ */ new Map();
  for (const dynamicColumn of dynamicColumns) {
    dynamicColumnMap.set(dynamicColumn.functionName, {
      columnName: dynamicColumn.columnName,
      dynamicColumnFn: dynamicColumn.dynamicColumnFn
    });
  }
  const promises = dynamicColumnsToAdd.map(async (dynamicColumn) => {
    const dynamic = dynamicColumnMap.get(dynamicColumn);
    const casedKey = convertCase(
      dynamic?.columnName,
      typeofModel.modelCaseConvention
    );
    Object.assign(model, { [casedKey]: await dynamic?.dynamicColumnFn() });
  });
  await Promise.all(promises);
}

// src/Sql/QueryBuilder/QueryBuilder.ts
var QueryBuilder = class {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param logs - A boolean indicating whether to log queries.
   */
  constructor(model, table, logs, sqlDataSource) {
    this.sqlDataSource = sqlDataSource;
    this.model = model;
    this.logs = logs;
    this.table = table;
    this.selectQuery = SELECT_default(
      this.sqlDataSource.getDbType(),
      this.model
    ).selectAll;
    this.selectTemplate = SELECT_default(
      this.sqlDataSource.getDbType(),
      this.model
    );
    this.whereTemplate = WHERE_TS_default(
      this.sqlDataSource.getDbType(),
      this.model
    );
    this.joinQuery = "";
    this.relations = [];
    this.dynamicColumns = [];
    this.whereQuery = "";
    this.groupByQuery = "";
    this.orderByQuery = "";
    this.limitQuery = "";
    this.offsetQuery = "";
    this.params = [];
  }
  groupFooterQuery() {
    return this.groupByQuery + this.orderByQuery + this.limitQuery + this.offsetQuery;
  }
  async mergeRawPacketIntoModel(model, row, typeofModel) {
    const columns = getModelColumns(this.model);
    Object.entries(row).forEach(([key, value]) => {
      const casedKey = convertCase(
        key,
        typeofModel.modelCaseConvention
      );
      if (columns.includes(casedKey)) {
        Object.assign(model, { [casedKey]: value });
        return;
      }
      model.extraColumns[key] = value;
    });
    if (!this.dynamicColumns.length) {
      return;
    }
    await addDynamicColumnsToModel(this.model, model, this.dynamicColumns);
  }
};

// src/Sql/Resources/Query/JOIN.ts
var joinTemplate = (typeofModel, relatedTable, primaryColumn, foreignColumn) => {
  const table = typeofModel.table;
  const foreignColumnName = foreignColumn.includes(".") ? foreignColumn.split(".").pop() : foreignColumn;
  const primaryColumnName = primaryColumn.includes(".") ? primaryColumn.split(".").pop() : primaryColumn;
  return {
    innerJoin: () => {
      const foreignColumnConverted = convertCase(
        foreignColumnName,
        typeofModel.databaseCaseConvention
      );
      const primaryColumnConverted = convertCase(
        primaryColumnName,
        typeofModel.databaseCaseConvention
      );
      return `
INNER JOIN ${relatedTable} ON ${relatedTable}.${foreignColumnConverted} = ${table}.${primaryColumnConverted} `;
    },
    leftJoin: () => {
      const foreignColumnConverted = convertCase(
        foreignColumnName,
        typeofModel.databaseCaseConvention
      );
      const primaryColumnConverted = convertCase(
        primaryColumnName,
        typeofModel.databaseCaseConvention
      );
      return `
LEFT JOIN ${relatedTable} ON ${relatedTable}.${foreignColumnConverted} = ${table}.${primaryColumnConverted} `;
    }
  };
};
var JOIN_default = joinTemplate;

// src/Sql/pagination.ts
function getPaginationMetadata(page, limit, total) {
  return {
    total,
    perPage: limit,
    currentPage: page,
    firstPage: 1,
    isEmpty: total === 0,
    lastPage: Math.max(1, Math.ceil(total / limit)),
    hasMorePages: page < Math.max(1, Math.ceil(total / limit)),
    hasPages: total > limit
  };
}

// src/Sql/Resources/Query/DELETE.ts
var deleteTemplate = (table, dbType) => {
  return {
    delete: (column2, value) => {
      let baseQuery = `DELETE FROM ${table} WHERE ${column2} = PLACEHOLDER`;
      switch (dbType) {
        case "mariadb":
        case "sqlite":
        case "mysql":
          baseQuery = baseQuery.replace("PLACEHOLDER", "?");
          break;
        case "postgres":
          baseQuery = baseQuery.replace("PLACEHOLDER", "$1");
          break;
        case "mssql":
          baseQuery = baseQuery.replace("PLACEHOLDER", `@${column2}`);
          break;
        default:
          throw new Error("Unsupported database type");
      }
      return { query: baseQuery, params: [value] };
    },
    massiveDelete: (whereClause, joinClause = "") => {
      return `DELETE FROM ${table} ${joinClause} ${whereClause}`;
    }
  };
};
var DELETE_default = deleteTemplate;

// src/Sql/Resources/Query/INSERT.ts
var insertTemplate = (dbType, typeofModel) => {
  const table = typeofModel.table;
  return {
    insert: (columns, values) => {
      columns = columns.map(
        (column2) => convertCase(column2, typeofModel.databaseCaseConvention)
      );
      let placeholders;
      let params;
      switch (dbType) {
        case "mysql":
        case "sqlite":
        case "mariadb":
          placeholders = columns.map(() => "?").join(", ");
          params = values;
          break;
        case "mssql":
          placeholders = columns.map((column2) => `@${column2}`).join(", ");
          params = values;
          break;
        case "postgres":
          placeholders = columns.map((_2, index) => {
            if (isNestedObject(values[index])) {
              return `$${index + 1}::jsonb`;
            }
            return `$${index + 1}`;
          }).join(", ");
          params = values.map(
            (value) => isNestedObject(value) ? JSON.stringify(value) : value
          );
          break;
        default:
          throw new Error("Unsupported database type");
      }
      const query = dbType !== "postgres" ? `INSERT INTO ${table} (${columns.join(", ")})
VALUES (${placeholders});` : `INSERT INTO ${table} (${columns.join(", ")})
VALUES (${placeholders}) RETURNING *;`;
      return { query, params };
    },
    insertMany: (columns, values) => {
      columns = columns.map(
        (column2) => convertCase(column2, typeofModel.databaseCaseConvention)
      );
      let valueSets;
      let params = [];
      switch (dbType) {
        case "mysql":
        case "sqlite":
        case "mariadb":
          valueSets = values.map((valueSet) => {
            params.push(...valueSet);
            return `(${valueSet.map(() => "?").join(", ")})`;
          });
          break;
        case "mssql":
          valueSets = values.map((valueSet) => {
            params.push(...valueSet);
            return `(${valueSet.map((column2) => `@${column2}`).join(", ")})`;
          });
          break;
        case "postgres":
          valueSets = values.map((valueSet, rowIndex) => {
            params.push(
              ...valueSet.map(
                (value) => isNestedObject(value) ? JSON.stringify(value) : value
              )
            );
            return `(${valueSet.map((value, colIndex) => {
              if (isNestedObject(value)) {
                return `$${rowIndex * columns.length + colIndex + 1}::jsonb`;
              }
              return `$${rowIndex * columns.length + colIndex + 1}`;
            }).join(", ")})`;
          });
          break;
        default:
          throw new Error("Unsupported database type");
      }
      const query = dbType !== "postgres" ? `INSERT INTO ${table} (${columns.join(", ")})
VALUES ${valueSets.join(", ")};` : `INSERT INTO ${table} (${columns.join(", ")})
VALUES ${valueSets.join(", ")} RETURNING *;`;
      return { query, params };
    }
  };
};
var INSERT_default = insertTemplate;

// src/Sql/Resources/Query/RELATIONS.ts
function parseValueType(value) {
  return typeof value;
}
function convertValueToSQL(value, type2) {
  switch (type2) {
    case "string":
      return `'${value}'`;
    case "number":
    case "boolean":
      return `${value}`;
    default:
      throw new Error(`Unsupported value type: ${type2}`);
  }
}
function relationTemplates(models, relation, relationName, typeofModel) {
  const primaryKey = relation.model.primaryKey;
  const foreignKey = relation.foreignKey;
  const relatedModel = relation.relatedModel;
  const primaryKeyValues = models.map((model) => {
    const value = model[convertCase(primaryKey, typeofModel.modelCaseConvention)];
    return { value, type: parseValueType(value) };
  });
  const foreignKeyValues = models.map((model) => {
    const value = model[convertCase(foreignKey, typeofModel.modelCaseConvention)];
    return { value, type: parseValueType(value) };
  });
  const softDeleteColumn = relation.options?.softDeleteColumn;
  const softDeleteQuery = relation.options?.softDeleteType === "date" ? ` AND ${relatedModel}.${convertCase(
    softDeleteColumn,
    typeofModel.databaseCaseConvention
  )} IS NULL` : ` AND ${relatedModel}.${convertCase(
    softDeleteColumn,
    typeofModel.databaseCaseConvention
  )} = false`;
  switch (relation.type) {
    case "hasOne" /* hasOne */:
      if (primaryKeyValues.some(({ value }) => !value)) {
        Logger_default.error(
          `Invalid primaryKey values for ${typeofModel.name}, ${primaryKeyValues.map(({ value }) => value).join(", ")}`
        );
        throw new Error(
          `Invalid primaryKey values for ${typeofModel.name}, ${primaryKeyValues.map(({ value }) => value).join(", ")}`
        );
      }
      return `SELECT *, '${relationName}' as relation_name FROM ${relatedModel} WHERE ${relatedModel}.${convertCase(
        foreignKey,
        typeofModel.databaseCaseConvention
      )} IN (${primaryKeyValues.map(({ value, type: type2 }) => convertValueToSQL(value, type2)).join(", ")})${softDeleteColumn ? softDeleteQuery : ""};`;
    case "belongsTo" /* belongsTo */:
      if (foreignKeyValues.some(({ value }) => !value)) {
        Logger_default.error(
          `Invalid foreignKey values for ${relatedModel}, ${foreignKeyValues.map(({ value }) => value).join(", ")}`
        );
        throw new Error(
          `Invalid foreignKey values for ${relatedModel}, ${foreignKeyValues.map(({ value }) => value).join(", ")}`
        );
      }
      if (!primaryKey) {
        throw new Error(
          `Related Model ${relatedModel} does not have a primary key`
        );
      }
      return `SELECT *, '${relationName}' as relation_name FROM ${relatedModel} WHERE ${relatedModel}.${primaryKey} IN (${foreignKeyValues.map(({ value, type: type2 }) => convertValueToSQL(value, type2)).join(", ")}) ${softDeleteColumn ? softDeleteQuery : ""};`;
    case "hasMany" /* hasMany */:
      if (primaryKeyValues.some(({ value }) => !value)) {
        Logger_default.error(
          `Invalid primaryKey values: ${primaryKeyValues.map(
            ({ value }) => value
          )}`
        );
        throw new Error("Invalid primaryKey values");
      }
      return `SELECT *, '${relationName}' as relation_name FROM ${relatedModel} WHERE ${relatedModel}.${convertCase(
        foreignKey,
        typeofModel.databaseCaseConvention
      )} IN (${primaryKeyValues.map(({ value, type: type2 }) => convertValueToSQL(value, type2)).join(", ")}) ${softDeleteColumn ? softDeleteQuery : ""};`;
    default:
      throw new Error(`Unknown relation type: ${relation.type}`);
  }
}
var RELATIONS_default = relationTemplates;

// src/Sql/Resources/Query/UPDATE.ts
var updateTemplate = (dbType, typeofModel) => {
  const table = typeofModel.table;
  return {
    update: (columns, values, primaryKey, primaryKeyValue) => {
      if (columns.includes("extraColumns")) {
        const extraColumnsIndex = columns.indexOf("extraColumns");
        columns.splice(columns.indexOf("extraColumns"), 1);
        values.splice(extraColumnsIndex, 1);
      }
      columns = columns.map(
        (column2) => convertCase(column2, typeofModel.databaseCaseConvention)
      );
      let setClause;
      let params;
      switch (dbType) {
        case "mysql":
        case "sqlite":
        case "mariadb":
          setClause = columns.map((column2) => `\`${column2}\` = ?`).join(", ");
          params = [...values, primaryKeyValue];
          break;
        case "postgres":
          setClause = columns.map((column2, index) => `"${column2}" = $${index + 1}`).join(", ");
          params = [...values, primaryKeyValue];
          break;
        case "mssql":
          setClause = columns.map((column2, index) => `"${column2}" = @${column2}`).join(", ");
          params = [...values, primaryKeyValue];
          break;
        default:
          throw new Error("Unsupported database type");
      }
      const primaryKeyPlaceholder = dbType === "postgres" ? `$${columns.length + 1}` : dbType === "mssql" ? `@${primaryKey}` : "?";
      const query = `UPDATE ${table} 
SET ${setClause} 
WHERE ${primaryKey} = ${primaryKeyPlaceholder};`;
      return { query, params };
    },
    massiveUpdate: (columns, values, whereClause, joinClause = "") => {
      columns = columns.map(
        (column2) => convertCase(column2, typeofModel.databaseCaseConvention)
      );
      let setClause;
      const params = [];
      switch (dbType) {
        case "mysql":
        case "sqlite":
        case "mariadb":
          setClause = columns.map((column2) => `\`${column2}\` = ?`).join(", ");
          values.forEach((value) => {
            params.push(value ?? null);
          });
          break;
        case "postgres":
          setClause = columns.map((column2, index) => `"${column2}" = $${index + 1}`).join(", ");
          values.forEach((value) => {
            params.push(value ?? null);
          });
          break;
        case "mssql":
          setClause = columns.map((column2) => `"${column2}" = @${column2}`).join(", ");
          values.forEach((value) => {
            params.push(value ?? null);
          });
          break;
        default:
          throw new Error("Unsupported database type");
      }
      const query = `UPDATE ${table} ${joinClause}
SET ${setClause} ${whereClause}`;
      return { query, params };
    }
  };
};
var UPDATE_default = updateTemplate;

// src/Sql/Models/ModelManager/AbstractModelManager.ts
var AbstractModelManager = class {
  /**
   * @param model
   * @param logs
   * @param sqlDataSource Passed if a custom connection is provided
   */
  constructor(model, logs, sqlDataSource) {
    this.logs = logs;
    this.model = model;
    this.throwError = false;
    this.modelInstance = getBaseModelInstance();
    this.sqlDataSource = sqlDataSource;
  }
};

// src/Sql/Mssql/MssqlModelManager.ts
var import_mssql = __toESM(require_mssql());

// src/Sql/QueryBuilder/WhereQueryBuilder.ts
var WhereQueryBuilder = class {
  /**
   * @description Constructs a QueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, logs, isNestedCondition = false, sqlDataSource) {
    this.whereQuery = "";
    this.whereParams = [];
    this.isNestedCondition = false;
    this.model = model;
    this.sqlDataSource = sqlDataSource;
    this.logs = logs;
    this.table = table;
    this.whereTemplate = WHERE_TS_default(
      this.sqlDataSource.getDbType(),
      this.model
    );
    this.whereParams = [];
    this.isNestedCondition = isNestedCondition;
  }
  /**
   * @description Accepts a value and executes a callback only of the value exists
   * @param {any} value
   * @param callback
   */
  when(value, cb) {
    if (value === void 0 || value === null) {
      return this;
    }
    cb(value, this);
    return this;
  }
  where(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.whereQuery || this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.where(
      column2,
      actualValue,
      operator
    );
    this.whereQuery = query;
    this.whereParams.push(...params);
    return this;
  }
  andWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (!this.whereQuery && !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  orWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (!this.whereQuery && !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  whereBetween(column2, min, max) {
    if (!this.whereQuery && !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  andWhereBetween(column2, min, max) {
    if (!this.whereQuery && !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  orWhereBetween(column2, min, max) {
    if (!this.whereQuery && !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  whereNotBetween(column2, min, max) {
    if (!this.whereQuery && !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  orWhereNotBetween(column2, min, max) {
    if (!this.whereQuery && !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  whereIn(column2, values) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  andWhereIn(column2, values) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  orWhereIn(column2, values) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  whereNotIn(column2, values) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  orWhereNotIn(column2, values) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  whereNull(column2) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  andWhereNull(column2) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  orWhereNull(column2) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNull(column2);
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  whereNotNull(column2) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  andWhereNotNull(column2) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  orWhereNotNull(column2) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.whereParams.push(...params);
    return this;
  }
  /**
   * @description Adds a raw WHERE condition to the query.
   * @param query - The raw SQL WHERE condition.
   * @returns The QueryBuilder instance for chaining.
   */
  rawWhere(query) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery = rawQuery2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawAndWhere(query);
    this.whereQuery += rawQuery;
    this.whereParams.push(...params);
    return this;
  }
  /**
   * @description Adds a raw AND WHERE condition to the query.
   * @param query - The raw SQL WHERE condition.
   * @returns The QueryBuilder instance for chaining.
   */
  rawAndWhere(query) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery = rawQuery2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawAndWhere(query);
    this.whereQuery += rawQuery;
    this.whereParams.push(...params);
    return this;
  }
  /**
   * @description Adds a raw OR WHERE condition to the query.
   * @param query - The raw SQL WHERE condition.
   * @returns The QueryBuilder instance for chaining.
   */
  rawOrWhere(query) {
    if (!this.whereQuery || !this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery = rawQuery2;
      this.whereParams.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawOrWhere(query);
    this.whereQuery += rawQuery;
    this.whereParams.push(...params);
    return this;
  }
};

// src/Sql/QueryBuilder/UpdateQueryBuilder.ts
var ModelUpdateQueryBuilder = class extends WhereQueryBuilder {
};

// src/Sql/Mssql/MssqlUpdateQueryBuilder.ts
var MssqlUpdateQueryBuilder = class _MssqlUpdateQueryBuilder extends ModelUpdateQueryBuilder {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param mssqlConnection - The MySQL connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, mssqlConnection, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, false, sqlDataSource);
    this.joinQuery = "";
    this.isNestedCondition = false;
    this.sqlConnection = mssqlConnection;
    this.updateTemplate = UPDATE_default(
      this.sqlDataSource.getDbType(),
      this.model
    );
    this.joinQuery = "";
    this.isNestedCondition = isNestedCondition;
  }
  async withData(data, options) {
    const { ignoreBeforeUpdateHook } = options || {};
    if (!ignoreBeforeUpdateHook) {
      this.model.beforeUpdate(this);
    }
    const columns = Object.keys(data);
    const values = Object.values(data);
    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(
      this.whereQuery
    );
    const { query, params } = this.updateTemplate.massiveUpdate(
      columns,
      values,
      this.whereQuery,
      this.joinQuery
    );
    params.push(...this.whereParams);
    log(query, this.logs, params);
    try {
      const mssqlRequest = this.sqlConnection.request();
      MssqllModelManager.addParamsToMssqlRequest(mssqlRequest, query, params);
      const result = await mssqlRequest.query(query);
      return result.rowsAffected[0];
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   * @description Build more complex where conditions.
   * @param cb
   */
  whereBuilder(cb) {
    const queryBuilder = new _MssqlUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.whereParams.push(...queryBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex OR-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  orWhereBuilder(cb) {
    const nestedBuilder = new _MssqlUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex AND-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  andWhereBuilder(cb) {
    const nestedBuilder = new _MssqlUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
};

// src/Sql/Mssql/MssqlDeleteQueryBuilder.ts
var import_luxon2 = require("luxon");

// src/Sql/QueryBuilder/DeleteQueryBuilder.ts
var ModelDeleteQueryBuilder = class extends WhereQueryBuilder {
};

// src/Sql/Mssql/MssqlDeleteQueryBuilder.ts
var MssqlDeleteQueryBuilder = class _MssqlDeleteQueryBuilder extends ModelDeleteQueryBuilder {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param sqlConnection - The mssql connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, sqlConnection, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, false, sqlDataSource);
    this.isNestedCondition = false;
    this.sqlConnection = sqlConnection;
    this.updateTemplate = UPDATE_default(sqlDataSource.getDbType(), this.model);
    this.deleteTemplate = DELETE_default(table, sqlDataSource.getDbType());
    this.joinQuery = "";
    this.isNestedCondition = isNestedCondition;
  }
  async softDelete(options) {
    const {
      column: column2 = "deletedAt",
      value = import_luxon2.DateTime.local().toISO(),
      ignoreBeforeDeleteHook = false
    } = options || {};
    if (!ignoreBeforeDeleteHook) {
      this.model.beforeDelete(this);
    }
    let { query, params } = this.updateTemplate.massiveUpdate(
      [column2],
      [value],
      this.whereQuery,
      this.joinQuery
    );
    params = [...params, ...this.whereParams];
    log(query, this.logs, params);
    try {
      const mssqlRequest = this.sqlConnection.request();
      MssqllModelManager.addParamsToMssqlRequest(mssqlRequest, query, params);
      const result = await mssqlRequest.query(query);
      return result.rowsAffected[0];
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async delete(options = {}) {
    const { ignoreBeforeDeleteHook } = options || {};
    if (!ignoreBeforeDeleteHook) {
      this.model.beforeDelete(this);
    }
    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(
      this.whereQuery
    );
    const query = this.deleteTemplate.massiveDelete(
      this.whereQuery,
      this.joinQuery
    );
    log(query, this.logs, this.whereParams);
    try {
      const mssqlRequest = this.sqlConnection.request();
      MssqllModelManager.addParamsToMssqlRequest(mssqlRequest, query, []);
      const result = await mssqlRequest.query(query);
      return result.rowsAffected[0];
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   * @description Build more complex where conditions.
   * @param cb
   */
  whereBuilder(cb) {
    const queryBuilder = new _MssqlDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.whereParams.push(...queryBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex OR-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  orWhereBuilder(cb) {
    const nestedBuilder = new _MssqlDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex AND-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  andWhereBuilder(cb) {
    const nestedBuilder = new _MssqlDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
};

// src/Sql/Mssql/MssqlQueryBuilder.ts
var MssqlQueryBuilder = class _MssqlQueryBuilder extends QueryBuilder {
  /**
   * @param table - The name of the table.
   * @param sqlConnection - The mssql connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, sqlConnection, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, sqlDataSource);
    this.isNestedCondition = false;
    this.sqlConnection = sqlConnection;
    this.isNestedCondition = isNestedCondition;
    this.mysqlModelManagerUtils = new SqlModelManagerUtils(
      "mssql",
      this.sqlConnection
    );
    this.limitNumber = 0;
  }
  checkLimitQuery() {
    if (!this.limitNumber) {
      return;
    }
    this.limitQuery = this.selectTemplate.limit(
      this.limitNumber,
      !!this.offsetQuery
    );
  }
  async one(options = { throwErrorOnNull: false }) {
    this.checkLimitQuery();
    if (!options.ignoreHooks?.includes("beforeFetch")) {
      this.model.beforeFetch(this);
    }
    let query = "";
    if (this.joinQuery && !this.selectQuery) {
      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);
    }
    query = this.selectQuery + this.joinQuery;
    if (this.whereQuery) {
      query += this.whereQuery;
    }
    query = this.whereTemplate.convertPlaceHolderToValue(query);
    this.limit(1);
    this.checkLimitQuery();
    query += this.groupFooterQuery();
    query = query.trim();
    log(query, this.logs, this.params);
    try {
      const mssqlRequest = this.sqlConnection.request();
      MssqllModelManager.addParamsToMssqlRequest(
        mssqlRequest,
        query,
        this.params
      );
      const result = (await mssqlRequest.query(query)).recordset;
      if (!result.length) {
        if (options.throwErrorOnNull) {
          throw new Error("ROW_NOT_FOUND");
        }
        return null;
      }
      const modelInstance = getBaseModelInstance();
      await this.mergeRawPacketIntoModel(modelInstance, result, this.model);
      const relationModels = await this.mysqlModelManagerUtils.parseQueryBuilderRelations(
        [modelInstance],
        this.model,
        this.relations,
        this.logs
      );
      const model = await parseDatabaseDataIntoModelResponse(
        [modelInstance],
        this.model,
        relationModels
      );
      return !options.ignoreHooks?.includes("afterFetch") ? (await this.model.afterFetch([model]))[0] : model;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async oneOrFail(options) {
    const model = await this.one({
      throwErrorOnNull: true,
      ignoreHooks: options?.ignoreHooks
    });
    return model;
  }
  async many(options = {}) {
    this.checkLimitQuery();
    if (!options.ignoreHooks?.includes("beforeFetch")) {
      this.model.beforeFetch(this);
    }
    let query = "";
    if (this.joinQuery && !this.selectQuery) {
      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);
    }
    query = this.selectQuery + this.joinQuery;
    if (this.whereQuery) {
      query += this.whereQuery;
    }
    query += this.groupFooterQuery();
    query = this.whereTemplate.convertPlaceHolderToValue(query);
    query = query.trim();
    log(query, this.logs, this.params);
    try {
      const mssqlRequest = this.sqlConnection.request();
      MssqllModelManager.addParamsToMssqlRequest(
        mssqlRequest,
        query,
        this.params
      );
      const result = (await mssqlRequest.query(query)).recordsets;
      const modelPromises = result.map(async (row) => {
        const modelInstance = getBaseModelInstance();
        await this.mergeRawPacketIntoModel(modelInstance, row, this.model);
        return modelInstance;
      });
      const models = await Promise.all(modelPromises);
      const relationModels = await this.mysqlModelManagerUtils.parseQueryBuilderRelations(
        models,
        this.model,
        this.relations,
        this.logs
      );
      const serializedModels = await parseDatabaseDataIntoModelResponse(
        models,
        this.model,
        relationModels
      );
      if (!serializedModels) {
        return [];
      }
      if (!options.ignoreHooks?.includes("afterFetch")) {
        await this.model.afterFetch(serializedModels);
      }
      return Array.isArray(serializedModels) ? serializedModels : [serializedModels];
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async getCount(options = { ignoreHooks: false }) {
    if (options.ignoreHooks) {
      const [result2] = await this.sqlConnection.query(
        `SELECT COUNT(*) as total from ${this.table}`
      );
      return result2[0].total;
    }
    this.select("COUNT(*) as total");
    const result = await this.one();
    return result ? +result.extraColumns.total : 0;
  }
  async getSum(column2, options = { ignoreHooks: false }) {
    if (options.ignoreHooks) {
      const [result2] = await this.sqlConnection.query(
        `SELECT SUM(${column2}) as total from ${this.table}`
      );
      return result2[0].total;
    }
    column2 = convertCase(column2, this.model.databaseCaseConvention);
    this.select(`SUM(${column2}) as total`);
    const result = await this.one();
    return result ? +result.extraColumns.total : 0;
  }
  async paginate(page, limit, options) {
    this.offsetQuery = this.selectTemplate.offset((page - 1) * limit);
    this.limitNumber = limit;
    this.checkLimitQuery();
    const originalSelectQuery = this.selectQuery;
    this.select("COUNT(*) as total");
    const total = await this.many(options);
    this.selectQuery = originalSelectQuery;
    const models = await this.many(options);
    const paginationMetadata = getPaginationMetadata(
      page,
      limit,
      +total[0].extraColumns["total"]
    );
    let data = await parseDatabaseDataIntoModelResponse(models, this.model) || [];
    if (Array.isArray(data)) {
      data = data.filter((model) => model !== null);
    }
    return {
      paginationMetadata,
      data: Array.isArray(data) ? data : [data]
    };
  }
  select(...columns) {
    this.selectQuery = this.selectTemplate.selectColumns(
      ...columns
    );
    return this;
  }
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.leftJoin();
    return this;
  }
  addRelations(relations) {
    this.relations = relations;
    return this;
  }
  addDynamicColumns(dynamicColumns) {
    this.dynamicColumns = dynamicColumns;
    return this;
  }
  whereBuilder(cb) {
    const queryBuilder = new _MssqlQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.params.push(...queryBuilder.params);
    return this;
  }
  orWhereBuilder(cb) {
    const nestedBuilder = new _MssqlQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.params.push(...nestedBuilder.params);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.params.push(...nestedBuilder.params);
    return this;
  }
  andWhereBuilder(cb) {
    const nestedBuilder = new _MssqlQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.params.push(...nestedBuilder.params);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.params.push(...nestedBuilder.params);
    return this;
  }
  when(value, cb) {
    if (value === void 0 || value === null) {
      return this;
    }
    cb(value, this);
    return this;
  }
  where(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  rawWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  rawAndWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawAndWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawAndWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawAndWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  rawOrWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawOrWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawOrWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawOrWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  groupBy(...columns) {
    this.groupByQuery = this.selectTemplate.groupBy(...columns);
    return this;
  }
  orderBy(columns, order) {
    this.orderByQuery = this.selectTemplate.orderBy(columns, order);
    return this;
  }
  limit(limit) {
    this.limitNumber = limit;
    return this;
  }
  offset(offset) {
    this.offsetQuery = this.selectTemplate.offset(offset);
    return this;
  }
  copy() {
    const queryBuilder = new _MssqlQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      this.isNestedCondition,
      this.sqlDataSource
    );
    queryBuilder.selectQuery = this.selectQuery;
    queryBuilder.whereQuery = this.whereQuery;
    queryBuilder.joinQuery = this.joinQuery;
    queryBuilder.groupByQuery = this.groupByQuery;
    queryBuilder.orderByQuery = this.orderByQuery;
    queryBuilder.limitQuery = this.limitQuery;
    queryBuilder.offsetQuery = this.offsetQuery;
    queryBuilder.params = [...this.params];
    queryBuilder.relations = [...this.relations];
    return queryBuilder;
  }
  groupFooterQuery() {
    return this.groupByQuery + this.orderByQuery + this.offsetQuery + this.limitQuery;
  }
};

// src/Sql/Mssql/MssqlModelManager.ts
var MssqllModelManager = class _MssqllModelManager extends AbstractModelManager {
  /**
   * Constructor for MssqlModelManager class.
   *
   * @param {typeof Model} model - Model constructor.
   * @param {Connection} mssqlConnection - MySQL connection pool.
   * @param {boolean} logs - Flag to enable or disable logging.
   */
  constructor(model, mssqlConnection, logs, sqlDataSource) {
    super(model, logs, sqlDataSource);
    this.mssqlConnection = mssqlConnection;
    this.sqlModelManagerUtils = new SqlModelManagerUtils(
      "mssql",
      mssqlConnection
    );
  }
  /**
   * Find method to retrieve multiple records from the database based on the input conditions.
   *
   * @param {FindType} input - Optional query parameters for filtering, ordering, and pagination.
   * @returns Promise resolving to an array of models.
   */
  async find(input) {
    try {
      if (!input) {
        return await this.query().many();
      }
      const query = this.query();
      if (input.select) {
        query.select(...input.select);
      }
      if (input.relations) {
        query.addRelations(input.relations);
      }
      if (input.where) {
        Object.entries(input.where).forEach(([key, value]) => {
          query.where(key, value);
        });
      }
      if (input.orderBy) {
        query.orderBy(input.orderBy.columns, input.orderBy.type);
      }
      if (input.limit) {
        query.limit(input.limit);
      }
      if (input.offset) {
        query.offset(input.offset);
      }
      if (input.groupBy) {
        query.groupBy(...input.groupBy);
      }
      return await query.many({ ignoreHooks: input.ignoreHooks || [] });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Find a single record from the database based on the input conditions.
   *
   * @param {FindOneType} input - Query parameters for filtering and selecting a single record.
   * @returns Promise resolving to a single model or null if not found.
   */
  async findOne(input) {
    try {
      const query = this.query();
      if (input.select) {
        query.select(...input.select);
      }
      if (input.relations) {
        query.addRelations(input.relations);
      }
      if (input.where) {
        Object.entries(input.where).forEach(([key, value]) => {
          query.where(key, value);
        });
      }
      return await query.one({
        throwErrorOnNull: input.throwErrorOnNull || false,
        ignoreHooks: input.ignoreHooks || []
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Find a single record by its PK from the database.
   *
   * @param {string | number | boolean} value - PK of the record to retrieve, hooks will not have any effect, since it's a direct query for the PK.
   * @returns Promise resolving to a single model or null if not found.
   */
  async findOneByPrimaryKey(value, throwErrorOnNull = false) {
    try {
      if (!this.model.primaryKey) {
        throw new Error(
          "Model " + this.model.table + " has no primary key to be retrieved by"
        );
      }
      return await this.query().where(this.model.primaryKey, value).one({
        throwErrorOnNull
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Save a new model instance to the database.
   *
   * @param {Model} model - Model instance to be saved.
   * @param {TransactionType} trx - TransactionType to be used on the save operation.
   * @returns Promise resolving to the saved model or null if saving fails.
   */
  async insert(model) {
    this.model.beforeInsert(model);
    const { query, params } = this.sqlModelManagerUtils.parseInsert(
      model,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      log(query, this.logs, params);
      const mysqlRequest = this.mssqlConnection.request();
      _MssqllModelManager.addParamsToMssqlRequest(mysqlRequest, query, params);
      mysqlRequest.output(this.model.primaryKey, import_mssql.default.VarChar(255));
      const result = await mysqlRequest.query(query);
      if (!result.output[this.model.primaryKey]) {
        return null;
      }
      return await this.findOneByPrimaryKey(
        result.output[this.model.primaryKey]
      );
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Create multiple model instances in the database.
   *
   * @param {Model} model - Model instance to be saved.
   * @param {TransactionType} trx - TransactionType to be used on the save operation.
   * @returns Promise resolving to an array of saved models or null if saving fails.
   */
  async insertMany(models) {
    models.forEach((model) => {
      this.model.beforeInsert(model);
    });
    const { query, params } = this.sqlModelManagerUtils.parseMassiveInsert(
      models,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseMassiveInsert(
        models,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(query2, this.logs, params2);
      const mssqlRequest = this.mssqlConnection.request();
      _MssqllModelManager.addParamsToMssqlRequest(mssqlRequest, query2, params2);
      models.forEach((_2, index) => {
        mssqlRequest.output(
          this.model.primaryKey,
          import_mssql.default.VarChar(255),
          `@${this.model.primaryKey}${index}`
        );
      });
      const result = await mssqlRequest.query(query2);
      const idsToFetchList = models.map(
        (_2, index) => result.output[this.model.primaryKey + index]
      );
      return await this.query().whereIn(this.model.primaryKey, idsToFetchList).many();
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Update an existing model instance in the database.
   * @param {Model} model - Model instance to be updated.
   * @param {TransactionType} trx - TransactionType to be used on the update operation.
   * @returns Promise resolving to the updated model or null if updating fails.
   */
  async updateRecord(model) {
    if (!this.model.primaryKey) {
      throw new Error(
        "Model " + this.model.table + " has no primary key to be updated, try save"
      );
    }
    try {
      const updateQuery = this.sqlModelManagerUtils.parseUpdate(
        model,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(updateQuery.query, this.logs, updateQuery.params);
      const mssqlRequest = this.mssqlConnection.request();
      _MssqllModelManager.addParamsToMssqlRequest(
        mssqlRequest,
        updateQuery.query,
        updateQuery.params
      );
      await mssqlRequest.query(updateQuery.query);
      if (!this.model.primaryKey) {
        log(
          "Model has no primary key so no record can be retrieved",
          this.logs
        );
        return null;
      }
      return await this.findOneByPrimaryKey(
        model[this.model.primaryKey]
      );
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * @description Delete a record from the database from the given model.
   *
   * @param {Model} model - Model to delete.
   * @param {TransactionType} trx - TransactionType to be used on the delete operation.
   * @returns Promise resolving to the deleted model or null if deleting fails.
   */
  async deleteRecord(model) {
    try {
      if (!this.model.primaryKey) {
        throw new Error(
          "Model " + this.model.table + " has no primary key to be deleted from"
        );
      }
      const { query, params } = this.sqlModelManagerUtils.parseDelete(
        this.model.table,
        this.model.primaryKey,
        model[this.model.primaryKey]
      );
      log(query, this.logs, params);
      const mssqlRequest = this.mssqlConnection.request();
      _MssqllModelManager.addParamsToMssqlRequest(mssqlRequest, query, params);
      await mssqlRequest.query(query);
      return model;
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Create and return a new instance of the MysqlQueryBuilder for building more complex SQL queries.
   *
   * @returns {MssqlQueryBuilder<Model>} - Instance of MysqlQueryBuilder.
   */
  query() {
    return new MssqlQueryBuilder(
      this.model,
      this.model.table,
      this.mssqlConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
  /**
   * @description Returns an update query builder.
   */
  update() {
    return new MssqlUpdateQueryBuilder(
      this.model,
      this.model.table,
      this.mssqlConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
  /**
   * @description Returns a delete query builder.
   */
  deleteQuery() {
    return new MssqlDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.mssqlConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
  /**
   *  @description Adds parameters to the mssql request object given a li
   * @param request
   * @param query
   * @param params
   */
  static addParamsToMssqlRequest(request3, query, params) {
    const queryParameters = query.match(/@(\w+)/g);
    queryParameters?.forEach((param, index) => {
      request3.input(param.replace("@", ""), params[index]);
    });
  }
};

// src/Sql/Models/ModelManager/ModelManagerUtils.ts
var SqlModelManagerUtils = class {
  constructor(dbType, sqlConnection) {
    this.dbType = dbType;
    this.sqlConnection = sqlConnection;
  }
  parseInsert(model, typeofModel, dbType) {
    const filteredModel = this.filterRelationsAndMetadata(model);
    const keys = Object.keys(filteredModel);
    const values = Object.values(filteredModel);
    const insert = INSERT_default(dbType, typeofModel);
    return insert.insert(keys, values);
  }
  parseMassiveInsert(models, typeofModel, dbType) {
    const filteredModels = models.map(
      (m) => this.filterRelationsAndMetadata(m)
    );
    const insert = INSERT_default(dbType, typeofModel);
    const keys = Object.keys(filteredModels[0]);
    const values = filteredModels.map((model) => Object.values(model));
    return insert.insertMany(keys, values);
  }
  parseUpdate(model, typeofModel, dbType) {
    const update = UPDATE_default(dbType, typeofModel);
    const filteredModel = this.filterRelationsAndMetadata(model);
    const keys = Object.keys(filteredModel);
    const values = Object.values(filteredModel);
    const primaryKeyValue = filteredModel[typeofModel.primaryKey];
    return update.update(
      keys,
      values,
      typeofModel.primaryKey,
      primaryKeyValue
    );
  }
  filterRelationsAndMetadata(model) {
    const filteredModel = {};
    const keys = Object.keys(model);
    const isRelation = (value) => value instanceof Relation;
    for (const key of keys) {
      if (isRelation(model[key])) {
        continue;
      }
      Object.assign(filteredModel, { [key]: model[key] });
    }
    return filteredModel;
  }
  parseDelete(table, column2, value) {
    return DELETE_default(table, this.dbType).delete(column2, value);
  }
  getRelationFromModel(relationField, typeofModel) {
    const relations = getRelations(typeofModel);
    const relation = relations.find((r) => r.columnName === relationField);
    if (!relation) {
      throw new Error(
        `Relation ${relationField} not found in model ${typeofModel}`
      );
    }
    return relation;
  }
  // Parses and fills input relations directly into the model
  async parseQueryBuilderRelations(models, typeofModel, input, logs) {
    if (!input.length) {
      return [];
    }
    if (!typeofModel.primaryKey) {
      throw new Error(`Model ${typeofModel} does not have a primary key`);
    }
    let relationQuery = "";
    const relationQueries = [];
    const relationMap = {};
    try {
      input.forEach((inputRelation) => {
        const relation = this.getRelationFromModel(inputRelation, typeofModel);
        const query = RELATIONS_default(
          models,
          relation,
          inputRelation,
          typeofModel
        );
        relationQueries.push(query);
        relationMap[inputRelation] = query;
      });
      relationQuery = relationQueries.join(" UNION ALL ");
      log(relationQuery, logs);
      let result = await this.getQueryResult(relationQuery);
      result = Array.isArray(result) ? result : [result];
      const resultMap = {};
      result.forEach((row) => {
        const relationName = row.relation_name;
        delete row.relation_name;
        if (!resultMap[relationName]) {
          resultMap[relationName] = [];
        }
        resultMap[relationName].push(row);
      });
      const resultArray = input.map(
        (inputRelation) => {
          const modelsForRelation = resultMap[inputRelation] || [];
          return {
            [inputRelation]: modelsForRelation
          };
        }
      );
      return resultArray;
    } catch (error) {
      queryError("Query Error: " + relationQuery + error);
      throw new Error("Failed to parse relations " + error);
    }
  }
  async getQueryResult(query, params = []) {
    switch (this.dbType) {
      case "mysql":
      case "mariadb":
        const resultMysql = await this.sqlConnection.query(query, params);
        return resultMysql[0];
      case "postgres":
        const resultPg = await this.sqlConnection.query(
          query,
          params
        );
        return resultPg.rows;
      case "sqlite":
        return await new Promise((resolve, reject) => {
          this.sqlConnection.all(
            query,
            params,
            (err, result2) => {
              if (err) {
                reject(err);
              }
              resolve(result2);
            }
          );
        });
      case "mssql":
        const mssqlRequest = this.sqlConnection.request();
        MssqllModelManager.addParamsToMssqlRequest(mssqlRequest, query, params);
        const result = await mssqlRequest.query(query);
        return result.recordsets;
      default:
        throw new Error(`Unsupported data source type: ${this.dbType}`);
    }
  }
};

// src/Sql/Mysql/MysqlQueryBuilder.ts
var MysqlQueryBuilder = class _MysqlQueryBuilder extends QueryBuilder {
  /**
   * @param table - The name of the table.
   * @param mysqlConnection - The MySQL connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, mysqlConnection, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, sqlDataSource);
    this.isNestedCondition = false;
    this.mysqlConnection = mysqlConnection;
    this.isNestedCondition = isNestedCondition;
    this.mysqlModelManagerUtils = new SqlModelManagerUtils(
      "mysql",
      this.mysqlConnection
    );
  }
  async one(options = { throwErrorOnNull: false }) {
    if (!options.ignoreHooks?.includes("beforeFetch")) {
      this.model.beforeFetch(this);
    }
    let query = "";
    if (this.joinQuery && !this.selectQuery) {
      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);
    }
    query = this.selectQuery + this.joinQuery;
    if (this.whereQuery) {
      query += this.whereQuery;
    }
    query = this.whereTemplate.convertPlaceHolderToValue(query);
    this.limit(1);
    query += this.groupFooterQuery();
    query = query.trim();
    log(query, this.logs, this.params);
    try {
      const [rows] = await this.mysqlConnection.query(
        query,
        this.params
      );
      if (!rows.length) {
        if (options.throwErrorOnNull) {
          throw new Error("ROW_NOT_FOUND");
        }
        return null;
      }
      const modelInstance = getBaseModelInstance();
      await this.mergeRawPacketIntoModel(modelInstance, rows[0], this.model);
      const relationModels = await this.mysqlModelManagerUtils.parseQueryBuilderRelations(
        [modelInstance],
        this.model,
        this.relations,
        this.logs
      );
      const model = await parseDatabaseDataIntoModelResponse(
        [modelInstance],
        this.model,
        relationModels
      );
      return !options.ignoreHooks?.includes("afterFetch") ? (await this.model.afterFetch([model]))[0] : model;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async oneOrFail(options) {
    const model = await this.one({
      throwErrorOnNull: true,
      ignoreHooks: options?.ignoreHooks
    });
    return model;
  }
  async many(options = {}) {
    if (!options.ignoreHooks?.includes("beforeFetch")) {
      this.model.beforeFetch(this);
    }
    let query = "";
    if (this.joinQuery && !this.selectQuery) {
      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);
    }
    query = this.selectQuery + this.joinQuery;
    if (this.whereQuery) {
      query += this.whereQuery;
    }
    query += this.groupFooterQuery();
    query = this.whereTemplate.convertPlaceHolderToValue(query);
    query = query.trim();
    log(query, this.logs, this.params);
    try {
      const [rows] = await this.mysqlConnection.query(
        query,
        this.params
      );
      const modelPromises = rows.map(async (row) => {
        const modelInstance = getBaseModelInstance();
        await this.mergeRawPacketIntoModel(modelInstance, row, this.model);
        return modelInstance;
      });
      const models = await Promise.all(modelPromises);
      const relationModels = await this.mysqlModelManagerUtils.parseQueryBuilderRelations(
        models,
        this.model,
        this.relations,
        this.logs
      );
      const serializedModels = await parseDatabaseDataIntoModelResponse(
        models,
        this.model,
        relationModels
      );
      if (!serializedModels) {
        return [];
      }
      if (!options.ignoreHooks?.includes("afterFetch")) {
        await this.model.afterFetch(serializedModels);
      }
      return Array.isArray(serializedModels) ? serializedModels : [serializedModels];
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async getCount(options = { ignoreHooks: false }) {
    if (options.ignoreHooks) {
      const [result2] = await this.mysqlConnection.query(
        `SELECT COUNT(*) as total from ${this.table}`
      );
      return result2[0].total;
    }
    this.select("COUNT(*) as total");
    const result = await this.one();
    return result ? +result.extraColumns.total : 0;
  }
  async getSum(column2, options = { ignoreHooks: false }) {
    if (options.ignoreHooks) {
      const [result2] = await this.mysqlConnection.query(
        `SELECT SUM(${column2}) as total from ${this.table}`
      );
      return result2[0].total;
    }
    column2 = convertCase(column2, this.model.databaseCaseConvention);
    this.select(`SUM(${column2}) as total`);
    const result = await this.one();
    return result ? +result.extraColumns.total : 0;
  }
  async paginate(page, limit, options) {
    this.limitQuery = this.selectTemplate.limit(limit);
    this.offsetQuery = this.selectTemplate.offset((page - 1) * limit);
    const originalSelectQuery = this.selectQuery;
    this.select("COUNT(*) as total");
    const total = await this.many(options);
    this.selectQuery = originalSelectQuery;
    const models = await this.many(options);
    const paginationMetadata = getPaginationMetadata(
      page,
      limit,
      +total[0].extraColumns["total"]
    );
    let data = await parseDatabaseDataIntoModelResponse(models, this.model) || [];
    if (Array.isArray(data)) {
      data = data.filter((model) => model !== null);
    }
    return {
      paginationMetadata,
      data: Array.isArray(data) ? data : [data]
    };
  }
  select(...columns) {
    this.selectQuery = this.selectTemplate.selectColumns(
      ...columns
    );
    return this;
  }
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.leftJoin();
    return this;
  }
  addRelations(relations) {
    this.relations = relations;
    return this;
  }
  addDynamicColumns(dynamicColumns) {
    this.dynamicColumns = dynamicColumns;
    return this;
  }
  whereBuilder(cb) {
    const queryBuilder = new _MysqlQueryBuilder(
      this.model,
      this.table,
      this.mysqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.params.push(...queryBuilder.params);
    return this;
  }
  orWhereBuilder(cb) {
    const nestedBuilder = new _MysqlQueryBuilder(
      this.model,
      this.table,
      this.mysqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.params.push(...nestedBuilder.params);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.params.push(...nestedBuilder.params);
    return this;
  }
  andWhereBuilder(cb) {
    const nestedBuilder = new _MysqlQueryBuilder(
      this.model,
      this.table,
      this.mysqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.params.push(...nestedBuilder.params);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.params.push(...nestedBuilder.params);
    return this;
  }
  when(value, cb) {
    if (value === void 0 || value === null) {
      return this;
    }
    cb(value, this);
    return this;
  }
  where(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  rawWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  rawAndWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawAndWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawAndWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawAndWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  rawOrWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawOrWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawOrWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawOrWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  groupBy(...columns) {
    this.groupByQuery = this.selectTemplate.groupBy(...columns);
    return this;
  }
  orderBy(columns, order) {
    this.orderByQuery = this.selectTemplate.orderBy(columns, order);
    return this;
  }
  limit(limit) {
    this.limitQuery = this.selectTemplate.limit(limit);
    return this;
  }
  offset(offset) {
    this.offsetQuery = this.selectTemplate.offset(offset);
    return this;
  }
  copy() {
    const queryBuilder = new _MysqlQueryBuilder(
      this.model,
      this.table,
      this.mysqlConnection,
      this.logs,
      this.isNestedCondition,
      this.sqlDataSource
    );
    queryBuilder.selectQuery = this.selectQuery;
    queryBuilder.whereQuery = this.whereQuery;
    queryBuilder.joinQuery = this.joinQuery;
    queryBuilder.groupByQuery = this.groupByQuery;
    queryBuilder.orderByQuery = this.orderByQuery;
    queryBuilder.limitQuery = this.limitQuery;
    queryBuilder.offsetQuery = this.offsetQuery;
    queryBuilder.params = [...this.params];
    queryBuilder.relations = [...this.relations];
    return queryBuilder;
  }
  groupFooterQuery() {
    return this.groupByQuery + this.orderByQuery + this.limitQuery + this.offsetQuery;
  }
};

// src/Sql/Mysql/MysqlUpdateQueryBuilder.ts
var MysqlUpdateQueryBuilder = class _MysqlUpdateQueryBuilder extends ModelUpdateQueryBuilder {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param mysqlConnection - The MySQL connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, mysqlConnection, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, false, sqlDataSource);
    this.joinQuery = "";
    this.isNestedCondition = false;
    this.sqlConnection = mysqlConnection;
    this.updateTemplate = UPDATE_default(
      this.sqlDataSource.getDbType(),
      this.model
    );
    this.joinQuery = "";
    this.isNestedCondition = isNestedCondition;
  }
  async withData(data, options) {
    const { ignoreBeforeUpdateHook } = options || {};
    if (!ignoreBeforeUpdateHook) {
      this.model.beforeUpdate(this);
    }
    const columns = Object.keys(data);
    const values = Object.values(data);
    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(
      this.whereQuery
    );
    const { query, params } = this.updateTemplate.massiveUpdate(
      columns,
      values,
      this.whereQuery,
      this.joinQuery
    );
    params.push(...this.whereParams);
    log(query, this.logs, params);
    try {
      const rows = await this.sqlConnection.query(query, params);
      if (!rows[0].affectedRows) {
        return 0;
      }
      return rows[0].affectedRows;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   * @description Build more complex where conditions.
   * @param cb
   */
  whereBuilder(cb) {
    const queryBuilder = new _MysqlUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.whereParams.push(...queryBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex OR-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  orWhereBuilder(cb) {
    const nestedBuilder = new _MysqlUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex AND-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  andWhereBuilder(cb) {
    const nestedBuilder = new _MysqlUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
};

// src/Sql/Mysql/MysqlDeleteQueryBuilder.ts
var import_luxon3 = require("luxon");
var MysqlDeleteQueryBuilder = class _MysqlDeleteQueryBuilder extends ModelDeleteQueryBuilder {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param mysqlConnection - The MySQL connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, mysql2, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, false, sqlDataSource);
    this.isNestedCondition = false;
    this.sqlConnection = mysql2;
    this.updateTemplate = UPDATE_default(sqlDataSource.getDbType(), this.model);
    this.deleteTemplate = DELETE_default(table, sqlDataSource.getDbType());
    this.joinQuery = "";
    this.isNestedCondition = isNestedCondition;
  }
  async softDelete(options) {
    const {
      column: column2 = "deletedAt",
      value = import_luxon3.DateTime.local().toISO(),
      ignoreBeforeDeleteHook = false
    } = options || {};
    if (!ignoreBeforeDeleteHook) {
      this.model.beforeDelete(this);
    }
    let { query, params } = this.updateTemplate.massiveUpdate(
      [column2],
      [value],
      this.whereQuery,
      this.joinQuery
    );
    params = [...params, ...this.whereParams];
    log(query, this.logs, params);
    try {
      const rows = await this.sqlConnection.query(query, params);
      if (!rows[0].affectedRows) {
        return 0;
      }
      return rows[0].affectedRows;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async delete(options = {}) {
    const { ignoreBeforeDeleteHook } = options || {};
    if (!ignoreBeforeDeleteHook) {
      this.model.beforeDelete(this);
    }
    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(
      this.whereQuery
    );
    const query = this.deleteTemplate.massiveDelete(
      this.whereQuery,
      this.joinQuery
    );
    log(query, this.logs, this.whereParams);
    try {
      const rows = await this.sqlConnection.query(query, this.whereParams);
      if (!rows[0].affectedRows) {
        return 0;
      }
      return rows[0].affectedRows;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   * @description Build more complex where conditions.
   * @param cb
   */
  whereBuilder(cb) {
    const queryBuilder = new _MysqlDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.whereParams.push(...queryBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex OR-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  orWhereBuilder(cb) {
    const nestedBuilder = new _MysqlDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex AND-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  andWhereBuilder(cb) {
    const nestedBuilder = new _MysqlDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
};

// src/Sql/Mysql/MysqlModelManager.ts
var MysqlModelManager = class extends AbstractModelManager {
  /**
   * Constructor for MysqlModelManager class.
   *
   * @param {typeof Model} model - Model constructor.
   * @param {Connection} mysqlConnection - MySQL connection pool.
   * @param {boolean} logs - Flag to enable or disable logging.
   */
  constructor(model, mysqlConnection, logs, sqlDataSource) {
    super(model, logs, sqlDataSource);
    this.mysqlConnection = mysqlConnection;
    this.sqlModelManagerUtils = new SqlModelManagerUtils(
      "mysql",
      mysqlConnection
    );
  }
  /**
   * Find method to retrieve multiple records from the database based on the input conditions.
   *
   * @param {FindType} input - Optional query parameters for filtering, ordering, and pagination.
   * @returns Promise resolving to an array of models.
   */
  async find(input) {
    try {
      if (!input) {
        return await this.query().many();
      }
      const query = this.query();
      if (input.select) {
        query.select(...input.select);
      }
      if (input.relations) {
        query.addRelations(input.relations);
      }
      if (input.where) {
        Object.entries(input.where).forEach(([key, value]) => {
          query.where(key, value);
        });
      }
      if (input.orderBy) {
        query.orderBy(input.orderBy.columns, input.orderBy.type);
      }
      if (input.limit) {
        query.limit(input.limit);
      }
      if (input.offset) {
        query.offset(input.offset);
      }
      if (input.groupBy) {
        query.groupBy(...input.groupBy);
      }
      return await query.many({ ignoreHooks: input.ignoreHooks || [] });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Find a single record from the database based on the input conditions.
   *
   * @param {FindOneType} input - Query parameters for filtering and selecting a single record.
   * @returns Promise resolving to a single model or null if not found.
   */
  async findOne(input) {
    try {
      const query = this.query();
      if (input.select) {
        query.select(...input.select);
      }
      if (input.relations) {
        query.addRelations(input.relations);
      }
      if (input.where) {
        Object.entries(input.where).forEach(([key, value]) => {
          query.where(key, value);
        });
      }
      return await query.one({
        throwErrorOnNull: input.throwErrorOnNull || false,
        ignoreHooks: input.ignoreHooks || []
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Find a single record by its PK from the database.
   *
   * @param {string | number | boolean} value - PK of the record to retrieve, hooks will not have any effect, since it's a direct query for the PK.
   * @returns Promise resolving to a single model or null if not found.
   */
  async findOneByPrimaryKey(value, throwErrorOnNull = false) {
    try {
      if (!this.model.primaryKey) {
        throw new Error(
          "Model " + this.model.table + " has no primary key to be retrieved by"
        );
      }
      return await this.query().where(this.model.primaryKey, value).one({
        throwErrorOnNull
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Save a new model instance to the database.
   *
   * @param {Model} model - Model instance to be saved.
   * @param {TransactionType} trx - TransactionType to be used on the save operation.
   * @returns Promise resolving to the saved model or null if saving fails.
   */
  async insert(model) {
    this.model.beforeInsert(model);
    const { query, params } = this.sqlModelManagerUtils.parseInsert(
      model,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseInsert(
        model,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(query2, this.logs, params2);
      const [result] = await this.mysqlConnection.query(
        query2,
        params2
      );
      return await this.findOneByPrimaryKey(result["insertId"]);
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Create multiple model instances in the database.
   *
   * @param {Model} model - Model instance to be saved.
   * @param {TransactionType} trx - TransactionType to be used on the save operation.
   * @returns Promise resolving to an array of saved models or null if saving fails.
   */
  async insertMany(models) {
    models.forEach((model) => {
      this.model.beforeInsert(model);
    });
    const { query, params } = this.sqlModelManagerUtils.parseMassiveInsert(
      models,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseMassiveInsert(
        models,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(query2, this.logs, params2);
      const [rows] = await this.mysqlConnection.query(query2, params2);
      if (!rows.affectedRows || !rows.insertId) {
        return [];
      }
      const idsToFetchList = Array.from(
        { length: rows.affectedRows },
        (_2, i) => i + rows.insertId
      );
      return await this.query().whereIn(this.model.primaryKey, idsToFetchList).many();
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Update an existing model instance in the database.
   * @param {Model} model - Model instance to be updated.
   * @param {TransactionType} trx - TransactionType to be used on the update operation.
   * @returns Promise resolving to the updated model or null if updating fails.
   */
  async updateRecord(model) {
    if (!this.model.primaryKey) {
      throw new Error(
        "Model " + this.model.table + " has no primary key to be updated, try save"
      );
    }
    try {
      const updateQuery = this.sqlModelManagerUtils.parseUpdate(
        model,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(updateQuery.query, this.logs, updateQuery.params);
      await this.mysqlConnection.query(updateQuery.query, updateQuery.params);
      if (!this.model.primaryKey) {
        log(
          "Model has no primary key so no record can be retrieved",
          this.logs
        );
        return null;
      }
      return await this.findOneByPrimaryKey(
        model[this.model.primaryKey]
      );
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * @description Delete a record from the database from the given model.
   *
   * @param {Model} model - Model to delete.
   * @param {TransactionType} trx - TransactionType to be used on the delete operation.
   * @returns Promise resolving to the deleted model or null if deleting fails.
   */
  async deleteRecord(model) {
    try {
      if (!this.model.primaryKey) {
        throw new Error(
          "Model " + this.model.table + " has no primary key to be deleted from"
        );
      }
      const { query, params } = this.sqlModelManagerUtils.parseDelete(
        this.model.table,
        this.model.primaryKey,
        model[this.model.primaryKey]
      );
      log(query, this.logs, params);
      const [rows] = await this.mysqlConnection.query(
        query,
        params
      );
      if (this.sqlDataSource.getDbType() === "mariadb") {
        return await parseDatabaseDataIntoModelResponse(
          [rows[0]],
          this.model
        );
      }
      return model;
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Create and return a new instance of the MysqlQueryBuilder for building more complex SQL queries.
   *
   * @returns {MysqlQueryBuilder<Model>} - Instance of MysqlQueryBuilder.
   */
  query() {
    return new MysqlQueryBuilder(
      this.model,
      this.model.table,
      this.mysqlConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
  /**
   * @description Returns an update query builder.
   */
  update() {
    return new MysqlUpdateQueryBuilder(
      this.model,
      this.model.table,
      this.mysqlConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
  /**
   * @description Returns a delete query builder.
   */
  deleteQuery() {
    return new MysqlDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.mysqlConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
};

// src/Sql/Postgres/PostgresQueryBuilder.ts
var import_reflect_metadata = require("reflect-metadata");
var PostgresQueryBuilder = class _PostgresQueryBuilder extends QueryBuilder {
  constructor(model, table, pgClient, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, sqlDataSource);
    this.pgClient = pgClient;
    this.isNestedCondition = isNestedCondition;
    this.postgresModelManagerUtils = new SqlModelManagerUtils(
      "postgres",
      this.pgClient
    );
  }
  select(...columns) {
    this.selectQuery = this.selectTemplate.selectColumns(
      ...columns
    );
    return this;
  }
  async one(options = { throwErrorOnNull: false }) {
    if (!options.ignoreHooks?.includes("beforeFetch")) {
      this.model.beforeFetch(this);
    }
    this.limitQuery = this.selectTemplate.limit(1);
    let query = "";
    if (this.joinQuery && !this.selectQuery) {
      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);
    }
    query = this.selectQuery + this.joinQuery;
    if (this.whereQuery) {
      query += this.whereQuery;
    }
    query = this.whereTemplate.convertPlaceHolderToValue(query);
    this.limit(1);
    query += this.groupFooterQuery();
    query = query.trim();
    log(query, this.logs, this.params);
    try {
      const result = await this.pgClient.query(query, this.params);
      if (!result.rows[0]) {
        if (options.throwErrorOnNull) {
          throw new Error("ROW_NOT_FOUND");
        }
        return null;
      }
      const modelInstance = getBaseModelInstance();
      await this.mergeRawPacketIntoModel(
        modelInstance,
        result.rows[0],
        this.model
      );
      const relationModels = await this.postgresModelManagerUtils.parseQueryBuilderRelations(
        [modelInstance],
        this.model,
        this.relations,
        this.logs
      );
      const model = await parseDatabaseDataIntoModelResponse(
        [modelInstance],
        this.model,
        relationModels
      );
      return !options.ignoreHooks?.includes("afterFetch") ? (await this.model.afterFetch([model]))[0] : model;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async oneOrFail(options) {
    const model = await this.one({
      throwErrorOnNull: true,
      ignoreHooks: options?.ignoreHooks
    });
    return model;
  }
  async many(options = {}) {
    if (!options.ignoreHooks?.includes("beforeFetch")) {
      this.model.beforeFetch(this);
    }
    let query = "";
    if (this.joinQuery && !this.selectQuery) {
      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);
    }
    query = this.selectQuery + this.joinQuery;
    if (this.whereQuery) {
      query += this.whereQuery;
    }
    query += this.groupFooterQuery();
    query = this.whereTemplate.convertPlaceHolderToValue(query);
    query = query.trim();
    log(query, this.logs, this.params);
    try {
      const result = await this.pgClient.query(query, this.params);
      const rows = result.rows;
      const modelPromises = rows.map(async (row) => {
        const modelInstance = getBaseModelInstance();
        await this.mergeRawPacketIntoModel(modelInstance, row, this.model);
        return modelInstance;
      });
      const models = await Promise.all(modelPromises);
      const relationModels = await this.postgresModelManagerUtils.parseQueryBuilderRelations(
        models,
        this.model,
        this.relations,
        this.logs
      );
      const serializedModels = await parseDatabaseDataIntoModelResponse(
        models,
        this.model,
        relationModels
      );
      if (!serializedModels) {
        return [];
      }
      if (!options.ignoreHooks?.includes("afterFetch")) {
        await this.model.afterFetch(serializedModels);
      }
      return Array.isArray(serializedModels) ? serializedModels : [serializedModels];
    } catch (error) {
      throw new Error("Query failed: " + error.message);
    }
  }
  async getCount(options = { ignoreHooks: false }) {
    if (options.ignoreHooks) {
      const { rows } = await this.pgClient.query(
        `SELECT COUNT(*) as total from ${this.table}`
      );
      return +rows[0].total;
    }
    this.select("COUNT(*) as total");
    const result = await this.one();
    return result ? +result.extraColumns["total"] : 0;
  }
  async getSum(column2, options = { ignoreHooks: false }) {
    if (options.ignoreHooks) {
      const { rows } = await this.pgClient.query(
        `SELECT SUM(${column2}) as total from ${this.table}`
      );
      return +rows[0].total || 0;
    }
    column2 = convertCase(column2, this.model.databaseCaseConvention);
    this.select(`SUM(${column2}) as total`);
    const result = await this.one();
    return result ? +result.extraColumns["total"] : 0;
  }
  async paginate(page, limit, options) {
    this.limitQuery = this.selectTemplate.limit(limit);
    this.offsetQuery = this.selectTemplate.offset((page - 1) * limit);
    const originalSelectQuery = this.selectQuery;
    this.select("COUNT(*) as total");
    const total = await this.many(options);
    this.selectQuery = originalSelectQuery;
    const models = await this.many(options);
    const paginationMetadata = getPaginationMetadata(
      page,
      limit,
      +total[0].extraColumns["total"]
    );
    let data = await parseDatabaseDataIntoModelResponse(models, this.model) || [];
    if (Array.isArray(data)) {
      data = data.filter((model) => model !== null);
    }
    return {
      paginationMetadata,
      data: Array.isArray(data) ? data : [data]
    };
  }
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.leftJoin();
    return this;
  }
  addRelations(relations) {
    this.relations = relations;
    return this;
  }
  addDynamicColumns(dynamicColumns) {
    this.dynamicColumns = dynamicColumns;
    return this;
  }
  whereBuilder(cb) {
    const queryBuilder = new _PostgresQueryBuilder(
      this.model,
      this.table,
      this.pgClient,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.params.push(...queryBuilder.params);
    return this;
  }
  orWhereBuilder(cb) {
    const nestedBuilder = new _PostgresQueryBuilder(
      this.model,
      this.table,
      this.pgClient,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.params.push(...nestedBuilder.params);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.params.push(...nestedBuilder.params);
    return this;
  }
  andWhereBuilder(cb) {
    const nestedBuilder = new _PostgresQueryBuilder(
      this.model,
      this.table,
      this.pgClient,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.params.push(...nestedBuilder.params);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.params.push(...nestedBuilder.params);
    return this;
  }
  when(value, cb) {
    if (value === void 0 || value === null) {
      return this;
    }
    cb(value, this);
    return this;
  }
  where(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  rawWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  rawAndWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawAndWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawAndWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawAndWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  rawOrWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawOrWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawOrWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawOrWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  groupBy(...columns) {
    this.groupByQuery = this.selectTemplate.groupBy(...columns);
    return this;
  }
  orderBy(columns, order) {
    this.orderByQuery = this.selectTemplate.orderBy(columns, order);
    return this;
  }
  limit(limit) {
    this.limitQuery = this.selectTemplate.limit(limit);
    return this;
  }
  offset(offset) {
    this.offsetQuery = this.selectTemplate.offset(offset);
    return this;
  }
  copy() {
    const queryBuilder = new _PostgresQueryBuilder(
      this.model,
      this.table,
      this.pgClient,
      this.logs,
      this.isNestedCondition,
      this.sqlDataSource
    );
    queryBuilder.selectQuery = this.selectQuery;
    queryBuilder.whereQuery = this.whereQuery;
    queryBuilder.groupByQuery = this.groupByQuery;
    queryBuilder.orderByQuery = this.orderByQuery;
    queryBuilder.limitQuery = this.limitQuery;
    queryBuilder.offsetQuery = this.offsetQuery;
    queryBuilder.params = [...this.params];
    return queryBuilder;
  }
  groupFooterQuery() {
    return this.groupByQuery + this.orderByQuery + this.limitQuery + this.offsetQuery;
  }
};

// src/Sql/Postgres/PostgresUpdateQueryBuilder.ts
var PostgresUpdateQueryBuilder = class _PostgresUpdateQueryBuilder extends ModelUpdateQueryBuilder {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param pgClient - The MySQL connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, pgClient, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, false, sqlDataSource);
    this.joinQuery = "";
    this.isNestedCondition = false;
    this.sqlConnection = pgClient;
    this.updateTemplate = UPDATE_default(
      this.sqlDataSource.getDbType(),
      this.model
    );
    this.joinQuery = "";
    this.isNestedCondition = isNestedCondition;
  }
  async withData(data, options) {
    const { ignoreBeforeUpdateHook } = options || {};
    if (!ignoreBeforeUpdateHook) {
      this.model.beforeUpdate(this);
    }
    const columns = Object.keys(data);
    const values = Object.values(data);
    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(
      this.whereQuery,
      values.length + 1
    );
    const { query, params } = this.updateTemplate.massiveUpdate(
      columns,
      values,
      this.whereQuery,
      this.joinQuery
    );
    params.push(...this.whereParams);
    log(query, this.logs, params);
    try {
      const result = await this.sqlConnection.query(query, params);
      if (!result.rows) {
        return 0;
      }
      return result.rowCount || 0;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   * @description Build more complex where conditions.
   * @param cb
   */
  whereBuilder(cb) {
    const queryBuilder = new _PostgresUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.whereParams.push(...queryBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex OR-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  orWhereBuilder(cb) {
    const nestedBuilder = new _PostgresUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex AND-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  andWhereBuilder(cb) {
    const nestedBuilder = new _PostgresUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
};

// src/Sql/Postgres/PostgresDeleteQueryBuilder.ts
var import_luxon4 = require("luxon");
var PostgresDeleteQueryBuilder = class _PostgresDeleteQueryBuilder extends ModelDeleteQueryBuilder {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param pgClient - The MySQL connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, pgClient, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, false, sqlDataSource);
    this.isNestedCondition = false;
    this.sqlConnection = pgClient;
    this.updateTemplate = UPDATE_default(sqlDataSource.getDbType(), this.model);
    this.deleteTemplate = DELETE_default(table, sqlDataSource.getDbType());
    this.joinQuery = "";
    this.isNestedCondition = isNestedCondition;
  }
  async delete(options = {}) {
    const { ignoreBeforeDeleteHook } = options || {};
    if (!ignoreBeforeDeleteHook) {
      this.model.beforeDelete(this);
    }
    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(
      this.whereQuery
    );
    const query = this.deleteTemplate.massiveDelete(
      this.whereQuery,
      this.joinQuery
    );
    log(query, this.logs, this.whereParams);
    try {
      const result = await this.sqlConnection.query(query, this.whereParams);
      if (!result.rows) {
        return 0;
      }
      return result.rowCount || 0;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async softDelete(options) {
    const {
      column: column2 = "deletedAt",
      value = import_luxon4.DateTime.local().toISO(),
      ignoreBeforeDeleteHook = false
    } = options || {};
    if (!ignoreBeforeDeleteHook) {
      this.model.beforeDelete(this);
    }
    let { query, params } = this.updateTemplate.massiveUpdate(
      [column2],
      [value],
      this.whereQuery,
      this.joinQuery
    );
    params = [...params, ...this.whereParams];
    log(query, this.logs, params);
    try {
      const result = await this.sqlConnection.query(query, params);
      if (!result.rows) {
        return 0;
      }
      return result.rowCount || 0;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   * @description Build more complex where conditions.
   * @param cb
   */
  whereBuilder(cb) {
    const queryBuilder = new _PostgresDeleteQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.whereParams.push(...queryBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex OR-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  orWhereBuilder(cb) {
    const nestedBuilder = new _PostgresDeleteQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex AND-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  andWhereBuilder(cb) {
    const nestedBuilder = new _PostgresDeleteQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
};

// src/Sql/Postgres/PostgresModelManager.ts
var PostgresModelManager = class extends AbstractModelManager {
  /**
   * Constructor for PostgresModelManager class.
   *
   * @param {typeof Model} model - Model constructor.
   * @param {Pool} pgConnection - PostgreSQL connection pool.
   * @param {boolean} logs - Flag to enable or disable logging.
   */
  constructor(model, pgConnection, logs, sqlDataSource) {
    super(model, logs, sqlDataSource);
    this.pgConnection = pgConnection;
    this.sqlModelManagerUtils = new SqlModelManagerUtils(
      "postgres",
      pgConnection
    );
  }
  /**
   * Find method to retrieve multiple records from the database based on the input conditions.
   *
   * @param {FindType} input - Optional query parameters for filtering, ordering, and pagination.
   * @returns Promise resolving to an array of models.
   */
  async find(input) {
    try {
      if (!input) {
        return await this.query().many();
      }
      const query = this.query();
      if (input.select) {
        query.select(...input.select);
      }
      if (input.relations) {
        query.addRelations(input.relations);
      }
      if (input.where) {
        Object.entries(input.where).forEach(([key, value]) => {
          query.where(key, value);
        });
      }
      if (input.orderBy) {
        query.orderBy(input.orderBy.columns, input.orderBy.type);
      }
      if (input.limit) {
        query.limit(input.limit);
      }
      if (input.offset) {
        query.offset(input.offset);
      }
      if (input.groupBy) {
        query.groupBy(...input.groupBy);
      }
      return await query.many({ ignoreHooks: input.ignoreHooks || [] });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Find a single record from the database based on the input conditions.
   *
   * @param {FindOneType} input - Query parameters for filtering and selecting a single record.
   * @returns Promise resolving to a single model or null if not found.
   */
  async findOne(input) {
    try {
      const query = this.query();
      if (input.select) {
        query.select(...input.select);
      }
      if (input.relations) {
        query.addRelations(input.relations);
      }
      if (input.where) {
        Object.entries(input.where).forEach(([key, value]) => {
          query.where(key, value);
        });
      }
      return await query.one({
        throwErrorOnNull: input.throwErrorOnNull || false,
        ignoreHooks: input.ignoreHooks || []
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Find a single record by its PK from the database.
   *
   * @param {string | number | boolean} value - PK value of the record to retrieve.
   * @returns Promise resolving to a single model or null if not found.
   */
  async findOneByPrimaryKey(value, throwErrorOnNull = false) {
    try {
      if (!this.model.primaryKey) {
        throw new Error(
          "Model " + this.model.table + " has no primary key to be retrieved by"
        );
      }
      return await this.query().where(this.model.primaryKey, "=", value).one({ throwErrorOnNull });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Save a new model instance to the database.
   *
   * @param {Model} model - Model instance to be saved.
   * @param {MysqlTransaction} trx - MysqlTransaction to be used on the save operation.
   * @returns Promise resolving to the saved model or null if saving fails.
   */
  async insert(model) {
    this.model.beforeInsert(model);
    const { query, params } = this.sqlModelManagerUtils.parseInsert(
      model,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseInsert(
        model,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(query2, this.logs, params2);
      const { rows } = await this.pgConnection.query(query2, params2);
      const insertedModel = rows[0];
      if (!insertedModel) {
        throw new Error(rows[0]);
      }
      return await parseDatabaseDataIntoModelResponse(
        [insertedModel],
        this.model
      );
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Create multiple model instances in the database.
   *
   * @param {Model} models - Model instance to be saved.
   * @param {Transaction} trx - MysqlTransaction to be used on the save operation.
   * @returns Promise resolving to an array of saved models or null if saving fails.
   */
  async insertMany(models) {
    models.forEach((model) => this.model.beforeInsert(model));
    const { query, params } = this.sqlModelManagerUtils.parseMassiveInsert(
      models,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseMassiveInsert(
        models,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(query2, this.logs, params2);
      const { rows } = await this.pgConnection.query(query2, params2);
      const insertedModel = rows;
      if (!insertedModel.length) {
        return [];
      }
      const insertModelPromise = insertedModel.map(
        async (model) => await parseDatabaseDataIntoModelResponse([model], this.model)
      );
      return await Promise.all(insertModelPromise);
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Update an existing model instance in the database.
   * @param {Model} model - Model instance to be updated.
   * @param {Transaction} trx - Transaction to be used on the update operation.
   * @returns Promise resolving to the updated model or null if updating fails.
   */
  async updateRecord(model) {
    const { table, primaryKey } = this.model;
    if (!primaryKey) {
      throw new Error(
        "Model " + table + " has no primary key to be updated, try save"
      );
    }
    const { query, params } = this.sqlModelManagerUtils.parseUpdate(
      model,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseUpdate(
        model,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(query2, this.logs, params2);
      await this.pgConnection.query(query2, params2);
      if (!primaryKey) {
        return null;
      }
      return await this.findOneByPrimaryKey(
        model[primaryKey]
      );
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * @description Delete a record from the database from the given model.
   *
   * @param {Model} model - Model to delete.
   * @param {Transaction} trx - Transaction to be used on the delete operation.
   * @returns Promise resolving to the deleted model or null if deleting fails.
   */
  async deleteRecord(model) {
    try {
      if (!this.model.primaryKey) {
        throw new Error(
          "Model " + this.model.table + " has no primary key to be deleted from"
        );
      }
      const { query, params } = this.sqlModelManagerUtils.parseDelete(
        this.model.table,
        this.model.primaryKey,
        model[this.model.primaryKey]
      );
      log(query, this.logs, params);
      await this.pgConnection.query(query, params);
      return model;
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Create and return a new instance of the MysqlQueryBuilder for building more complex SQL queries.
   *
   * @returns {MysqlQueryBuilder<Model>} - Instance of MysqlQueryBuilder.
   */
  query() {
    return new PostgresQueryBuilder(
      this.model,
      this.model.table,
      this.pgConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
  /**
   * @description Returns an update query builder.
   */
  update() {
    return new PostgresUpdateQueryBuilder(
      this.model,
      this.model.table,
      this.pgConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
  /**
   * @description Returns a delete query builder.
   */
  deleteQuery() {
    return new PostgresDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.pgConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
};

// src/Sql/Sqlite/SQLiteQueryBuilder.ts
var SQLiteQueryBuilder = class _SQLiteQueryBuilder extends QueryBuilder {
  /**
   * @param table - The name of the table.
   * @param sqLiteConnection - The MySQL connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, sqLiteConnection, logs, isNestedCondition = false, sqlDataSource) {
    super(model, table, logs, sqlDataSource);
    this.isNestedCondition = false;
    this.sqLiteConnection = sqLiteConnection;
    this.isNestedCondition = isNestedCondition;
    this.sqliteModelManagerUtils = new SqlModelManagerUtils(
      "sqlite",
      this.sqLiteConnection
    );
  }
  async one(options = { throwErrorOnNull: false }) {
    if (!options.ignoreHooks?.includes("beforeFetch")) {
      this.model.beforeFetch(this);
    }
    let query = "";
    if (this.joinQuery && !this.selectQuery) {
      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);
    }
    query = this.selectQuery + this.joinQuery;
    if (this.whereQuery) {
      query += this.whereQuery;
    }
    query = this.whereTemplate.convertPlaceHolderToValue(query);
    this.limit(1);
    query += this.groupFooterQuery();
    query = query.trim();
    log(query, this.logs, this.params);
    try {
      const results = await this.promisifyQuery(query, this.params);
      if (!results.length) {
        return null;
      }
      const result = results[0];
      if (options.throwErrorOnNull && !result) {
        throw new Error("ERR_NOT_FOUND");
      }
      const modelInstance = getBaseModelInstance();
      await this.mergeRawPacketIntoModel(modelInstance, result, this.model);
      const relationModels = await this.sqliteModelManagerUtils.parseQueryBuilderRelations(
        [modelInstance],
        this.model,
        this.relations,
        this.logs
      );
      const model = await parseDatabaseDataIntoModelResponse(
        [modelInstance],
        this.model,
        relationModels
      );
      return !options.ignoreHooks?.includes("afterFetch") ? (await this.model.afterFetch([model]))[0] : model;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async oneOrFail(options) {
    const model = await this.one({
      throwErrorOnNull: true,
      ignoreHooks: options?.ignoreHooks
    });
    return model;
  }
  async many(options = {}) {
    if (!options.ignoreHooks?.includes("beforeFetch")) {
      this.model.beforeFetch(this);
    }
    let query = "";
    if (this.joinQuery && !this.selectQuery) {
      this.selectQuery = this.selectTemplate.selectColumns(`${this.table}.*`);
    }
    query = this.selectQuery + this.joinQuery;
    if (this.whereQuery) {
      query += this.whereQuery;
    }
    query += this.groupFooterQuery();
    query = this.whereTemplate.convertPlaceHolderToValue(query);
    query = query.trim();
    log(query, this.logs, this.params);
    try {
      const results = await this.promisifyQuery(query, this.params);
      const modelPromises = results.map(async (result) => {
        const modelInstance = getBaseModelInstance();
        await this.mergeRawPacketIntoModel(modelInstance, result, this.model);
        return modelInstance;
      });
      const models = await Promise.all(modelPromises);
      const relationModels = await this.sqliteModelManagerUtils.parseQueryBuilderRelations(
        models,
        this.model,
        this.relations,
        this.logs
      );
      const serializedModels = await parseDatabaseDataIntoModelResponse(
        models,
        this.model,
        relationModels
      );
      if (!serializedModels) {
        return [];
      }
      if (!options.ignoreHooks?.includes("afterFetch")) {
        await this.model.afterFetch(serializedModels);
      }
      return Array.isArray(serializedModels) ? serializedModels : [serializedModels];
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async raw(query, params = []) {
    return await this.promisifyQuery(query, params);
  }
  async getCount(options = { ignoreHooks: false }) {
    if (options.ignoreHooks) {
      const result2 = await this.promisifyQuery(
        "SELECT COUNT(*) as total FROM " + this.table,
        []
      );
      return +result2[0].total;
    }
    this.select("COUNT(*) as total");
    const result = await this.one();
    return result ? +result.extraColumns.total : 0;
  }
  async getSum(column2, options = { ignoreHooks: false }) {
    if (!options.ignoreHooks) {
      const result2 = await this.promisifyQuery(
        `SELECT SUM("${column2}) as total FROM ` + this.table,
        []
      );
      return +result2[0].total || 0;
    }
    column2 = convertCase(column2, this.model.databaseCaseConvention);
    this.select(`SUM(${column2}) as total`);
    const result = await this.one();
    return result ? +result.extraColumns.total : 0;
  }
  async paginate(page, limit, options) {
    this.limitQuery = this.selectTemplate.limit(limit);
    this.offsetQuery = this.selectTemplate.offset((page - 1) * limit);
    const originalSelectQuery = this.selectQuery;
    this.select("COUNT(*) as total");
    const total = await this.many(options);
    this.selectQuery = originalSelectQuery;
    const models = await this.many(options);
    const paginationMetadata = getPaginationMetadata(
      page,
      limit,
      +total[0].extraColumns["total"]
    );
    let data = await parseDatabaseDataIntoModelResponse(models, this.model) || [];
    if (Array.isArray(data)) {
      data = data.filter((model) => model !== null);
    }
    return {
      paginationMetadata,
      data: Array.isArray(data) ? data : [data]
    };
  }
  select(...columns) {
    this.selectQuery = this.selectTemplate.selectColumns(
      ...columns
    );
    return this;
  }
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.leftJoin();
    return this;
  }
  addRelations(relations) {
    this.relations = relations;
    return this;
  }
  addDynamicColumns(dynamicColumns) {
    this.dynamicColumns = dynamicColumns;
    return this;
  }
  whereBuilder(cb) {
    const queryBuilder = new _SQLiteQueryBuilder(
      this.model,
      this.table,
      this.sqLiteConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.params.push(...queryBuilder.params);
    return this;
  }
  orWhereBuilder(cb) {
    const nestedBuilder = new _SQLiteQueryBuilder(
      this.model,
      this.table,
      this.sqLiteConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.params.push(...nestedBuilder.params);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.params.push(...nestedBuilder.params);
    return this;
  }
  andWhereBuilder(cb) {
    const nestedBuilder = new _SQLiteQueryBuilder(
      this.model,
      this.table,
      this.sqLiteConnection,
      this.logs,
      true,
      this.sqlDataSource
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.params.push(...nestedBuilder.params);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.params.push(...nestedBuilder.params);
    return this;
  }
  when(value, cb) {
    if (value === void 0 || value === null) {
      return this;
    }
    cb(value, this);
    return this;
  }
  where(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhere(column2, operatorOrValue, value) {
    let operator = "=";
    let actualValue;
    if (typeof operatorOrValue === "string" && value) {
      operator = operatorOrValue;
      actualValue = value;
    } else {
      actualValue = operatorOrValue;
      operator = "=";
    }
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhere(
        column2,
        actualValue,
        operator
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.where(
        column2,
        actualValue,
        operator
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhere(
      column2,
      actualValue,
      operator
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotBetween(column2, min, max) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotBetween(
        column2,
        min,
        max
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotBetween(
      column2,
      min,
      max
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotIn(column2, values) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotIn(
        column2,
        values
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotIn(
        column2,
        values
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotIn(
      column2,
      values
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNull(column2);
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNull(column2);
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  whereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  andWhereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.andWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.andWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  orWhereNotNull(column2) {
    if (this.isNestedCondition) {
      const { query: query2, params: params2 } = this.whereTemplate.orWhereNotNull(
        column2
      );
      this.whereQuery += query2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: query2, params: params2 } = this.whereTemplate.whereNotNull(
        column2
      );
      this.whereQuery = query2;
      this.params.push(...params2);
      return this;
    }
    const { query, params } = this.whereTemplate.orWhereNotNull(
      column2
    );
    this.whereQuery += query;
    this.params.push(...params);
    return this;
  }
  rawWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  rawAndWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawAndWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawAndWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawAndWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  rawOrWhere(query) {
    if (this.isNestedCondition) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawOrWhere(query);
      this.whereQuery += rawQuery2;
      this.params.push(...params2);
      return this;
    }
    if (!this.whereQuery) {
      const { query: rawQuery2, params: params2 } = this.whereTemplate.rawOrWhere(query);
      this.whereQuery = rawQuery2;
      this.params.push(...params2);
      return this;
    }
    const { query: rawQuery, params } = this.whereTemplate.rawOrWhere(query);
    this.whereQuery += rawQuery;
    this.params.push(...params);
    return this;
  }
  groupBy(...columns) {
    this.groupByQuery = this.selectTemplate.groupBy(...columns);
    return this;
  }
  orderBy(columns, order) {
    this.orderByQuery = this.selectTemplate.orderBy(columns, order);
    return this;
  }
  limit(limit) {
    this.limitQuery = this.selectTemplate.limit(limit);
    return this;
  }
  offset(offset) {
    this.offsetQuery = this.selectTemplate.offset(offset);
    return this;
  }
  copy() {
    const queryBuilder = new _SQLiteQueryBuilder(
      this.model,
      this.table,
      this.sqLiteConnection,
      this.logs,
      this.isNestedCondition,
      this.sqlDataSource
    );
    queryBuilder.selectQuery = this.selectQuery;
    queryBuilder.whereQuery = this.whereQuery;
    queryBuilder.joinQuery = this.joinQuery;
    queryBuilder.groupByQuery = this.groupByQuery;
    queryBuilder.orderByQuery = this.orderByQuery;
    queryBuilder.limitQuery = this.limitQuery;
    queryBuilder.offsetQuery = this.offsetQuery;
    queryBuilder.params = [...this.params];
    queryBuilder.relations = [...this.relations];
    return queryBuilder;
  }
  groupFooterQuery() {
    return this.groupByQuery + this.orderByQuery + this.limitQuery + this.offsetQuery;
  }
  promisifyQuery(query, params) {
    return new Promise((resolve, reject) => {
      this.sqLiteConnection.all(query, params, (err, result) => {
        if (err) {
          reject(err);
        }
        if (!result) {
          resolve([]);
        }
        if (!Array.isArray(result)) {
          resolve([result]);
        }
        resolve(result);
      });
    });
  }
};

// src/Sql/Sqlite/SQLiteUpdateQueryBuilder.ts
var SQLiteUpdateQueryBuilder = class _SQLiteUpdateQueryBuilder extends ModelUpdateQueryBuilder {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param sqlLiteCOnnection - The MySQL connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, sqlLiteConnection, logs, isNestedCondition = false, sqlDataSource, sqlModelManagerUtils) {
    super(model, table, logs, false, sqlDataSource);
    this.joinQuery = "";
    this.isNestedCondition = false;
    this.sqlConnection = sqlLiteConnection;
    this.updateTemplate = UPDATE_default(
      this.sqlDataSource.getDbType(),
      this.model
    );
    this.joinQuery = "";
    this.isNestedCondition = isNestedCondition;
    this.sqlModelManagerUtils = sqlModelManagerUtils;
  }
  /**
   * @description Updates a record in the database.
   * @param data - The data to update.
   * @param trx - The transaction to run the query in.
   * @returns The updated records.
   */
  async withData(data, options) {
    const { ignoreBeforeUpdateHook } = options || {};
    if (!ignoreBeforeUpdateHook) {
      this.model.beforeUpdate(this);
    }
    const columns = Object.keys(data);
    const values = Object.values(data);
    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(
      this.whereQuery,
      values.length + 1
    );
    const { query, params } = this.updateTemplate.massiveUpdate(
      columns,
      values,
      this.whereQuery,
      this.joinQuery
    );
    params.push(...this.whereParams);
    log(query, this.logs, params);
    try {
      const result = await this.promisifyQuery(query, params);
      return result;
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   * @description Build more complex where conditions.
   * @param cb
   */
  whereBuilder(cb) {
    const queryBuilder = new _SQLiteUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource,
      this.sqlModelManagerUtils
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.whereParams.push(...queryBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex OR-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  orWhereBuilder(cb) {
    const nestedBuilder = new _SQLiteUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource,
      this.sqlModelManagerUtils
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex AND-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  andWhereBuilder(cb) {
    const nestedBuilder = new _SQLiteUpdateQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource,
      this.sqlModelManagerUtils
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  promisifyQuery(query, params) {
    return new Promise((resolve, reject) => {
      this.sqlConnection.run(query, params, function(err) {
        if (err) {
          return reject(err);
        }
        resolve(this.changes);
      });
    });
  }
};

// src/Sql/Sqlite/SQLiteDeleteQueryBuilder.ts
var import_luxon5 = require("luxon");
var SQLiteDeleteQueryBuilder = class _SQLiteDeleteQueryBuilder extends ModelDeleteQueryBuilder {
  /**
   * @description Constructs a MysqlQueryBuilder instance.
   * @param model - The model class associated with the table.
   * @param table - The name of the table.
   * @param sqlConnection - The Sqlite connection pool.
   * @param logs - A boolean indicating whether to log queries.
   * @param isNestedCondition - A boolean indicating whether the query is nested in another query.
   */
  constructor(model, table, sqlConnection, logs, isNestedCondition = false, sqlDataSource, sqlModelManagerUtils) {
    super(model, table, logs, false, sqlDataSource);
    this.isNestedCondition = false;
    this.sqlConnection = sqlConnection;
    this.updateTemplate = UPDATE_default(sqlDataSource.getDbType(), this.model);
    this.deleteTemplate = DELETE_default(table, sqlDataSource.getDbType());
    this.joinQuery = "";
    this.isNestedCondition = isNestedCondition;
    this.isNestedCondition = isNestedCondition;
    this.sqlModelManagerUtils = sqlModelManagerUtils;
  }
  async delete(options = {}) {
    const { ignoreBeforeDeleteHook } = options || {};
    if (!ignoreBeforeDeleteHook) {
      this.model.beforeDelete(this);
    }
    this.whereQuery = this.whereTemplate.convertPlaceHolderToValue(
      this.whereQuery
    );
    const query = this.deleteTemplate.massiveDelete(
      this.whereQuery,
      this.joinQuery
    );
    log(query, this.logs, this.whereParams);
    try {
      return await this.promisifyQuery(query, this.whereParams);
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  async softDelete(options) {
    const {
      column: column2 = "deletedAt",
      value = import_luxon5.DateTime.local().toISO(),
      ignoreBeforeDeleteHook = false
    } = options || {};
    if (!ignoreBeforeDeleteHook) {
      this.model.beforeDelete(this);
    }
    let { query, params } = this.updateTemplate.massiveUpdate(
      [column2],
      [value],
      this.whereQuery,
      this.joinQuery
    );
    params = [...params, ...this.whereParams];
    log(query, this.logs, params);
    try {
      return await this.promisifyQuery(query, params);
    } catch (error) {
      queryError(query);
      throw new Error("Query failed " + error);
    }
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  join(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   *
   * @param relationTable - The name of the related table.
   * @param primaryColumn - The name of the primary column in the caller table.
   * @param foreignColumn - The name of the foreign column in the related table.
   */
  leftJoin(relationTable, primaryColumn, foreignColumn) {
    const join = JOIN_default(
      this.model,
      relationTable,
      primaryColumn,
      foreignColumn
    );
    this.joinQuery += join.innerJoin();
    return this;
  }
  /**
   * @description Build more complex where conditions.
   * @param cb
   */
  whereBuilder(cb) {
    const queryBuilder = new _SQLiteDeleteQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource,
      this.sqlModelManagerUtils
    );
    cb(queryBuilder);
    let whereCondition = queryBuilder.whereQuery.trim();
    if (whereCondition.startsWith("AND")) {
      whereCondition = whereCondition.substring(4);
    } else if (whereCondition.startsWith("OR")) {
      whereCondition = whereCondition.substring(3);
    }
    whereCondition = "(" + whereCondition + ")";
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? whereCondition : `WHERE ${whereCondition}`;
    } else {
      this.whereQuery += ` AND ${whereCondition}`;
    }
    this.whereParams.push(...queryBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex OR-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  orWhereBuilder(cb) {
    const nestedBuilder = new _SQLiteDeleteQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource,
      this.sqlModelManagerUtils
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    nestedCondition = `(${nestedCondition})`;
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` OR ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  /**
   * @description Build complex AND-based where conditions.
   * @param cb Callback function that takes a query builder and adds conditions to it.
   */
  andWhereBuilder(cb) {
    const nestedBuilder = new _SQLiteDeleteQueryBuilder(
      this.model,
      this.table,
      this.sqlConnection,
      this.logs,
      true,
      this.sqlDataSource,
      this.sqlModelManagerUtils
    );
    cb(nestedBuilder);
    let nestedCondition = nestedBuilder.whereQuery.trim();
    if (nestedCondition.startsWith("AND")) {
      nestedCondition = nestedCondition.substring(4);
    } else if (nestedCondition.startsWith("OR")) {
      nestedCondition = nestedCondition.substring(3);
    }
    if (!this.whereQuery) {
      this.whereQuery = this.isNestedCondition ? nestedCondition : `WHERE ${nestedCondition}`;
      this.whereParams.push(...nestedBuilder.whereParams);
      return this;
    }
    this.whereQuery += ` AND ${nestedCondition}`;
    this.whereParams.push(...nestedBuilder.whereParams);
    return this;
  }
  promisifyQuery(query, params) {
    return new Promise((resolve, reject) => {
      this.sqlConnection.run(query, params, function(err) {
        if (err) {
          return reject(err);
        }
        resolve(this.changes);
      });
    });
  }
};

// src/Sql/Sqlite/SQLiteModelManager.ts
var SQLiteModelManager = class extends AbstractModelManager {
  /**
   * Constructor for SqLiteModelManager class.
   *
   * @param {typeof Model} model - Model constructor.
   * @param {Pool} sqLiteConnection - SQLite connection.
   * @param {boolean} logs - Flag to enable or disable logging.
   */
  constructor(model, sqLiteConnection, logs, sqlDataSource) {
    super(model, logs, sqlDataSource);
    this.sqLiteConnection = sqLiteConnection;
    this.sqlModelManagerUtils = new SqlModelManagerUtils(
      "sqlite",
      sqLiteConnection
    );
  }
  /**
   * Find method to retrieve multiple records from the database based on the input conditions.
   *
   * @param {FindType} input - Optional query parameters for filtering, ordering, and pagination.
   * @returns Promise resolving to an array of models.
   */
  async find(input) {
    try {
      if (!input) {
        return await this.query().many();
      }
      const query = this.query();
      if (input.select) {
        query.select(...input.select);
      }
      if (input.relations) {
        query.addRelations(input.relations);
      }
      if (input.where) {
        Object.entries(input.where).forEach(([key, value]) => {
          query.where(key, value);
        });
      }
      if (input.orderBy) {
        query.orderBy(input.orderBy.columns, input.orderBy.type);
      }
      if (input.limit) {
        query.limit(input.limit);
      }
      if (input.offset) {
        query.offset(input.offset);
      }
      if (input.groupBy) {
        query.groupBy(...input.groupBy);
      }
      return await query.many({ ignoreHooks: input.ignoreHooks || [] });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Find a single record from the database based on the input conditions.
   *
   * @param {FindOneType} input - Query parameters for filtering and selecting a single record.
   * @returns Promise resolving to a single model or null if not found.
   */
  async findOne(input) {
    try {
      const query = this.query();
      if (input.select) {
        query.select(...input.select);
      }
      if (input.relations) {
        query.addRelations(input.relations);
      }
      if (input.where) {
        Object.entries(input.where).forEach(([key, value]) => {
          query.where(key, value);
        });
      }
      return await query.one({
        throwErrorOnNull: input.throwErrorOnNull || false,
        ignoreHooks: input.ignoreHooks || []
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Find a single record by its PK from the database.
   *
   * @param {string | number | boolean} value - PK of the record to retrieve, hooks will not have any effect, since it's a direct query for the PK.
   * @returns Promise resolving to a single model or null if not found.
   */
  async findOneByPrimaryKey(value, throwErrorOnNull = false) {
    try {
      if (!this.model.primaryKey) {
        throw new Error(
          "Model " + this.model.table + " has no primary key to be retrieved by"
        );
      }
      return await this.query().where(this.model.primaryKey, value).one({
        throwErrorOnNull
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Save a new model instance to the database.
   *
   * @param {Model} model - Model instance to be saved.
   * @param {SqliteTransaction} trx - SqliteTransaction to be used on the save operation.
   * @returns Promise resolving to the saved model or null if saving fails.
   */
  async insert(model) {
    this.model.beforeInsert(model);
    const { query, params } = this.sqlModelManagerUtils.parseInsert(
      model,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseInsert(
        model,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(query2, this.logs, params2);
      return await this.promisifyQuery(query2, params2, {
        isCreate: true,
        models: model
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Create multiple model instances in the database.
   *
   * @param {Model} model - Model instance to be saved.
   * @param {SqliteTransaction} trx - SqliteTransaction to be used on the save operation.
   * @returns Promise resolving to an array of saved models or null if saving fails.
   */
  async insertMany(models) {
    models.forEach((model) => {
      this.model.beforeInsert(model);
    });
    const { query, params } = this.sqlModelManagerUtils.parseMassiveInsert(
      models,
      this.model,
      this.sqlDataSource.getDbType()
    );
    try {
      const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseMassiveInsert(
        models,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(query2, this.logs, params2);
      return await this.promisifyQuery(query2, params2, {
        isinsertMany: true,
        models
      });
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Update an existing model instance in the database.
   * @param {Model} model - Model instance to be updated.
   * @param {SqliteTransaction} trx - SqliteTransaction to be used on the update operation.
   * @returns Promise resolving to the updated model or null if updating fails.
   */
  async updateRecord(model) {
    if (!this.model.primaryKey) {
      throw new Error(
        "Model " + this.model.table + " has no primary key to be updated, try save"
      );
    }
    try {
      const updateQuery = this.sqlModelManagerUtils.parseUpdate(
        model,
        this.model,
        this.sqlDataSource.getDbType()
      );
      log(updateQuery.query, this.logs, updateQuery.params);
      await this.promisifyQuery(updateQuery.query, updateQuery.params);
      return await this.findOneByPrimaryKey(
        model[this.model.primaryKey]
      );
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * @description Delete a record from the database from the given model.
   *
   * @param {Model} model - Model to delete.
   * @param trx - SqliteTransaction to be used on the delete operation.
   * @returns Promise resolving to the deleted model or null if deleting fails.
   */
  async deleteRecord(model) {
    try {
      if (!this.model.primaryKey) {
        throw new Error(
          "Model " + this.model.table + " has no primary key to be deleted from"
        );
      }
      const { query, params } = this.sqlModelManagerUtils.parseDelete(
        this.model.table,
        this.model.primaryKey,
        model[this.model.primaryKey]
      );
      log(query, this.logs, params);
      await this.promisifyQuery(query, params);
      return model;
    } catch (error) {
      queryError(error);
      throw new Error("Query failed " + error);
    }
  }
  /**
   * Create and return a new instance of the MysqlQueryBuilder for building more complex SQL queries.
   *
   * @returns {MysqlQueryBuilder<Model>} - Instance of MysqlQueryBuilder.
   */
  query() {
    return new SQLiteQueryBuilder(
      this.model,
      this.model.table,
      this.sqLiteConnection,
      this.logs,
      false,
      this.sqlDataSource
    );
  }
  /**
   * @description Returns an update query builder.
   */
  update() {
    return new SQLiteUpdateQueryBuilder(
      this.model,
      this.model.table,
      this.sqLiteConnection,
      this.logs,
      false,
      this.sqlDataSource,
      this.sqlModelManagerUtils
    );
  }
  /**
   * @description Returns a delete query builder.
   */
  deleteQuery() {
    return new SQLiteDeleteQueryBuilder(
      this.model,
      this.model.table,
      this.sqLiteConnection,
      this.logs,
      false,
      this.sqlDataSource,
      this.sqlModelManagerUtils
    );
  }
  promisifyQuery(query, params, options = {
    isCreate: false,
    isinsertMany: false,
    models: []
  }) {
    if (options.isCreate || options.isinsertMany) {
      if (options.isCreate) {
        const table2 = this.model.table;
        const sqLiteConnection2 = this.sqLiteConnection;
        return new Promise((resolve, reject) => {
          this.sqLiteConnection.run(
            query,
            params,
            function(err) {
              if (err) {
                return reject(err);
              }
              const lastID = this.lastID;
              const selectQuery = `SELECT * FROM ${table2} WHERE id = ?`;
              sqLiteConnection2.get(
                selectQuery,
                [lastID],
                (err2, row) => {
                  if (err2) {
                    return reject(err2);
                  }
                  resolve(row);
                }
              );
            }
          );
        });
      }
      if (!Array.isArray(options.models)) {
        throw new Error(
          "Models should be an array when massive creating on sqlite"
        );
      }
      const models = options.models;
      const table = this.model.table;
      const finalResult = [];
      const sqLiteConnection = this.sqLiteConnection;
      return new Promise((resolve, reject) => {
        models.forEach((model) => {
          const { query: query2, params: params2 } = this.sqlModelManagerUtils.parseInsert(
            model,
            this.model,
            this.sqlDataSource.getDbType()
          );
          this.sqLiteConnection.run(query2, params2, function(err) {
            if (err) {
              return reject(err);
            }
            const lastID = this.lastID;
            const selectQuery = `SELECT * FROM ${table} WHERE id = ?`;
            sqLiteConnection.get(selectQuery, [lastID], (err2, row) => {
              if (err2) {
                return reject(err2);
              }
              finalResult.push(row);
              if (finalResult.length === models.length) {
                resolve(finalResult);
              }
            });
          });
        });
      });
    }
    return new Promise((resolve, reject) => {
      this.sqLiteConnection.all(query, params, (err, rows) => {
        if (err) {
          return reject(err);
        }
        resolve(rows);
      });
    });
  }
};

// src/Sql/Resources/Query/TRANSACTION.ts
var BEGIN_TRANSACTION = "BEGIN; \n";
var COMMIT_TRANSACTION = "COMMIT; \n";
var ROLLBACK_TRANSACTION = "ROLLBACK; \n";

// src/Sql/Transaction.ts
var Transaction = class {
  constructor(sqlDataSource, logs = false) {
    this.sqlDataSource = sqlDataSource;
    this.sqlConnection = this.sqlDataSource.getCurrentConnection();
    this.logs = logs;
  }
  async startTransaction() {
    try {
      switch (this.sqlDataSource.getDbType()) {
        case "mysql":
        case "mariadb":
          log(BEGIN_TRANSACTION, this.logs);
          await this.sqlConnection.beginTransaction();
          break;
        case "postgres":
          log(BEGIN_TRANSACTION, this.logs);
          await this.sqlConnection.query(BEGIN_TRANSACTION);
          break;
        case "sqlite":
          log(BEGIN_TRANSACTION, this.logs);
          this.sqlConnection.run(BEGIN_TRANSACTION, (err) => {
            if (err) {
              throw new Error(err.message);
            }
          });
          break;
        default:
          throw new Error("Invalid database type while beginning transaction");
      }
    } catch (error) {
      await this.releaseConnection();
    }
  }
  async commit() {
    try {
      switch (this.sqlDataSource.getDbType()) {
        case "mysql":
        case "mariadb":
          log(COMMIT_TRANSACTION, this.logs);
          await this.sqlConnection.commit();
          break;
        case "postgres":
          log(COMMIT_TRANSACTION, this.logs);
          await this.sqlConnection.query(COMMIT_TRANSACTION);
          break;
        case "sqlite":
          log(COMMIT_TRANSACTION, this.logs);
          this.sqlConnection.run(COMMIT_TRANSACTION, (err) => {
            if (err) {
              throw new Error(err.message);
            }
          });
          break;
        default:
          throw new Error("Invalid database type while committing transaction");
      }
    } catch (error) {
      throw error;
    } finally {
      await this.releaseConnection();
    }
  }
  async rollback() {
    try {
      switch (this.sqlDataSource.getDbType()) {
        case "mysql":
        case "mariadb":
          log(ROLLBACK_TRANSACTION, this.logs);
          await this.sqlConnection.rollback();
          break;
        case "postgres":
          log(ROLLBACK_TRANSACTION, this.logs);
          await this.sqlConnection.query(ROLLBACK_TRANSACTION);
          break;
        case "sqlite":
          log(ROLLBACK_TRANSACTION, this.logs);
          this.sqlConnection.run(ROLLBACK_TRANSACTION, (err) => {
            if (err) {
              throw new Error(err.message);
            }
          });
          break;
        default:
          throw new Error(
            "Invalid database type while rolling back transaction"
          );
      }
    } finally {
      await this.releaseConnection();
    }
  }
  async releaseConnection() {
    switch (this.sqlDataSource.getDbType()) {
      case "mysql":
      case "mariadb":
        await this.sqlConnection.end();
        break;
      case "postgres":
        await this.sqlConnection.end();
        break;
      case "sqlite":
        this.sqlConnection.close();
        break;
      default:
        throw new Error("Invalid database type while releasing connection");
    }
  }
};

// src/Sql/SqlDatasource.ts
var _SqlDataSource = class _SqlDataSource extends DataSource {
  constructor(input) {
    super(input);
    this.isConnected = false;
  }
  getDbType() {
    return this.type;
  }
  /**
   * @description Connects to the database establishing a connection. If no connection details are provided, the default values from the env will be taken instead
   * @description The User input connection details will always come first
   */
  static async connect(input, cb) {
    const sqlDataSource = new this(input);
    switch (sqlDataSource.type) {
      case "mysql":
      case "mariadb":
        sqlDataSource.sqlConnection = await import_promise.default.createConnection({
          host: sqlDataSource.host,
          port: sqlDataSource.port,
          user: sqlDataSource.username,
          password: sqlDataSource.password,
          database: sqlDataSource.database,
          ...input?.mysqlOptions
        });
        break;
      case "postgres":
        sqlDataSource.sqlConnection = new import_pg.default.Client({
          host: sqlDataSource.host,
          port: sqlDataSource.port,
          user: sqlDataSource.username,
          password: sqlDataSource.password,
          database: sqlDataSource.database,
          ...input?.pgOptions
        });
        await sqlDataSource.sqlConnection.connect();
        break;
      case "sqlite":
        sqlDataSource.sqlConnection = new import_sqlite3.default.Database(
          sqlDataSource.database,
          import_sqlite3.default.OPEN_READWRITE | import_sqlite3.default.OPEN_CREATE,
          (err) => {
            if (err) {
              throw new Error(`Error while connecting to sqlite: ${err}`);
            }
          }
        );
        break;
      case "mssql":
        sqlDataSource.sqlConnection = await import_mssql2.default.connect({
          server: sqlDataSource.host,
          user: sqlDataSource.username,
          password: sqlDataSource.password,
          database: sqlDataSource.database,
          ...input?.mssqlOptions
        });
        break;
      default:
        throw new Error(`Unsupported datasource type: ${sqlDataSource.type}`);
    }
    sqlDataSource.isConnected = true;
    _SqlDataSource.instance = sqlDataSource;
    cb?.();
    return sqlDataSource;
  }
  static getInstance() {
    if (!this.instance) {
      throw new Error("Sql database connection not established");
    }
    return _SqlDataSource.instance;
  }
  /**
   * @description Starts a transaction on the database and returns the transaction object
   * @param model
   * @returns {Promise<Transaction>} trx
   */
  async startTransaction(driverSpecificOptions) {
    const sqlDataSource = new _SqlDataSource({
      type: this.type,
      host: this.host,
      port: this.port,
      username: this.username,
      password: this.password,
      database: this.database,
      logs: this.logs,
      ...driverSpecificOptions
    });
    await sqlDataSource.connectDriver();
    sqlDataSource.isConnected = true;
    const mysqlTrx = new Transaction(sqlDataSource, this.logs);
    await mysqlTrx.startTransaction();
    return mysqlTrx;
  }
  /**
   * @description Alias for startTransaction
   * @returns {Promise<Transaction>} trx
   */
  async beginTransaction(driverSpecificOptions) {
    return this.startTransaction(driverSpecificOptions);
  }
  /**
   * @description Alias for startTransaction
   * @returns {Promise<Transaction>} trx
   */
  async transaction(driverSpecificOptions) {
    return this.startTransaction(driverSpecificOptions);
  }
  /**
   * @description Returns model manager for the provided model
   * @param model
   */
  getModelManager(model) {
    if (!this.isConnected) {
      throw new Error("Sql database connection not established");
    }
    switch (this.type) {
      case "mysql":
      case "mariadb":
        return new MysqlModelManager(
          model,
          this.sqlConnection,
          this.logs,
          this
        );
      case "postgres":
        return new PostgresModelManager(
          model,
          this.sqlConnection,
          this.logs,
          this
        );
      case "sqlite":
        return new SQLiteModelManager(
          model,
          this.sqlConnection,
          this.logs,
          this
        );
      case "mssql":
        return new MssqllModelManager(
          model,
          this.sqlConnection,
          this.logs,
          this
        );
      default:
        throw new Error(`Unsupported datasource type: ${this.type}`);
    }
  }
  /**
   * @description Executes a callback function with the provided connection details
   * @description Static Model methods will always use the base connection created with SqlDataSource.connect() method
   * @param connectionDetails
   * @param cb
   */
  static async useConnection(connectionDetails, cb) {
    const customSqlInstance = new _SqlDataSource(connectionDetails);
    await customSqlInstance.connectDriver({
      mysqlOptions: connectionDetails.mysqlOptions,
      pgOptions: connectionDetails.pgOptions,
      mssqlOptions: connectionDetails.mssqlOptions
    });
    customSqlInstance.isConnected = true;
    try {
      await cb(customSqlInstance).then(async () => {
        if (!customSqlInstance.isConnected) {
          return;
        }
        await customSqlInstance.closeConnection();
      });
    } catch (error) {
      if (customSqlInstance.isConnected) {
        await customSqlInstance.closeConnection();
      }
      throw error;
    }
  }
  /**
   * @description Returns the current connection
   * @returns {Promise<SqlConnectionType>} sqlConnection
   */
  getCurrentConnection() {
    return this.sqlConnection;
  }
  /**
   * @description Returns separate raw sql connection
   */
  async getRawConnection(driverSpecificOptions) {
    switch (this.type) {
      case "mysql":
      case "mariadb":
        return await (0, import_promise.createConnection)({
          host: this.host,
          port: this.port,
          user: this.username,
          password: this.password,
          database: this.database,
          ...driverSpecificOptions?.mysqlOptions
        });
      case "postgres":
        const client = new import_pg.default.Client({
          host: this.host,
          port: this.port,
          user: this.username,
          password: this.password,
          database: this.database,
          ...driverSpecificOptions?.pgOptions
        });
        await client.connect();
        return client;
      case "sqlite":
        return new import_sqlite3.default.Database(
          this.database,
          import_sqlite3.default.OPEN_READWRITE | import_sqlite3.default.OPEN_CREATE,
          (err) => {
            if (err) {
              throw new Error(`Error while connecting to sqlite: ${err}`);
            }
          }
        );
      case "mssql":
        return await import_mssql2.default.connect({
          server: this.host,
          user: this.username,
          password: this.password,
          database: this.database,
          ...driverSpecificOptions?.mssqlOptions
        });
      default:
        throw new Error(`Unsupported datasource type: ${this.type}`);
    }
  }
  /**
   * @description Closes the connection to the database
   * @returns
   */
  async closeConnection() {
    if (!this.isConnected) {
      Logger_default.warn("Connection already closed", this);
      return;
    }
    Logger_default.warn("Closing connection", this);
    switch (this.type) {
      case "mysql":
      case "mariadb":
        await this.sqlConnection.end();
        this.isConnected = false;
        _SqlDataSource.instance = null;
        break;
      case "postgres":
        await this.sqlConnection.end();
        this.isConnected = false;
        _SqlDataSource.instance = null;
        break;
      case "sqlite":
        await new Promise((resolve, reject) => {
          this.sqlConnection.close((err) => {
            if (err) {
              reject(err);
            }
            resolve();
          });
        });
        this.isConnected = false;
        _SqlDataSource.instance = null;
        break;
      case "mssql":
        await this.sqlConnection.close();
        this.isConnected = false;
        _SqlDataSource.instance = null;
        break;
      default:
        throw new Error(`Unsupported datasource type: ${this.type}`);
    }
  }
  /**
   * @description Executes a raw query on the database
   * @param query
   * @param params
   * @returns
   */
  async rawQuery(query, params = []) {
    if (!this.isConnected) {
      throw new Error("Sql database connection not established");
    }
    log(query, this.logs, params);
    switch (this.type) {
      case "mysql":
      case "mariadb":
        const [mysqlRows] = await this.sqlConnection.execute(query, params);
        return mysqlRows;
      case "postgres":
        const { rows } = await this.sqlConnection.query(
          query,
          params
        );
        return rows;
      case "sqlite":
        return new Promise((resolve, reject) => {
          this.sqlConnection.all(
            query,
            params,
            (err, rows2) => {
              if (err) {
                reject(err);
              }
              resolve(rows2);
            }
          );
        });
      case "mssql":
        const mssqlRequest = this.sqlConnection.request();
        MssqllModelManager.addParamsToMssqlRequest(mssqlRequest, query, params);
        return (await mssqlRequest.query(query)).recordset;
      default:
        throw new Error(`Unsupported datasource type: ${this.type}`);
    }
  }
  /**
   * @description Executes a raw query on the database with the base connection created with SqlDataSource.connect() method
   * @param query
   * @param params
   * @returns
   */
  static async rawQuery(query, params = []) {
    const sqlDataSource = _SqlDataSource.getInstance();
    if (!sqlDataSource || !sqlDataSource.isConnected) {
      throw new Error("Sql database connection not established");
    }
    log(query, _SqlDataSource.getInstance()?.logs ?? false, params);
    switch (sqlDataSource.type) {
      case "mysql":
      case "mariadb":
        const [mysqlRows] = await sqlDataSource.sqlConnection.execute(query, params);
        return mysqlRows;
      case "postgres":
        const { rows } = await sqlDataSource.sqlConnection.query(
          query,
          params
        );
        return rows;
      case "sqlite":
        return new Promise((resolve, reject) => {
          sqlDataSource.sqlConnection.all(
            query,
            params,
            (err, rows2) => {
              if (err) {
                reject(err);
              }
              resolve(rows2);
            }
          );
        });
      case "mssql":
        const mssqlRequest = sqlDataSource.sqlConnection.request();
        MssqllModelManager.addParamsToMssqlRequest(mssqlRequest, query, params);
        return (await mssqlRequest.query(query)).recordset;
      default:
        throw new Error(`Unsupported datasource type: ${sqlDataSource.type}`);
    }
  }
  async connectDriver(driverSpecificOptions) {
    switch (this.type) {
      case "mysql":
      case "mariadb":
        this.sqlConnection = await import_promise.default.createConnection({
          host: this.host,
          port: this.port,
          user: this.username,
          password: this.password,
          database: this.database,
          ...driverSpecificOptions?.mysqlOptions
        });
        break;
      case "postgres":
        this.sqlConnection = new import_pg.default.Client({
          host: this.host,
          port: this.port,
          user: this.username,
          password: this.password,
          database: this.database,
          ...driverSpecificOptions?.pgOptions
        });
        await this.sqlConnection.connect();
        break;
      case "sqlite":
        this.sqlConnection = new import_sqlite3.default.Database(
          this.database,
          import_sqlite3.default.OPEN_READWRITE | import_sqlite3.default.OPEN_CREATE,
          (err) => {
            if (err) {
              throw new Error(`Error while connecting to sqlite: ${err}`);
            }
          }
        );
        break;
      case "mssql":
        this.sqlConnection = await import_mssql2.default.connect({
          server: this.host,
          user: this.username,
          password: this.password,
          database: this.database,
          ...driverSpecificOptions?.mssqlOptions
        });
        break;
      default:
        throw new Error(`Unsupported datasource type: ${this.type}`);
    }
  }
};
_SqlDataSource.instance = null;
var SqlDataSource = _SqlDataSource;

// src/Sql/Models/Model.ts
function getBaseTable(target) {
  const className = target.name;
  const table = className.endsWith("s") ? convertCase(className, "snake") : convertCase(className, "snake") + "s";
  return table;
}
function getBaseModelInstance() {
  return { extraColumns: {} };
}
var tableMap = /* @__PURE__ */ new WeakMap();
var primaryKeyMap = /* @__PURE__ */ new WeakMap();
var Model = class {
  /**
   * @description Static getter for table;
   * @internal
   */
  static get table() {
    if (!tableMap.has(this)) {
      tableMap.set(this, this.tableName || getBaseTable(this));
    }
    return tableMap.get(this);
  }
  /**
   * @description Getter for the primary key of the model
   */
  static get primaryKey() {
    if (!primaryKeyMap.has(this)) {
      primaryKeyMap.set(this, getPrimaryKey(this));
    }
    return primaryKeyMap.get(this);
  }
  /**
   * @description Constructor for the model, it's not meant to be used directly, it just initializes the extraColumns, it's advised to only use the static methods to interact with the Model instances
   */
  constructor() {
    this.extraColumns = {};
  }
  /**
   * @description Gives a query instance for the given model
   * @param model
   * @returns {ModelQueryBuilder<T>}
   */
  static query(options = {}) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.query();
  }
  /**
   * @description Finds the first record in the database
   * @param model
   * @param {FindType} options
   * @returns {Promise<T[]>}
   */
  static async first(options = { throwErrorOnNull: false }) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return await modelManager.query().one(options);
  }
  /**
   * @description Finds records for the given model
   * @param model
   * @param {FindType} options
   * @returns {Promise<T[]>}
   */
  static find(options) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager({
      trx: options?.trx,
      useConnection: options?.useConnection
    });
    return modelManager.find(options);
  }
  /**
   * @description Finds a record for the given model
   * @param model
   * @param {FindOneType} options
   * @returns {Promise<T | null>}
   */
  static findOne(options) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.findOne(options);
  }
  /**
   * @description Finds a record for the given model for the given id, "id" must be set in the model in order for it to work
   * @param model
   * @param {number | string} id
   * @returns {Promise<T | null>}
   */
  static findOneByPrimaryKey(value, options = {
    throwErrorOnNull: false
  }) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.findOneByPrimaryKey(value, options.throwErrorOnNull);
  }
  /**
   * @description Refreshes a model from the database, the model must have a primary key defined
   * @param model
   */
  static refresh(model, options = {
    throwErrorOnNull: false
  }) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    const primaryKey = typeofModel.primaryKey;
    const primaryKeyValue = model[primaryKey];
    return modelManager.findOneByPrimaryKey(
      primaryKeyValue,
      options.throwErrorOnNull
    );
  }
  /**
   * @description Saves a new record to the database
   * @description While using mysql, it will return records only if the primary key is auto incrementing integer, else it will always return null
   * @param model
   * @param {Model} modelData
   * @param trx
   * @returns {Promise<T | null>}
   */
  static insert(modelData, options = {}) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.insert(modelData);
  }
  /**
   * @description Saves multiple records to the database
   * @description WHile using mysql, it will return records only if the primary key is auto incrementing integer, else it will always return []
   * @param model
   * @param {Model} modelsData
   * @param trx
   * @returns {Promise<T[]>}
   */
  static insertMany(modelsData, options = {}) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.insertMany(modelsData);
  }
  /**
   * @description Updates a record to the database
   * @param model
   * @param {Model} modelInstance
   * @param trx
   * @returns
   */
  static updateRecord(modelInstance, options = {}) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.updateRecord(modelInstance);
  }
  /**
   * @description Finds the first record or creates a new one if it doesn't exist
   * @param model
   * @param {Partial<T>} searchCriteria
   * @param {Partial<T>} createData
   */
  static async firstOrCreate(searchCriteria, createData, options = {}) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    const doesExist = await modelManager.findOne({
      where: searchCriteria
    });
    if (doesExist) {
      return doesExist;
    }
    return await modelManager.insert(createData);
  }
  /**
   * @description Updates or creates a new record
   * @param {Partial<T>} searchCriteria
   * @param {Partial<T>} data
   * @param options - The options to update the record on conflict, default is true
   */
  static async upsert(searchCriteria, data, options = {
    updateOnConflict: true
  }) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    const doesExist = await modelManager.findOne({
      where: searchCriteria
    });
    if (doesExist) {
      data[typeofModel.primaryKey] = doesExist[typeofModel.primaryKey];
      if (options.updateOnConflict) {
        return await modelManager.updateRecord(data);
      }
      return doesExist;
    }
    return await modelManager.insert(data);
  }
  /**
   * @description Updates or creates multiple records
   * @param {Partial<T>} searchCriteria
   * @param {Partial<T>} data
   * @param options - The options to update the record on conflict, default is true
   * @returns - The updated or created records
   */
  static async upsertMany(searchCriteria, data, options = {
    updateOnConflict: true
  }) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    if (!data.every(
      (record) => searchCriteria.every((column2) => column2 in record)
    )) {
      throw new Error(
        "Conflict columns are not present in the data, please make sure to include them in the data, " + searchCriteria.join(", ")
      );
    }
    const results = [];
    for (let i = 0; i < data.length; i++) {
      const record = data[i];
      const search = searchCriteria.reduce((acc, column2) => {
        acc[column2] = record[column2];
        return acc;
      }, {});
      const doesExist = await modelManager.findOne({
        where: search
      });
      if (doesExist) {
        record[typeofModel.primaryKey] = doesExist[typeofModel.primaryKey];
        if (options.updateOnConflict) {
          results.push(await modelManager.updateRecord(record));
          continue;
        }
        results.push(doesExist);
        continue;
      }
      results.push(await modelManager.insert(record));
    }
    return results;
  }
  /**
   * @description Updates records to the database
   * @param model
   * @param {Model} modelInstance
   * @param trx
   * @returns Update query builder
   */
  static update(options = {}) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.update();
  }
  /**
   * @description Gives a Delete query builder instance
   * @param model
   * @param {Model} modelInstance
   * @param trx
   * @returns
   */
  static deleteQuery(options = {}) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.deleteQuery();
  }
  /**
   * @description Deletes a record to the database
   * @param model
   * @param {Model} modelInstance
   * @param trx
   * @returns
   */
  static deleteRecord(modelInstance, options = {}) {
    const typeofModel = this;
    const modelManager = typeofModel.getModelManager(options);
    return modelManager.deleteRecord(modelInstance);
  }
  /**
   * @description Soft Deletes a record to the database
   * @param model
   * @param {Model} modelInstance
   * @param options - The options to soft delete the record, column and value - Default is 'deletedAt' for column and the current date and time for value, string is always counted as a Date stringified as new Date().toString()
   * @param trx
   * @returns
   */
  static async softDelete(modelInstance, options) {
    const typeofModel = this;
    const {
      column: column2 = "deletedAt",
      value = import_luxon6.DateTime.local().toISO()
    } = options || {};
    modelInstance[column2] = value;
    const modelManager = typeofModel.getModelManager({
      trx: options?.trx,
      useConnection: options?.useConnection
    });
    await modelManager.updateRecord(modelInstance);
    if (typeof value === "string") {
      modelInstance[column2] = import_luxon6.DateTime.fromISO(value);
    }
    modelInstance[column2] = value;
    return await parseDatabaseDataIntoModelResponse(
      [modelInstance],
      typeofModel
    );
  }
  /**
   * @description Adds dynamic columns to the model that are not defined in the Table and are defined in the model
   * @description It does not support custom connection or transaction
   * @param model
   * @param data
   * @param dynamicColumns
   * @returns
   */
  static async addDynamicColumns(data, dynamicColumns) {
    const typeofModel = this;
    typeofModel.establishConnection();
    if (Array.isArray(data)) {
      for (const model of data) {
        await addDynamicColumnsToModel(
          typeofModel,
          model,
          dynamicColumns
        );
      }
      return data;
    }
    if (!Array.isArray(data)) {
      await addDynamicColumnsToModel(
        typeofModel,
        data,
        dynamicColumns
      );
      return data;
    }
    for (const model of data.data) {
      await addDynamicColumnsToModel(
        typeofModel,
        model,
        dynamicColumns
      );
    }
    return data;
  }
  /**
   * @description Merges the provided data with the instance
   * @param instance
   * @param data
   * @returns {void}
   */
  static combineProps(instance, data) {
    for (const key in data) {
      Object.assign(instance, { [key]: data[key] });
    }
  }
  /**
   * @description Adds a beforeFetch clause to the model, adding the ability to modify the query before fetching the data
   * @param queryBuilder
   */
  static beforeFetch(queryBuilder) {
    queryBuilder;
  }
  /**
   * @description Adds a beforeCreate clause to the model, adding the ability to modify the data after fetching the data
   * @param data
   * @returns {T}
   */
  static beforeInsert(data) {
    return data;
  }
  /**
   * @description Adds a beforeUpdate clause to the model, adding the ability to modify the query before updating the data
   * @param data
   */
  static beforeUpdate(queryBuilder) {
    queryBuilder;
  }
  /**
   * @description Adds a beforeDelete clause to the model, adding the ability to modify the query before deleting the data
   * @param data
   */
  static beforeDelete(queryBuilder) {
    queryBuilder;
  }
  /**
   * @description Adds a afterFetch clause to the model, adding the ability to modify the data after fetching the data
   * @param data
   * @returns {T}
   */
  static async afterFetch(data) {
    return data;
  }
  /**
   * @description Establishes a connection to the database instantiated from the SqlDataSource.connect method, this is done automatically when using the static methods
   * @description This method is meant to be used only if you want to establish sql instance of the model directly
   * @internal
   * @returns {void}
   */
  static establishConnection() {
    const sql = SqlDataSource.getInstance();
    if (!sql) {
      throw new Error(
        "Sql instance not initialized, did you defined it in SqlDataSource.connect static method?"
      );
    }
    this.sqlInstance = sql;
  }
  /**
   * @description Gives the correct model manager with the correct connection based on the options provided
   * @param this
   * @param options
   * @returns
   */
  static getModelManager(options) {
    if (options.useConnection) {
      return options.useConnection.getModelManager(
        this
      );
    }
    if (options.trx) {
      return options.trx.sqlDataSource.getModelManager(
        this
      );
    }
    const typeofModel = this;
    typeofModel.establishConnection();
    return typeofModel.sqlInstance.getModelManager(typeofModel);
  }
};
/**
 * @description Defines the case convention for the model
 * @type {CaseConvention}
 */
Model.modelCaseConvention = "camel";
/**
 * @description Defines the case convention for the database, this should be the case convention you use in your database
 * @type {CaseConvention}
 */
Model.databaseCaseConvention = "snake";

// src/index.ts
var import_ioredis2 = require("ioredis");

// src/NoSql/Redis/RedisDataSource.ts
var import_ioredis = __toESM(require("ioredis"));
var RedisDataSource = class _RedisDataSource {
  constructor(input) {
    this.isConnected = false;
    const port = input?.port || +process.env.REDIS_PORT || 6379;
    this.redisConnection = new import_ioredis.default({
      host: input?.host || process.env.REDIS_HOST,
      username: input?.username || process.env.REDIS_USERNAME,
      port,
      password: input?.password || process.env.REDIS_PASSWORD,
      ...input
    });
  }
  /**
   * @description Connects to the Redis database establishing a connection. If no connection details are provided, the default values from the env will be taken instead
   * @description The User input connection details will always come first
   * @description This is intended as a singleton connection to the redis database, if you need multiple connections, use the getConnection method
   * @param {RedisDataSourceInput} input - Details for the Redis connection
   */
  static async connect(input) {
    if (_RedisDataSource.isConnected) {
      return;
    }
    const port = input?.port || +process.env.REDIS_PORT || 6379;
    _RedisDataSource.redisConnection = new import_ioredis.default({
      host: input?.host || process.env.REDIS_HOST,
      username: input?.username || process.env.REDIS_USERNAME,
      port,
      password: input?.password || process.env.REDIS_PASSWORD,
      ...input
    });
    try {
      await _RedisDataSource.redisConnection.ping();
      _RedisDataSource.isConnected = true;
    } catch (error) {
      throw new Error(`Failed to connect to Redis: ${error}`);
    }
  }
  /**
   * @description Establishes a connection to the Redis database and returns the connection
   * @param input
   * @returns
   */
  static async getConnection(input) {
    const connection = new _RedisDataSource(input);
    await connection.redisConnection.ping();
    connection.isConnected = true;
    return connection;
  }
  /**
   * @description Sets a key-value pair in the Redis database
   * @param {string} key - The key
   * @param {string} value - The value
   * @param {number} expirationTime - The expiration time in milliseconds
   * @returns {Promise<void>}
   */
  static async set(key, value, expirationTime) {
    expirationTime = expirationTime ? expirationTime / 1e3 : void 0;
    if (typeof value === "object" && !Buffer.isBuffer(value)) {
      value = JSON.stringify(value);
    }
    if (typeof value === "boolean") {
      value = value.toString();
    }
    try {
      if (expirationTime) {
        await _RedisDataSource.redisConnection.setex(key, expirationTime, value);
        return;
      }
      await _RedisDataSource.redisConnection.set(key, value);
    } catch (error) {
      throw new Error(`Failed to set key-value pair in Redis: ${error}`);
    }
  }
  /**
   * @description Gets the value of a key in the Redis database
   * @param {string} key - The key
   * @returns {Promise<string>}
   */
  static async get(key) {
    try {
      const value = await _RedisDataSource.redisConnection.get(key);
      return _RedisDataSource.getValue(value);
    } catch (error) {
      throw new Error(`Failed to get value from Redis: ${error}`);
    }
  }
  /**
   * @description Gets the value of a key in the Redis database as a buffer
   */
  static async getBuffer(key) {
    try {
      return await _RedisDataSource.redisConnection.getBuffer(key);
    } catch (error) {
      throw new Error(`Failed to get value from Redis: ${error}`);
    }
  }
  /**
   * @description Gets the value of a key in the Redis database and deletes the key
   * @param {string} key - The key
   * @returns {Promise
   * <T | null>}
   */
  static async getAndDelete(key) {
    try {
      const value = await _RedisDataSource.redisConnection.get(key);
      await _RedisDataSource.redisConnection.del(key);
      return _RedisDataSource.getValue(value);
    } catch (error) {
      throw new Error(`Failed to get value from Redis: ${error}`);
    }
  }
  /**
   * @description Deletes a key from the Redis database
   * @param {string} key - The key
   * @returns {Promise<void>}
   */
  static async delete(key) {
    try {
      await _RedisDataSource.redisConnection.del(key);
    } catch (error) {
      throw new Error(`Failed to delete key from Redis: ${error}`);
    }
  }
  /**
   * @description Flushes all the data in the Redis database
   * @returns {Promise<void>}
   */
  static async flushAll() {
    try {
      await _RedisDataSource.redisConnection.flushall();
    } catch (error) {
      throw new Error(`Failed to flush Redis database: ${error}`);
    }
  }
  /**
   * @description Returns the raw Redis connection that uses the ioredis library
   * @returns {Redis}
   */
  static getRawConnection() {
    if (!_RedisDataSource.isConnected || !_RedisDataSource.redisConnection) {
      throw new Error("Redis connection not established");
    }
    return _RedisDataSource.redisConnection;
  }
  /**
   * @description Disconnects from the Redis database
   * @returns {Promise<void>}
   */
  static async disconnect() {
    try {
      await _RedisDataSource.redisConnection.quit();
      _RedisDataSource.isConnected = false;
    } catch (error) {
      throw new Error(`Failed to disconnect from Redis: ${error}`);
    }
  }
  /**
   * @description Sets a key-value pair in the Redis database
   * @param {string} key - The key
   * @param {string} value - The value
   * @param {number} expirationTime - The expiration time in milliseconds
   * @returns {Promise<void>}
   */
  async set(key, value, expirationTime) {
    expirationTime = expirationTime ? expirationTime / 1e3 : void 0;
    if (typeof value === "object" && !Buffer.isBuffer(value)) {
      value = JSON.stringify(value);
    }
    if (typeof value === "boolean") {
      value = value.toString();
    }
    try {
      if (expirationTime) {
        await this.redisConnection.setex(key, expirationTime, value);
        return;
      }
      await this.redisConnection.set(key, value);
    } catch (error) {
      throw new Error(`Failed to set key-value pair in Redis: ${error}`);
    }
  }
  /**
   * @description Gets the value of a key in the Redis database
   * @param {string} key - The key
   * @returns {Promise<string>}
   */
  async get(key) {
    try {
      const value = await this.redisConnection.get(key);
      return _RedisDataSource.getValue(value);
    } catch (error) {
      throw new Error(`Failed to get value from Redis: ${error}`);
    }
  }
  /**
   * @description Gets the value of a key in the Redis database as a buffer
   */
  async getBuffer(key) {
    try {
      return await this.redisConnection.getBuffer(key);
    } catch (error) {
      throw new Error(`Failed to get value from Redis: ${error}`);
    }
  }
  /**
   * @description Gets the value of a key in the Redis database and deletes the key
   * @param {string} key - The key
   * @returns {Promise
   * <T | null>}
   */
  async getAndDelete(key) {
    try {
      const value = await this.redisConnection.get(key);
      await this.redisConnection.del(key);
      return _RedisDataSource.getValue(value);
    } catch (error) {
      throw new Error(`Failed to get value from Redis: ${error}`);
    }
  }
  /**
   * @description Deletes a key from the Redis database
   * @param {string} key - The key
   * @returns {Promise<void>}
   */
  async delete(key) {
    try {
      await this.redisConnection.del(key);
    } catch (error) {
      throw new Error(`Failed to delete key from Redis: ${error}`);
    }
  }
  /**
   * @description Flushes all the data in the Redis database
   * @returns {Promise<void>}
   */
  async flushAll() {
    try {
      await this.redisConnection.flushall();
    } catch (error) {
      throw new Error(`Failed to flush Redis database: ${error}`);
    }
  }
  /**
   * @description Returns the raw Redis connection that uses the ioredis library
   * @returns {Redis}
   */
  getRawConnection() {
    if (!this.isConnected || !this.redisConnection) {
      throw new Error("Redis connection not established");
    }
    return this.redisConnection;
  }
  /**
   * @description Disconnects from the Redis database
   * @returns {Promise<void>}
   */
  async disconnect() {
    try {
      await this.redisConnection.quit();
      this.isConnected = false;
    } catch (error) {
      throw new Error(`Failed to disconnect from Redis: ${error}`);
    }
  }
  static getValue(value) {
    if (!value) {
      return null;
    }
    try {
      const jsonVal = JSON.parse(value);
      return jsonVal;
    } catch (_error) {
    }
    if (value === "true" || value === "false") {
      return Boolean(value);
    }
    if (Number(value)) {
      return Number(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return value;
  }
};

// src/index.ts
(async () => {
  const sql = await SqlDataSource.connect({
    type: "mssql",
    host: "localhost",
    port: 1433,
    username: "sa",
    password: "s!wASadsfamf\xE8asp@\xDFfasngosinam",
    database: "master",
    logs: true,
    mssqlOptions: {
      driver: "msnodesqlv8",
      server: "localhost",
      options: {
        encrypt: false,
        trustServerCertificate: true,
        trustedConnection: true
      }
    }
  });
  await sql.closeConnection();
})();
var src_default = {
  // Sql
  Model,
  column,
  belongsTo,
  hasOne,
  hasMany,
  Relation,
  SqlDataSource,
  Migration,
  getRelations,
  getModelColumns,
  // Redis
  Redis: RedisDataSource
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Migration,
  Model,
  ModelDeleteQueryBuilder,
  ModelUpdateQueryBuilder,
  Redis,
  RedisOptions,
  Relation,
  SqlDataSource,
  belongsTo,
  column,
  getModelColumns,
  getPrimaryKey,
  getRelations,
  hasMany,
  hasOne
});
/*! Bundled license information:

@azure/msal-node/dist/cache/serializer/Serializer.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-common/dist/utils/Constants.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/AuthErrorCodes.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/AuthError.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/ClientAuthError.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/crypto/ICrypto.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/logger/Logger.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/packageMetadata.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/AuthorityOptions.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/account/AuthToken.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/utils/TimeUtils.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/cache/utils/CacheHelpers.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/ClientConfigurationError.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/utils/StringUtils.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/request/ScopeSet.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/account/ClientInfo.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/account/AccountInfo.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/AuthorityType.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/account/TokenClaims.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/ProtocolMode.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/cache/entities/AccountEntity.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/utils/UrlUtils.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/url/UrlString.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/AuthorityMetadata.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/CacheErrorCodes.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/CacheError.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/cache/CacheManager.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/config/ClientConfiguration.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/ServerError.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/network/ThrottlingUtils.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/network/NetworkManager.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/account/CcsCredential.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/constants/AADServerParamKeys.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/request/RequestValidator.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/request/RequestParameterBuilder.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/utils/FunctionWrappers.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/RegionDiscovery.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/Authority.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/authority/AuthorityFactory.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/client/BaseClient.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/utils/ProtocolUtils.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/crypto/PopTokenGenerator.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/response/ResponseHandler.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/utils/ClientAssertionUtils.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/client/AuthorizationCodeClient.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/client/RefreshTokenClient.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/client/SilentFlowClient.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-common/dist/index-node.mjs:
  (*! @azure/msal-common v14.15.0 2024-09-20 *)

@azure/msal-node/dist/cache/serializer/Deserializer.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/internals.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/utils/Constants.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/utils/NetworkUtils.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/network/HttpClient.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/error/ManagedIdentityError.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/config/ManagedIdentityId.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/retry/LinearRetryPolicy.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/network/HttpClientWithRetries.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/error/NodeAuthError.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/config/Configuration.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/crypto/GuidGenerator.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/utils/EncodingUtils.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/crypto/HashUtils.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/crypto/PkceGenerator.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/crypto/CryptoProvider.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/cache/NodeStorage.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/cache/TokenCache.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@azure/msal-node/dist/client/ClientAssertion.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/packageMetadata.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/UsernamePasswordClient.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ClientApplication.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/network/LoopbackClient.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/DeviceCodeClient.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/PublicClientApplication.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ClientCredentialClient.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/OnBehalfOfClient.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ConfidentialClientApplication.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ManagedIdentityClient.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/client/ManagedIdentityApplication.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

@azure/msal-node/dist/index.mjs:
  (*! @azure/msal-node v2.14.0 2024-09-20 *)

js-md4/src/md4.js:
  (**
   * [js-md4]{@link https://github.com/emn178/js-md4}
   *
   * @namespace md4
   * @version 0.3.2
   * @author Yi-Cyuan Chen [emn178@gmail.com]
   * @copyright Yi-Cyuan Chen 2015-2027
   * @license MIT
   *)

@js-joda/core/dist/js-joda.esm.js:
  (*! @version @js-joda/core - 5.6.3 *)
  (*! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors *)
  (*! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos *)
  (*! @license BSD-3-Clause (see LICENSE in the root directory of this source tree) *)
  (**
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (**
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
*/
//# sourceMappingURL=index.js.map
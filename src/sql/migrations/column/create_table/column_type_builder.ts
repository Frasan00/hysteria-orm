import { HysteriaError } from "../../../../errors/hysteria_error";
import logger from "../../../../utils/logger";
import type { SqlDataSourceType } from "../../../sql_data_source_types";
import { ColumnBuilder } from "./column_builder";

export type DateOptions = {
  autoCreate?: boolean;
  autoUpdate?: boolean;
  timezone?: string;
};

export interface ColumnConstraints {
  nullable(): ColumnConstraints;
  default(value: string | number | boolean): ColumnConstraints;
  unsigned(): ColumnConstraints;
  notNullable(): ColumnConstraints;
  primary(): ColumnConstraints;
  unique(): ColumnConstraints;
  autoIncrement(): ColumnConstraints;
  references(
    table: string,
    column: string,
    options?: { onDelete: string; onUpdate: string },
  ): ColumnConstraints;
}

export interface IColumnTypeBuilder {
  string(name: string, length?: number): ColumnConstraints;
  varchar(name: string, length?: number): ColumnConstraints;
  uuid(name: string): ColumnConstraints;
  autoGeneratedUUID(name: string): ColumnConstraints;
  tinytext(name: string): ColumnConstraints;
  mediumtext(name: string): ColumnConstraints;
  longtext(name: string): ColumnConstraints;
  binary(name: string, length?: number): ColumnConstraints;
  enum(name: string, values: string[]): ColumnConstraints;
  text(name: string): ColumnConstraints;
  char(name: string, length?: number): ColumnConstraints;
  tinyint(name: string): ColumnConstraints;
  smallint(name: string): ColumnConstraints;
  mediumint(name: string): ColumnConstraints;
  serial(name: string): ColumnConstraints;
  bigSerial(name: string): ColumnConstraints;
  integer(name: string, length?: number): ColumnConstraints;
  bigInteger(name: string): ColumnConstraints;
  int(name: string): ColumnConstraints;
  bigint(name: string): ColumnConstraints;
  float(
    name: string,
    options?: { precision: number; scale: number },
  ): ColumnConstraints;
  decimal(
    name: string,
    options?: { precision: number; scale: number },
  ): ColumnConstraints;
  double(
    name: string,
    options?: { precision: number; scale: number },
  ): ColumnConstraints;
  boolean(name: string): ColumnConstraints;
  date(
    name: string,
    options?: Omit<DateOptions, "timezone">,
  ): ColumnConstraints;
  timestamp(name: string, options?: DateOptions): ColumnConstraints;
  jsonb(name: string): ColumnConstraints;
}

class ColumnConstraintsBuilder implements ColumnConstraints {
  constructor(private builder: ColumnTypeBuilder) {}

  nullable(): ColumnConstraints {
    this.builder.appendToQuery(" NULL");
    return this;
  }

  default(value: string | number | boolean | null): ColumnConstraints {
    if (value === null) {
      value = "NULL";
    }

    this.builder.appendToQuery(` DEFAULT ${value}`);
    return this;
  }

  unsigned(): ColumnConstraints {
    this.builder.appendToQuery(" UNSIGNED");
    return this;
  }

  notNullable(): ColumnConstraints {
    this.builder.appendToQuery(" NOT NULL");
    return this;
  }

  primary(): ColumnConstraints {
    switch (this.builder.getSqlType()) {
      case "mysql":
      case "mariadb":
      case "postgres":
      case "cockroachdb":
      case "sqlite":
        this.builder.appendToQuery(" PRIMARY KEY");
        return this;
      default:
        throw new HysteriaError(
          "ColumnConstraintsBuilder::primary",
          `UNSUPPORTED_DATABASE_TYPE_${this.builder.getSqlType()}`,
        );
    }
  }

  unique(): ColumnConstraints {
    this.builder.appendToQuery(" UNIQUE");
    return this;
  }

  autoIncrement(): ColumnConstraints {
    switch (this.builder.getSqlType()) {
      case "mysql":
      case "mariadb":
        this.builder.appendToQuery(" AUTO_INCREMENT");
        return this;
      case "postgres":
      case "cockroachdb":
        throw new HysteriaError(
          "ColumnConstraintsBuilder::autoIncrement",
          "NOT_SUPPORTED_IN_POSTGRESQL",
        );
      case "sqlite":
        throw new HysteriaError(
          "ColumnConstraintsBuilder::autoIncrement",
          "NOT_SUPPORTED_IN_SQLITE",
        );
      default:
        throw new HysteriaError(
          "ColumnConstraintsBuilder::autoIncrement",
          `UNSUPPORTED_DATABASE_TYPE_${this.builder.getSqlType()}`,
        );
    }
  }

  references(
    table: string,
    column: string,
    options?: { onDelete: string; onUpdate: string },
  ): ColumnConstraints {
    this.builder.references(table, column, options);
    return this;
  }
}

export default class ColumnTypeBuilder
  extends ColumnBuilder
  implements IColumnTypeBuilder
{
  private constraintsBuilder: ColumnConstraintsBuilder;

  constructor(
    table: string,
    queryStatements: string[],
    afterDefinitionQueries: string[],
    partialQuery: string,
    sqlType: SqlDataSourceType,
  ) {
    super(
      table,
      queryStatements,
      afterDefinitionQueries,
      partialQuery,
      sqlType,
    );
    this.constraintsBuilder = new ColumnConstraintsBuilder(this);
  }

  public getSqlType(): SqlDataSourceType {
    return this.sqlType;
  }

  public appendToQuery(text: string): void {
    this.partialQuery += text;
  }

  public references(
    table: string,
    column: string,
    options?: { onDelete: string; onUpdate: string },
  ): void {
    this.columnReferences?.push({
      localColumn: this.columnName,
      table,
      column,
      onDelete: options?.onDelete,
      onUpdate: options?.onUpdate,
    });
  }

  // Types
  string(name: string, length: number = 255): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` VARCHAR(${length})`;
        break;

      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" VARCHAR(${length})`;
        break;

      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::string",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @alias string
   */
  varchar(name: string, length: number = 255): ColumnConstraints {
    this.checkLastComma();
    return this.string(name, length);
  }

  /**
   * @description Generates a UUID
   */
  uuid(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "postgres":
      case "cockroachdb":
        this.queryStatements.push(
          `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`,
        );

        this.columnName = name;
        this.partialQuery += ` "${name}" UUID`;
        break;
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` CHAR(36)`;
        break;
      case "sqlite":
        logger.warn("sqlite does not support UUID, using text instead");
        this.columnName = name;
        this.partialQuery += ` ${name} TEXT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::uuid",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @description Generates a UUID using the database's built-in function
   * @mysql It's suggested to not use this nut use regular uuid() function and use beforeInsert hook in the model to generate an uuid at runtime
   */
  autoGeneratedUUID(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "postgres":
      case "cockroachdb":
        this.queryStatements.push(
          `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`,
        );

        this.columnName = name;
        this.partialQuery += ` "${name}" UUID DEFAULT uuid_generate_v4()`;
        break;
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` CHAR(36) DEFAULT (UUID())`;
        break;
      case "sqlite":
        logger.warn("sqlite does not support UUID, using text instead");
        this.columnName = name;
        this.partialQuery += ` ${name} TEXT DEFAULT (hex(randomblob(16)))`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::autoGeneratedUUID",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  tinytext(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` TINYTEXT`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::tinytext",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  mediumtext(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` MEDIUMTEXT`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::mediumtext",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  longtext(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` LONGTEXT`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::longtext",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @description Creates a binary column
   * @postgres Length has no effect on postgres
   */
  binary(name: string, length: number = 255): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` BINARY(${length})`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" BYTEA`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" BLOB(${length})`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::binary",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  enum(name: string, values: string[]): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` ENUM('${values.join("', '")}')`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT CHECK(${name} IN ('${values.join(
          "', '",
        )}'))`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" VARCHAR(255) CHECK(${name} IN ('${values.join(
          "', '",
        )}'))`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::enum",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  text(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` TEXT`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::text",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  char(name: string, length: number = 255): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` CHAR(${length})`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" CHAR(${length})`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" CHAR(${length})`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::char",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @description Creates an array column
   * @description Only supported in postgres
   */
  array(name: string, type: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" TEXT[]`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::array",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  tinyint(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` TINYINT`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" SMALLINT`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" TINYINT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::tinyint",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  smallint(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` SMALLINT`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" SMALLINT`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" SMALLINT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::smallint",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  mediumint(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` MEDIUMINT`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" INTEGER`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" MEDIUMINT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::mediumint",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @description If using mysql, it will automatically add INT AUTO_INCREMENT
   * @description If using sqlite, it will automatically be converted in INTEGER PRIMARY KEY AUTO-INCREMENT because an auto-increment column cannot not be a primary key in sqlite
   */
  serial(name: string): ColumnConstraints {
    this.checkLastComma();
    if (this.sqlType === `mysql` || this.sqlType === `mariadb`) {
      this.columnName = name;
      this.partialQuery += ` \`${name}\` INT AUTO_INCREMENT`;
      return this.constraintsBuilder;
    }

    if (this.sqlType === `sqlite`) {
      this.columnName = name;
      this.partialQuery += ` "${name}" INTEGER PRIMARY KEY AUTOINCREMENT`;
      return this.constraintsBuilder;
    }

    this.columnName = name;
    this.partialQuery += ` "${name}" SERIAL`;
    return this.constraintsBuilder;
  }

  /**
   * @description If using mysql, it will automatically be converted in BIGINT AUTO_INCREMENT
   * @description If using sqlite, it will automatically be converted in INTEGER PRIMARY KEY AUTO-INCREMENT because an auto-increment column cannot not be a primary key in sqlite
   */
  bigSerial(name: string): ColumnConstraints {
    this.checkLastComma();
    if (this.sqlType === `mysql` || this.sqlType === `mariadb`) {
      this.columnName = name;
      this.partialQuery += ` \`${name}\` BIGINT AUTO_INCREMENT`;
      return this.constraintsBuilder;
    }

    if (this.sqlType === `sqlite`) {
      this.columnName = name;
      this.partialQuery += ` "${name}" INTEGER PRIMARY KEY AUTOINCREMENT`;
      return this.constraintsBuilder;
    }

    this.columnName = name;
    this.partialQuery += ` "${name}" BIGSERIAL`;
    return this.constraintsBuilder;
  }

  integer(name: string, length?: number): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` INT ${length ? `(${length})` : ""}`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" INTEGER ${length ? `(${length})` : ""}`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" INTEGER ${length ? `(${length})` : ""}`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::integer",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  bigInteger(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` BIGINT`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" BIGINT`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" BIGINT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::bigInteger",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @description Alias for integer
   * @returns ColumnOptionsBuilder
   */
  int(name: string): ColumnConstraints {
    this.checkLastComma();
    return this.integer(name);
  }

  /**
   * @description Alias for bigInteger
   * @returns ColumnOptionsBuilder
   */
  bigint(name: string): ColumnConstraints {
    this.checkLastComma();
    return this.bigInteger(name);
  }

  /**
   * @description Creates a float column
   * @description Precision and scale are only for mysql
   */
  float(
    name: string,
    options: {
      precision: number;
      scale: number;
    } = {
      precision: 10,
      scale: 2,
    },
  ): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` FLOAT(${options.precision}, ${options.scale})`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" REAL`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" REAL`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::float",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  decimal(
    name: string,
    options: {
      precision: number;
      scale: number;
    } = {
      precision: 10,
      scale: 2,
    },
  ): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` DECIMAL(${options.precision}, ${options.scale})`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" DECIMAL(${options.precision}, ${options.scale})`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" DECIMAL(${options.precision}, ${options.scale})`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::decimal",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @description Creates a double column
   * @description Precision and scale are only for mysql
   */
  double(
    name: string,
    options: {
      precision: number;
      scale: number;
    } = {
      precision: 10,
      scale: 2,
    },
  ): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` DOUBLE(${options.precision}, ${options.scale})`;
        break;
      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" DOUBLE PRECISION`;
        break;
      case "sqlite":
        this.columnName = name;
        this.partialQuery += ` "${name}" REAL`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::double",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @description Adds a boolean column to the database
   * @sqlite Sqlite does not support boolean columns directly, INTEGER CHECK between 0 and 1 will be used instead
   */
  boolean(name: string): ColumnConstraints {
    this.checkLastComma();
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.columnName = name;
        this.partialQuery += ` \`${name}\` BOOLEAN`;
        break;

      case "postgres":
      case "cockroachdb":
        this.columnName = name;
        this.partialQuery += ` "${name}" BOOLEAN`;
        break;
      case "sqlite":
        logger.warn(
          "sqlite does not support boolean columns, using integer instead",
        );
        this.columnName = name;
        this.partialQuery += ` ${name} INTEGER CHECK(${name} IN (0, 1))`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::boolean",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  /**
   * @description Creates a date column
   * @sqlite Sqlite does not support auto updating a timestamp column nor date columns in general, TEXT will be used instead
   */
  date(
    name: string,
    options?: Omit<DateOptions, "timezone">,
  ): ColumnConstraints {
    this.checkLastComma();
    if (this.sqlType === "sqlite") {
      logger.warn("sqlite does not support date columns, using text instead");

      this.columnName = name;
      this.partialQuery += ` ${name} TEXT`;
      if (options && options.autoCreate) {
        this.partialQuery += "  DEFAULT CURRENT_DATE";
      }

      if (options && options.autoUpdate) {
        throw new HysteriaError(
          "ColumnTypeBuilder::date",
          "NOT_SUPPORTED_IN_SQLITE",
        );
      }

      return this.constraintsBuilder;
    }

    this.columnName = name;
    this.partialQuery += ` ${name} DATE`;

    if (options && options.autoCreate) {
      this.partialQuery += "  DEFAULT CURRENT_DATE";
    }

    if (options && options.autoUpdate) {
      switch (this.sqlType) {
        case "postgres":
        case "cockroachdb":
          this.afterDefinitionQueries.push(
            `CREATE OR REPLACE FUNCTION update_date_column() RETURNS TRIGGER AS $$
            BEGIN
              NEW.${name} = now();
              RETURN NEW;
            END;
            $$ language 'plpgsql';`,
          );
          break;
        default:
          this.partialQuery += "  ON UPDATE CURRENT_TIMESTAMP";
      }
    }

    return this.constraintsBuilder;
  }

  /**
   * @description Creates a timestamp column
   * @sqlite Sqlite does not support auto updating a timestamp column nor date columns in general, TEXT will be used instead
   */
  timestamp(name: string, options?: DateOptions): ColumnConstraints {
    this.checkLastComma();
    if (this.sqlType === "sqlite") {
      logger.warn(
        "sqlite does not support timestamp columns, using text instead",
      );

      this.columnName = name;
      this.partialQuery += ` ${name} TEXT`;
      if (options && options.autoCreate) {
        this.partialQuery += "  DEFAULT CURRENT_TIMESTAMP";
      }

      if (options && options.autoUpdate) {
        throw new HysteriaError(
          "ColumnTypeBuilder::timestamp",
          "NOT_SUPPORTED_IN_SQLITE",
        );
      }

      if (options && options.timezone) {
        this.partialQuery += ` ${options.timezone}`;
      }

      return this.constraintsBuilder;
    }

    this.columnName = name;
    this.partialQuery += ` ${name} TIMESTAMP`;
    if (options && options.autoCreate) {
      this.partialQuery += "  DEFAULT CURRENT_TIMESTAMP";
    }

    if (options && options.autoUpdate) {
      if (this.sqlType === "postgres" || this.sqlType === "cockroachdb") {
        this.afterDefinitionQueries.push(
          `CREATE OR REPLACE FUNCTION update_timestamp_column() RETURNS TRIGGER AS $$
          BEGIN
            NEW.${name} = now();
            RETURN NEW;
          END;
          $$ language 'plpgsql';`,
        );
      }

      if (this.sqlType === "mysql" || this.sqlType === "mariadb") {
        this.partialQuery += "  ON UPDATE CURRENT_TIMESTAMP";
      }
    }

    if (options && options.timezone) {
      this.partialQuery += ` ${options.timezone}`;
    }

    return this.constraintsBuilder;
  }

  /**
   * @description EXPERIMENTAL
   * @sqlite Sqlite does not support jsonb columns, TEXT will be used instead
   */
  jsonb(name: string): ColumnConstraints {
    this.checkLastComma();
    this.columnName = name;
    switch (this.sqlType) {
      case "postgres":
      case "cockroachdb":
        this.partialQuery += ` ${name} JSONB`;
        break;
      case "mariadb":
      case "mysql":
        this.partialQuery += ` ${name} JSON`;
        break;
      case "sqlite":
        logger.warn(
          "sqlite does not support jsonb columns, using text instead",
        );
        this.partialQuery += ` ${name} TEXT`;
        break;
      default:
        throw new HysteriaError(
          "ColumnTypeBuilder::jsonb",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    return this.constraintsBuilder;
  }

  private checkLastComma(): void {
    if (this.partialQuery.endsWith("(\n")) {
      return;
    }

    this.partialQuery = this.partialQuery.trim().replace(/,+$/, "");
    if (this.partialQuery && !this.partialQuery.endsWith("(\n")) {
      this.partialQuery += ", ";
    }
  }
}

import { HysteriaError } from "../../../../errors/hysteria_error";
import type { SqlDataSourceType } from "../../../sql_data_source_types";
import ColumnTypeBuilder, {
  DateOptions,
} from "../create_table/column_type_builder";

type References = {
  table: string;
  column: string;
  onDelete?: string;
  onUpdate?: string;
};

type AlterOptions = {
  afterColumn?: string;
  references?: References;
};

type DataType =
  | "uuid"
  | "autoGeneratedUUID"
  | "varchar"
  | "tinytext"
  | "mediumtext"
  | "longtext"
  | "binary"
  | "text"
  | "char"
  | "tinyint"
  | "smallint"
  | "mediumint"
  | "integer"
  | "bigint"
  | "float"
  | "decimal"
  | "double"
  | "boolean"
  | "jsonb";

type BaseOptions = {
  /**
   * @description The column to add the new column after
   * @postgres does not support afterColumn and throw an error
   * @sqlite does not support afterColumn and throw an error
   */
  afterColumn?: string;
  references?: References;
  precision?: number;
  scale?: number;
  default?: any;
  primaryKey?: boolean;
  unique?: boolean;
  notNullable?: boolean;
  autoIncrement?: boolean;
  length?: number;
};

export default class ColumnBuilderAlter {
  protected table: string;
  protected queryStatements: string[];
  protected sqlType: SqlDataSourceType;
  protected partialQuery: string;

  constructor(
    table: string,
    queryStatements: string[],
    partialQuery: string,
    sqlType: SqlDataSourceType,
  ) {
    this.table = table;
    this.queryStatements = queryStatements;
    this.partialQuery = partialQuery;
    this.sqlType = sqlType;
  }

  /**
   * @description Add a new column to the table
   */
  addColumn(
    columnName: string,
    dataType: DataType,
    options?: BaseOptions,
  ): ColumnBuilderAlter {
    let query = `ALTER TABLE ${this.table} ADD COLUMN `;
    const columnsBuilder = new ColumnTypeBuilder("", [], [], "", this.sqlType);
    switch (dataType) {
      case "uuid":
        columnsBuilder.uuid(columnName);
        break;
      case "autoGeneratedUUID":
        columnsBuilder.autoGeneratedUUID(columnName);
        break;
      case "varchar":
        columnsBuilder.varchar(columnName, options?.length);
        break;
      case "tinytext":
        columnsBuilder.tinytext(columnName);
        break;
      case "mediumtext":
        columnsBuilder.mediumtext(columnName);
        break;
      case "longtext":
        columnsBuilder.longtext(columnName);
        break;
      case "binary":
        columnsBuilder.binary(columnName, options?.length);
        break;
      case "text":
        columnsBuilder.text(columnName);
        break;
      case "char":
        columnsBuilder.char(columnName, options?.length);
        break;
      case "tinyint":
        columnsBuilder.tinyint(columnName);
        break;
      case "smallint":
        columnsBuilder.smallint(columnName);
        break;
      case "mediumint":
        columnsBuilder.mediumint(columnName);
        break;
      case "integer":
        columnsBuilder.integer(columnName, options?.length);
        break;
      case "bigint":
        columnsBuilder.bigint(columnName);
        break;
      case "float":
        const { precision: floatPrecision = 10, scale: floatScale = 2 } =
          options || {};
        columnsBuilder.float(columnName, {
          precision: floatPrecision,
          scale: floatScale,
        });
        break;
      case "decimal":
        const { precision = 10, scale = 2 } = options || {};
        columnsBuilder.decimal(columnName, {
          precision: precision,
          scale: scale,
        });
        break;
      case "double":
        const { precision: doublePrecision = 10, scale: doubleScale = 2 } =
          options || {};
        columnsBuilder.double(columnName, {
          precision: doublePrecision,
          scale: doubleScale,
        });
        break;
      case "boolean":
        columnsBuilder.boolean(columnName);
        break;
      case "jsonb":
        columnsBuilder.jsonb(columnName);
        break;
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::addColumn",
          `UNSUPPORTED_DATA_TYPE_${dataType}`,
        );
    }

    query += columnsBuilder.partialQuery;

    if (options?.default !== undefined) {
      if (typeof options.default === "string") {
        query += ` DEFAULT '${options.default}'`;
      } else if (options.default instanceof Date) {
        query += ` DEFAULT '${options.default.toISOString()}'`;
      } else if (typeof options.default === "object") {
        query += ` DEFAULT '${JSON.stringify(options.default)}'`;
      } else if (typeof options.default === null) {
        query += " DEFAULT NULL";
      } else {
        query += ` DEFAULT ${options.default}`;
      }
    }

    if (options?.primaryKey) {
      query += " PRIMARY KEY";
    }

    if (options?.unique) {
      query += " UNIQUE";
    }

    if (options?.references) {
      query += ` REFERENCES ${options.references.table}(${
        options.references.column
      }) ON DELETE ${options.references.onDelete || "NO ACTION"} ON UPDATE ${
        options.references.onUpdate || "NO ACTION"
      }`;
    }

    if (options?.afterColumn) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          query += ` AFTER ${options.afterColumn}`;
          break;
        case "postgres":
          throw new HysteriaError(
            "ColumnBuilderAlter::addColumn::afterColumn",
            "NOT_SUPPORTED_IN_POSTGRES",
          );
        case "sqlite":
          throw new HysteriaError(
            "ColumnBuilderAlter::addColumn::afterColumn",
            "NOT_SUPPORTED_IN_SQLITE",
          );
        default:
          throw new HysteriaError(
            "ColumnBuilderAlter::addColumn",
            `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
          );
      }
    }

    this.partialQuery = query;
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Add a new date column to the table
   */
  addDateColumn(
    columnName: string,
    type: "date" | "timestamp",
    options?: DateOptions & {
      afterColumn?: string;
      notNullable?: boolean;
      default?: string | Date;
    },
  ): ColumnBuilderAlter {
    let query = `ALTER TABLE ${this.table} ADD COLUMN ${columnName} ${type}`;
    if (options?.autoCreate) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          query += " DEFAULT CURRENT_TIMESTAMP";
          break;
        case "postgres":
          query += " DEFAULT CURRENT_TIMESTAMP";
          break;
        case "sqlite":
          query += " DEFAULT CURRENT_TIMESTAMP";
          break;
        default:
          throw new HysteriaError(
            "ColumnBuilderAlter::addDateColumn",
            `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
          );
      }
    }

    if (options?.autoUpdate) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          query += " ON UPDATE CURRENT_TIMESTAMP";
          break;
        case "postgres":
          query += " ON UPDATE CURRENT_TIMESTAMP";
          break;
        case "sqlite":
          query += " ON UPDATE CURRENT_TIMESTAMP";
          break;
        default:
          throw new HysteriaError(
            "ColumnBuilderAlter::addDateColumn",
            `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
          );
      }
    }

    if (options?.notNullable) {
      query += " NOT NULL";
    }

    if (options?.default !== undefined) {
      if (typeof options.default === "string") {
        query += ` DEFAULT '${options.default}'`;
      } else if (options.default instanceof Date) {
        query += ` DEFAULT '${options.default.toISOString()}'`;
      } else {
        throw new HysteriaError(
          "ColumnBuilderAlter::addDateColumn::default",
          "INVALID_DEFAULT_VALUE",
        );
      }
    }

    if (options?.afterColumn) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          query += ` AFTER ${options.afterColumn}`;
          break;
        case "postgres":
          throw new HysteriaError(
            "ColumnBuilderAlter::addDateColumn::afterColumn",
            "NOT_SUPPORTED_IN_POSTGRES",
          );
        case "sqlite":
          throw new HysteriaError(
            "ColumnBuilderAlter::addDateColumn::afterColumn",
            "NOT_SUPPORTED_IN_SQLITE",
          );
        default:
          throw new HysteriaError(
            "ColumnBuilderAlter::addDateColumn::afterColumn",
            `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
          );
      }
    }

    this.partialQuery = query;
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Add a new enum column to the table
   */
  addEnumColumn(
    columnName: string,
    values: string[],
    options?: {
      afterColumn?: string;
      notNullable?: boolean;
      default?: string;
      unique?: boolean;
    },
  ): ColumnBuilderAlter {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        const parsedValues = values.map((value) => {
          if (typeof value === "number") {
            return value;
          } else if (typeof value === "boolean") {
            return value ? 1 : 0;
          } else if (typeof value === "string") {
            return `'${value}'`;
          }
        });
        this.partialQuery = `ALTER TABLE ${
          this.table
        } ADD COLUMN ${columnName} ENUM(${parsedValues.join(", ")})`;
        break;
      case "postgres":
        const enumTypeName = `${this.table}_${columnName}_enum`;
        const parsedValuesPg = values.map((value) => {
          if (typeof value === "number") {
            return value;
          } else if (typeof value === "boolean") {
            return value ? 1 : 0;
          } else if (typeof value === "string") {
            return `'${value}'`;
          }
        });
        this.partialQuery = `
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = '${enumTypeName}') THEN
    CREATE TYPE ${enumTypeName} AS ENUM(${parsedValuesPg.join(", ")});
  END IF;
END $$;
ALTER TABLE ${this.table} ADD COLUMN ${columnName} ${enumTypeName}
      `;
        break;
      case "sqlite":
        const parsedValuesSqlite = values.map((value) => {
          if (typeof value === "number") {
            return value;
          } else if (typeof value === "boolean") {
            return value ? 1 : 0;
          } else if (typeof value === "string") {
            return `'${value}'`;
          }
        });
        this.partialQuery = `ALTER TABLE ${
          this.table
        } ADD COLUMN ${columnName} TEXT ${
          options?.notNullable ? "NOT NULL" : ""
        } DEFAULT ${
          options?.default ? `'${options.default}'` : "NULL"
        } CHECK (${columnName} IN (${parsedValuesSqlite.join(", ")}))`;
        break;
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::addEnumColumn",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    if (options?.notNullable && this.sqlType !== "sqlite") {
      this.partialQuery += " NOT NULL";
    }

    if (options?.default && this.sqlType !== "sqlite") {
      this.partialQuery += ` DEFAULT '${options.default}'`;
    }

    if (options?.unique) {
      this.partialQuery += " UNIQUE";
    }

    if (options?.afterColumn) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          this.partialQuery += ` AFTER ${options.afterColumn}`;
          break;
        case "postgres":
          throw new HysteriaError(
            "ColumnBuilderAlter::addEnumColumn::afterColumn",
            "NOT_SUPPORTED_IN_POSTGRES",
          );
        case "sqlite":
          throw new HysteriaError(
            "ColumnBuilderAlter::addEnumColumn::afterColumn",
            "NOT_SUPPORTED_IN_SQLITE",
          );
        default:
          throw new HysteriaError(
            "ColumnBuilderAlter::addEnumColumn",
            `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
          );
      }
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Drops a column from the table
   */
  dropColumn(columnName: string): ColumnBuilderAlter {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} DROP COLUMN ${columnName}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} DROP COLUMN ${columnName}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} DROP COLUMN ${columnName}`;
        break;
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::dropColumn",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Renames a column
   * @sqlite does not support renaming columns, will throw an error
   */
  renameColumn(
    oldColumnName: string,
    newColumnName: string,
  ): ColumnBuilderAlter {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} RENAME COLUMN \`${oldColumnName}\` TO \`${newColumnName}\``;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} RENAME COLUMN ${oldColumnName} TO ${newColumnName}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} RENAME COLUMN \`${oldColumnName}\` TO \`${newColumnName}\``;
        break;
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::renameColumn",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  modifyColumnType(
    columnName: string,
    newDataType: string,
    options?: BaseOptions,
  ): ColumnBuilderAlter {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${
          this.table
        } MODIFY COLUMN ${columnName} ${newDataType}${
          options && options.length ? `(${options.length})` : ""
        }`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${
          this.table
        } ALTER COLUMN ${columnName} TYPE ${newDataType}${
          options && options.length ? `(${options.length})` : ""
        }`;
        break;
      case "sqlite":
        throw new HysteriaError(
          "ColumnBuilderAlter::modifyColumnType",
          "NOT_SUPPORTED_IN_SQLITE",
        );
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::modifyColumnType",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    if (options?.notNullable) {
      this.partialQuery += " NOT NULL";
    }

    if (options?.default !== undefined) {
      this.partialQuery += ` DEFAULT ${options.default}`;
    }

    if (options?.primaryKey) {
      this.partialQuery += " PRIMARY KEY";
    }

    if (options?.unique) {
      this.partialQuery += " UNIQUE";
    }

    if (options?.references) {
      this.partialQuery += ` REFERENCES ${options.references.table}(${
        options.references.column
      }) ON DELETE ${options.references.onDelete || "NO ACTION"} ON UPDATE ${
        options.references.onUpdate || "NO ACTION"
      }`;
    }

    if (options?.afterColumn) {
      switch (this.sqlType) {
        case "mariadb":
        case "mysql":
          this.partialQuery += ` AFTER ${options.afterColumn}`;
          break;
        case "postgres":
          throw new HysteriaError(
            "ColumnBuilderAlter::modifyColumnType::afterColumn",
            "NOT_SUPPORTED_IN_POSTGRES",
          );
        default:
          throw new HysteriaError(
            "ColumnBuilderAlter::modifyColumnType",
            `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
          );
      }
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Renames a table
   */
  renameTable(oldtable: string, newtable: string): ColumnBuilderAlter {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `RENAME TABLE ${oldtable} TO ${newtable}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${oldtable} RENAME TO ${newtable}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${oldtable} RENAME TO ${newtable}`;
        break;
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::renameTable",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Set a default value
   * @sqlite Sqlite does not support alter table default values
   */
  setDefaultValue(
    columnName: string,
    defaultValue: string | number | boolean | null,
  ): ColumnBuilderAlter {
    if (defaultValue === null) {
      defaultValue = "NULL";
    }

    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} SET DEFAULT ${defaultValue}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} SET DEFAULT ${defaultValue}`;
        break;
      case "sqlite":
        throw new HysteriaError(
          "ColumnBuilderAlter::setDefaultValue",
          "NOT_SUPPORTED_IN_SQLITE",
        );
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::setDefaultValue",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Drop a default value
   */
  dropDefaultValue(columnName: string): ColumnBuilderAlter {
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} DROP DEFAULT`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} ALTER COLUMN ${columnName} DROP DEFAULT`;
        break;
      case "sqlite":
        throw new HysteriaError(
          "ColumnBuilderAlter::dropDefaultValue",
          "NOT_SUPPORTED_IN_SQLITE",
        );
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::dropDefaultValue",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Add a foreign key
   */
  addForeignKey(columnName: string, options: AlterOptions): ColumnBuilderAlter {
    if (!options.references) {
      throw new HysteriaError(
        "ColumnBuilderAlter::addForeignKey",
        "REFERENCES_OPTION_REQUIRED",
      );
    }

    const fkName = `${this.table}_${columnName}_fk`;
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${
          this.table
        } ADD CONSTRAINT ${fkName} FOREIGN KEY (${columnName}) REFERENCES ${
          options.references.table
        }(${options.references.column}) ON DELETE ${
          options.references.onDelete || "NO ACTION"
        } ON UPDATE ${options.references.onUpdate || "NO ACTION"}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${
          this.table
        } ADD CONSTRAINT ${fkName} FOREIGN KEY (${columnName}) REFERENCES ${
          options.references.table
        }(${options.references.column}) ON DELETE ${
          options.references.onDelete || "NO ACTION"
        } ON UPDATE ${options.references.onUpdate || "NO ACTION"}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${
          this.table
        } ADD CONSTRAINT ${fkName} FOREIGN KEY (${columnName}) REFERENCES ${
          options.references.table
        }(${options.references.column}) ON DELETE ${
          options.references.onDelete || "NO ACTION"
        } ON UPDATE ${options.references.onUpdate || "NO ACTION"}`;
        break;
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::addForeignKey",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @description Drop a foreign key
   */
  dropForeignKey(columnName: string): ColumnBuilderAlter {
    const fkName = `${this.table}_${columnName}_fk`;
    switch (this.sqlType) {
      case "mariadb":
      case "mysql":
        this.partialQuery = `ALTER TABLE ${this.table} DROP FOREIGN KEY ${fkName}`;
        break;
      case "postgres":
        this.partialQuery = `ALTER TABLE ${this.table} DROP CONSTRAINT ${fkName}`;
        break;
      case "sqlite":
        this.partialQuery = `ALTER TABLE ${this.table} DROP CONSTRAINT ${fkName}`;
        break;
      default:
        throw new HysteriaError(
          "ColumnBuilderAlter::dropForeignKey",
          `UNSUPPORTED_DATABASE_TYPE_${this.sqlType}`,
        );
    }

    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
    return this;
  }

  /**
   * @internal
   */
  commit(): void {
    this.queryStatements.push(this.partialQuery);
    this.partialQuery = "";
  }
}

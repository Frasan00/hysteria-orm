import { ModelManager } from "./model_manager/model_manager";
import type {
  FindOneType,
  FindReturnType,
  FindType,
  InsertOptions,
  ModelKey,
  ModelRelation,
  OnlyM2MRelations,
  UnrestrictedFindOneType,
  UnrestrictedFindType,
  UpsertOptions,
  WhereType,
} from "./model_manager/model_manager_types";
import type { ModelQueryBuilder } from "./model_query_builder/model_query_builder";
import type {
  BaseModelMethodOptions,
  ModelWithoutRelations,
} from "./model_types";

import { Entity } from "../../entity";
import { HysteriaError } from "../../errors/hysteria_error";
import { CaseConvention, convertCase } from "../../utils/case_utils";
import { baseSoftDeleteDate } from "../../utils/date_utils";
import { DryModelQueryBuilderWithoutReadOperations } from "../query_builder/query_builder_types";
import type {
  TableColumnInfo,
  TableIndexInfo,
  TableSchemaInfo,
} from "../schema_introspection_types";
import { serializeModel } from "../serializer";
import { SqlDataSource } from "../sql_data_source";
import { databasesWithReturning } from "../sql_runner/sql_runner_constants";
import {
  belongsTo,
  column,
  getIndexes,
  getModelColumns,
  getPrimaryKey,
  getRelations,
  getRelationsMetadata,
  getUniques,
  hasMany,
  hasOne,
  manyToMany,
} from "./decorators/model_decorators";
import {
  ColumnType,
  IndexType,
  LazyRelationType,
  UniqueType,
} from "./decorators/model_decorators_types";
import { AnnotatedModel } from "./model_query_builder/model_query_builder_types";
import { getBaseTableName } from "./model_utils";
import { ManyToMany } from "./relations/many_to_many";
import { RelationEnum } from "./relations/relation";

/**
 * @description Represents a Table in the Database
 */
export abstract class Model extends Entity {
  declare private "*": string;

  /**
   * @description The column used to soft delete a record, default is deletedAt
   */
  static softDeleteColumn = "deletedAt";

  /**
   * @description The value used to soft delete a record, default is the current date and time
   * @default format: "YYYY-MM-DD HH:mm:ss" in UTC timezone
   */
  static softDeleteValue: boolean | string = baseSoftDeleteDate();

  /**
   * @description The sql sqlInstance generated by SqlDataSource.connect
   */
  static sqlInstance: SqlDataSource;

  /**
   * @description Getter for the table name of the model
   */
  static get table(): string {
    const descriptor = Object.getOwnPropertyDescriptor(this, "table");
    if (descriptor && "value" in descriptor) {
      return descriptor.value;
    }

    return getBaseTableName(this);
  }

  /**
   * @description Setter for the table name of the model
   */
  static set table(value: string) {
    Object.defineProperty(this, "table", {
      value,
      writable: true,
      enumerable: true,
      configurable: true,
    });
  }

  /**
   * @description Getter for the primary key of the model
   */
  static get primaryKey(): string | undefined {
    return getPrimaryKey(this);
  }

  constructor() {
    super();
  }

  /**
   * @description Returns all the records for the given model
   */
  static async all<T extends Model>(
    this: new () => T | typeof Model,
    options: BaseModelMethodOptions = {},
  ): Promise<AnnotatedModel<T, {}>[]> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.find({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
    })) as AnnotatedModel<T, {}>[];
  }

  /**
   * @description Gives a query sqlInstance for the given model
   */
  static query<T extends Model>(
    this: new () => T | typeof Model,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): ModelQueryBuilder<T> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.query() as ModelQueryBuilder<T>;
  }

  /**
   * @description Returns a dry query builder instance
   * @description The dry query builder instance will not execute the query
   */
  static dryQuery<T extends Model>(
    this: new () => T | typeof Model,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): DryModelQueryBuilderWithoutReadOperations<T> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.dryQuery() as unknown as DryModelQueryBuilderWithoutReadOperations<T>;
  }

  /**
   * @description Finds the first record in the database
   * @deprecated Used only for debugging purposes, use findOne or query instead
   */
  static async first<T extends Model>(
    this: new () => T | typeof Model,
    options?: BaseModelMethodOptions,
  ): Promise<AnnotatedModel<T, {}> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.query().one({
      ignoreHooks: options?.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
    });
  }

  /**
   * @description Finds records for the given model
   */
  static async find<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    findOptions?: FindType<T, S, R> | UnrestrictedFindType<T, S, R>,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<FindReturnType<T, S, R>[]> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.find(
      findOptions as FindType<T, S, R>,
    )) as FindReturnType<T, S, R>[];
  }

  /**
   * @description Finds a record for the given model or throws an error if it doesn't exist
   */
  static async findOneOrFail<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    findOneOptions: (
      | FindOneType<T, S, R>
      | UnrestrictedFindOneType<T, S, R>
    ) & {
      customError?: Error;
    },
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<FindReturnType<T, S, R>> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.findOneOrFail(
      findOneOptions as FindOneType<T, S, R>,
    )) as FindReturnType<T, S, R>;
  }

  /**
   * @description Finds a record for the given model
   */
  static async findOne<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    findOneOptions: (FindOneType<T, S, R> | UnrestrictedFindOneType<T, S, R>) &
      BaseModelMethodOptions,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<FindReturnType<T, S, R> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.findOne(
      findOneOptions as FindOneType<T, S, R>,
    )) as FindReturnType<T, S, R> | null;
  }

  /**
   * @description Finds records for the given column and value
   */
  static async findBy<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    column: ModelKey<T>,
    value: string | number | boolean | Date | null,
    options: BaseModelMethodOptions = {},
  ): Promise<FindReturnType<T, S, R>[]> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.find({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
      where: {
        [column as unknown as keyof T]: value as T[keyof T],
      } as WhereType<T>,
    })) as FindReturnType<T, S, R>[];
  }

  /**
   * @description Finds the first record for the given column and value
   */
  static async findOneBy<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    column: ModelKey<T>,
    value: string | number | boolean | Date | null,
    options: BaseModelMethodOptions = {},
  ): Promise<FindReturnType<T, S, R> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.findOne({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
      where: {
        [column as keyof T]: value as T[keyof T],
      } as WhereType<T>,
    })) as FindReturnType<T, S, R> | null;
  }

  /**
   * @description Finds a record for the given model for the given value, the model must have a primary key defined else it will throw an error
   */
  static async findOneByPrimaryKey<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    value: string | number,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ): Promise<FindReturnType<T, S, R> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.findOneByPrimaryKey(value)) as FindReturnType<
      T,
      S,
      R
    > | null;
  }

  /**
   * @description Refreshes a model from the database, the model must have a primary key defined
   */
  static async refresh<T extends Model>(
    this: new () => T | typeof Model,
    model: T,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ): Promise<AnnotatedModel<T, {}> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    const primaryKey = typeofModel.primaryKey as keyof T;
    const primaryKeyValue = model[primaryKey];
    const refreshedModel = await modelManager.findOneByPrimaryKey(
      primaryKeyValue as string,
    );
    if (!refreshedModel) {
      return null;
    }

    return refreshedModel;
  }

  /**
   * @description Saves a new record to the database
   * @description $annotations will be ignored if set in the modelData and won't be returned in the response
   * @warning If not using postgres and the model has no primary key, the model will be saved, but it won't be possible to retrieve it so at that point it will be returned as null, this is not typed as Model | null for type safety reasons
   * @mysql If no Primary Key is present in the model definition, the model will be returned
   * @sqlite If no Primary Key is present in the model definition, the model will be returned
   * @sqlite Returning Not supported and won't have effect
   */
  static async insert<T extends Model>(
    this: new () => T | typeof Model,
    modelData: Partial<ModelWithoutRelations<T>>,
    options: BaseModelMethodOptions & InsertOptions<T> = {},
  ): Promise<AnnotatedModel<T, {}>> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.insert(modelData as T, {
      ignoreHooks: options.ignoreHooks,
      returning: options.returning,
    });
  }

  /**
   * @description Saves multiple records to the database
   * @description $annotations will be ignored if set in the modelData and won't be returned in the response
   * @warning If not using postgres and the model has no primary key, the models will be saved, but it won't be possible to retrieve them so at that point they will be returned as an empty array
   * @mysql If no Primary Key is present in the model definition, the model will be returned
   * @sqlite If no Primary Key is present in the model definition, the model will be returned
   * @sqlite Returning Not supported and won't have effect
   */
  static async insertMany<T extends Model>(
    this: new () => T | typeof Model,
    modelsData: Partial<ModelWithoutRelations<T>>[],
    options: BaseModelMethodOptions & InsertOptions<T> = {},
  ): Promise<AnnotatedModel<T, {}>[]> {
    if (!modelsData.length) {
      return [];
    }

    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.insertMany(modelsData as T[], {
      ignoreHooks: options.ignoreHooks,
      returning: options.returning,
    });
  }

  /**
   * @description Syncs in the through table the given models for the given relation
   * @param relation The many to many relation to sync, this is not type safe since many to many relations defined at a decorator level
   * @param leftModel The source (left) model instance to synchronize in the many-to-many relation.
   * @param rightModels The target (right) model instances to associate with the left model in the join table.
   * @param joinTableCustomData Optional function that returns custom data for each join table row (receives rightModel and index)
   * @param options.caseConvention Optional. Controls naming convention for left/right foreign keys in the join table. Defaults to the left model's convention; set to `none` to disable.
   * @warning Use only when the join table contains no business logic beyond foreign keys. For business logic, define and use a dedicated join model.
   * @warning This method does not trigger hooks on the join table, even if a Model exists. Use the join model's `insertMany` for hook support.
   * @throws {HysteriaError} If the specified relation does not exist on the model.
   * @throws {HysteriaError} If the specified relation is not a many-to-many relation.
   */
  static async sync<T extends Model, R extends OnlyM2MRelations<T>>(
    this: new () => T | typeof Model,
    relation: R,
    leftModel: T,
    rightModels: T[R] extends any[] ? T[R] : T[R][],
    joinTableCustomData?: (
      rightModel: T[R] extends any[] ? T[R][number] : T[R],
      index: number,
    ) => Record<string, any>,
    options: BaseModelMethodOptions & { caseConvention?: CaseConvention } = {},
  ): Promise<void> {
    if (!Array.isArray(rightModels)) {
      rightModels = [rightModels] as T[R] extends any[] ? T[R] : T[R][];
    }

    if (!rightModels.length) {
      return;
    }

    const typeofModel = this as unknown as typeof Model;
    const modelRelations = getRelations(typeofModel);
    const m2mRelation = modelRelations.find(
      (r) => r.columnName === relation,
    ) as ManyToMany;

    if (!m2mRelation) {
      throw new HysteriaError(
        `${typeofModel.name}::sync`,
        "RELATION_NOT_FOUND",
      );
    }

    if (m2mRelation.type !== RelationEnum.manyToMany) {
      throw new HysteriaError(
        `${typeofModel.name}::sync`,
        "RELATION_NOT_MANY_TO_MANY",
      );
    }

    const casedLeftForeignKey = convertCase(
      m2mRelation.leftForeignKey,
      options.caseConvention || typeofModel.databaseCaseConvention,
    );

    const casedRightForeignKey = convertCase(
      m2mRelation.rightForeignKey,
      options.caseConvention || typeofModel.databaseCaseConvention,
    );

    const joinTableModelsToInsert = rightModels.map((rightModel, index) => ({
      [casedLeftForeignKey]: leftModel[typeofModel.primaryKey as keyof T],
      [casedRightForeignKey]:
        rightModel[m2mRelation.model.primaryKey as keyof T],
      ...(joinTableCustomData ? joinTableCustomData(rightModel, index) : {}),
    }));

    class ThroughModel extends Model {
      static databaseCaseConvention: CaseConvention = "preserve";
      static modelCaseConvention: CaseConvention = "preserve";

      static get table() {
        return m2mRelation.throughModel;
      }
    }

    const throughModelManager =
      ThroughModel.dispatchModelManager<InstanceType<typeof ThroughModel>>(
        options,
      );

    await throughModelManager.insertMany(joinTableModelsToInsert);
  }

  /**
   * @description Updates a record, returns the updated record
   * @description Model is retrieved from the database using the primary key regardless of any model hooks
   * @description Can only be used if the model has a primary key, use a massive update if the model has no primary key
   * @throws {HysteriaError} If the model has no primary key
   */
  static async updateRecord<T extends Model>(
    this: new () => T | typeof Model,
    modelSqlInstance: Partial<T>,
    updatePayload?: Partial<ModelWithoutRelations<T>>,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ): Promise<AnnotatedModel<T, {}>> {
    try {
      const typeofModel = this as unknown as typeof Model;
      const modelManager = typeofModel.dispatchModelManager<T>(options);
      updatePayload &&
        typeofModel.combineProps(modelSqlInstance, updatePayload as Partial<T>);
      const updatedModel = await modelManager.updateRecord(modelSqlInstance);
      return updatedModel;
    } catch (error) {
      if (
        error instanceof HysteriaError &&
        error.message === "MODEL_HAS_NO_PRIMARY_KEY"
      ) {
        throw new HysteriaError(
          `${this.name}::updateRecord`,
          "MODEL_HAS_NO_PRIMARY_KEY",
        );
      }

      throw error;
    }
  }

  /**
   * @description Finds the first record or creates a new one if it doesn't exist
   */
  static async firstOrInsert<T extends Model, O extends boolean = false>(
    this: new () => T | typeof Model,
    searchCriteria: Partial<ModelWithoutRelations<T>>,
    createData: Partial<ModelWithoutRelations<T>>,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> & {
      fullResponse?: O;
    } = {},
  ): Promise<
    O extends true
      ? {
          isNew: boolean;
          model: T;
        }
      : T
  > {
    if (!options.fullResponse) {
      options.fullResponse = false as O;
    }

    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    const doesExist = (await modelManager.findOne({
      where: searchCriteria as WhereType<T>,
    })) as T;

    if (doesExist) {
      if (options.fullResponse) {
        return {
          isNew: false,
          model: doesExist,
        } as O extends true ? { isNew: boolean; model: T } : T;
      }

      return doesExist as O extends true ? { isNew: boolean; model: T } : T;
    }

    const newModel = (await modelManager.insert(createData as T)) as T;
    if (options.fullResponse) {
      return {
        isNew: true,
        model: newModel,
      } as O extends true ? { isNew: boolean; model: T } : T;
    }

    return newModel as O extends true ? { isNew: boolean; model: T } : T;
  }

  /**
   * @description Updates or creates a new record
   */
  static async upsert<T extends Model>(
    this: new () => T | typeof Model,
    searchCriteria: Partial<ModelWithoutRelations<T>>,
    data: Partial<ModelWithoutRelations<T>>,
    options: UpsertOptions<T> & BaseModelMethodOptions = {
      updateOnConflict: true,
    },
  ): Promise<AnnotatedModel<T, {}>> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    const doesExist = await modelManager.findOne({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
      where: searchCriteria as WhereType<T>,
    });

    if (doesExist) {
      (data as T)[typeofModel.primaryKey as keyof T] =
        doesExist[typeofModel.primaryKey as keyof ModelWithoutRelations<T>];

      if (options.updateOnConflict) {
        return (await modelManager.updateRecord(data as T, {
          returning: options.returning as ModelKey<T>[] | undefined,
        })) as T;
      }

      return doesExist;
    }

    return (await modelManager.insert(data as T, {
      ignoreHooks: options.ignoreHooks,
      returning: options.returning ?? (["*"] as ModelKey<T>[]),
    })) as T;
  }

  /**
   * @description Updates or creates multiple records
   * @param {updateOnConflict} If true, the record will be updated if it exists, otherwise it will be ignored
   */
  static async upsertMany<T extends Model>(
    this: new () => T | typeof Model,
    conflictColumns: ModelKey<T>[],
    data: Partial<ModelWithoutRelations<T>>[],
    options: UpsertOptions<T> & BaseModelMethodOptions = {
      updateOnConflict: true,
    },
  ): Promise<AnnotatedModel<T, {}>[]> {
    if (!data.length) {
      return [];
    }

    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);

    if (
      !data.every((record) => {
        const recordKeys = new Set(Object.keys(record));
        return conflictColumns.every((col) => recordKeys.has(col as string));
      })
    ) {
      throw new HysteriaError(
        "Model::upsertMany",
        "CONFLICT_COLUMNS_NOT_PRESENT_IN_DATA",
      );
    }

    const columnsToUpdate = Object.keys(data[0]);
    const upsertResult = await modelManager.upsertMany(
      conflictColumns as string[],
      columnsToUpdate,
      data as ModelWithoutRelations<T>[],
      {
        ignoreHooks: options.ignoreHooks,
        returning: options.returning,
        updateOnConflict: options.updateOnConflict ?? true,
      },
    );

    const dbType = typeofModel.sqlInstance.getDbType();
    if (databasesWithReturning.includes(dbType)) {
      return (await serializeModel(
        upsertResult as T[],
        typeofModel,
        options.returning as string[],
      )) as unknown as AnnotatedModel<T, {}>[];
    }

    const lookupQuery = modelManager.query();
    if (options.returning?.length) {
      lookupQuery.select(...options.returning);
    }

    const conflictMap = new Map<string, any>();
    conflictColumns.forEach((column) => {
      data.forEach((record) => {
        conflictMap.set(column as string, [
          ...(conflictMap.get(column as string) || []),
          record[column as unknown as keyof ModelWithoutRelations<T>],
        ]);
      });
    });

    lookupQuery.where((query) => {
      conflictColumns.forEach((column) => {
        query.orWhereIn(column, conflictMap.get(column as string) || []);
      });
    });

    return lookupQuery.many({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
    });
  }

  /**
   * @description Deletes a record to the database
   */
  static async deleteRecord<T extends Model>(
    this: new () => T | typeof Model,
    modelSqlInstance: T,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<void> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.deleteRecord(modelSqlInstance);
  }

  /**
   * @description Soft Deletes a record to the database
   * @description default column: deletedAt
   * @description default value: The current date and time in UTC timezone in the format "YYYY-MM-DD HH:mm:ss"
   * @description You can override the column and value by providing the column and value on the static properties of the model `softDeleteColumn` and `softDeleteValue`
   */
  static async softDelete<T extends Model>(
    this: new () => T | typeof Model,
    modelSqlInstance: T,
    softDeleteOptions?: {
      column?: ModelKey<T>;
      value?: string | number | boolean | Date;
    },
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<AnnotatedModel<T, {}>> {
    const typeofModel = this as unknown as typeof Model;
    const {
      column = typeofModel.softDeleteColumn as ModelKey<T>,
      value = typeofModel.softDeleteValue,
    } = softDeleteOptions || {};

    modelSqlInstance[column as keyof T] = value as T[keyof T];
    const modelManager = typeofModel.dispatchModelManager<T>({
      trx: options?.trx,
      connection: options?.connection,
    });
    await modelManager.updateRecord(modelSqlInstance);

    if (typeof value === "string") {
      modelSqlInstance[column as keyof T] = new Date(value) as T[keyof T];
      return modelSqlInstance as AnnotatedModel<T, {}>;
    }

    modelSqlInstance[column as keyof T] = value as T[keyof T];
    return modelSqlInstance as AnnotatedModel<T, {}>;
  }

  /**
   * @description Truncates the table for the given model
   */
  static async truncate<T extends Model>(
    this: new () => T | typeof Model,
    options: BaseModelMethodOptions = {},
  ): Promise<void> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.query().truncate();
  }

  /**
   * @description Returns the table info for the model form the database
   */
  static async getTableInfo(): Promise<TableColumnInfo[]> {
    const typeofModel = this as unknown as typeof Model;
    typeofModel.establishConnection();
    return typeofModel.sqlInstance.getTableInfo(typeofModel.table);
  }

  /**
   * @description Returns the index info for the model form the database
   */
  static async getIndexInfo(): Promise<TableIndexInfo[]> {
    const typeofModel = this as unknown as typeof Model;
    typeofModel.establishConnection();
    return typeofModel.sqlInstance.getIndexInfo(typeofModel.table);
  }

  /**
   * @description Returns the table schema for the model form the database
   */
  static async getTableSchema(): Promise<TableSchemaInfo> {
    const typeofModel = this as unknown as typeof Model;
    typeofModel.establishConnection();
    return typeofModel.sqlInstance.getTableSchema(typeofModel.table);
  }

  /**
   * @description Merges the provided data with the model instance
   */
  static combineProps<T extends Model>(
    sqlInstance: Partial<T>,
    data: Partial<T>,
  ): void {
    for (const key in data) {
      Object.assign(sqlInstance, { [key]: data[key] });
    }
  }

  // #region Lifecycle hooks

  /**
   * @description Adds a beforeFetch clause to the model, adding the ability to modify the querybuilder before fetching the data
   */
  static beforeFetch?(
    queryBuilder: ModelQueryBuilder<any>,
  ): Promise<void> | void;

  /**
   * @description Adds a beforeInsert clause to the model modifying the data before inserting the data
   * @param {Model} data The model to be inserted, in insertMany the hook will be called for each model
   * @example
   * ```typescript
   * static async beforeInsert?(data: User): Promise<void> {
   *   data.name = data.name.toUpperCase();
   * }
   * ```
   */
  static beforeInsert?(data: any): Promise<void> | void;

  /**
   * @description Adds a beforeInsertMany clause to the model modifying the data before inserting the data
   * @param {Model[]} data The models to be inserted, in insertMany the hook will be called for each model
   * @example
   * ```typescript
   * static async beforeInsertMany?(data: User[]): Promise<void> {
   *   data.forEach((user) => {
   *     user.name = user.name.toUpperCase();
   *   });
   * }
   * ```
   */
  static beforeInsertMany?(data: any[]): Promise<void> | void;

  /**
   * @description Adds a beforeUpdate clause to the model, adding the ability to modify the query before updating the data
   * @description Includes soft delete
   */
  static beforeUpdate?(
    queryBuilder: ModelQueryBuilder<any>,
  ): Promise<void> | void;

  /**
   * @description Adds a beforeDelete clause to the model, adding the ability to modify the query before deleting the data
   * @warning This hook does not include soft delete since it's an update operation
   */
  static beforeDelete?(
    queryBuilder: ModelQueryBuilder<any>,
  ): Promise<void> | void;

  /**
   * @description Adds a afterFetch clause to the model, adding the ability to modify the data after fetching the data
   * @param {Model} data Models fetched from the database, must always provide an implementation for an array of models regardless of the query result
   * @example
   * ```typescript
   * static async afterFetch?(data: User[]): Promise<User[]> {
   *   return data;
   * }
   * ```
   */
  static afterFetch?(data: any[]): Promise<any[]> | any[];

  // #endregion Lifecycle hooks

  /**
   * @description Returns the columns of the model
   */
  static getColumns(): ColumnType[] {
    return getModelColumns(this);
  }

  /**
   * @description Returns the relations of the model
   */
  static getRelations(): LazyRelationType[] {
    return getRelationsMetadata(this);
  }

  /**
   * @description Returns the indexes metadata of the model
   */
  static getIndexes(): IndexType[] {
    return getIndexes(this);
  }

  static getUniques(): UniqueType[] {
    return getUniques(this);
  }

  // JS Static methods

  /**
   * @description Defines a column in the model, useful in javascript in order to not have to rely on decorators since are not supported without a transpiler like babel
   * @javascript
   */
  static column(columnName: string, ...args: Parameters<typeof column>): void {
    column(...args)(this.prototype, columnName);
  }

  /**
   * @description Defines an hasOne relation
   * @javascript
   */
  static hasOne(columnName: string, ...args: Parameters<typeof hasOne>): void {
    hasOne(...args)(this.prototype, columnName);
  }

  /**
   * @description Defines an hasMany
   * @javascript
   */
  static hasMany(
    columnName: string,
    ...args: Parameters<typeof hasMany>
  ): void {
    hasMany(...args)(this.prototype, columnName);
  }

  /**
   * @description Defines a belongsTo
   * @javascript
   */
  static belongsTo(
    columnName: string,
    ...args: Parameters<typeof belongsTo>
  ): void {
    belongsTo(...args)(this.prototype, columnName);
  }

  /**
   * @description Defines a many to many
   * @javascript
   */
  static manyToMany(
    columnName: string,
    ...args: Parameters<typeof manyToMany>
  ): void {
    manyToMany(...args)(this.prototype, columnName);
  }

  /**
   * @description Establishes a connection to the database instantiated from the SqlDataSource.connect method, this is done automatically when using the static methods
   * @description This method is meant to be used only if you want to establish sql sqlInstance of the model directly
   * @internal
   */
  private static establishConnection(): void {
    const sql = SqlDataSource.getInstance();
    if (!sql) {
      throw new HysteriaError(
        "sqlInstance not initialized, did you defined it in SqlDataSource.connect static method?",
        "CONNECTION_NOT_ESTABLISHED",
      );
    }

    this.sqlInstance = sql;
  }

  /**
   * @description Gives the correct model manager with the correct connection based on the options provided
   */
  private static dispatchModelManager<T extends Model>(
    this: typeof Model,
    options?: BaseModelMethodOptions,
  ): ModelManager<T> {
    if (options?.connection) {
      return options.connection.getModelManager<T>(
        this as unknown as typeof Model,
      );
    }

    if (options?.trx) {
      return options.trx.sql.getModelManager<T>(
        this as unknown as typeof Model,
      );
    }

    const typeofModel = this as unknown as typeof Model;
    typeofModel.establishConnection();
    return typeofModel.sqlInstance.getModelManager<T>(typeofModel);
  }

  // instance methods

  /**
   * @description inserts or updates the model to the database, must have a primary key in order to work
   * @throws {HysteriaError} If the model has no primary key
   */
  async save<T extends Model = this>(
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ) {
    const instance = this as unknown as new () => T | typeof Model;
    const typeofModel = instance.constructor as typeof Model &
      (new () => typeof Model);
    const primaryKey = typeofModel.primaryKey as keyof T;
    if (!primaryKey) {
      throw new HysteriaError(
        typeofModel.name + "::save",
        "MODEL_HAS_NO_PRIMARY_KEY",
      );
    }

    const primaryKeyValue: string | number =
      instance[primaryKey as keyof typeof instance];

    const searchCriteria = {
      [primaryKey]: primaryKeyValue,
    } as unknown as ModelWithoutRelations<T>;

    const { [primaryKey]: _, ...payloadWithoutPrimaryKey } =
      instance as unknown as ModelWithoutRelations<T>;

    const result = await typeofModel.upsert(
      searchCriteria,
      payloadWithoutPrimaryKey as ModelWithoutRelations<T>,
      {
        updateOnConflict: true,
        ...options,
      },
    );

    typeofModel.combineProps(this as unknown as T, result as unknown as T);
    return this as unknown as T;
  }

  /**
   * @description Updates the model in the database, must have a primary key in order to work
   * @throws {HysteriaError} If the model has no primary key valorized in the instance
   */
  async update<T extends Model = this>(
    payload: Partial<ModelWithoutRelations<T>>,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ) {
    const instance = this as unknown as new () => T | typeof Model;
    const typeofModel = instance.constructor as typeof Model &
      (new () => typeof Model);

    const primaryKey = typeofModel.primaryKey as keyof T;
    if (!primaryKey) {
      throw new HysteriaError(
        typeofModel.name + "::save",
        "MODEL_HAS_NO_PRIMARY_KEY",
      );
    }

    const primaryKeyValue: string | number =
      instance[primaryKey as keyof typeof instance];

    if (!primaryKeyValue) {
      throw new HysteriaError(
        typeofModel.name + "::update",
        "MODEL_HAS_NO_PRIMARY_KEY_VALUE",
      );
    }

    await typeofModel.updateRecord(instance as unknown as T, payload, options);
  }

  /**
   * @description Soft deletes the model from the database, must have a primary key in order to work
   * @throws {HysteriaError} If the model has no primary key valorized in the instance
   */
  async softDelete<T extends Model = this>(
    this: T,
    softDeleteOptions?: {
      column?: keyof ModelWithoutRelations<T>;
      value?: string | number | boolean | Date;
    },
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ) {
    const instance = this as unknown as new () => T | typeof Model;
    const typeofModel = instance.constructor as typeof Model &
      (new () => typeof Model);

    const primaryKey = typeofModel.primaryKey as keyof T;
    if (!primaryKey) {
      throw new HysteriaError(
        typeofModel.name + "::softDelete",
        "MODEL_HAS_NO_PRIMARY_KEY",
      );
    }

    const primaryKeyValue: string | number =
      instance[primaryKey as keyof typeof instance];

    if (!primaryKeyValue) {
      throw new HysteriaError(
        typeofModel.name + "::softDelete",
        "MODEL_HAS_NO_PRIMARY_KEY_VALUE",
      );
    }

    await typeofModel.softDelete(
      instance as unknown as T,
      softDeleteOptions as {
        column?: ModelKey<T>;
        value?: string | number | boolean | Date;
      },
      options,
    );
  }

  /**
   * @description Deletes the model from the database, must have a primary key in order to work
   * @throws {HysteriaError} If the model has no primary key valorized in the instance
   */
  async delete<T extends Model = this>(
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ) {
    const instance = this as unknown as new () => T | typeof Model;
    const typeofModel = instance.constructor as typeof Model &
      (new () => typeof Model);

    const primaryKey = typeofModel.primaryKey as keyof T;
    if (!primaryKey) {
      throw new HysteriaError(
        typeofModel.name + "::delete",
        "MODEL_HAS_NO_PRIMARY_KEY",
      );
    }

    const primaryKeyValue: string | number =
      instance[primaryKey as keyof typeof instance];

    if (!primaryKeyValue) {
      throw new HysteriaError(
        typeofModel.name + "::delete",
        "MODEL_HAS_NO_PRIMARY_KEY_VALUE",
      );
    }

    await typeofModel.deleteRecord(this as unknown as T, options);
  }

  /**
   * @description Refreshes the model from the database, it both updates the instance and returns the refreshed model
   * @throws {HysteriaError} If the model has no primary key valorized in the instance
   */
  async refresh<T extends Model = this>(
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ) {
    const instance = this as unknown as new () => T | typeof Model;
    const typeofModel = instance.constructor as typeof Model &
      (new () => typeof Model);

    const primaryKey = typeofModel.primaryKey as keyof T;
    if (!primaryKey) {
      throw new HysteriaError(
        typeofModel.name + "::refresh",
        "MODEL_HAS_NO_PRIMARY_KEY",
      );
    }

    const primaryKeyValue: string | number =
      instance[primaryKey as keyof typeof instance];

    if (!primaryKeyValue) {
      throw new HysteriaError(
        typeofModel.name + "::refresh",
        "MODEL_HAS_NO_PRIMARY_KEY_VALUE",
      );
    }

    const refreshed = await typeofModel.refresh(this as unknown as T, options);
    typeofModel.combineProps(this as unknown as T, refreshed as unknown as T);
    return this as unknown as T;
  }
}

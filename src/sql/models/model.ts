import "reflect-metadata";
import type { ModelManager } from "./model_manager/model_manager";
import type {
  FindOneType,
  FindReturnType,
  FindType,
  InsertOptions,
  ModelKey,
  ModelRelation,
  UnrestrictedFindOneType,
  UnrestrictedFindType,
  UpsertOptions,
  WhereType,
} from "./model_manager/model_manager_types";
import type { ModelQueryBuilder } from "./model_query_builder/model_query_builder";
import type {
  BaseModelMethodOptions,
  ModelWithoutRelations,
} from "./model_types";

import { Entity } from "../../entity";
import { HysteriaError } from "../../errors/hysteria_error";
import { baseSoftDeleteDate } from "../../utils/date_utils";
import { serializeModel } from "../serializer";
import { SqlDataSource } from "../sql_data_source";
import { databasesWithReturning } from "../sql_runner/sql_runner_constants";
import {
  belongsTo,
  column,
  getModelColumns,
  getPrimaryKey,
  getRelationsMetadata,
  hasMany,
  hasOne,
  manyToMany,
} from "./decorators/model_decorators";
import {
  ColumnType,
  LazyRelationType,
} from "./decorators/model_decorators_types";
import { AnnotatedModel } from "./model_query_builder/model_query_builder_types";
import { getBaseTableName } from "./model_utils";

/**
 * @description Represents a Table in the Database
 */
export abstract class Model extends Entity {
  declare private "*": string;

  /**
   * @description The column used to soft delete a record, default is deletedAt
   */
  static softDeleteColumn = "deletedAt";

  /**
   * @description The value used to soft delete a record, default is the current date and time
   * @default format: "YYYY-MM-DD HH:mm:ss" in UTC timezone
   */
  static softDeleteValue = baseSoftDeleteDate();

  /**
   * @description The sql sqlInstance generated by SqlDataSource.connect
   */
  static sqlInstance: SqlDataSource;

  /**
   * @description Getter for the table name of the model
   */
  static get table(): string {
    const descriptor = Object.getOwnPropertyDescriptor(this, "table");
    if (descriptor && "value" in descriptor) {
      return descriptor.value;
    }

    return getBaseTableName(this);
  }

  /**
   * @description Setter for the table name of the model
   */
  static set table(value: string) {
    Object.defineProperty(this, "table", {
      value,
      writable: true,
      enumerable: true,
      configurable: true,
    });
  }

  /**
   * @description Getter for the primary key of the model
   */
  static get primaryKey(): string | undefined {
    return getPrimaryKey(this);
  }

  /**
   * @description Constructor for the model, it's not meant to be used directly, it just initializes the $annotations, it's advised to only use the static methods to interact with the database to save the model
   * @description Using the constructor could lead to unexpected behavior, if you want to create a new record use the insert method
   * @deprecated
   */
  constructor() {
    super();
  }

  /**
   * @description Returns all the records for the given model
   */
  static async all<T extends Model>(
    this: new () => T | typeof Model,
    options: BaseModelMethodOptions = {},
  ): Promise<AnnotatedModel<T, {}>[]> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.find({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
    })) as AnnotatedModel<T, {}>[];
  }

  /**
   * @description Gives a query sqlInstance for the given model
   */
  static query<T extends Model>(
    this: new () => T | typeof Model,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): ModelQueryBuilder<T> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.query() as ModelQueryBuilder<T>;
  }

  /**
   * @description Finds the first record in the database
   * @deprecated Used only for debugging purposes, use findOne or query instead
   */
  static async first<T extends Model>(
    this: new () => T | typeof Model,
    options?: BaseModelMethodOptions,
  ): Promise<AnnotatedModel<T, {}> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.query().one({
      ignoreHooks: options?.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
    });
  }

  /**
   * @description Finds records for the given model
   */
  static async find<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    findOptions?: FindType<T, S, R> | UnrestrictedFindType<T, S, R>,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<FindReturnType<T, S, R>[]> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.find(
      findOptions as FindType<T, S, R>,
    )) as FindReturnType<T, S, R>[];
  }

  /**
   * @description Finds a record for the given model or throws an error if it doesn't exist
   */
  static async findOneOrFail<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    findOneOptions: (
      | FindOneType<T, S, R>
      | UnrestrictedFindOneType<T, S, R>
    ) & {
      customError?: Error;
    },
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<FindReturnType<T, S, R>> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.findOneOrFail(
      findOneOptions as FindOneType<T, S, R>,
    )) as FindReturnType<T, S, R>;
  }

  /**
   * @description Finds a record for the given model
   */
  static async findOne<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    findOneOptions: (FindOneType<T, S, R> | UnrestrictedFindOneType<T, S, R>) &
      BaseModelMethodOptions,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<FindReturnType<T, S, R> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.findOne(
      findOneOptions as FindOneType<T, S, R>,
    )) as FindReturnType<T, S, R> | null;
  }

  /**
   * @description Finds records for the given column and value
   */
  static async findBy<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    column: S,
    value: string | number | boolean | Date | null,
    options: BaseModelMethodOptions = {},
  ): Promise<FindReturnType<T, S, R>[]> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.find({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
      where: {
        [column as unknown as keyof T]: value as T[keyof T],
      } as WhereType<T>,
    })) as FindReturnType<T, S, R>[];
  }

  /**
   * @description Finds the first record for the given column and value
   */
  static async findOneBy<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    column: ModelKey<T>,
    value: string | number | boolean | Date | null,
    options: BaseModelMethodOptions = {},
  ): Promise<FindReturnType<T, S, R> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.findOne({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
      where: {
        [column as keyof T]: value as T[keyof T],
      } as WhereType<T>,
    })) as FindReturnType<T, S, R> | null;
  }

  /**
   * @description Finds a record for the given model for the given value, the model must have a primary key defined else it will throw an error
   */
  static async findOneByPrimaryKey<
    T extends Model,
    S extends ModelKey<T>[] = never[],
    R extends ModelRelation<T>[] = never[],
  >(
    this: new () => T | typeof Model,
    value: string | number,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ): Promise<FindReturnType<T, S, R> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return (await modelManager.findOneByPrimaryKey(value)) as FindReturnType<
      T,
      S,
      R
    > | null;
  }

  /**
   * @description Refreshes a model from the database, the model must have a primary key defined
   */
  static async refresh<T extends Model>(
    this: new () => T | typeof Model,
    model: T,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ): Promise<AnnotatedModel<T, {}> | null> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    const primaryKey = typeofModel.primaryKey as keyof T;
    const primaryKeyValue = model[primaryKey];
    const refreshedModel = await modelManager.findOneByPrimaryKey(
      primaryKeyValue as string,
    );
    if (!refreshedModel) {
      return null;
    }

    return refreshedModel;
  }

  /**
   * @description Saves a new record to the database
   * @description $annotations will be ignored if set in the modelData and won't be returned in the response
   * @warning If not using postgres and the model has no primary key, the model will be saved, but it won't be possible to retrieve it so at that point it will be returned as null, this is not typed as Model | null for type safety reasons
   * @mysql If no Primary Key is present in the model definition, the exact input model will be returned
   * @sqlite If no Primary Key is present in the model definition, the exact input will be returned
   * @sqlite Returning Not supported and won't have effect
   */
  static async insert<T extends Model>(
    this: new () => T | typeof Model,
    modelData: Partial<ModelWithoutRelations<T>>,
    options: BaseModelMethodOptions & InsertOptions<T> = {},
  ): Promise<AnnotatedModel<T, {}>> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.insert(modelData as T, {
      ignoreHooks: options.ignoreHooks,
      returning: options.returning,
    });
  }

  /**
   * @description Saves multiple records to the database
   * @description $annotations will be ignored if set in the modelData and won't be returned in the response
   * @warning If not using postgres and the model has no primary key, the models will be saved, but it won't be possible to retrieve them so at that point they will be returned as an empty array
   * @mysql If no Primary Key is present in the model definition, the exact input model will be returned
   * @sqlite If no Primary Key is present in the model definition, the exact input will be returned
   * @sqlite Returning Not supported and won't have effect
   */
  static async insertMany<T extends Model>(
    this: new () => T | typeof Model,
    modelsData: Partial<ModelWithoutRelations<T>>[],
    options: BaseModelMethodOptions & InsertOptions<T> = {},
  ): Promise<AnnotatedModel<T, {}>[]> {
    if (!modelsData.length) {
      return [];
    }

    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.insertMany(modelsData as T[], {
      ignoreHooks: options.ignoreHooks,
      returning: options.returning,
    });
  }

  /**
   * @description Updates a record, returns the updated record
   * @description Model is retrieved from the database using the primary key regardless of any model hooks
   * @description Can only be used if the model has a primary key, use a massive update if the model has no primary key
   * @throws {HysteriaError} If the model has no primary key
   */
  static async updateRecord<T extends Model>(
    this: new () => T | typeof Model,
    modelSqlInstance: Partial<T>,
    updatePayload?: ModelWithoutRelations<T>,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> = {},
  ): Promise<AnnotatedModel<T, {}>> {
    try {
      const typeofModel = this as unknown as typeof Model;
      const modelManager = typeofModel.dispatchModelManager<T>(options);
      updatePayload &&
        typeofModel.combineProps(modelSqlInstance, updatePayload as Partial<T>);
      const updatedModel = await modelManager.updateRecord(modelSqlInstance);
      return updatedModel;
    } catch (error) {
      if (
        error instanceof HysteriaError &&
        error.message === "MODEL_HAS_NO_PRIMARY_KEY"
      ) {
        throw new HysteriaError(
          `${this.name}::updateRecord`,
          "MODEL_HAS_NO_PRIMARY_KEY",
        );
      }

      throw error;
    }
  }

  /**
   * @description Finds the first record or creates a new one if it doesn't exist
   */
  static async firstOrInsert<T extends Model, O extends boolean = false>(
    this: new () => T | typeof Model,
    searchCriteria: Partial<ModelWithoutRelations<T>>,
    createData: Partial<ModelWithoutRelations<T>>,
    options: Omit<BaseModelMethodOptions, "ignoreHooks"> & {
      fullResponse?: O;
    } = {},
  ): Promise<
    O extends true
      ? {
          isNew: boolean;
          model: T;
        }
      : T
  > {
    if (!options.fullResponse) {
      options.fullResponse = false as O;
    }

    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    const doesExist = (await modelManager.findOne({
      where: searchCriteria as WhereType<T>,
    })) as T;

    if (doesExist) {
      if (options.fullResponse) {
        return {
          isNew: false,
          model: doesExist,
        } as O extends true ? { isNew: boolean; model: T } : T;
      }

      return doesExist as O extends true ? { isNew: boolean; model: T } : T;
    }

    const newModel = (await modelManager.insert(createData as T)) as T;
    if (options.fullResponse) {
      return {
        isNew: true,
        model: newModel,
      } as O extends true ? { isNew: boolean; model: T } : T;
    }

    return newModel as O extends true ? { isNew: boolean; model: T } : T;
  }

  /**
   * @description Updates or creates a new record
   */
  static async upsert<T extends Model>(
    this: new () => T | typeof Model,
    searchCriteria: Partial<ModelWithoutRelations<T>>,
    data: Partial<ModelWithoutRelations<T>>,
    options: UpsertOptions<T> & BaseModelMethodOptions = {
      updateOnConflict: true,
    },
  ): Promise<AnnotatedModel<T, {}>> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    const doesExist = await modelManager.findOne({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
      where: searchCriteria as WhereType<T>,
    });

    if (doesExist) {
      (data as T)[typeofModel.primaryKey as keyof T] =
        doesExist[typeofModel.primaryKey as keyof ModelWithoutRelations<T>];

      if (options.updateOnConflict) {
        return (await modelManager.updateRecord(data as T, {
          returning: options.returning as ModelKey<T>[] | undefined,
        })) as T;
      }

      return doesExist;
    }

    return (await modelManager.insert(data as T, {
      ignoreHooks: options.ignoreHooks,
      returning: options.returning ?? (["*"] as ModelKey<T>[]),
    })) as T;
  }

  /**
   * @description Updates or creates multiple records
   * @param {updateOnConflict} If true, the record will be updated if it exists, otherwise it will be ignored
   */
  static async upsertMany<T extends Model>(
    this: new () => T | typeof Model,
    conflictColumns: ModelKey<T>[],
    data: Partial<ModelWithoutRelations<T>>[],
    options: UpsertOptions<T> & BaseModelMethodOptions = {
      updateOnConflict: true,
    },
  ): Promise<AnnotatedModel<T, {}>[]> {
    if (!data.length) {
      return [];
    }

    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);

    if (
      !data.every((record) => {
        const recordKeys = new Set(Object.keys(record));
        return conflictColumns.every((col) => recordKeys.has(col as string));
      })
    ) {
      throw new HysteriaError(
        "Model::upsertMany",
        "CONFLICT_COLUMNS_NOT_PRESENT_IN_DATA",
      );
    }

    const columnsToUpdate = Object.keys(data[0]);
    const upsertResult = await modelManager.upsertMany(
      conflictColumns as string[],
      columnsToUpdate,
      data as ModelWithoutRelations<T>[],
      {
        ignoreHooks: options.ignoreHooks,
        returning: options.returning,
        updateOnConflict: options.updateOnConflict || true,
      },
    );

    const dbType = typeofModel.sqlInstance.getDbType();
    if (databasesWithReturning.includes(dbType)) {
      return (await serializeModel(
        upsertResult as T[],
        typeofModel,
        options.returning as string[],
      )) as unknown as AnnotatedModel<T, {}>[];
    }

    const lookupQuery = modelManager.query();
    if (options.returning?.length) {
      lookupQuery.select(...options.returning);
    }

    const conflictMap = new Map<string, any>();
    conflictColumns.forEach((column) => {
      data.forEach((record) => {
        conflictMap.set(column as string, [
          ...(conflictMap.get(column as string) || []),
          record[column as unknown as keyof ModelWithoutRelations<T>],
        ]);
      });
    });

    lookupQuery.whereBuilder((query) => {
      conflictColumns.forEach((column) => {
        query.orWhereIn(column, conflictMap.get(column as string) || []);
      });
    });

    return lookupQuery.many({
      ignoreHooks: options.ignoreHooks ? ["afterFetch", "beforeFetch"] : [],
    });
  }

  /**
   * @description Deletes a record to the database
   */
  static async deleteRecord<T extends Model>(
    this: new () => T | typeof Model,
    modelSqlInstance: T,
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<void> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.deleteRecord(modelSqlInstance);
  }

  /**
   * @description Soft Deletes a record to the database
   * @description default column: deletedAt
   * @description default value: The current date and time in UTC timezone in the format "YYYY-MM-DD HH:mm:ss"
   * @description You can override the column and value by providing the column and value on the static properties of the model `softDeleteColumn` and `softDeleteValue`
   */
  static async softDelete<T extends Model>(
    this: new () => T | typeof Model,
    modelSqlInstance: T,
    softDeleteOptions?: {
      column?: ModelKey<T>;
      value?: string | number | boolean | Date;
    },
    options?: Omit<BaseModelMethodOptions, "ignoreHooks">,
  ): Promise<AnnotatedModel<T, {}>> {
    const typeofModel = this as unknown as typeof Model;
    const {
      column = typeofModel.softDeleteColumn as ModelKey<T>,
      value = typeofModel.softDeleteValue,
    } = softDeleteOptions || {};

    modelSqlInstance[column as keyof T] = value as T[keyof T];
    const modelManager = typeofModel.dispatchModelManager<T>({
      trx: options?.trx,
      useConnection: options?.useConnection,
    });
    await modelManager.updateRecord(modelSqlInstance);

    if (typeof value === "string") {
      modelSqlInstance[column as keyof T] = new Date(value) as T[keyof T];
      return modelSqlInstance as AnnotatedModel<T, {}>;
    }

    modelSqlInstance[column as keyof T] = value as T[keyof T];
    return modelSqlInstance as AnnotatedModel<T, {}>;
  }

  /**
   * @description Truncates the table for the given model
   */
  static async truncate<T extends Model>(
    this: new () => T | typeof Model,
    options: BaseModelMethodOptions = {},
  ): Promise<void> {
    const typeofModel = this as unknown as typeof Model;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.query().truncate();
  }

  /**
   * @description Merges the provided data with the model instance
   */
  static combineProps<T extends Model>(
    sqlInstance: Partial<T>,
    data: Partial<T>,
  ): void {
    for (const key in data) {
      Object.assign(sqlInstance, { [key]: data[key] });
    }
  }

  /**
   * @description Adds a beforeFetch clause to the model, adding the ability to modify the query before fetching the data
   */
  static beforeFetch?(queryBuilder: ModelQueryBuilder<any>): void;

  /**
   * @description Adds a beforeInsert clause to the model, adding the ability to modify the data before inserting the data
   * @param {Model} data The single model to be inserted, in insertMany the hook will be called for each model
   * @example
   * ```typescript
   * static async beforeInsert?(data: User): Promise<void> {
   *   data.name = data.name.toUpperCase();
   * }
   * ```
   */
  static beforeInsert?(data: any): Promise<void> | void;

  /**
   * @description Adds a beforeUpdate clause to the model, adding the ability to modify the query before updating the data
   */
  static beforeUpdate?(queryBuilder: ModelQueryBuilder<any>): void;

  /**
   * @description Adds a beforeDelete clause to the model, adding the ability to modify the query before deleting the data
   */
  static beforeDelete?(queryBuilder: ModelQueryBuilder<any>): void;

  /**
   * @description Adds a afterFetch clause to the model, adding the ability to modify the data after fetching the data
   * @param {Model} data The single model to be fetched, in queries that return multiple models the hook will be called for each model
   * @example
   * ```typescript
   * static async afterFetch?(data: User): Promise<User> {
   *   return data;
   * }
   * ```
   */
  static afterFetch?(data: any): Promise<any> | any;

  /**
   * @description Returns the columns of the model
   */
  static getModelColumns(this: typeof Model): ColumnType[] {
    return getModelColumns(this);
  }

  /**
   * @description Returns the relations of the model
   */
  static getModelRelations(this: typeof Model): LazyRelationType[] {
    return getRelationsMetadata(this);
  }

  // JS Static methods

  /**
   * @description Defines a column in the model, useful in javascript in order to not have to rely on decorators since are not supported without a transpiler like babel
   * @javascript
   */
  static column(columnName: string, ...args: Parameters<typeof column>): void {
    column(...args)(this.prototype, columnName);
  }

  /**
   * @description Defines an hasOne relation
   * @javascript
   */
  static hasOne(columnName: string, ...args: Parameters<typeof hasOne>): void {
    hasOne(...args)(this.prototype, columnName);
  }

  /**
   * @description Defines an hasMany
   * @javascript
   */
  static hasMany(
    columnName: string,
    ...args: Parameters<typeof hasMany>
  ): void {
    hasMany(...args)(this.prototype, columnName);
  }

  /**
   * @description Defines a belongsTo
   * @javascript
   */
  static belongsTo(
    columnName: string,
    ...args: Parameters<typeof belongsTo>
  ): void {
    belongsTo(...args)(this.prototype, columnName);
  }

  /**
   * @description Defines a many to many
   * @javascript
   */
  static manyToMany(
    columnName: string,
    ...args: Parameters<typeof manyToMany>
  ): void {
    manyToMany(...args)(this.prototype, columnName);
  }

  /**
   * @description Establishes a connection to the database instantiated from the SqlDataSource.connect method, this is done automatically when using the static methods
   * @description This method is meant to be used only if you want to establish sql sqlInstance of the model directly
   * @internal
   */
  private static establishConnection(): void {
    const sql = SqlDataSource.getInstance();
    if (!sql) {
      throw new HysteriaError(
        "sqlInstance not initialized, did you defined it in SqlDataSource.connect static method?",
        "CONNECTION_NOT_ESTABLISHED",
      );
    }

    this.sqlInstance = sql;
  }

  /**
   * @description Gives the correct model manager with the correct connection based on the options provided
   */
  private static dispatchModelManager<T extends Model>(
    this: typeof Model,
    options?: BaseModelMethodOptions,
  ): ModelManager<T> {
    if (options?.useConnection) {
      return options.useConnection.getModelManager<T>(
        this as unknown as typeof Model,
      );
    }

    if (options?.trx) {
      return options.trx.sqlDataSource.getModelManager<T>(
        this as unknown as typeof Model,
      );
    }

    const typeofModel = this as unknown as typeof Model;
    typeofModel.establishConnection();
    return typeofModel.sqlInstance.getModelManager<T>(typeofModel);
  }
}

import { AstParser } from "../../../ast/parser";
import { ColumnTypeNode } from "../../../ast/query/node/column";
import { QueryNode } from "../../../ast/query/query";
import { Model } from "../../../models/model";
import { getColumnValue } from "../../../resources/utils";
import type { Interpreter } from "../../interpreter";
import { InterpreterUtils } from "../../interpreter_utils";

/**
 * Oracle data type mappings:
 * - VARCHAR -> VARCHAR2 (max 4000 bytes, or 32767 in 12c+ with extended strings)
 * - TEXT/LONGTEXT/MEDIUMTEXT/TINYTEXT -> CLOB
 * - INTEGER/INT -> NUMBER(10)
 * - BIGINT -> NUMBER(19)
 * - SMALLINT -> NUMBER(5)
 * - TINYINT -> NUMBER(3)
 * - FLOAT/REAL -> BINARY_FLOAT
 * - DOUBLE -> BINARY_DOUBLE
 * - BOOLEAN -> NUMBER(1)
 * - BYTEA/BINARY/BLOB -> BLOB
 * - JSON/JSONB -> CLOB (or JSON type in 21c+)
 * - UUID -> RAW(16) or VARCHAR2(36)
 * - AUTO_INCREMENT -> Use GENERATED AS IDENTITY (12c+) or sequence+trigger
 */
class OracleColumnTypeInterpreter implements Interpreter {
  declare model: typeof Model;

  toSql(node: QueryNode): ReturnType<typeof AstParser.prototype.parse> {
    const colNode = node as ColumnTypeNode;
    if (colNode.isRawValue) {
      return { sql: colNode.column as string, bindings: [] };
    }

    const utils = new InterpreterUtils(this.model);
    const columnName = utils.formatStringColumn(
      "oracledb",
      getColumnValue(colNode.column),
    );

    const dt = colNode.dataType.toLowerCase();

    if (dt === "char") {
      const len = colNode.length ?? 1;
      return { sql: `${columnName} char(${len})`, bindings: [] };
    } else if (dt === "varchar") {
      const len = colNode.length ?? 255;
      return { sql: `${columnName} varchar2(${len})`, bindings: [] };
    } else if (
      dt === "text" ||
      dt === "longtext" ||
      dt === "mediumtext" ||
      dt === "tinytext"
    ) {
      return { sql: `${columnName} clob`, bindings: [] };
    } else if (dt === "uuid") {
      // Store UUID as VARCHAR2(36) for readability, or RAW(16) for efficiency
      return { sql: `${columnName} varchar2(36)`, bindings: [] };
    } else if (dt === "ulid") {
      return { sql: `${columnName} varchar2(26)`, bindings: [] };
    } else if (dt === "bigint") {
      if (colNode.autoIncrement) {
        // Oracle 12c+ supports GENERATED AS IDENTITY
        return {
          sql: `${columnName} number(19) generated by default as identity`,
          bindings: [],
        };
      }
      return { sql: `${columnName} number(19)`, bindings: [] };
    } else if (dt === "tinyint") {
      return { sql: `${columnName} number(3)`, bindings: [] };
    } else if (dt === "smallint") {
      return { sql: `${columnName} number(5)`, bindings: [] };
    } else if (dt === "mediumint") {
      return { sql: `${columnName} number(7)`, bindings: [] };
    } else if (dt === "float" || dt === "real") {
      return { sql: `${columnName} binary_float`, bindings: [] };
    } else if (dt === "double") {
      return { sql: `${columnName} binary_double`, bindings: [] };
    } else if (dt === "decimal" || dt === "numeric") {
      const precision = colNode.precision ?? 10;
      const scale = colNode.scale ?? 0;
      return {
        sql: `${columnName} number(${precision}, ${scale})`,
        bindings: [],
      };
    } else if (dt === "date") {
      // Oracle DATE includes time component
      return { sql: `${columnName} date`, bindings: [] };
    } else if (dt === "year") {
      return { sql: `${columnName} number(4)`, bindings: [] };
    } else if (dt === "time") {
      // Oracle doesn't have a TIME-only type, use INTERVAL or store in VARCHAR2
      return { sql: `${columnName} varchar2(8)`, bindings: [] };
    } else if (dt === "datetime" || dt === "timestamp") {
      const withTz = colNode.withTimezone ? " with time zone" : "";
      const p =
        typeof colNode.precision === "number" ? `(${colNode.precision})` : "";
      return {
        sql: `${columnName} timestamp${p}${withTz}`.trimEnd(),
        bindings: [],
      };
    } else if (dt === "boolean" || dt === "bool") {
      // Oracle doesn't have native BOOLEAN in SQL, use NUMBER(1)
      return { sql: `${columnName} number(1)`, bindings: [] };
    } else if (
      dt === "bytea" ||
      dt === "binary" ||
      dt === "varbinary" ||
      dt === "blob" ||
      dt === "longblob" ||
      dt === "mediumblob" ||
      dt === "tinyblob"
    ) {
      return { sql: `${columnName} blob`, bindings: [] };
    } else if (dt === "json" || dt === "jsonb") {
      // Oracle 21c+ has native JSON type, use CLOB for older versions
      return { sql: `${columnName} clob`, bindings: [] };
    } else if (dt === "enum") {
      if (colNode.enumValues && colNode.enumValues.length > 0) {
        const values = colNode.enumValues.map((v) => `'${v}'`).join(", ");
        return {
          sql: `${columnName} varchar2(255) check (${columnName} in (${values}))`,
          bindings: [],
        };
      }
      return { sql: `${columnName} varchar2(255)`, bindings: [] };
    } else if (dt === "integer" || dt === "int") {
      if (colNode.autoIncrement) {
        // Oracle 12c+ supports GENERATED AS IDENTITY
        return {
          sql: `${columnName} number(10) generated by default as identity`,
          bindings: [],
        };
      }
      return { sql: `${columnName} number(10)`, bindings: [] };
    } else if (
      dt === "geometry" ||
      dt === "point" ||
      dt === "linestring" ||
      dt === "polygon" ||
      dt === "multipoint"
    ) {
      // Oracle Spatial uses SDO_GEOMETRY for all spatial types
      return { sql: `${columnName} sdo_geometry`, bindings: [] };
    }

    return {
      sql: `${columnName} ${dt} ${colNode.length ? `(${colNode.length})` : ""}`,
      bindings: [],
    };
  }
}

export default new OracleColumnTypeInterpreter();

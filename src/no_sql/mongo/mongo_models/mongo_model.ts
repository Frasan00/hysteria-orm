import { AbstractModel } from "../../../abstract_model";
import { MongoDataSource } from "../mongo_data_source";
import { MongoModelManager } from "./mongo_model_manager";
import {
  BaseModelMethodOptions,
  getBaseCollectionName,
  ModelKeyOrAny,
} from "./mongo_model_types";

const collectionMap = new WeakMap<typeof MongoModel, string>();

export function getBaseMongoModelInstance<T extends MongoModel>(): T {
  return { extraColumns: {} } as T;
}

export class MongoModel extends AbstractModel {
  /**
   * @description The sql sqlInstance generated by SqlDataSource.connect
   */
  static mongoInstance: MongoDataSource;

  /**
   * @description Collection name for the model, if not set it will be the plural snake case of the model name given that is in PascalCase (es. User -> users)
   */
  static collectionName: string;

  /**
   * @description Static getter for collection;
   * @internal
   */
  static get collection(): string {
    if (!collectionMap.has(this)) {
      collectionMap.set(
        this,
        this.collectionName || getBaseCollectionName(this),
      );
    }

    return collectionMap.get(this)!;
  }

  public id!: string;

  /**
   * @description Saves a new record to the collection
   * @param model
   * @param {Model} modelData - The data to be saved
   * @param {BaseModelMethodOptions} options - The options to get the model manager
   * @returns {Promise<T>}
   */
  static insert<T extends MongoModel>(
    this: new () => T | typeof MongoModel,
    modelData: ModelKeyOrAny<T>,
    options: BaseModelMethodOptions = {},
  ): Promise<T> {
    const typeofModel = this as unknown as typeof MongoModel;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.insert(modelData);
  }

  static async insertMany<T extends MongoModel>(
    this: new () => T | typeof MongoModel,
    modelData: ModelKeyOrAny<T>[],
    options: BaseModelMethodOptions = {},
  ): Promise<T[]> {
    const typeofModel = this as unknown as typeof MongoModel;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.insertMany(modelData);
  }

  /**
   * @description Gets the main connection from the mongoInstance
   */
  private static establishConnection(): void {
    const mongo = MongoDataSource.getInstance();
    if (!mongo) {
      throw new Error(
        "mongo mongoInstance not initialized, did you defined it in MongoDataSource.connect static method?",
      );
    }

    this.mongoInstance = mongo;
  }

  /**
   * @description Gives the correct model manager with the correct connection based on the options provided
   * @param this
   * @param options - The options to get the model manager
   * @returns
   */
  private static dispatchModelManager<T extends MongoModel>(
    options: BaseModelMethodOptions,
  ): MongoModelManager<T> {
    if (options.useConnection) {
      return options.useConnection.getModelManager<T>(
        this as unknown as typeof MongoModel,
        this.mongoInstance,
      );
    }

    if (options.session) {
      return options.session.mongoDataSource.getModelManager<T>(
        this as unknown as typeof MongoModel,
        options.session.mongoDataSource,
      );
    }

    const typeofModel = this as unknown as typeof MongoModel;
    typeofModel.establishConnection();
    return typeofModel.mongoInstance.getModelManager<T>(
      typeofModel,
      typeofModel.mongoInstance,
    );
  }
}

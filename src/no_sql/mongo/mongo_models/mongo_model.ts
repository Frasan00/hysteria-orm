import { AbstractModel } from "../../../abstract_model";
import { column } from "../../../sql/models/model_decorators";
import { MongoDataSource } from "../mongo_data_source";
import { MongoQueryBuilder } from "../query_builder/mongo_query_builder";
import { MongoModelManager } from "./mongo_model_manager";
import {
  getBaseCollectionName,
  BaseModelMethodOptions,
  ModelKeyOrAny,
} from "./mongo_model_types";

const collectionMap = new WeakMap<typeof MongoModel, string>();

export function getBaseMongoModelInstance<T extends MongoModel>(): T {
  return { extraColumns: {} } as T;
}

export class MongoModel extends AbstractModel {
  /**
   * @description The sql sqlInstance generated by SqlDataSource.connect
   */
  static mongoInstance: MongoDataSource;

  /**
   * @description Collection name for the model, if not set it will be the plural snake case of the model name given that is in PascalCase (es. User -> users)
   */
  static collectionName: string;

  /**
   * @description Static getter for collection;
   * @internal
   */
  static get collection(): string {
    if (!collectionMap.has(this)) {
      collectionMap.set(
        this,
        this.collectionName || getBaseCollectionName(this),
      );
    }

    return collectionMap.get(this)!;
  }

  @column()
  declare id: string;

  /**
   * @description Gets the main query builder for the model
   * @param options - The options to get the model manager
   * @returns {MongoQueryBuilder<T>}
   */
  static query<T extends MongoModel>(
    this: new () => T | typeof MongoModel,
    options: BaseModelMethodOptions = {},
  ): MongoQueryBuilder<T> {
    const typeofModel = this as unknown as typeof MongoModel;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.query();
  }

  /**
   * @description Saves a new record to the collection
   * @param model
   * @param {Model} modelData - The data to be saved
   * @param {BaseModelMethodOptions} options - The options to get the model manager
   * @returns {Promise<T>}
   */
  static insert<T extends MongoModel>(
    this: new () => T | typeof MongoModel,
    modelData: ModelKeyOrAny<T>,
    options: BaseModelMethodOptions = {},
  ): Promise<T> {
    const typeofModel = this as unknown as typeof MongoModel;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.insert(modelData);
  }

  /**
   * @description Saves multiple records to the collection
   * @param {Model} modelData - The data to be fetched
   * @param {BaseModelMethodOptions} options - The options to get the model manager
   * @returns {Promise<T>}
   */
  static async insertMany<T extends MongoModel>(
    this: new () => T | typeof MongoModel,
    modelData: ModelKeyOrAny<T>[],
    options: BaseModelMethodOptions = {},
  ): Promise<T[]> {
    const typeofModel = this as unknown as typeof MongoModel;
    const modelManager = typeofModel.dispatchModelManager<T>(options);
    return modelManager.insertMany(modelData);
  }

  /**
   * @description Gets the main connection from the mongoInstance
   */
  private static establishConnection(): void {
    const mongo = MongoDataSource.getInstance();
    if (!mongo) {
      throw new Error(
        "mongo mongoInstance not initialized, did you defined it in MongoDataSource.connect static method?",
      );
    }

    this.mongoInstance = mongo;
  }

  /**
   * @description Gives the correct model manager with the correct connection based on the options provided
   * @param this
   * @param options - The options to get the model manager
   * @returns
   */
  private static dispatchModelManager<T extends MongoModel>(
    this: typeof MongoModel,
    options: BaseModelMethodOptions,
  ): MongoModelManager<T> {
    if (options.useConnection) {
      return options.useConnection.getModelManager<T>(
        this,
        options.useConnection,
      );
    }

    if (options.session) {
      return options.session.mongoDataSource.getModelManager<T>(
        this,
        options.session.mongoDataSource,
      );
    }

    const typeofModel = this as unknown as typeof MongoModel;
    typeofModel.establishConnection();
    return typeofModel.mongoInstance.getModelManager<T>(
      typeofModel,
      typeofModel.mongoInstance,
    );
  }

  /**
   * @description Adds a beforeFetch clause to the model, adding the ability to modify the query before fetching the data
   * @param queryBuilder
   */
  static beforeFetch(queryBuilder: MongoQueryBuilder<any>): void {
    queryBuilder;
  }

  /**
   * @description Adds a beforeInsert clause to the model, adding the ability to modify the data after fetching the data
   * @param data
   * @returns {T}
   */
  static beforeInsert(data: any): void {
    return data;
  }

  /**
   * @description Adds a beforeUpdate clause to the model, adding the ability to modify the query before updating the data
   * @param data
   */
  // static beforeUpdate(queryBuilder: ModelUpdateQueryBuilder<any>): void {
  //   queryBuilder;
  // }

  /**
   * @description Adds a beforeDelete clause to the model, adding the ability to modify the query before deleting the data
   * @param data
   */
  // static beforeDelete(queryBuilder: ModelDeleteQueryBuilder<any>): void {
  //   queryBuilder;
  // }

  /**
   * @description Adds a afterFetch clause to the model, adding the ability to modify the data after fetching the data
   * @param data
   * @returns {T}
   */
  static async afterFetch(data: any[]): Promise<MongoModel[]> {
    return data;
  }
}

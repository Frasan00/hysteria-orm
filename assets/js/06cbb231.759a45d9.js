"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[6770],{6470:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"databases/sql/advanced/model-embedding","title":"Model Embedding","description":"Model embedding in Hysteria ORM allows you to attach models directly to a SQL data source instance, providing a convenient way to access your models through the data source. This feature is similar to Prisma\'s client model access pattern.","source":"@site/docs/databases/sql/advanced/model-embedding.md","sourceDirName":"databases/sql/advanced","slug":"/databases/sql/advanced/model-embedding","permalink":"/hysteria-orm/docs/databases/sql/advanced/model-embedding","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/advanced/model-embedding.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"SQLite JSON Limitations","permalink":"/hysteria-orm/docs/databases/sql/advanced/sqlite-json-limitations"},"next":{"title":"MongoDB Introduction","permalink":"/hysteria-orm/docs/databases/nosql/mongodb/introduction"}}');var t=s(4848),i=s(8453);const r={},d="Model Embedding",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Connecting with Embedded Models",id:"connecting-with-embedded-models",level:3},{value:"Using with Secondary Connections",id:"using-with-secondary-connections",level:3},{value:"Using with Temporary Connections",id:"using-with-temporary-connections",level:3},{value:"TypeScript Support",id:"typescript-support",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Duplicate Model Keys",id:"duplicate-model-keys",level:3},{value:"Reserved Keywords",id:"reserved-keywords",level:3},{value:"Important Notes",id:"important-notes",level:2},{value:"Static Singleton Connection Limitation",id:"static-singleton-connection-limitation",level:3},{value:"Model Independence",id:"model-independence",level:3},{value:"Best Practices",id:"best-practices",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"model-embedding",children:"Model Embedding"})}),"\n",(0,t.jsx)(n.p,{children:"Model embedding in Hysteria ORM allows you to attach models directly to a SQL data source instance, providing a convenient way to access your models through the data source. This feature is similar to Prisma's client model access pattern."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"When you embed models in a SQL data source instance, they become available as properties on the data source object, allowing you to access them directly without importing the model classes separately."}),"\n",(0,t.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.h3,{id:"connecting-with-embedded-models",children:"Connecting with Embedded Models"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { sql } from "hysteria-orm";\nimport { User } from "./models/User";\nimport { Post } from "./models/Post";\n\n// Connect with embedded models\nconst sqlInstance = await sql.connect({\n  models: {\n    user: User,\n    post: Post,\n  },\n});\n\n// Access models directly through the data source\nconst users = await sqlInstance.user.query().many();\nconst posts = await sqlInstance.post.query().many();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-with-secondary-connections",children:"Using with Secondary Connections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Create a secondary connection with embedded models\nconst anotherSql = await sql.connectToSecondarySource({\n  models: {\n    user: User,\n    post: Post,\n  },\n});\n\n// Use the embedded models with the specific connection\nconst user = await anotherSql.user.insert(\n  { name: "John Doe" },\n  { connection: anotherSql }\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-with-temporary-connections",children:"Using with Temporary Connections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'await sql.useConnection(\n  {\n    type: "postgres",\n    host: "localhost",\n    port: 5432,\n    username: "user",\n    password: "password",\n    database: "mydb",\n    models: {\n      user: User,\n      post: Post,\n    },\n  },\n  async (sql) => {\n    const user = await sql.user.insert({ name: "John Doe" });\n    const posts = await sql.post.query().many();\n  }\n);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"typescript-support",children:"TypeScript Support"}),"\n",(0,t.jsxs)(n.p,{children:["For proper TypeScript support when using embedded models, use the ",(0,t.jsx)(n.code,{children:"AugmentedSqlDataSource"})," type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { AugmentedSqlDataSource } from "hysteria-orm";\nimport { User } from "./models/User";\nimport { Post } from "./models/Post";\n\nlet sqlInstance: AugmentedSqlDataSource<{\n  user: typeof User;\n  post: typeof Post;\n}>;\n\nbeforeAll(async () => {\n  sqlInstance = await sql.connect({\n    models: {\n      user: User,\n      post: Post,\n    },\n  });\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.h3,{id:"duplicate-model-keys",children:"Duplicate Model Keys"}),"\n",(0,t.jsxs)(n.p,{children:["The most common error occurs when you try to use a model key that conflicts with existing sql properties or methods. The following will throw a ",(0,t.jsx)(n.code,{children:"HysteriaError"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \u274c This will throw an error - 'connect' is a reserved method\nawait sql.connect({\n  models: {\n    connect: User, // Error: Duplicate model keys while instantiating models\n  },\n});\n\n// \u274c This will also throw an error - 'query' is a reserved method\nawait sql.connect({\n  models: {\n    query: User, // Error: Duplicate model keys while instantiating models\n  },\n});\n\n// \u2705 This works correctly\nawait sql.connect({\n  models: {\n    user: User,\n    post: Post,\n  },\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reserved-keywords",children:"Reserved Keywords"}),"\n",(0,t.jsx)(n.p,{children:"The following keywords are reserved and cannot be used as model keys:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"connect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"query"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"disconnect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"startGlobalTransaction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"commitGlobalTransaction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"rollbackGlobalTransaction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"closeConnection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"isConnected"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"getDbType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"rawQuery"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"useConnection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"connectToSecondarySource"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,t.jsx)(n.h3,{id:"static-singleton-connection-limitation",children:"Static Singleton Connection Limitation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Important"}),": Model embedding is not available with the static singleton connection pattern. You must use a SQL data source instance to embed models."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// \u274c This does NOT support model embedding\nimport { sql } from "hysteria-orm";\nawait sql.connect();\n// Models are not embedded in the global sql instance\n\n// \u2705 This supports model embedding\nconst sqlInstance = await sql.connect({\n  models: {\n    user: User,\n    post: Post,\n  },\n});\n// Models are embedded in sqlInstance\n'})}),"\n",(0,t.jsx)(n.h3,{id:"model-independence",children:"Model Independence"}),"\n",(0,t.jsx)(n.p,{children:"Embedded models can still be used as standalone entities. Embedding them in a data source instance is optional and provides convenience but doesn't change their core functionality."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Models work both ways\nconst sqlInstance = await sql.connect({\n  models: { user: User },\n});\n\n// Using embedded model\nconst user1 = await sqlInstance.user.query().first();\n\n// Using standalone model (still works)\nconst user2 = await User.query().first();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use descriptive model keys"}),": Choose meaningful names for your model keys that reflect the model's purpose."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Type your data sources"}),": Always use ",(0,t.jsx)(n.code,{children:"AugmentedSqlDataSource<T>"})," for proper TypeScript support when embedding models."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Avoid reserved keywords"}),": Check that your model keys don't conflict with sql methods or properties."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Consider connection scope"}),": Use embedded models when you need model access within a specific connection context."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Error handling"}),": Always handle potential ",(0,t.jsx)(n.code,{children:"HysteriaError"})," exceptions when connecting with embedded models."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>d});var o=s(6540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[7167],{4177:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"databases/sql/advanced/caching","title":"Caching","description":"Hysteria ORM provides a flexible caching system that allows you to cache expensive computations, database queries, or any async operations. The caching system is fully integrated with SqlDataSource and supports multiple cache adapters.","source":"@site/docs/databases/sql/advanced/caching.md","sourceDirName":"databases/sql/advanced","slug":"/databases/sql/advanced/caching","permalink":"/hysteria-orm/databases/sql/advanced/caching","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/advanced/caching.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Caching","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Relations Overview","permalink":"/hysteria-orm/databases/sql/relations/overview"},"next":{"title":"Advanced SQL Features: CTE","permalink":"/hysteria-orm/databases/sql/advanced/cte"}}');var t=a(4848),r=a(8453);const i={title:"Caching",sidebar_position:5},c="Caching",d={},l=[{value:"Cache Adapters",id:"cache-adapters",level:2},{value:"InMemoryAdapter",id:"inmemoryadapter",level:3},{value:"RedisCacheAdapter",id:"rediscacheadapter",level:3},{value:"Defining Cache Keys",id:"defining-cache-keys",level:2},{value:"Using the Cache",id:"using-the-cache",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"With TTL (Time-To-Live)",id:"with-ttl-time-to-live",level:3},{value:"Invalidating Cache",id:"invalidating-cache",level:3},{value:"Invalidating All Cache Entries",id:"invalidating-all-cache-entries",level:3},{value:"Argument-Based Caching",id:"argument-based-caching",level:2},{value:"Complex Arguments",id:"complex-arguments",level:3},{value:"Type Safety",id:"type-safety",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Using with Secondary Connections",id:"using-with-secondary-connections",level:2},{value:"Using with useConnection",id:"using-with-useconnection",level:2},{value:"Custom Cache Adapter",id:"custom-cache-adapter",level:2},{value:"Best Practices",id:"best-practices",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"caching",children:"Caching"})}),"\n",(0,t.jsxs)(n.p,{children:["Hysteria ORM provides a flexible caching system that allows you to cache expensive computations, database queries, or any async operations. The caching system is fully integrated with ",(0,t.jsx)(n.code,{children:"SqlDataSource"})," and supports multiple cache adapters."]}),"\n",(0,t.jsx)(n.h2,{id:"cache-adapters",children:"Cache Adapters"}),"\n",(0,t.jsx)(n.p,{children:"Hysteria ORM comes with two built-in cache adapters:"}),"\n",(0,t.jsx)(n.h3,{id:"inmemoryadapter",children:"InMemoryAdapter"}),"\n",(0,t.jsxs)(n.p,{children:["A simple in-memory cache adapter that stores values in a ",(0,t.jsx)(n.code,{children:"Map"}),". Ideal for development, testing, or single-instance applications."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { SqlDataSource, InMemoryAdapter } from "hysteria-orm";\n\nconst sql = new SqlDataSource({\n  type: "postgres",\n  host: "localhost",\n  database: "mydb",\n  cacheStrategy: {\n    cacheAdapter: new InMemoryAdapter(), // default adapter can be omitted\n    keys: {\n      // Define your cache keys here\n    },\n  },\n});\n\nawait sql.connect();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"rediscacheadapter",children:"RedisCacheAdapter"}),"\n",(0,t.jsxs)(n.p,{children:["A production-ready Redis cache adapter using ",(0,t.jsx)(n.code,{children:"ioredis"}),". Perfect for distributed applications and multi-instance deployments."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { SqlDataSource, RedisCacheAdapter } from "hysteria-orm";\n\nconst sql = new SqlDataSource({\n  type: "postgres",\n  host: "localhost",\n  database: "mydb",\n  cacheStrategy: {\n    cacheAdapter: new RedisCacheAdapter({\n      host: "localhost",\n      port: 6379,\n      username: "default",\n      password: "your-password",\n      db: 0,\n    }),\n    keys: {\n      // Define your cache keys here\n    },\n  },\n});\n\nawait sql.connect();\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RedisCacheAdapter"})," requires the ",(0,t.jsx)(n.code,{children:"ioredis"})," package to be installed in your project."]})}),"\n",(0,t.jsx)(n.h2,{id:"defining-cache-keys",children:"Defining Cache Keys"}),"\n",(0,t.jsxs)(n.p,{children:["Cache keys are defined as async handler functions in the ",(0,t.jsx)(n.code,{children:"cacheStrategy.keys"})," configuration. Each key maps to a function that computes the value when it's not cached."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const sql = new SqlDataSource({\n  type: "postgres",\n  host: "localhost",\n  database: "mydb",\n  cacheStrategy: {\n    cacheAdapter: new InMemoryAdapter(),\n    keys: {\n      // Handler with no arguments\n      appConfig: async () => {\n        return fetchAppConfiguration();\n      },\n\n      // Handler with arguments\n      userById: async (userId: string) => {\n        return User.query().where("id", userId).first();\n      },\n\n      // Handler with multiple arguments\n      searchResults: async (query: string, page: number, limit: number) => {\n        return Product.query()\n          .where("name", "LIKE", `%${query}%`)\n          .limit(limit)\n          .offset((page - 1) * limit)\n          .many();\n      },\n    },\n  },\n});\n\nawait sql.connect();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"using-the-cache",children:"Using the Cache"}),"\n",(0,t.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"useCache"})," to get a cached value or compute and cache it if not present:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Handler with no arguments\nconst config = await sql.useCache("appConfig");\n\n// Handler with arguments\nconst user = await sql.useCache("userById", "user-123");\n\n// Handler with multiple arguments\nconst results = await sql.useCache("searchResults", "laptop", 1, 10);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"with-ttl-time-to-live",children:"With TTL (Time-To-Live)"}),"\n",(0,t.jsx)(n.p,{children:"You can specify a TTL in milliseconds as the first argument after the key:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Cache for 5 minutes (300,000 ms)\nconst config = await sql.useCache("appConfig", 300_000);\n\n// Cache user for 1 minute with arguments\nconst user = await sql.useCache("userById", 60_000, "user-123");\n\n// Cache search results for 30 seconds\nconst results = await sql.useCache("searchResults", 30_000, "laptop", 1, 10);\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["When TTL is ",(0,t.jsx)(n.code,{children:"0"})," or not provided, the value is cached indefinitely (or until manually invalidated)."]})}),"\n",(0,t.jsx)(n.h3,{id:"invalidating-cache",children:"Invalidating Cache"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"invalidCache"})," to remove a cached value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Invalidate a key with no arguments\nawait sql.invalidCache("appConfig");\n\n// Invalidate a specific cached entry (with arguments)\nawait sql.invalidCache("userById", "user-123");\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Cache keys are automatically hashed based on their arguments, so invalidating ",(0,t.jsx)(n.code,{children:"userById"})," with ",(0,t.jsx)(n.code,{children:'"user-123"'})," only removes that specific user's cache, not all cached users."]})}),"\n",(0,t.jsx)(n.h3,{id:"invalidating-all-cache-entries",children:"Invalidating All Cache Entries"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"invalidateAllCache"})," to remove all cached entries for a given key regardless of the arguments:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'await sql.invalidateAllCache("appConfig");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"argument-based-caching",children:"Argument-Based Caching"}),"\n",(0,t.jsx)(n.p,{children:"The caching system automatically generates unique cache keys based on the arguments passed to the handler. This means the same cache key with different arguments will store separate cached values:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// These are cached separately\nconst user1 = await sql.useCache("userById", "user-1");\nconst user2 = await sql.useCache("userById", "user-2");\n\n// Invalidating one doesn\'t affect the other\nawait sql.invalidCache("userById", "user-1");\n// user2 is still cached\n'})}),"\n",(0,t.jsx)(n.h3,{id:"complex-arguments",children:"Complex Arguments"}),"\n",(0,t.jsx)(n.p,{children:"The caching system supports complex arguments including objects and arrays:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const keys = {\n  filteredProducts: async (filter: { category: string; minPrice: number }) => {\n    return Product.query()\n      .where("category", filter.category)\n      .where("price", ">=", filter.minPrice)\n      .many();\n  },\n};\n\n// These are cached separately\nawait sql.useCache("filteredProducts", {\n  category: "electronics",\n  minPrice: 100,\n});\nawait sql.useCache("filteredProducts", {\n  category: "electronics",\n  minPrice: 200,\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"type-safety",children:"Type Safety"}),"\n",(0,t.jsxs)(n.p,{children:["The cache system is fully type-safe. TypeScript will infer the return type of ",(0,t.jsx)(n.code,{children:"useCache"})," based on the handler's return type, and it will enforce the correct arguments:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const keys = {\n  userById: async (id: string) => {\n    return { id, name: "John" };\n  },\n  sum: async (a: number, b: number) => {\n    return a + b;\n  },\n};\n\n// TypeScript knows this returns { id: string, name: string }\nconst user = await sql.useCache("userById", "123");\n\n// TypeScript enforces correct argument types\nconst result = await sql.useCache("sum", 1, 2); // Returns number\n\n// TypeScript error: Expected 2 arguments\nawait sql.useCache("sum", 1);\n\n// TypeScript error: Argument must be number\nawait sql.useCache("sum", "1", "2");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"If a cache handler throws an error, the error is propagated and the value is not cached:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const keys = {\n  riskyOperation: async () => {\n    const result = await someExternalApi();\n    if (!result.success) {\n      throw new Error("API call failed");\n    }\n    return result.data;\n  },\n};\n\ntry {\n  await sql.useCache("riskyOperation");\n} catch (error) {\n  // Error is propagated, nothing is cached\n  // Next call will attempt to compute again\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"using-with-secondary-connections",children:"Using with Secondary Connections"}),"\n",(0,t.jsxs)(n.p,{children:["Cache works with secondary connections created via ",(0,t.jsx)(n.code,{children:"connectToSecondarySource"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const secondaryDb = await SqlDataSource.connectToSecondarySource({\n  type: "mysql",\n  host: "localhost",\n  database: "secondary",\n  cacheStrategy: {\n    cacheAdapter: new RedisCacheAdapter({ host: "localhost", port: 6379 }),\n    keys: {\n      expensiveQuery: async () => {\n        return await runExpensiveQuery();\n      },\n    },\n  },\n});\n\nconst result = await secondaryDb.useCache("expensiveQuery", 60_000);\n\n// Don\'t forget to disconnect (this also closes the Redis connection)\nawait secondaryDb.disconnect();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"using-with-useconnection",children:"Using with useConnection"}),"\n",(0,t.jsxs)(n.p,{children:["Cache is also supported within ",(0,t.jsx)(n.code,{children:"useConnection"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'await SqlDataSource.useConnection(\n  {\n    type: "sqlite",\n    database: ":memory:",\n    cacheStrategy: {\n      cacheAdapter: new InMemoryAdapter(),\n      keys: {\n        computeValue: async () => "computed",\n      },\n    },\n  },\n  async (connection) => {\n    const value = await connection.useCache("computeValue");\n    // Connection is automatically closed when callback completes\n  }\n);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"custom-cache-adapter",children:"Custom Cache Adapter"}),"\n",(0,t.jsxs)(n.p,{children:["You can create your own cache adapter by implementing the ",(0,t.jsx)(n.code,{children:"CacheAdapter"})," interface:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { CacheAdapter } from "hysteria-orm";\n\nexport class MyCustomAdapter implements CacheAdapter {\n  async get<T = void>(key: string): Promise<T> {\n    // Return cached value or undefined\n  }\n\n  async set<T = any>(key: string, data: T, ttl?: number): Promise<void> {\n    // Store the value, optionally with TTL in milliseconds\n  }\n\n  async invalidate(key: string): Promise<void> {\n    // Remove the cached value\n  }\n\n  // Optional\n  async disconnect(): Promise<void> {\n    // Clean up connections when SqlDataSource disconnects\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use meaningful key names"}),": Choose descriptive names that indicate what's being cached."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Set appropriate TTLs"}),": Consider how fresh the data needs to be. Use shorter TTLs for frequently changing data."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Invalidate on mutations"}),": When updating data, remember to invalidate related cache entries."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Redis for production"}),": The ",(0,t.jsx)(n.code,{children:"InMemoryAdapter"})," doesn't share state across instances. Use ",(0,t.jsx)(n.code,{children:"RedisCacheAdapter"})," for distributed applications."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handle cache misses gracefully"}),": The handler is called on cache miss, so ensure it handles errors appropriately."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const keys = {\n  userData: async (userId: string) => {\n    const user = await User.find(userId);\n    if (!user) {\n      throw new NotFoundError(`User ${userId} not found`);\n    }\n    return user;\n  },\n};\n\n// In your application code\ntry {\n  const user = await sql.useCache("userData", userId);\n} catch (error) {\n  if (error instanceof NotFoundError) {\n    // Handle missing user\n  }\n  throw error;\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"See also:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/hysteria-orm/databases/sql/advanced/transactions",children:"Transactions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/hysteria-orm/databases/sql/advanced/cte",children:"CTE"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/hysteria-orm/databases/sql/advanced/json",children:"JSON Columns"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>c});var s=a(6540);const t={},r=s.createContext(t);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
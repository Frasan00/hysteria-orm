"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[6770],{6470:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"databases/sql/advanced/model-embedding","title":"Model Embedding","description":"Model embedding allows you to attach models directly to a SQL data source instance, providing a Prisma-like API for accessing your models.","source":"@site/docs/databases/sql/advanced/model-embedding.md","sourceDirName":"databases/sql/advanced","slug":"/databases/sql/advanced/model-embedding","permalink":"/hysteria-orm/docs/databases/sql/advanced/model-embedding","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/advanced/model-embedding.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Model Embedding","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"SQLite JSON Limitations","permalink":"/hysteria-orm/docs/databases/sql/advanced/sqlite-json-limitations"},"next":{"title":"Advanced SQL Features: Read Replication","permalink":"/hysteria-orm/docs/databases/sql/advanced/replication"}}');var t=s(4848),i=s(8453);const r={title:"Model Embedding",sidebar_position:6},l="Model Embedding",a={},d=[{value:"Overview",id:"overview",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Connecting with Embedded Models",id:"connecting-with-embedded-models",level:3},{value:"Using with Default Connection",id:"using-with-default-connection",level:3},{value:"Using with Secondary Connections",id:"using-with-secondary-connections",level:3},{value:"Using with Temporary Connections",id:"using-with-temporary-connections",level:3},{value:"Using with Cloned Connections",id:"using-with-cloned-connections",level:3},{value:"TypeScript Support",id:"typescript-support",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Duplicate Model Keys",id:"duplicate-model-keys",level:3},{value:"Reserved Keywords",id:"reserved-keywords",level:3},{value:"Important Notes",id:"important-notes",level:2},{value:"Model Independence",id:"model-independence",level:3},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"model-embedding",children:"Model Embedding"})}),"\n",(0,t.jsx)(n.p,{children:"Model embedding allows you to attach models directly to a SQL data source instance, providing a Prisma-like API for accessing your models."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["When you embed models in a SQL data source instance, they become available via the ",(0,t.jsx)(n.code,{children:".models"})," property on the data source object, allowing you to access them directly without importing the model classes separately."]}),"\n",(0,t.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.h3,{id:"connecting-with-embedded-models",children:"Connecting with Embedded Models"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { SqlDataSource } from "hysteria-orm";\nimport { User } from "./models/User";\nimport { Post } from "./models/Post";\n\n// Create instance with embedded models\nconst sql = new SqlDataSource({\n  type: "postgres",\n  host: "localhost",\n  database: "mydb",\n  models: {\n    user: User,\n    post: Post,\n  },\n});\n\nawait sql.connect();\n\n// Access models via .models property\nconst users = await sql.models.user.query().many();\nconst posts = await sql.models.post.query().many();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-with-default-connection",children:"Using with Default Connection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'await sql.startGlobalTransaction();\nawait sql.models.user.insert({\n  name: "John",\n});\n\nconst user = await sql.models.user.query().first();\nexpect(user).toBeDefined();\nexpect(user?.name).toBe("John");\n\nawait sql.rollbackGlobalTransaction();\nawait sql.closeConnection();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-with-secondary-connections",children:"Using with Secondary Connections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Create a secondary connection with embedded models\nconst anotherSql = await SqlDataSource.connectToSecondarySource({\n  type: "postgres",\n  host: "replica.db.com",\n  database: "mydb",\n  models: {\n    user: User,\n    post: Post,\n  },\n});\n\nawait anotherSql.startGlobalTransaction();\nawait anotherSql.models.user.insert(\n  { name: "John" },\n  { connection: anotherSql }\n);\n\nconst user = await anotherSql.models.user\n  .query({ connection: anotherSql })\n  .first();\n\nawait anotherSql.rollbackGlobalTransaction();\nawait anotherSql.closeConnection();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-with-temporary-connections",children:"Using with Temporary Connections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'await SqlDataSource.useConnection(\n  {\n    type: "postgres",\n    host: "localhost",\n    port: 5432,\n    username: "user",\n    password: "password",\n    database: "mydb",\n    models: {\n      user: User,\n      post: Post,\n    },\n  },\n  async (sql) => {\n    await sql.startGlobalTransaction();\n    await sql.models.user.insert(\n      { name: "John" },\n      { connection: sql }\n    );\n\n    const user = await sql.models.user\n      .query({ connection: sql })\n      .first();\n\n    await sql.rollbackGlobalTransaction();\n    await sql.closeConnection();\n  }\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-with-cloned-connections",children:"Using with Cloned Connections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const clonedSql = await sql.clone({ shouldRecreatePool: true });\nawait clonedSql.startGlobalTransaction();\nawait clonedSql.models.user.insert(\n  { name: "John" },\n  { connection: clonedSql }\n);\n\nconst user = await clonedSql.models.user\n  .query({ connection: clonedSql })\n  .first();\n\nawait clonedSql.rollbackGlobalTransaction();\nawait clonedSql.closeConnection();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"typescript-support",children:"TypeScript Support"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { SqlDataSource } from "hysteria-orm";\nimport { User } from "./models/User";\nimport { Post } from "./models/Post";\n\nlet sql: SqlDataSource<\n  "postgres",\n  { user: typeof User; post: typeof Post }\n>;\n\nbeforeAll(async () => {\n  sql = new SqlDataSource({\n    type: "postgres",\n    host: "localhost",\n    database: "mydb",\n    models: {\n      user: User,\n      post: Post,\n    },\n  }) as typeof sql;\n  await sql.connect();\n});\n\n// Access models via .models with full type safety\nconst users = await sql.models.user.query().many();\nconst posts = await sql.models.post.query().many();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.h3,{id:"duplicate-model-keys",children:"Duplicate Model Keys"}),"\n",(0,t.jsxs)(n.p,{children:["The most common error occurs when you try to use a model key that conflicts with existing sql properties or methods. The following will throw a ",(0,t.jsx)(n.code,{children:"HysteriaError"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// \u274c This will throw an error - \'connect\' is a reserved method\nnew SqlDataSource({\n  type: "postgres",\n  models: {\n    connect: User, // Error: Duplicate model keys while instantiating models\n  },\n});\n\n// \u274c This will also throw an error - \'query\' is a reserved method\nnew SqlDataSource({\n  type: "postgres",\n  models: {\n    query: User, // Error: Duplicate model keys while instantiating models\n  },\n});\n\n// \u2705 This works correctly\nnew SqlDataSource({\n  type: "postgres",\n  models: {\n    user: User,\n    post: Post,\n  },\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"reserved-keywords",children:"Reserved Keywords"}),"\n",(0,t.jsx)(n.p,{children:"The following keywords are reserved and cannot be used as model keys:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"connect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"query"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"disconnect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"startGlobalTransaction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"commitGlobalTransaction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"rollbackGlobalTransaction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"closeConnection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"isConnected"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"getDbType"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"rawQuery"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"useConnection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"connectToSecondarySource"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,t.jsx)(n.h3,{id:"model-independence",children:"Model Independence"}),"\n",(0,t.jsx)(n.p,{children:"Embedded models can still be used as standalone entities. Embedding them in a data source instance is optional and provides convenience but doesn't change their core functionality."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Models work both ways\nconst sql = new SqlDataSource({\n  type: "postgres",\n  models: { user: User },\n});\nawait sql.connect();\n\n// Using embedded model via .models\nconst user1 = await sql.models.user.query().first();\n\n// Using standalone model (still works)\nconst user2 = await User.query().first();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use descriptive model keys"}),": Choose meaningful names for your model keys that reflect the model's purpose."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Type your data sources"}),": Always use ",(0,t.jsx)(n.code,{children:"SqlDataSourceWithModels<D, T>"})," for proper TypeScript support when embedding models."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Avoid reserved keywords"}),": Check that your model keys don't conflict with sql methods or properties."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Consider connection scope"}),": Use embedded models when you need model access within a specific connection context."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Error handling"}),": Always handle potential ",(0,t.jsx)(n.code,{children:"HysteriaError"})," exceptions when creating instances with embedded models."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var o=s(6540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);
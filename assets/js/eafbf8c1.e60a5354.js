"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[3391],{6080:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"databases/sql/query-builder/query-builder","title":"QueryBuilder (Raw SQL)","description":"The QueryBuilder is a low-level, Knex-like API for building raw SQL queries. Access it via sql.query(\'table\').","source":"@site/docs/databases/sql/query-builder/query-builder.md","sourceDirName":"databases/sql/query-builder","slug":"/databases/sql/query-builder/","permalink":"/hysteria-orm/databases/sql/query-builder/","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/query-builder/query-builder.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"QueryBuilder (Raw SQL)","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"SQL Functions","permalink":"/hysteria-orm/databases/sql/query-builder/sql-functions"},"next":{"title":"Command Line Interface Overview","permalink":"/hysteria-orm/databases/sql/cli/overview"}}');var i=n(4848),a=n(8453);const t={title:"QueryBuilder (Raw SQL)",sidebar_position:2},l="QueryBuilder (Raw SQL)",c={},d=[{value:"Key Features",id:"key-features",level:2},{value:"Basics",id:"basics",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Pagination with Cursor",id:"pagination-with-cursor",level:3},{value:"Joins",id:"joins",level:3},{value:"Advanced Features",id:"advanced-features",level:3},{value:"<code>pluck</code>",id:"pluck",level:4},{value:"<code>increment</code> / <code>decrement</code>",id:"increment--decrement",level:4},{value:"<code>lockForUpdate</code> / <code>forShare</code>",id:"lockforupdate--forshare",level:4},{value:"<code>with</code> (Common Table Expressions, CTE)",id:"with-common-table-expressions-cte",level:4},{value:"Example Usage",id:"example-usage",level:2},{value:"Filtering",id:"filtering",level:2},{value:"Raw right-hand side with rawStatement",id:"raw-right-hand-side-with-rawstatement",level:3},{value:"Insert &amp; Update with Raw Statements",id:"insert--update-with-raw-statements",level:2},{value:"Raw Statements in Insert",id:"raw-statements-in-insert",level:3},{value:"Raw Statements in Update",id:"raw-statements-in-update",level:3},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Automatic JSON Serialization",id:"automatic-json-serialization",level:2},{value:"What Gets Serialized",id:"what-gets-serialized",level:3},{value:"Selecting Columns",id:"selecting-columns",level:2},{value:"Basic Select",id:"basic-select",level:3},{value:"Select with Alias (Tuple Syntax)",id:"select-with-alias-tuple-syntax",level:3},{value:"Mixed Selection",id:"mixed-selection",level:3},{value:"Pagination",id:"pagination",level:2},{value:"Chunking Large Datasets",id:"chunking-large-datasets",level:3},{value:"Pagination Methods",id:"pagination-methods",level:3},{value:"From",id:"from",level:2},{value:"Joins",id:"joins-1",level:2},{value:"Basic Joins",id:"basic-joins",level:3},{value:"Joins with Additional Conditions",id:"joins-with-additional-conditions",level:3},{value:"CTEs (Common Table Expressions)",id:"ctes-common-table-expressions",level:2},{value:"Truncate",id:"truncate",level:2},{value:"Soft Delete",id:"soft-delete",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Comparison to ModelQueryBuilder",id:"comparison-to-modelquerybuilder",level:2},{value:"Full API Reference",id:"full-api-reference",level:2},{value:"Filtering",id:"filtering-1",level:3},{value:"Subqueries &amp; Nested Conditions",id:"subqueries--nested-conditions",level:3},{value:"Joins",id:"joins-2",level:3},{value:"Group By &amp; Having",id:"group-by--having",level:3},{value:"Unions",id:"unions",level:3},{value:"Aggregates",id:"aggregates",level:3},{value:"Select &amp; Raw Select",id:"select--raw-select",level:3},{value:"Type-Safe Selects",id:"type-safe-selects",level:3},{value:"Explicit Types with <code>selectRaw</code>",id:"explicit-types-with-selectraw",level:4},{value:"Type-Safe SQL Functions with <code>selectFunc</code>",id:"type-safe-sql-functions-with-selectfunc",level:4},{value:"Type-Safe JSON Selects",id:"type-safe-json-selects",level:4},{value:"Subquery Type Safety",id:"subquery-type-safety",level:4},{value:"Chaining Selects",id:"chaining-selects",level:4},{value:"selectRaw with CAST",id:"selectraw-with-cast",level:3},{value:"Pluck",id:"pluck-1",level:3},{value:"Pagination",id:"pagination-1",level:3},{value:"Streaming (experimental)",id:"streaming-experimental",level:3},{value:"Locking",id:"locking",level:3},{value:"CTEs (Common Table Expressions)",id:"ctes-common-table-expressions-1",level:3},{value:"Copying &amp; Query Output",id:"copying--query-output",level:3},{value:"Raw Queries",id:"raw-queries",level:2},{value:"Raw Query with Parameters",id:"raw-query-with-parameters",level:3},{value:"QueryBuilder Only",id:"querybuilder-only",level:3}];function o(e){const s={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"querybuilder-raw-sql",children:"QueryBuilder (Raw SQL)"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"QueryBuilder"})," is a low-level, Knex-like API for building raw SQL queries. Access it via ",(0,i.jsx)(s.code,{children:"sql.query('table')"}),".\nIt's suitable for performance crucial database queries since there is no serialization and the driver rows are directly returned from the query."]}),"\n",(0,i.jsx)(s.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Works with any table (even without a model)"}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Type-safe select methods"})," - column types are inferred from select calls"]}),"\n",(0,i.jsx)(s.li,{children:"Flexible for migrations, admin scripts, or advanced SQL"}),"\n",(0,i.jsx)(s.li,{children:"Supports filtering, selecting, joining, pagination, CTEs, truncate, softDelete, and more"}),"\n"]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Best Practice:"})," Use QueryBuilder for raw SQL, migrations, or when want the max performance in a query. For app logic, prefer the ModelQueryBuilder."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"basics",children:"Basics"}),"\n",(0,i.jsxs)(s.p,{children:["For type-safe application queries use the ModelQueryBuilder. This page focuses on raw SQL with ",(0,i.jsx)(s.code,{children:"sql.query(table)"}),"."]}),"\n",(0,i.jsx)(s.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const users = await sql.query("users").where("status", "active").many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"pagination-with-cursor",children:"Pagination with Cursor"}),"\n",(0,i.jsxs)(s.p,{children:["Paginate with cursor is a pagination method that allows you to paginate the results with a cursor that does not use the offset clause (more efficient for large datasets).\nDiscriminator is used to identify the unique value to paginate by.\nBy default it generates an order by clause to the query ",(0,i.jsx)(s.code,{children:'orderBy(discriminator, "asc")'})," if not already present."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Get the first page\nconst [users, cursor] = await sql\n  .query("users")\n  .paginateWithCursor(1, { discriminator: "age" });\n\n// Get the second page\nconst [users2, cursor2] = await sql\n  .query("users")\n  .paginateWithCursor(1, { discriminator: "age" }, cursor);\n'})}),"\n",(0,i.jsx)(s.h3,{id:"joins",children:"Joins"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const postsWithUsers = await sql\n  .query("posts")\n  .join("users", "posts.userId", "users.id")\n  .select("posts.*", "users.name")\n  .many();\n\n// Alias are supported in `join` and `from`\nconst postsWithUsersWithAlias = await sql\n  .query("posts")\n  .join("users as u", "posts.userId", "u.id")\n  .select("posts.*", "u.name")\n  .many();\n\n// Add additional conditions with a callback\nconst postsWithActiveUsers = await sql\n  .query("posts")\n  .join("users", "posts.userId", "users.id", (q) =>\n    q.where("users.isActive", true)\n  )\n  .select("posts.*", "users.name")\n  .many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,i.jsx)(s.h4,{id:"pluck",children:(0,i.jsx)(s.code,{children:"pluck"})}),"\n",(0,i.jsx)(s.p,{children:"Extract a single column as an array."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const names = await User.query().pluck("name"); // string[]\n'})}),"\n",(0,i.jsxs)(s.h4,{id:"increment--decrement",children:[(0,i.jsx)(s.code,{children:"increment"})," / ",(0,i.jsx)(s.code,{children:"decrement"})]}),"\n",(0,i.jsx)(s.p,{children:"Atomically increment or decrement a column."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").increment("age", 1);\nawait sql.query("users").decrement("age", 1);\n'})}),"\n",(0,i.jsxs)(s.h4,{id:"lockforupdate--forshare",children:[(0,i.jsx)(s.code,{children:"lockForUpdate"})," / ",(0,i.jsx)(s.code,{children:"forShare"})]}),"\n",(0,i.jsx)(s.p,{children:"Apply row-level locking (Postgres/MySQL only)."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const users = await sql.query("users").lockForUpdate().many();\nconst users = await sql.query("users").forShare().many();\n'})}),"\n",(0,i.jsxs)(s.h4,{id:"with-common-table-expressions-cte",children:[(0,i.jsx)(s.code,{children:"with"})," (Common Table Expressions, CTE)"]}),"\n",(0,i.jsx)(s.p,{children:"Use CTEs for advanced queries."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const users = await sql\n  .query("users")\n  .with("users_cte", (qb) => qb.select("name").where("isActive", true))\n  .many();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// After connecting with SqlDataSource\nconst users = await sql.query("users").where("status", "active").many();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"filtering",children:"Filtering"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const users = await sql.query("users").where("age", ">", 18).many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"raw-right-hand-side-with-rawstatement",children:"Raw right-hand side with rawStatement"}),"\n",(0,i.jsxs)(s.p,{children:["When you need to compare a column to another column or an expression without creating a binding, use ",(0,i.jsx)(s.code,{children:"sql.rawStatement"}),". Identifiers inside the raw string are automatically quoted per database dialect."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// After connecting with SqlDataSource\nawait sql.query("users").where("id", sql.rawStatement("user.id")).many();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"insert--update-with-raw-statements",children:"Insert & Update with Raw Statements"}),"\n",(0,i.jsxs)(s.p,{children:["You can use ",(0,i.jsx)(s.code,{children:"sql.rawStatement()"})," in insert and update operations to reference column values, expressions, or SQL functions without creating parameter bindings."]}),"\n",(0,i.jsx)(s.h3,{id:"raw-statements-in-insert",children:"Raw Statements in Insert"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Insert with raw SQL expression\nawait sql.query("users").insert({\n  name: sql.rawStatement("\'John Doe\'"),\n  email: "john@example.com",\n});\n\n// Insert with column reference\nawait sql.query("audit_logs").insert({\n  user_id: sql.rawStatement(\n    "(SELECT id FROM users WHERE email = \'admin@example.com\')"\n  ),\n  action: "login",\n});\n'})}),"\n",(0,i.jsx)(s.h3,{id:"raw-statements-in-update",children:"Raw Statements in Update"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Update a column to reference another column\nawait sql.query("users").update({\n  display_name: sql.rawStatement("name"),\n});\n\n// Update with SQL expression\nawait sql.query("users").update({\n  full_name: sql.rawStatement("CONCAT(first_name, \' \', last_name)"),\n});\n'})}),"\n",(0,i.jsx)(s.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Copy column values:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql\n  .query("users")\n  .where("old_email", null)\n  .update({\n    old_email: sql.rawStatement("email"),\n  });\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Set timestamps:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").update({\n  last_login: sql.rawStatement("CURRENT_TIMESTAMP"),\n});\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Conditional updates:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"await sql.query(\"products\").update({\n  status: sql.rawStatement(\n    \"CASE WHEN stock > 0 THEN 'available' ELSE 'out_of_stock' END\"\n  ),\n});\n"})}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note:"})," Raw statements bypass parameter binding, so ensure the SQL is safe from injection. Never use raw statements with user input directly."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"automatic-json-serialization",children:"Automatic JSON Serialization"}),"\n",(0,i.jsxs)(s.p,{children:["When using ",(0,i.jsx)(s.code,{children:"insert()"})," or ",(0,i.jsx)(s.code,{children:"update()"})," with the QueryBuilder, plain objects and arrays are automatically serialized to JSON strings. This means you don't need to manually call ",(0,i.jsx)(s.code,{children:"JSON.stringify()"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Objects are automatically stringified\nawait sql.query("users").insert({\n  name: "John",\n  metadata: { preferences: { theme: "dark" }, tags: ["admin", "active"] },\n});\n\n// Arrays are automatically stringified\nawait sql.query("users").update({\n  roles: ["admin", "editor"],\n});\n'})}),"\n",(0,i.jsx)(s.h3,{id:"what-gets-serialized",children:"What Gets Serialized"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Value Type"}),(0,i.jsx)(s.th,{children:"Auto-Stringify"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:["Plain objects ",(0,i.jsx)(s.code,{children:'{ key: "value" }'})]}),(0,i.jsx)(s.td,{children:"\u2705 Yes"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:["Arrays ",(0,i.jsx)(s.code,{children:"[1, 2, 3]"})]}),(0,i.jsx)(s.td,{children:"\u2705 Yes"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"null"})," / ",(0,i.jsx)(s.code,{children:"undefined"})]}),(0,i.jsx)(s.td,{children:"\u274c No"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"Primitives (string, number, boolean)"}),(0,i.jsx)(s.td,{children:"\u274c No"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"Date"})," instances"]}),(0,i.jsx)(s.td,{children:"\u274c No (handled by database driver)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"RawNode"})," (from ",(0,i.jsx)(s.code,{children:"sql.rawStatement()"}),")"]}),(0,i.jsx)(s.td,{children:"\u274c No"})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:["This behavior applies to both the raw ",(0,i.jsx)(s.code,{children:"QueryBuilder"})," and ",(0,i.jsx)(s.code,{children:"ModelQueryBuilder"}),". For models with ",(0,i.jsx)(s.code,{children:"@column.json()"})," decorators, the column's ",(0,i.jsx)(s.code,{children:"prepare"})," function takes precedence."]}),"\n",(0,i.jsx)(s.h2,{id:"selecting-columns",children:"Selecting Columns"}),"\n",(0,i.jsx)(s.h3,{id:"basic-select",children:"Basic Select"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const names = await sql.query("users").select("name").many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"select-with-alias-tuple-syntax",children:"Select with Alias (Tuple Syntax)"}),"\n",(0,i.jsxs)(s.p,{children:["Use ",(0,i.jsx)(s.code,{children:"[column, alias]"})," tuples to alias columns:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Select with alias\nconst users = await sql\n  .query("users")\n  .select(["name", "userName"], ["email", "userEmail"])\n  .many();\n\n// users[0].userName - aliased from name\n// users[0].userEmail - aliased from email\n'})}),"\n",(0,i.jsx)(s.h3,{id:"mixed-selection",children:"Mixed Selection"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Mix regular columns and aliased columns\nconst users = await sql\n  .query("users")\n  .select("id", ["name", "userName"], "status")\n  .many();\n'})}),"\n",(0,i.jsxs)(s.admonition,{title:"Avoid Wildcards for Better Type Safety",type:"tip",children:[(0,i.jsxs)(s.p,{children:["While ",(0,i.jsx)(s.code,{children:'select("*")'})," works, it's recommended to select specific columns for better type inference:"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// \u2705 Preferred: Explicit columns\nconst users = await sql.query("users").select("id", "name", "email").many();\n\n// \u26a0\ufe0f Less precise: Wildcard returns Record<string, any>\nconst users = await sql.query("users").select("*").many();\n'})})]}),"\n",(0,i.jsx)(s.h2,{id:"pagination",children:"Pagination"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const page = await sql.query("users").paginate(1, 10);\nconsole.log(page.data, page.paginationMetadata);\n'})}),"\n",(0,i.jsx)(s.h3,{id:"chunking-large-datasets",children:"Chunking Large Datasets"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"chunk"})," method processes large datasets in manageable pieces without loading everything into memory:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Process users in chunks of 250\nfor await (const users of sql.query("users").chunk(250)) {\n  await processUserBatch(users);\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"pagination-methods",children:"Pagination Methods"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Method"}),(0,i.jsx)(s.th,{children:"Use Case"}),(0,i.jsx)(s.th,{children:"Return"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"paginate(page, perPage)"})}),(0,i.jsx)(s.td,{children:"API responses with metadata"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ data, paginationMetadata }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"limit(n).offset(m)"})}),(0,i.jsx)(s.td,{children:"Manual pagination"}),(0,i.jsx)(s.td,{children:"Array of results"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"chunk(size)"})}),(0,i.jsx)(s.td,{children:"Large dataset processing"}),(0,i.jsx)(s.td,{children:"Async iterable"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"from",children:"From"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const users = await sql\n  .query("users")\n  .from((qb) => {\n    qb.select("name")\n      .from("users as internal_users")\n      .where("internal_users.age", ">", 18);\n  }, "external_users")\n  .many();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"joins-1",children:"Joins"}),"\n",(0,i.jsx)(s.h3,{id:"basic-joins",children:"Basic Joins"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const postsWithUsers = await sql\n  .query("posts")\n  .join("users", "posts.userId", "users.id")\n  .select("posts.*", "users.name")\n  .many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"joins-with-additional-conditions",children:"Joins with Additional Conditions"}),"\n",(0,i.jsx)(s.p,{children:"You can add additional conditions to the join ON clause by passing a callback:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const postsWithActiveUsers = await sql\n  .query("posts")\n  .join("users", "posts.userId", "users.id", (q) =>\n    q.where("users.isActive", true)\n  )\n  .select("posts.*", "users.name")\n  .many();\n\n// This generates SQL similar to:\n// SELECT posts.*, users.name FROM posts\n// INNER JOIN users ON posts.userId = users.id AND users.isActive = true\n'})}),"\n",(0,i.jsx)(s.p,{children:"The callback receives a query builder that supports all where methods:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Multiple conditions\nawait sql\n  .query("posts")\n  .join("users", "posts.userId", "users.id", (q) =>\n    q.where("users.isActive", true).andWhere("users.verified", true)\n  )\n  .many();\n\n// Using different operators\nawait sql\n  .query("posts")\n  .innerJoin("users", "posts.userId", "users.id", (q) =>\n    q\n      .whereIn("users.status", ["active", "pending"])\n      .andWhere("users.age", ">=", 18)\n  )\n  .many();\n\n// Works with all join types: join, innerJoin, leftJoin, rightJoin, fullJoin\nawait sql\n  .query("posts")\n  .leftJoin("comments", "comments.postId", "posts.id", (q) =>\n    q.where("comments.approved", true)\n  )\n  .many();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"ctes-common-table-expressions",children:"CTEs (Common Table Expressions)"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const users = await sql\n  .query("users")\n  .with("users_cte", (qb) => qb.select("name").where("isActive", true))\n  .many();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"truncate",children:"Truncate"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").truncate();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"soft-delete",children:"Soft Delete"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").softDelete({ column: "deleted_at" });\n'})}),"\n",(0,i.jsx)(s.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Column values are typed as ",(0,i.jsx)(s.code,{children:"any"})," (no model column type inference)"]}),"\n",(0,i.jsx)(s.li,{children:"No decorator or relation support"}),"\n",(0,i.jsx)(s.li,{children:"Use with caution in app logic"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"comparison-to-modelquerybuilder",children:"Comparison to ModelQueryBuilder"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Type Safety:"})," QueryBuilder infers column names from selects; ModelQueryBuilder infers both names and types from the model."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Decorator/Relation Support:"})," Only ModelQueryBuilder supports model decorators and relations."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Use Case:"})," Use QueryBuilder for raw SQL, migrations, or admin scripts."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"full-api-reference",children:"Full API Reference"}),"\n",(0,i.jsx)(s.h3,{id:"filtering-1",children:"Filtering"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"where"}),", ",(0,i.jsx)(s.code,{children:"orWhere"}),", ",(0,i.jsx)(s.code,{children:"andWhere"}),", ",(0,i.jsx)(s.code,{children:"whereNot"}),", ",(0,i.jsx)(s.code,{children:"andWhereNot"}),", ",(0,i.jsx)(s.code,{children:"orWhereNot"}),", ",(0,i.jsx)(s.code,{children:"whereIn"}),", ",(0,i.jsx)(s.code,{children:"whereNotIn"}),", ",(0,i.jsx)(s.code,{children:"whereNull"}),", ",(0,i.jsx)(s.code,{children:"whereNotNull"}),", ",(0,i.jsx)(s.code,{children:"whereBetween"}),", ",(0,i.jsx)(s.code,{children:"whereLike"}),", ",(0,i.jsx)(s.code,{children:"whereNotLike"}),", ",(0,i.jsx)(s.code,{children:"andWhereLike"}),", ",(0,i.jsx)(s.code,{children:"andWhereNotLike"}),", ",(0,i.jsx)(s.code,{children:"orWhereLike"}),", ",(0,i.jsx)(s.code,{children:"orWhereNotLike"}),", ",(0,i.jsx)(s.code,{children:"whereExists"}),", ",(0,i.jsx)(s.code,{children:"whereNotExists"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").where("email", "like", "%@example.com").many();\nawait sql.query("users").whereIn("status", ["active", "pending"]).many();\nawait sql.query("users").whereNull("deletedAt").many();\nawait sql.query("users").whereBetween("age", [18, 30]).many();\nawait sql.query("users").whereNot("name", "Alice").many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"subqueries--nested-conditions",children:"Subqueries & Nested Conditions"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Overloads on ",(0,i.jsx)(s.code,{children:"where"}),"/",(0,i.jsx)(s.code,{children:"andWhere"}),"/",(0,i.jsx)(s.code,{children:"orWhere"})," and ",(0,i.jsx)(s.code,{children:"whereIn"}),"/",(0,i.jsx)(s.code,{children:"whereNotIn"})," support callbacks and subqueries."]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Grouped conditions with a callback, this ignores everything that is not a where clause\nawait sql\n  .query("users")\n  .where((qb) => {\n    qb.where("age", ">", 18).orWhere("isActive", true);\n  })\n  .many();\n\n// Column compared to a subquery (defaults to IN)\nawait sql\n  .query("users")\n  .where("id", (sub) =>\n    sub.select("userId").from("posts").where("published", true)\n  )\n  .many();\n\n// Column compared to a subquery with explicit operator\nawait sql\n  .query("users")\n  .where("id", "not in", (sub) => sub.select("userId").from("posts"))\n  .many();\n\n// OR with subquery\nawait sql\n  .query("users")\n  .orWhere("id", (sub) => sub.select("ownerId").from("teams"))\n  .many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"joins-2",children:"Joins"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"join"}),", ",(0,i.jsx)(s.code,{children:"leftJoin"}),", ",(0,i.jsx)(s.code,{children:"rightJoin"}),", ",(0,i.jsx)(s.code,{children:"innerJoin"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Basic join\nawait sql.query("posts").join("users", "posts.userId", "users.id").many();\n\n// Join with additional conditions via callback\nawait sql\n  .query("posts")\n  .join("users", "posts.userId", "users.id", (q) =>\n    q.where("users.isActive", true)\n  )\n  .many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"group-by--having",children:"Group By & Having"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"groupBy"}),", ",(0,i.jsx)(s.code,{children:"having"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").groupBy("status").having("COUNT(*)", ">", 1).many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"unions",children:"Unions"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"union"}),", ",(0,i.jsx)(s.code,{children:"unionAll"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").select("name").union("SELECT name FROM users").many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"aggregates",children:"Aggregates"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"getCount"}),", ",(0,i.jsx)(s.code,{children:"getMax"}),", ",(0,i.jsx)(s.code,{children:"getMin"}),", ",(0,i.jsx)(s.code,{children:"getAvg"}),", ",(0,i.jsx)(s.code,{children:"getSum"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const count = await sql.query("users").getCount();\nconst maxAge = await sql.query("users").getMax("age");\n'})}),"\n",(0,i.jsx)(s.h3,{id:"select--raw-select",children:"Select & Raw Select"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"select"}),", ",(0,i.jsx)(s.code,{children:"selectRaw"}),", ",(0,i.jsx)(s.code,{children:"selectFunc"}),", ",(0,i.jsx)(s.code,{children:"clearSelect"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").select("name", "email").many();\nawait sql.query("users").selectRaw("count(*) as count").one();\nawait sql.query("users").selectFunc("count", "*", "total").one();\nawait sql.query("users").clearSelect().many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"type-safe-selects",children:"Type-Safe Selects"}),"\n",(0,i.jsx)(s.p,{children:"The QueryBuilder provides type inference for select methods. Column names and aliases are tracked, giving you autocomplete and type checking on the result."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Inferred type: { name: any, userEmail: any } | null\nconst user = await sql\n  .query("users")\n  .select("name", ["email", "userEmail"])\n  .one();\n\nconsole.log(user?.name);      // \u2713 Valid\nconsole.log(user?.userEmail); // \u2713 Valid (aliased)\n'})}),"\n",(0,i.jsxs)(s.h4,{id:"explicit-types-with-selectraw",children:["Explicit Types with ",(0,i.jsx)(s.code,{children:"selectRaw"})]}),"\n",(0,i.jsx)(s.p,{children:"Use the generic parameter to specify exact types:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Inferred type: { total: number } | null\nconst result = await sql\n  .query("users")\n  .selectRaw<{ total: number }>("count(*) as total")\n  .one();\n\nconsole.log(result?.total); // number\n'})}),"\n",(0,i.jsxs)(s.h4,{id:"type-safe-sql-functions-with-selectfunc",children:["Type-Safe SQL Functions with ",(0,i.jsx)(s.code,{children:"selectFunc"})]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"selectFunc"})," method auto-infers return types based on the function name:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Return types are auto-inferred!\nconst stats = await sql\n  .query("users")\n  .selectFunc("count", "*", "userCount")   // userCount: number\n  .selectFunc("avg", "age", "avgAge")      // avgAge: number\n  .selectFunc("upper", "name", "upperName") // upperName: string\n  .one();\n\nconsole.log(stats?.userCount); // number\nconsole.log(stats?.avgAge);    // number\nconsole.log(stats?.upperName); // string\n'})}),"\n",(0,i.jsx)(s.h4,{id:"type-safe-json-selects",children:"Type-Safe JSON Selects"}),"\n",(0,i.jsx)(s.p,{children:"JSON selection methods also support type inference:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Inferred type: { userName: any } | null\nconst user = await sql\n  .query("users")\n  .selectJson("data", "$.user.name", "userName")\n  .one();\n\n// With explicit type\nconst typed = await sql\n  .query("users")\n  .selectJson<string, "userName">("data", "$.user.name", "userName")\n  .one();\n// typed?.userName is string\n'})}),"\n",(0,i.jsx)(s.h4,{id:"subquery-type-safety",children:"Subquery Type Safety"}),"\n",(0,i.jsx)(s.p,{children:"Subqueries also track their alias:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Inferred type: { latestPost: any } | null\nconst user = await sql\n  .query("users")\n  .select((sub) => {\n    sub.select("title").from("posts").where("userId", 1).limit(1);\n  }, "latestPost")\n  .one();\n\n// With explicit type\nconst typed = await sql\n  .query("users")\n  .select<string, "latestPost">((sub) => {\n    sub.select("title").from("posts").limit(1);\n  }, "latestPost")\n  .one();\n// typed?.latestPost is string\n'})}),"\n",(0,i.jsx)(s.h4,{id:"chaining-selects",children:"Chaining Selects"}),"\n",(0,i.jsx)(s.p,{children:"Types accumulate when chaining multiple select calls:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Inferred type: { name: any, total: number, avgAge: number }\nconst result = await sql\n  .query("users")\n  .select("name")\n  .selectFunc("count", "*", "total")\n  .selectFunc("avg", "age", "avgAge")\n  .one();\n'})}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Method"}),(0,i.jsx)(s.th,{children:"Inferred Type"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:'select("col")'})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ col: any }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:'select(["col", "alias"])'})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ alias: any }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"selectRaw<T>(...)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"T"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:'selectFunc("count", col, alias)'})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ [alias]: number }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:'selectFunc("sum", col, alias)'})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ [alias]: number }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:'selectFunc("avg", col, alias)'})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ [alias]: number }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:'selectFunc("upper", col, alias)'})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ [alias]: string }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:'selectFunc("lower", col, alias)'})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ [alias]: string }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"selectJson(col, path, alias)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ [alias]: any }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"selectJsonText(col, path, alias)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ [alias]: string }"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"select(cb, alias)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"{ [alias]: any }"})})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"selectraw-with-cast",children:"selectRaw with CAST"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"CAST"})," expressions are fully supported. The type after ",(0,i.jsx)(s.code,{children:"AS"})," inside ",(0,i.jsx)(s.code,{children:"CAST()"})," is recognized as a SQL type, not an alias:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// CAST type is not treated as alias\nawait sql.query("users").selectRaw("CAST(age AS VARCHAR) as ageString").one();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"pluck-1",children:"Pluck"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"pluck"})}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const names = await sql.query("users").pluck("name");\n'})}),"\n",(0,i.jsx)(s.h3,{id:"pagination-1",children:"Pagination"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"paginate"}),", ",(0,i.jsx)(s.code,{children:"limit"}),", ",(0,i.jsx)(s.code,{children:"offset"}),", ",(0,i.jsx)(s.code,{children:"chunk"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const page = await sql.query("users").paginate(1, 10);\nawait sql.query("users").limit(5).offset(10).many();\n\n// Process large datasets in chunks\nfor await (const users of sql.query("users").chunk(100)) {\n  // Process each chunk of 100 users\n  console.log(`Processing ${users.length} users...`);\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"streaming-experimental",children:"Streaming (experimental)"}),"\n",(0,i.jsx)(s.p,{children:"Process query results as a stream without loading everything at once. No hooks or serialization are run."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Async generator\nfor await (const user of await sql.query("users").stream()) {\n  console.log(`Processing user: ${user.name}`);\n}\n\n// Node.js Readable stream\nconst stream = await sql.query("users").stream();\nstream.on("data", (user) => console.log(user));\nstream.on("end", () => console.log("Done"));\n'})}),"\n",(0,i.jsx)(s.h3,{id:"locking",children:"Locking"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"lockForUpdate"}),", ",(0,i.jsx)(s.code,{children:"forShare"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql.query("users").lockForUpdate().many();\nawait sql.query("users").forShare().many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"ctes-common-table-expressions-1",children:"CTEs (Common Table Expressions)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"with"}),", ",(0,i.jsx)(s.code,{children:"withRecursive"}),", ",(0,i.jsx)(s.code,{children:"withMaterialized"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'await sql\n  .query("users")\n  // Normal CTE\n  .with("users_cte", (qb) => qb.select("name"))\n  // Recursive CTE\n  .withRecursive("users_cte", (qb) => qb.select("name"))\n  // Materialized CTE (PostgreSQL/CockroachDB only)\n  .withMaterialized("users_cte", (qb) => qb.select("name"))\n  .many();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"copying--query-output",children:"Copying & Query Output"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"copy"}),", ",(0,i.jsx)(s.code,{children:"toQuery"}),", ",(0,i.jsx)(s.code,{children:"unWrap"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const qb = sql.query("users").where("isActive", true);\nconst qbCopy = qb.clone();\nconst sqlString = qb.toQuery();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"raw-queries",children:"Raw Queries"}),"\n",(0,i.jsxs)(s.p,{children:["You can use the ",(0,i.jsx)(s.code,{children:"rawQuery"})," method to execute raw SQL queries."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const users = await sql.rawQuery("SELECT * FROM users");\n'})}),"\n",(0,i.jsx)(s.h3,{id:"raw-query-with-parameters",children:"Raw Query with Parameters"}),"\n",(0,i.jsxs)(s.p,{children:["You can use the ",(0,i.jsx)(s.code,{children:"rawQuery"})," method to execute raw SQL queries with parameters. You can use ",(0,i.jsx)(s.code,{children:"?"})," as a placeholder for the parameters regardless of the database dialect. You can still use the database specific placeholder syntax."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'// Generic placeholder syntax\nconst users = await sql.rawQuery("SELECT * FROM users WHERE age > ?", [18]);\n\n// Database specific placeholder syntax\nconst users = await sql.rawQuery("SELECT * FROM users WHERE age > $1", [18]);\n'})}),"\n",(0,i.jsx)(s.h3,{id:"querybuilder-only",children:"QueryBuilder Only"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All methods are available on QueryBuilder, but no model/relation helpers."}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.p,{children:["Next: ",(0,i.jsx)(s.a,{href:"/hysteria-orm/databases/sql/relations/overview",children:"Relations"})]})]})}function u(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>l});var r=n(6540);const i={},a=r.createContext(i);function t(e){const s=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);
"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[8452],{2316:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"databases/sql/standard-methods/basics","title":"Standard Model Methods","description":"Hysteria ORM models provide a rich set of static methods for interacting with your database. These methods are fully type-safe and support advanced options.","source":"@site/docs/databases/sql/standard-methods/basics.md","sourceDirName":"databases/sql/standard-methods","slug":"/databases/sql/standard-methods/basics","permalink":"/hysteria-orm/databases/sql/standard-methods/basics","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/standard-methods/basics.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Standard Model Methods","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Case Conventions","permalink":"/hysteria-orm/databases/sql/models/case-conventions"},"next":{"title":"Query Builder Basics","permalink":"/hysteria-orm/databases/sql/query-builder/basics"}}');var i=s(4848),t=s(8453);const d={title:"Standard Model Methods",sidebar_position:1},a="Standard Model Methods",l={},c=[{value:"CRUD Methods",id:"crud-methods",level:2},{value:"<code>find</code>",id:"find",level:3},{value:"<code>findOne</code>",id:"findone",level:3},{value:"<code>findOneOrFail</code>",id:"findoneorfail",level:3},{value:"<code>insert</code>",id:"insert",level:3},{value:"<code>insertMany</code>",id:"insertmany",level:3},{value:"<code>updateRecord</code>",id:"updaterecord",level:3},{value:"<code>deleteRecord</code>",id:"deleterecord",level:3},{value:"<code>firstOrInsert</code>",id:"firstorinsert",level:3},{value:"<code>upsert</code>",id:"upsert",level:3},{value:"<code>upsertMany</code>",id:"upsertmany",level:3},{value:"Where Clause Operations",id:"where-clause-operations",level:2},{value:"Simple Equality",id:"simple-equality",level:3},{value:"Comparison Operators",id:"comparison-operators",level:3},{value:"Range Operators",id:"range-operators",level:3},{value:"Null Checks",id:"null-checks",level:3},{value:"Pattern Matching",id:"pattern-matching",level:3},{value:"Array Operators",id:"array-operators",level:3},{value:"Regular Expression",id:"regular-expression",level:3},{value:"Logical Operators",id:"logical-operators",level:3},{value:"<code>$and</code> - Combine conditions with AND",id:"and---combine-conditions-with-and",level:4},{value:"<code>$or</code> - Combine conditions with OR",id:"or---combine-conditions-with-or",level:4},{value:"Complex Nested Conditions",id:"complex-nested-conditions",level:3},{value:"Operators Reference",id:"operators-reference",level:3},{value:"Best Practices",id:"best-practices",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"standard-model-methods",children:"Standard Model Methods"})}),"\n",(0,i.jsx)(n.p,{children:"Hysteria ORM models provide a rich set of static methods for interacting with your database. These methods are fully type-safe and support advanced options.\nStandard methods are type safe since only model columns are allowed to be selected."}),"\n",(0,i.jsx)(n.h2,{id:"crud-methods",children:"CRUD Methods"}),"\n",(0,i.jsx)(n.h3,{id:"find",children:(0,i.jsx)(n.code,{children:"find"})}),"\n",(0,i.jsx)(n.p,{children:"Fetch multiple records matching criteria."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const users = await User.find({ where: { status: \'active\' } });\n\nconst usersWithNameAndEmail = await User.find({\n  select: ["name", "email"],\n}); // { name: string, email: string }[]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"findone",children:(0,i.jsx)(n.code,{children:"findOne"})}),"\n",(0,i.jsx)(n.p,{children:"Fetch a single record matching criteria."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const user = await User.findOne({ where: { email: \'john@example.com\' } });\n\nconst userWithNameAndEmail = await User.findOne({\n  select: ["name", "email"],\n}); // { name: string, email: string } | null\n'})}),"\n",(0,i.jsx)(n.h3,{id:"findoneorfail",children:(0,i.jsx)(n.code,{children:"findOneOrFail"})}),"\n",(0,i.jsx)(n.p,{children:"Fetch a single record or throw if not found."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const user = await User.findOneOrFail({ where: { email: 'john@example.com' } });\n"})}),"\n",(0,i.jsx)(n.h3,{id:"insert",children:(0,i.jsx)(n.code,{children:"insert"})}),"\n",(0,i.jsx)(n.p,{children:"Insert a new record."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const user = await User.insert({ name: 'John', email: 'john@example.com' });\n"})}),"\n",(0,i.jsx)(n.h3,{id:"insertmany",children:(0,i.jsx)(n.code,{children:"insertMany"})}),"\n",(0,i.jsx)(n.p,{children:"Insert multiple records."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const users = await User.insertMany([\n  { name: 'John', email: 'john@example.com' },\n  { name: 'Jane', email: 'jane@example.com' },\n]);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"updaterecord",children:(0,i.jsx)(n.code,{children:"updateRecord"})}),"\n",(0,i.jsx)(n.p,{children:"Update a record by primary key."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"user.name = 'Johnny';\nconst updated = await User.updateRecord(user);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"deleterecord",children:(0,i.jsx)(n.code,{children:"deleteRecord"})}),"\n",(0,i.jsx)(n.p,{children:"Delete a record by primary key."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"await User.deleteRecord(user);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"firstorinsert",children:(0,i.jsx)(n.code,{children:"firstOrInsert"})}),"\n",(0,i.jsx)(n.p,{children:"Find a record or create it if it doesn't exist."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// First argument: search criteria\n// Second argument: data to insert if not found\nconst user = await User.firstOrInsert(\n  { email: 'john@example.com' },\n  { name: 'John', email: 'john@example.com', status: 'active' }\n);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"upsert",children:(0,i.jsx)(n.code,{children:"upsert"})}),"\n",(0,i.jsx)(n.p,{children:"Insert or update a record based on conflict keys (QueryBuilder only)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const [post] = await sql.query('posts').upsert(\n  { id: uuid, title: 'Title', content: 'Content' },  // data\n  { id: uuid },                                       // conflict keys\n  { returning: ['id', 'title'] }                      // options\n);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"upsertmany",children:(0,i.jsx)(n.code,{children:"upsertMany"})}),"\n",(0,i.jsx)(n.p,{children:"Insert or update multiple records (QueryBuilder only)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"await sql.query('posts').upsertMany(\n  ['id'],                                             // conflict columns\n  ['title', 'content'],                               // columns to update on conflict\n  [\n    { id: uuid1, title: 'First', content: 'Content 1' },\n    { id: uuid2, title: 'Second', content: 'Content 2' },\n  ]\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"where-clause-operations",children:"Where Clause Operations"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"where"})," clause in ",(0,i.jsx)(n.code,{children:"find"}),", ",(0,i.jsx)(n.code,{children:"findOne"}),", and ",(0,i.jsx)(n.code,{children:"findOneOrFail"})," supports a rich set of operators for filtering data. You can use simple equality, comparison operators, pattern matching, and complex nested conditions."]}),"\n",(0,i.jsx)(n.h3,{id:"simple-equality",children:"Simple Equality"}),"\n",(0,i.jsx)(n.p,{children:"The simplest form is direct field-value matching:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Simple equality\nconst users = await User.find({\n  where: { email: 'john@example.com' }\n});\n\n// Multiple fields (AND logic)\nconst users = await User.find({\n  where: { status: 'active', role: 'admin' }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"comparison-operators",children:"Comparison Operators"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"op"})," property to specify comparison operations:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Equal ($eq) - same as simple equality\nconst users = await User.find({\n  where: { age: { op: '$eq', value: 25 } }\n});\n\n// Not equal ($ne)\nconst users = await User.find({\n  where: { status: { op: '$ne', value: 'inactive' } }\n});\n\n// Greater than ($gt)\nconst users = await User.find({\n  where: { age: { op: '$gt', value: 18 } }\n});\n\n// Greater than or equal ($gte)\nconst users = await User.find({\n  where: { salary: { op: '$gte', value: 50000 } }\n});\n\n// Less than ($lt)\nconst users = await User.find({\n  where: { age: { op: '$lt', value: 65 } }\n});\n\n// Less than or equal ($lte)\nconst users = await User.find({\n  where: { balance: { op: '$lte', value: 1000 } }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"range-operators",children:"Range Operators"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Between\nconst users = await User.find({\n  where: { age: { op: '$between', value: [18, 30] } }\n});\n\n// Not between\nconst users = await User.find({\n  where: { age: { op: '$not between', value: [18, 30] } }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"null-checks",children:"Null Checks"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Is null\nconst users = await User.find({\n  where: { deletedAt: { op: '$is null' } }\n});\n\n// Is not null\nconst users = await User.find({\n  where: { email: { op: '$is not null' } }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// LIKE\nconst users = await User.find({\n  where: { name: { op: '$like', value: 'John%' } }\n});\n\n// NOT LIKE\nconst users = await User.find({\n  where: { email: { op: '$not like', value: '%spam%' } }\n});\n\n// ILIKE (case-insensitive, PostgreSQL)\nconst users = await User.find({\n  where: { name: { op: '$ilike', value: '%john%' } }\n});\n\n// NOT ILIKE\nconst users = await User.find({\n  where: { name: { op: '$not ilike', value: '%test%' } }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"array-operators",children:"Array Operators"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// IN - match any value in array\nconst users = await User.find({\n  where: { status: { op: '$in', value: ['active', 'pending'] } }\n});\n\n// NOT IN - exclude values in array\nconst users = await User.find({\n  where: { role: { op: '$nin', value: ['banned', 'suspended'] } }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"regular-expression",children:"Regular Expression"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// REGEXP\nconst users = await User.find({\n  where: { email: { op: '$regexp', value: /^[a-z]+@example\\.com$/ } }\n});\n\n// NOT REGEXP\nconst users = await User.find({\n  where: { name: { op: '$not regexp', value: /^test/i } }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"logical-operators",children:"Logical Operators"}),"\n",(0,i.jsxs)(n.h4,{id:"and---combine-conditions-with-and",children:[(0,i.jsx)(n.code,{children:"$and"})," - Combine conditions with AND"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const users = await User.find({\n  where: {\n    $and: [\n      { status: 'active' },\n      { age: { op: '$gte', value: 18 } }\n    ]\n  }\n});\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"or---combine-conditions-with-or",children:[(0,i.jsx)(n.code,{children:"$or"})," - Combine conditions with OR"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const users = await User.find({\n  where: {\n    $or: [\n      { role: 'admin' },\n      { role: 'moderator' }\n    ]\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"complex-nested-conditions",children:"Complex Nested Conditions"}),"\n",(0,i.jsxs)(n.p,{children:["You can nest ",(0,i.jsx)(n.code,{children:"$and"})," and ",(0,i.jsx)(n.code,{children:"$or"})," operators to create sophisticated queries:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Find users who are:\n// (active AND age >= 18) OR (premium AND verified)\nconst users = await User.find({\n  where: {\n    $or: [\n      {\n        $and: [\n          { status: 'active' },\n          { age: { op: '$gte', value: 18 } }\n        ]\n      },\n      {\n        $and: [\n          { isPremium: true },\n          { isVerified: true }\n        ]\n      }\n    ]\n  }\n});\n\n// Combine top-level fields with $or\nconst users = await User.find({\n  where: {\n    status: 'active',  // AND\n    $or: [\n      { name: { op: '$like', value: 'John%' } },\n      { name: { op: '$like', value: 'Jane%' } }\n    ]\n  }\n});\n\n// Deeply nested conditions\nconst users = await User.find({\n  where: {\n    $or: [\n      {\n        $and: [\n          { status: 'active' },\n          { age: { op: '$between', value: [20, 30] } }\n        ]\n      },\n      {\n        $and: [\n          { status: 'inactive' },\n          {\n            $or: [\n              { age: { op: '$gt', value: 50 } },\n              { name: { op: '$like', value: 'VIP%' } }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"operators-reference",children:"Operators Reference"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operator"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Example Value"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$eq"})}),(0,i.jsx)(n.td,{children:"Equal to"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$eq', value: 'active' }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$ne"})}),(0,i.jsx)(n.td,{children:"Not equal to"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$ne', value: 'deleted' }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$gt"})}),(0,i.jsx)(n.td,{children:"Greater than"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$gt', value: 18 }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$gte"})}),(0,i.jsx)(n.td,{children:"Greater than or equal"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$gte', value: 0 }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$lt"})}),(0,i.jsx)(n.td,{children:"Less than"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$lt', value: 100 }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$lte"})}),(0,i.jsx)(n.td,{children:"Less than or equal"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$lte', value: 999 }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$between"})}),(0,i.jsx)(n.td,{children:"Between two values"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$between', value: [10, 20] }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$not between"})}),(0,i.jsx)(n.td,{children:"Not between two values"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$not between', value: [10, 20] }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$is null"})}),(0,i.jsx)(n.td,{children:"Is NULL"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$is null' }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$is not null"})}),(0,i.jsx)(n.td,{children:"Is not NULL"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$is not null' }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$like"})}),(0,i.jsx)(n.td,{children:"LIKE pattern"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$like', value: '%test%' }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$not like"})}),(0,i.jsx)(n.td,{children:"NOT LIKE pattern"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$not like', value: '%spam%' }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$ilike"})}),(0,i.jsx)(n.td,{children:"Case-insensitive LIKE"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$ilike', value: '%John%' }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$not ilike"})}),(0,i.jsx)(n.td,{children:"Case-insensitive NOT LIKE"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$not ilike', value: '%test%' }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$in"})}),(0,i.jsx)(n.td,{children:"In array"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$in', value: [1, 2, 3] }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$nin"})}),(0,i.jsx)(n.td,{children:"Not in array"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$nin', value: [4, 5, 6] }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$regexp"})}),(0,i.jsx)(n.td,{children:"Regular expression match"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$regexp', value: /pattern/ }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$not regexp"})}),(0,i.jsx)(n.td,{children:"Not matching regex"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ op: '$not regexp', value: /pattern/ }"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always use the static methods for database operations."}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"findOneOrFail"})," for required lookups."]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"firstOrInsert"})," and ",(0,i.jsx)(n.code,{children:"upsert"})," for idempotent operations."]}),"\n",(0,i.jsxs)(n.li,{children:["Prefer ",(0,i.jsx)(n.code,{children:"$and"})," and ",(0,i.jsx)(n.code,{children:"$or"})," for complex conditions to make your queries more readable."]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"$in"})," instead of multiple ",(0,i.jsx)(n.code,{children:"$or"})," conditions when checking against a list of values."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Next: ",(0,i.jsx)(n.a,{href:"/hysteria-orm/databases/sql/query-builder/basics",children:"Query Builder"})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>a});var r=s(6540);const i={},t=r.createContext(i);function d(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);
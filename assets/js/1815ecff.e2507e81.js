"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[8174],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},8604:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"databases/sql/advanced/json","title":"Advanced SQL Features: JSON Columns","description":"Store and query JSON data directly in your SQL tables. JSON columns are useful for flexible, semi-structured data that doesn\'t fit a rigid schema.","source":"@site/docs/databases/sql/advanced/json.md","sourceDirName":"databases/sql/advanced","slug":"/databases/sql/advanced/json","permalink":"/hysteria-orm/docs/databases/sql/advanced/json","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/advanced/json.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Advanced SQL Features: JSON Columns","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Advanced SQL Features: CTE","permalink":"/hysteria-orm/docs/databases/sql/advanced/cte"},"next":{"title":"SQLite JSON Limitations","permalink":"/hysteria-orm/docs/databases/sql/advanced/sqlite-json-limitations"}}');var r=t(4848),i=t(8453);const a={title:"Advanced SQL Features: JSON Columns",sidebar_position:2},l="JSON Columns",o={},d=[{value:"Feature Support Matrix",id:"feature-support-matrix",level:2},{value:"Basic JSON Filtering",id:"basic-json-filtering",level:2},{value:"Logical Operations (AND/OR)",id:"logical-operations-andor",level:2},{value:"Array and Object Filtering",id:"array-and-object-filtering",level:2},{value:"Data Variations",id:"data-variations",level:2},{value:"Bulk Operations",id:"bulk-operations",level:2},{value:"Advanced JSON Filters",id:"advanced-json-filters",level:2},{value:"Selecting JSON Columns",id:"selecting-json-columns",level:2},{value:"Cross-Database Notes",id:"cross-database-notes",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"json-columns",children:"JSON Columns"})}),"\n",(0,r.jsx)(n.p,{children:"Store and query JSON data directly in your SQL tables. JSON columns are useful for flexible, semi-structured data that doesn't fit a rigid schema."}),"\n",(0,r.jsx)(n.h2,{id:"feature-support-matrix",children:"Feature Support Matrix"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"PostgreSQL"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"MySQL/MariaDB"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"SQLite"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["Basic JSON equality (",(0,r.jsx)(n.code,{children:"whereJson"}),")"]}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Nested property match"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"~"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Array element match"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"~"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"AND/OR JSON conditions"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"~"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["JSON containment (",(0,r.jsx)(n.code,{children:"whereJsonContains"}),")"]}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2717"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"JSON IN/NOT IN"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Select JSON column"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["~ = Limited/partial support, see ",(0,r.jsx)(n.a,{href:"/hysteria-orm/docs/databases/sql/advanced/sqlite-json-limitations",children:"SQLite JSON Limitations"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"basic-json-filtering",children:"Basic JSON Filtering"}),"\n",(0,r.jsx)(n.p,{children:"Query for full JSON object equality or by nested properties."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Full object equality\nawait User.query().whereJson("json", { foo: "bar", arr: [1, 2, 3] }).first();\n\n// Nested property (works best in PostgreSQL/MySQL)\nawait User.query().whereJson("json", { profile: { info: { age: 42 } } } ).first();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"logical-operations-andor",children:"Logical Operations (AND/OR)"}),"\n",(0,r.jsxs)(n.p,{children:["Combine multiple JSON conditions using ",(0,r.jsx)(n.code,{children:"andWhereJson"})," and ",(0,r.jsx)(n.code,{children:"orWhereJson"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// AND combination\nawait User.query()\n  .whereJson("json", { logic: "A" })\n  .andWhereJson("json", { status: "active" })\n  .first();\n\n// OR combination\nawait User.query()\n  .whereJson("json", { logic: "A" })\n  .orWhereJson("json", { logic: "B" })\n  .many();\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," Complex AND/OR combinations are only fully supported in PostgreSQL/MySQL. SQLite has limited support. See ",(0,r.jsx)(n.a,{href:"/hysteria-orm/docs/databases/sql/advanced/sqlite-json-limitations",children:"SQLite JSON Limitations"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"array-and-object-filtering",children:"Array and Object Filtering"}),"\n",(0,r.jsx)(n.p,{children:"Query by array elements or nested object properties in JSON columns."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Array element match (best in PostgreSQL/MySQL)\nawait User.query().whereJson("json", { tags: ["frontend", "typescript"] }).first();\n\n// Nested object property\nawait User.query().whereJson("json", { user: { profile: { settings: { theme: "dark" } } } }).first();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"data-variations",children:"Data Variations"}),"\n",(0,r.jsx)(n.p,{children:"Insert and retrieve various JSON structures, including primitives and null."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const variants = [\n  { foo: "bar", arr: [1, 2, 3], nested: { a: 1 } },\n  { simple: "string value" },\n  { number: 12345 },\n  { bool: true },\n  null,\n];\nfor (const json of variants) {\n  await User.insert({ ...UserFactory.getCommonUserData(), json });\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"bulk-operations",children:"Bulk Operations"}),"\n",(0,r.jsxs)(n.p,{children:["Insert many users with different JSON values and query using ",(0,r.jsx)(n.code,{children:"whereJson"})," or ",(0,r.jsx)(n.code,{children:"whereJsonIn"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'await User.insertMany([\n  { ...UserFactory.getCommonUserData(), json: { bulk: 1 } },\n  { ...UserFactory.getCommonUserData(), json: { bulk: 2 } },\n]);\n\nawait User.query().whereJson("json", { bulk: 1 }).first();\nawait User.query().whereJsonIn("json", [{ bulk: 1 }, { bulk: 2 }]).many();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-json-filters",children:"Advanced JSON Filters"}),"\n",(0,r.jsx)(n.p,{children:"Use containment and negation for advanced filtering (PostgreSQL/MySQL only)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Containment (not supported in SQLite)\nawait User.query().whereJsonContains("json", { arr: [1, 2, 3] }).first();\nawait User.query().whereJsonNotContains("json", { arr: [1, 2, 3] }).first();\n\n// Negation\nawait User.query().whereNotJson("json", { foo: "bar" }).first();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"selecting-json-columns",children:"Selecting JSON Columns"}),"\n",(0,r.jsx)(n.p,{children:"Select only the JSON column or combine with other columns."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Select only JSON\nawait User.query().select("json").where("email", "=", user.email).first();\n\n// Select JSON and another column\nawait User.query().select("json", "email").where("email", "=", user.email).first();\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cross-database-notes",children:"Cross-Database Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PostgreSQL/MySQL/MariaDB:"})," Full support for advanced JSON queries, containment, and deep property matching."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SQLite:"})," Only supports basic equality and simple queries. Advanced features (containment, deep property, array matching) are limited or unsupported. See ",(0,r.jsx)(n.a,{href:"/hysteria-orm/docs/databases/sql/advanced/sqlite-json-limitations",children:"SQLite JSON Limitations"})," for details."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"See also:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/hysteria-orm/docs/databases/sql/advanced/cte",children:"CTE"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/hysteria-orm/docs/databases/sql/advanced/transactions",children:"Transactions"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);
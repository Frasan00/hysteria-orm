"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[7538],{2479:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"databases/sql/relations/overview","title":"Relations Overview","description":"Hysteria ORM supports rich relation types between models:","source":"@site/docs/databases/sql/relations/overview.md","sourceDirName":"databases/sql/relations","slug":"/databases/sql/relations/overview","permalink":"/hysteria-orm/docs/databases/sql/relations/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/relations/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Relations Overview","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Create Migration Command","permalink":"/hysteria-orm/docs/databases/sql/cli/create-migration"},"next":{"title":"Caching","permalink":"/hysteria-orm/docs/databases/sql/advanced/caching"}}');var r=n(4848),i=n(8453);const a={title:"Relations Overview",sidebar_position:1},l="Relations Overview",d={},o=[{value:"Example Models",id:"example-models",level:2},{value:"Querying Relations",id:"querying-relations",level:2},{value:"Eager Loading",id:"eager-loading",level:3},{value:"Selecting Columns",id:"selecting-columns",level:3},{value:"Nested Relations",id:"nested-relations",level:3},{value:"Filtering on Relations",id:"filtering-on-relations",level:3},{value:"Limit and Offset",id:"limit-and-offset",level:3},{value:"Advanced relation queries",id:"advanced-relation-queries",level:3},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"relations-overview",children:"Relations Overview"})}),"\n",(0,r.jsx)(s.p,{children:"Hysteria ORM supports rich relation types between models:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Relation"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"belongsTo"})}),(0,r.jsx)(s.td,{children:"Inverse of hasOne/hasMany"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasOne"})}),(0,r.jsx)(s.td,{children:"One-to-one relationship"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasMany"})}),(0,r.jsx)(s.td,{children:"One-to-many relationship"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"manyToMany"})}),(0,r.jsx)(s.td,{children:"Many-to-many via join table"})]})]})]}),"\n",(0,r.jsxs)(s.p,{children:["Relations use batch loading\u2014one query per relation, only when ",(0,r.jsx)(s.code,{children:"load"})," is called."]}),"\n",(0,r.jsx)(s.admonition,{type:"caution",children:(0,r.jsx)(s.p,{children:"Loading too many relations can slow down your query. Be selective about what you load."})}),"\n",(0,r.jsx)(s.h2,{id:"example-models",children:"Example Models"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"class User extends Model {\n  @hasMany(() => Post, 'userId')\n  declare posts: Post[];\n\n  @manyToMany(() => Address, () => UserAddress, {\n    leftForeignKey: 'userId',\n    rightForeignKey: 'addressId',\n  })\n  declare addresses: Address[];\n}\n\nclass Post extends Model {\n  @column({ type: 'integer', primaryKey: true })\n  declare id: number;\n\n  @column({ type: 'integer' })\n  declare userId: number;\n\n  // Belongs to does not benefit from type inference by default for typescript limitations, it's adviced to use the generic type to avoid type errors\n  @belongsTo<typeof Post>(() => User, 'userId') // With the generic we are obligated to specify a model field\n  declare user: User;\n}\n\nclass Address extends Model {\n  @manyToMany(() => User, () => UserAddress, {\n    leftForeignKey: 'addressId',\n    rightForeignKey: 'userId',\n  })\n  declare users: User[];\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"querying-relations",children:"Querying Relations"}),"\n",(0,r.jsx)(s.admonition,{type:"important",children:(0,r.jsx)(s.p,{children:"Always select the foreign key in the relation query builder, otherwise the relation will not be filled."})}),"\n",(0,r.jsx)(s.h3,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts').many();\n"})}),"\n",(0,r.jsx)(s.h3,{id:"selecting-columns",children:"Selecting Columns"}),"\n",(0,r.jsxs)(s.p,{children:["The foreign key (",(0,r.jsx)(s.code,{children:"userId"}),") must be selected for relations to work:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts', (qb) =>\n  qb.select('id', 'title', 'userId')\n).many();\n"})}),"\n",(0,r.jsx)(s.h3,{id:"nested-relations",children:"Nested Relations"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts', (qb) =>\n  qb.load('user')\n).many();\n"})}),"\n",(0,r.jsx)(s.h3,{id:"filtering-on-relations",children:"Filtering on Relations"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts', (qb) =>\n  qb.where('title', 'Hello World')\n).many();\n"})}),"\n",(0,r.jsx)(s.h3,{id:"limit-and-offset",children:"Limit and Offset"}),"\n",(0,r.jsxs)(s.p,{children:["Limit and offset apply to the related models. Adding ",(0,r.jsx)(s.code,{children:"limit"})," or ",(0,r.jsx)(s.code,{children:"offset"})," creates a CTE internally."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts', (qb) =>\n  qb.where('title', 'Hello World').limit(10).offset(10)\n).many();\n"})}),"\n",(0,r.jsx)(s.h3,{id:"advanced-relation-queries",children:"Advanced relation queries"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:'const users = await User.query().load(\'posts\', (qb) =>\n  qb.annotate("max", "id", "maxId").load("user")\n).many();\n'})}),"\n",(0,r.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Use ",(0,r.jsx)(s.code,{children:"load"})," for batch relation loading."]}),"\n",(0,r.jsx)(s.li,{children:"Use callbacks for nested and filtered relations."}),"\n",(0,r.jsx)(s.li,{children:"Always define foreign keys explicitly for clarity."}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.p,{children:["Next: ",(0,r.jsx)(s.a,{href:"/hysteria-orm/docs/databases/sql/advanced/cte",children:"Advanced SQL Features"})]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var t=n(6540);const r={},i=t.createContext(r);function a(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);
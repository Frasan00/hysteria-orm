"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[3813],{4193:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"databases/sql/advanced/replication","title":"Advanced SQL Features: Read Replication","description":"Hysteria ORM provides built-in support for database read replication, allowing you to scale your read operations across multiple slave databases while ensuring all write operations go to the master. This is particularly useful for high-traffic applications that have more read operations than writes.","source":"@site/docs/databases/sql/advanced/replication.md","sourceDirName":"databases/sql/advanced","slug":"/databases/sql/advanced/replication","permalink":"/hysteria-orm/databases/sql/advanced/replication","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/advanced/replication.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Advanced SQL Features: Read Replication","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Model Embedding","permalink":"/hysteria-orm/databases/sql/advanced/model-embedding"},"next":{"title":"AdminJS (Experimental)","permalink":"/hysteria-orm/databases/sql/plugins/adminjs"}}');var i=a(4848),r=a(8453);const t={title:"Advanced SQL Features: Read Replication",sidebar_position:6},o="Read Replication",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Basic Configuration",id:"basic-configuration",level:2},{value:"Slave Selection Algorithms",id:"slave-selection-algorithms",level:2},{value:"Round Robin (Default)",id:"round-robin-default",level:3},{value:"Random",id:"random",level:3},{value:"Automatic Routing",id:"automatic-routing",level:2},{value:"Explicit Replication Mode",id:"explicit-replication-mode",level:2},{value:"Force Master for Reads",id:"force-master-for-reads",level:3},{value:"Force Slave for Reads",id:"force-slave-for-reads",level:3},{value:"With Query Builder",id:"with-query-builder",level:3},{value:"Important Considerations",id:"important-considerations",level:2},{value:"Replication Lag",id:"replication-lag",level:3},{value:"Transactions",id:"transactions",level:3},{value:"No Slaves Configured",id:"no-slaves-configured",level:3},{value:"Streaming Operations",id:"streaming-operations",level:2},{value:"Raw Queries",id:"raw-queries",level:2},{value:"Connection Management",id:"connection-management",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"read-replication",children:"Read Replication"})}),"\n",(0,i.jsx)(n.p,{children:"Hysteria ORM provides built-in support for database read replication, allowing you to scale your read operations across multiple slave databases while ensuring all write operations go to the master. This is particularly useful for high-traffic applications that have more read operations than writes."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Read replication in Hysteria ORM works by:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Automatically routing ",(0,i.jsx)(n.strong,{children:"read operations"})," (SELECT queries) to slave databases"]}),"\n",(0,i.jsxs)(n.li,{children:["Routing all ",(0,i.jsx)(n.strong,{children:"write operations"})," (INSERT, UPDATE, DELETE) to the master database"]}),"\n",(0,i.jsx)(n.li,{children:"Supporting multiple load-balancing algorithms (Round Robin and Random)"}),"\n",(0,i.jsx)(n.li,{children:"Providing explicit control over which database to use when needed"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,i.jsx)(n.p,{children:"Configure slaves when creating your SqlDataSource:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { SqlDataSource } from "hysteria-orm";\nimport { User } from "./models/user";\n\nconst sql = new SqlDataSource({\n  type: "postgres",\n  host: "master.db.com",\n  username: "root",\n  password: "password",\n  database: "mydb",\n\n  // Configure slave databases\n  replication: {\n    slaves: [\n      {\n        type: "postgres",\n        host: "slave1.db.com",\n        username: "root",\n        password: "password",\n        database: "mydb",\n      },\n      {\n        type: "postgres",\n        host: "slave2.db.com",\n        username: "root",\n        password: "password",\n        database: "mydb",\n      },\n    ],\n    slaveAlgorithm: "roundRobin",\n  },\n});\n\nawait sql.connect();\n\nawait sql.connect();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"slave-selection-algorithms",children:"Slave Selection Algorithms"}),"\n",(0,i.jsx)(n.h3,{id:"round-robin-default",children:"Round Robin (Default)"}),"\n",(0,i.jsx)(n.p,{children:"Distributes requests evenly across all slaves in sequence. Each slave gets an equal share of the traffic."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const sql = new SqlDataSource({\n  // ... connection config\n  replication: {\n    slaves: [\n      // ... slave configurations\n    ],\n    slaveAlgorithm: "roundRobin",\n  },\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use case:"})," Best for evenly distributed load when all slaves have similar capacity."]}),"\n",(0,i.jsx)(n.h3,{id:"random",children:"Random"}),"\n",(0,i.jsx)(n.p,{children:"Randomly selects a slave for each request."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const sql = new SqlDataSource({\n  // ... connection config\n  replication: {\n    slaves: [\n      // ... slave configurations\n    ],\n    slaveAlgorithm: "random",\n  },\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use case:"})," Useful for simple load distribution without tracking state."]}),"\n",(0,i.jsx)(n.h2,{id:"automatic-routing",children:"Automatic Routing"}),"\n",(0,i.jsx)(n.p,{children:"By default, Hysteria ORM automatically routes operations to the appropriate database:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Read operations \u2192 Automatically uses slaves or master as fallback\nconst users = await User.find();\nconst user = await User.findOne({ where: { id: 1 } });\nconst count = await User.query().getCount();\nconst paginated = await User.query().paginate(1, 10);\n\n// Write operations \u2192 Always uses master\nconst newUser = await User.insert({ name: "John", email: "john@example.com" });\nawait User.query().where("id", 1).update({ name: "Jane" });\nawait User.query().where("id", 1).delete();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"explicit-replication-mode",children:"Explicit Replication Mode"}),"\n",(0,i.jsxs)(n.p,{children:["You can override the automatic behavior using the ",(0,i.jsx)(n.code,{children:"replicationMode"})," option:"]}),"\n",(0,i.jsx)(n.h3,{id:"force-master-for-reads",children:"Force Master for Reads"}),"\n",(0,i.jsx)(n.p,{children:"Useful when you need strong consistency immediately after a write:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Write to master\nawait User.insert({ name: "John", email: "john@example.com" });\n\n// Force read from master (avoid replication lag)\nconst user = await User.find(\n  { where: { email: "john@example.com" } },\n  { replicationMode: "master" }\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"force-slave-for-reads",children:"Force Slave for Reads"}),"\n",(0,i.jsx)(n.p,{children:"Explicitly use slaves even when you have control flow that might default to master:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const users = await User.find(\n  {},\n  { replicationMode: "slave" }\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"with-query-builder",children:"With Query Builder"}),"\n",(0,i.jsxs)(n.p,{children:["The replication mode also works with the query builder using ",(0,i.jsx)(n.code,{children:"setReplicationMode()"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Force master for this read\nconst users = await User.query()\n  .setReplicationMode("master")\n  .where("active", true)\n  .many();\n\n// Force slave for this read\nconst count = await User.query()\n  .setReplicationMode("slave")\n  .getCount();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"replication-lag",children:"Replication Lag"}),"\n",(0,i.jsxs)(n.p,{children:["Slave databases may have a slight delay in receiving updates from the master. This is called ",(0,i.jsx)(n.strong,{children:"replication lag"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// This pattern can cause issues due to replication lag:\nconst user = await User.insert({ name: "John" }); // Writes to master\n\n// This might not find the user if slave hasn\'t replicated yet!\nconst found = await User.findOne({\n  where: { id: user.id }\n}); // Reads from slave\n\n// Solution: Force master read after write\nconst found = await User.findOne(\n  { where: { id: user.id } },\n  { replicationMode: "master" } // Read from master\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"transactions",children:"Transactions"}),"\n",(0,i.jsx)(n.p,{children:"All operations within a transaction use the master database, regardless of replication settings:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'await sql.startTransaction(async (trx) => {\n  // Both operations use master\n  const user = await User.insert({ name: "John" }, { trx });\n  const found = await User.findOne({ where: { id: user.id } }, { trx });\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"no-slaves-configured",children:"No Slaves Configured"}),"\n",(0,i.jsx)(n.p,{children:"If no slaves are configured, all operations automatically fall back to the master:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const sql = new SqlDataSource({\n  // ... connection config\n  replication: {\n    slaves: [],\n  },\n});\n\n// All operations use master\nconst users = await User.find(); // Uses master\n"})}),"\n",(0,i.jsx)(n.h2,{id:"streaming-operations",children:"Streaming Operations"}),"\n",(0,i.jsx)(n.p,{children:"Streaming operations also respect replication settings:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Streams from slave\nconst stream = await User.query().stream();\n\n// Streams from master\nconst stream = await User.query()\n  .setReplicationMode("master")\n  .stream();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"raw-queries",children:"Raw Queries"}),"\n",(0,i.jsx)(n.p,{children:"When using raw queries, write operations always use master, and read operations use slaves:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Uses master (INSERT)\nawait sql.query("users").insert({ name: "John", email: "john@example.com" });\n\n// Uses slave (SELECT)\nconst users = await sql.query("users").many();\n\n// Force master\nconst users = await sql.query("users")\n  .setReplicationMode("master")\n  .many();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"connection-management",children:"Connection Management"}),"\n",(0,i.jsx)(n.p,{children:"All slave connections are automatically managed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Connects to master and all slaves\nawait sql.connect();\n\n// Disconnects from master and all slaves\nawait sql.disconnect();\n"})}),"\n",(0,i.jsx)(n.p,{children:"If a slave fails to connect during initialization, an error will be thrown. Ensure all slave databases are accessible before connecting."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>o});var s=a(6540);const i={},r=s.createContext(i);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
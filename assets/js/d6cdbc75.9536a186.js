"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[3813],{4193:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"databases/sql/advanced/replication","title":"Advanced SQL Features: Read Replication","description":"Hysteria ORM provides built-in support for database read replication, allowing you to scale your read operations across multiple slave databases while ensuring all write operations go to the master. This is particularly useful for high-traffic applications that have more read operations than writes.","source":"@site/docs/databases/sql/advanced/replication.md","sourceDirName":"databases/sql/advanced","slug":"/databases/sql/advanced/replication","permalink":"/hysteria-orm/databases/sql/advanced/replication","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/advanced/replication.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Advanced SQL Features: Read Replication","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Model Embedding","permalink":"/hysteria-orm/databases/sql/advanced/model-embedding"},"next":{"title":"AdminJS (Experimental)","permalink":"/hysteria-orm/databases/sql/plugins/adminjs"}}');var r=a(4848),i=a(8453);const t={title:"Advanced SQL Features: Read Replication",sidebar_position:6},l="Read Replication",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Basic Configuration",id:"basic-configuration",level:2},{value:"Slave Selection Algorithms",id:"slave-selection-algorithms",level:2},{value:"Round Robin (Default)",id:"round-robin-default",level:3},{value:"Random",id:"random",level:3},{value:"Slave Failure Handling",id:"slave-failure-handling",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Behavior",id:"behavior",level:3},{value:"Without Failure Handler",id:"without-failure-handler",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Automatic Routing",id:"automatic-routing",level:2},{value:"Explicit Replication Mode",id:"explicit-replication-mode",level:2},{value:"Force Master for Reads",id:"force-master-for-reads",level:3},{value:"Force Slave for Reads",id:"force-slave-for-reads",level:3},{value:"With Query Builder",id:"with-query-builder",level:3},{value:"Important Considerations",id:"important-considerations",level:2},{value:"Replication Lag",id:"replication-lag",level:3},{value:"Transactions",id:"transactions",level:3},{value:"No Slaves Configured",id:"no-slaves-configured",level:3},{value:"Streaming Operations",id:"streaming-operations",level:2},{value:"Raw Queries",id:"raw-queries",level:2},{value:"Connection Management",id:"connection-management",level:2},{value:"Connection Initialization",id:"connection-initialization",level:3},{value:"Runtime Failures",id:"runtime-failures",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"read-replication",children:"Read Replication"})}),"\n",(0,r.jsx)(n.p,{children:"Hysteria ORM provides built-in support for database read replication, allowing you to scale your read operations across multiple slave databases while ensuring all write operations go to the master. This is particularly useful for high-traffic applications that have more read operations than writes."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Read replication in Hysteria ORM works by:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Automatically routing ",(0,r.jsx)(n.strong,{children:"read operations"})," (SELECT queries) to slave databases"]}),"\n",(0,r.jsxs)(n.li,{children:["Routing all ",(0,r.jsx)(n.strong,{children:"write operations"})," (INSERT, UPDATE, DELETE) to the master database"]}),"\n",(0,r.jsx)(n.li,{children:"Supporting multiple load-balancing algorithms (Round Robin and Random)"}),"\n",(0,r.jsx)(n.li,{children:"Providing explicit control over which database to use when needed"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Configure slaves when creating your SqlDataSource:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { SqlDataSource } from "hysteria-orm";\nimport { User } from "./models/user";\n\nconst sql = new SqlDataSource({\n  type: "postgres",\n  host: "master.db.com",\n  username: "root",\n  password: "password",\n  database: "mydb",\n\n  // Configure slave databases\n  replication: {\n    slaves: [\n      {\n        type: "postgres",\n        host: "slave1.db.com",\n        username: "root",\n        password: "password",\n        database: "mydb",\n      },\n      {\n        type: "postgres",\n        host: "slave2.db.com",\n        username: "root",\n        password: "password",\n        database: "mydb",\n      },\n    ],\n    slaveAlgorithm: "roundRobin",\n  },\n});\n\nawait sql.connect();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"slave-selection-algorithms",children:"Slave Selection Algorithms"}),"\n",(0,r.jsx)(n.h3,{id:"round-robin-default",children:"Round Robin (Default)"}),"\n",(0,r.jsx)(n.p,{children:"Distributes requests evenly across all slaves in sequence. Each slave gets an equal share of the traffic."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const sql = new SqlDataSource({\n  // ... connection config\n  replication: {\n    slaves: [\n      // ... slave configurations\n    ],\n    slaveAlgorithm: "roundRobin",\n  },\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use case:"})," Best for evenly distributed load when all slaves have similar capacity."]}),"\n",(0,r.jsx)(n.h3,{id:"random",children:"Random"}),"\n",(0,r.jsx)(n.p,{children:"Randomly selects a slave for each request."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const sql = new SqlDataSource({\n  // ... connection config\n  replication: {\n    slaves: [\n      // ... slave configurations\n    ],\n    slaveAlgorithm: "random",\n  },\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use case:"})," Useful for simple load distribution without tracking state."]}),"\n",(0,r.jsx)(n.h2,{id:"slave-failure-handling",children:"Slave Failure Handling"}),"\n",(0,r.jsx)(n.p,{children:"Hysteria ORM provides a callback mechanism to handle slave server failures gracefully. When a slave fails during a read operation, you can define custom behavior such as logging, alerting, or metrics collection, and the system will automatically fall back to the master database."}),"\n",(0,r.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Configure the failure handler when creating your SqlDataSource:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { SqlDataSource } from "hysteria-orm";\nimport logger from "./logger";\n\nconst sql = new SqlDataSource({\n  type: "postgres",\n  host: "master.db.com",\n  username: "root",\n  password: "password",\n  database: "mydb",\n\n  replication: {\n    slaves: [\n      {\n        type: "postgres",\n        host: "slave1.db.com",\n        username: "root",\n        password: "password",\n        database: "mydb",\n      },\n      {\n        type: "postgres",\n        host: "slave2.db.com",\n        username: "root",\n        password: "password",\n        database: "mydb",\n      },\n    ],\n    slaveAlgorithm: "roundRobin",\n\n    // Handle slave failures\n    onSlaveServerFailure: async (error: Error) => {\n      logger.error({ error }, "Slave server failure detected");\n      // Send alert, update metrics, etc.\n    },\n  },\n});\n\nawait sql.connect();\n'})}),"\n",(0,r.jsx)(n.h3,{id:"behavior",children:"Behavior"}),"\n",(0,r.jsx)(n.p,{children:"When a slave fails:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Callback Invocation"}),": The ",(0,r.jsx)(n.code,{children:"onSlaveServerFailure"})," callback is invoked with the error"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Fallback"}),": After the callback completes, the operation automatically falls back to the master database"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transparent Recovery"}),": The application continues functioning without interruption"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// If slave1 fails during this operation:\nconst users = await User.find();\n// 1. onSlaveServerFailure is called with the error\n// 2. Query is automatically retried on master\n// 3. Users are returned successfully\n"})}),"\n",(0,r.jsx)(n.h3,{id:"without-failure-handler",children:"Without Failure Handler"}),"\n",(0,r.jsxs)(n.p,{children:["If you don't provide an ",(0,r.jsx)(n.code,{children:"onSlaveServerFailure"})," callback, errors are thrown as usual:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const sql = new SqlDataSource({\n  // ... connection config\n  replication: {\n    slaves: [\n      // ... slave configurations\n    ],\n    // No onSlaveServerFailure callback\n  },\n});\n\n// If a slave fails, the error is thrown\nconst users = await User.find(); // Throws error if slave fails\n"})}),"\n",(0,r.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Monitoring and Alerting"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'replication: {\n  slaves: [/* ... */],\n  onSlaveServerFailure: async (error) => {\n    await monitoring.sendAlert({\n      severity: "high",\n      message: "Database slave failure",\n      error: error.message,\n    });\n  },\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Metrics Collection"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'replication: {\n  slaves: [/* ... */],\n  onSlaveServerFailure: async (error) => {\n    metrics.increment("db.slave.failure");\n    logger.error({ error }, "Slave failure");\n  },\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Graceful Degradation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'let slaveFailureCount = 0;\n\nreplication: {\n  slaves: [/* ... */],\n  onSlaveServerFailure: async (error) => {\n    slaveFailureCount++;\n    if (slaveFailureCount > 10) {\n      // Trigger circuit breaker or disable slave routing\n      await notifyOps("Multiple slave failures detected");\n    }\n  },\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"automatic-routing",children:"Automatic Routing"}),"\n",(0,r.jsx)(n.p,{children:"By default, Hysteria ORM automatically routes operations to the appropriate database:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Read operations \u2192 Automatically uses slaves or master as fallback\nconst users = await User.find();\nconst user = await User.findOne({ where: { id: 1 } });\nconst count = await User.query().getCount();\nconst paginated = await User.query().paginate(1, 10);\n\n// Write operations \u2192 Always uses master\nconst newUser = await User.insert({ name: "John", email: "john@example.com" });\nawait User.query().where("id", 1).update({ name: "Jane" });\nawait User.query().where("id", 1).delete();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"explicit-replication-mode",children:"Explicit Replication Mode"}),"\n",(0,r.jsxs)(n.p,{children:["You can override the automatic behavior using the ",(0,r.jsx)(n.code,{children:"replicationMode"})," option:"]}),"\n",(0,r.jsx)(n.h3,{id:"force-master-for-reads",children:"Force Master for Reads"}),"\n",(0,r.jsx)(n.p,{children:"Useful when you need strong consistency immediately after a write:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Write to master\nawait User.insert({ name: "John", email: "john@example.com" });\n\n// Force read from master (avoid replication lag)\nconst user = await User.find(\n  { where: { email: "john@example.com" } },\n  { replicationMode: "master" }\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"force-slave-for-reads",children:"Force Slave for Reads"}),"\n",(0,r.jsx)(n.p,{children:"Explicitly use slaves even when you have control flow that might default to master:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const users = await User.find(\n  {},\n  { replicationMode: "slave" }\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"with-query-builder",children:"With Query Builder"}),"\n",(0,r.jsxs)(n.p,{children:["The replication mode also works with the query builder using ",(0,r.jsx)(n.code,{children:"setReplicationMode()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Force master for this read\nconst users = await User.query()\n  .setReplicationMode("master")\n  .where("active", true)\n  .many();\n\n// Force slave for this read\nconst count = await User.query()\n  .setReplicationMode("slave")\n  .getCount();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"replication-lag",children:"Replication Lag"}),"\n",(0,r.jsxs)(n.p,{children:["Slave databases may have a slight delay in receiving updates from the master. This is called ",(0,r.jsx)(n.strong,{children:"replication lag"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// This pattern can cause issues due to replication lag:\nconst user = await User.insert({ name: "John" }); // Writes to master\n\n// This might not find the user if slave hasn\'t replicated yet!\nconst found = await User.findOne({\n  where: { id: user.id }\n}); // Reads from slave\n\n// Solution: Force master read after write\nconst found = await User.findOne(\n  { where: { id: user.id } },\n  { replicationMode: "master" } // Read from master\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"transactions",children:"Transactions"}),"\n",(0,r.jsx)(n.p,{children:"All operations within a transaction use the master database, regardless of replication settings:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'await sql.transaction(async (trx) => {\n  // Both operations use master\n  const user = await User.insert({ name: "John" }, { trx });\n  const found = await User.findOne({ where: { id: user.id } }, { trx });\n});\n'})}),"\n",(0,r.jsx)(n.h3,{id:"no-slaves-configured",children:"No Slaves Configured"}),"\n",(0,r.jsx)(n.p,{children:"If no slaves are configured, all operations automatically fall back to the master:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const sql = new SqlDataSource({\n  // ... connection config\n  replication: {\n    slaves: [],\n  },\n});\n\n// All operations use master\nconst users = await User.find(); // Uses master\n"})}),"\n",(0,r.jsx)(n.h2,{id:"streaming-operations",children:"Streaming Operations"}),"\n",(0,r.jsx)(n.p,{children:"Streaming operations also respect replication settings:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Streams from slave\nconst stream = await User.query().stream();\n\n// Streams from master\nconst stream = await User.query()\n  .setReplicationMode("master")\n  .stream();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"raw-queries",children:"Raw Queries"}),"\n",(0,r.jsx)(n.p,{children:"When using raw queries, write operations always use master, and read operations use slaves:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Uses master (INSERT)\nawait sql.query("users").insert({ name: "John", email: "john@example.com" });\n\n// Uses slave (SELECT)\nconst users = await sql.query("users").many();\n\n// Force master\nconst users = await sql.query("users")\n  .setReplicationMode("master")\n  .many();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"connection-management",children:"Connection Management"}),"\n",(0,r.jsx)(n.p,{children:"All slave connections are automatically managed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Connects to master and all slaves\nawait sql.connect();\n\n// Disconnects from master and all slaves\nawait sql.disconnect();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"connection-initialization",children:"Connection Initialization"}),"\n",(0,r.jsx)(n.p,{children:"If a slave fails to connect during initialization, an error will be thrown. Ensure all slave databases are accessible before connecting."}),"\n",(0,r.jsx)(n.h3,{id:"runtime-failures",children:"Runtime Failures"}),"\n",(0,r.jsxs)(n.p,{children:["For failures that occur during query execution (after successful connection), use the ",(0,r.jsx)(n.code,{children:"onSlaveServerFailure"})," callback to handle errors gracefully. The system will automatically fall back to the master database, ensuring your application continues to function even when slaves become unavailable."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const sql = new SqlDataSource({\n  // ... connection config\n  replication: {\n    slaves: [/* ... */],\n    onSlaveServerFailure: async (error) => {\n      // Handle runtime slave failures\n      logger.warn({ error }, "Slave unavailable, falling back to master");\n    },\n  },\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always handle slave failures"}),": Configure ",(0,r.jsx)(n.code,{children:"onSlaveServerFailure"})," to monitor and alert on slave issues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider replication lag"}),": Use ",(0,r.jsx)(n.code,{children:'replicationMode: "master"'})," for reads immediately after writes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor slave health"}),": Track slave failure rates and connection issues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use appropriate algorithms"}),': Choose between "roundRobin" and "random" based on your infrastructure']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test failover scenarios"}),": Ensure your application handles slave failures gracefully in production"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>l});var s=a(6540);const r={},i=s.createContext(r);function t(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[1737],{2924:(n,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>e,toc:()=>l});const e=JSON.parse('{"id":"databases/sql/advanced/transactions","title":"Advanced SQL Features: Transactions","description":"Hysteria ORM provides robust transaction support for SQL databases, allowing you to group multiple operations into a single atomic unit. Transactions ensure data consistency and integrity, supporting features like rollback, isolation levels, nested, concurrent, and global transactions.","source":"@site/docs/databases/sql/advanced/transactions.md","sourceDirName":"databases/sql/advanced","slug":"/databases/sql/advanced/transactions","permalink":"/hysteria-orm/docs/databases/sql/advanced/transactions","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/advanced/transactions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Advanced SQL Features: Transactions","sidebar_position":4}}');var s=t(4848),r=t(8453);const i={title:"Advanced SQL Features: Transactions",sidebar_position:4},o="Transactions",c={},l=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Custom Isolation Level",id:"custom-isolation-level",level:2},{value:"Manual Transaction Control",id:"manual-transaction-control",level:2},{value:"Nested Transactions (Savepoints)",id:"nested-transactions-savepoints",level:2},{value:"Concurrent Transactions",id:"concurrent-transactions",level:2},{value:"Global Transactions",id:"global-transactions",level:2},{value:"Error Handling and Transaction State",id:"error-handling-and-transaction-state",level:2},{value:"Notes",id:"notes",level:2}];function d(n){const a={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"transactions",children:"Transactions"})}),"\n",(0,s.jsx)(a.p,{children:"Hysteria ORM provides robust transaction support for SQL databases, allowing you to group multiple operations into a single atomic unit. Transactions ensure data consistency and integrity, supporting features like rollback, isolation levels, nested, concurrent, and global transactions."}),"\n",(0,s.jsx)(a.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsxs)(a.p,{children:["Use ",(0,s.jsx)(a.code,{children:"startTransaction"})," with a callback to run operations within a transaction. If an error is thrown, the transaction is rolled back automatically."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:'import { SqlDataSource } from "hysteria-orm";\nimport { User } from "./models/user";\n\nconst sql = new SqlDataSource({ type: "postgres", ... });\nawait sql.connect();\n\n// Automatically commits the transaction\nawait sql.startTransaction(async (trx) => {\n  await User.insert({ ...data }, { trx });\n});\n'})}),"\n",(0,s.jsx)(a.p,{children:"If an error occurs, changes are not committed:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:'await sql.startTransaction(async (trx) => {\n  await User.insert({ ...data }, { trx });\n  throw new Error("Test error"); // Transaction is rolled back automatically\n});\n\n// Raw transaction without models\nawait sql.startTransaction(async (trx) => {\n  await trx.sql.query("users");\n});\n'})}),"\n",(0,s.jsx)(a.h2,{id:"custom-isolation-level",children:"Custom Isolation Level"}),"\n",(0,s.jsx)(a.p,{children:"You can specify a transaction isolation level:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:'await sql.startTransaction(\n  async (trx) => {\n    await User.insert({ ...data }, { trx });\n  },\n  { isolationLevel: "SERIALIZABLE" },\n);\n'})}),"\n",(0,s.jsx)(a.h2,{id:"manual-transaction-control",children:"Manual Transaction Control"}),"\n",(0,s.jsx)(a.p,{children:"Start, commit, and rollback transactions manually:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:"const trx = await sql.startTransaction();\nawait User.insert({ ...data }, { trx });\nawait trx.commit();\n"})}),"\n",(0,s.jsx)(a.p,{children:"Rollback on error:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:'const trx = await sql.startTransaction();\ntry {\n  await User.insert({ ...data }, { trx });\n  throw new Error("fail");\n  await trx.commit();\n} catch {\n  await trx.rollback();\n}\n'})}),"\n",(0,s.jsx)(a.h2,{id:"nested-transactions-savepoints",children:"Nested Transactions (Savepoints)"}),"\n",(0,s.jsx)(a.p,{children:"Nested transactions are implemented using database savepoints on the same connection as the outer transaction (no new connections are opened). This enables partial rollbacks without affecting the outer scope."}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"No new connections: nested transactions reuse the outer transaction's connection"}),"\n",(0,s.jsx)(a.li,{children:"Commit: releases the savepoint (does not commit the outer transaction)"}),"\n",(0,s.jsx)(a.li,{children:"Rollback: rolls back to the savepoint (does not roll back the outer transaction)"}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["Savepoint names are stable and driver-safe: ",(0,s.jsx)(a.code,{children:"sp_<nestingDepth>_<transactionIdPrefix>"})," (for example: ",(0,s.jsx)(a.code,{children:"sp_2_AB12CD34"}),")."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:"const outerTrx = await sql.startTransaction();\nawait User.insert({ ...data }, { trx: outerTrx });\n\n// Creates a savepoint on the same connection\nconst innerTrx = await outerTrx.nestedTransaction();\ntry {\n  await User.insert({ ...data }, { trx: innerTrx });\n  await innerTrx.commit(); // RELEASE SAVEPOINT <name>\n} catch (e) {\n  await innerTrx.rollback(); // ROLLBACK TO (savepoint)\n  throw e;\n}\n\nawait outerTrx.commit(); // commits the top-level transaction and releases the connection\n"})}),"\n",(0,s.jsx)(a.h2,{id:"concurrent-transactions",children:"Concurrent Transactions"}),"\n",(0,s.jsx)(a.p,{children:"You can run multiple transactions in parallel on different connections:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:"const trx1 = await sql.startTransaction();\nconst trx2 = await sql.startTransaction();\nawait User.insert({ ...data }, { trx: trx1 });\nawait User.insert({ ...data }, { trx: trx2 });\nawait trx1.commit();\nawait trx2.commit();\n"})}),"\n",(0,s.jsx)(a.h2,{id:"global-transactions",children:"Global Transactions"}),"\n",(0,s.jsx)(a.p,{children:"For integration tests, you can use global transactions.\nGlobal transactions are not advised for production use."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:"await sql.startGlobalTransaction();\n// Automatically uses the transaction from the sql global transaction\nawait User.insert({ ...data });\nawait sql.commitGlobalTransaction();\n"})}),"\n",(0,s.jsx)(a.p,{children:"Rollback global transaction:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:"await sql.startGlobalTransaction();\nawait User.insert({ ...data });\nawait sql.rollbackGlobalTransaction();\n"})}),"\n",(0,s.jsx)(a.p,{children:"You can also use the static methods on the primary instance:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:"await SqlDataSource.startGlobalTransaction();\nawait User.insert({ ...data });\nawait SqlDataSource.rollbackGlobalTransaction();\n"})}),"\n",(0,s.jsx)(a.h2,{id:"error-handling-and-transaction-state",children:"Error Handling and Transaction State"}),"\n",(0,s.jsx)(a.p,{children:"You can enforce error throwing if a transaction is inactive:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:"const trx = await sql.startTransaction();\nawait trx.rollback();\nawait trx.rollback({ throwErrorOnInactiveTransaction: true }); // Throws HysteriaError\n"})}),"\n",(0,s.jsx)(a.p,{children:"Or suppress errors:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-typescript",children:"const trx = await sql.startTransaction();\nawait trx.rollback();\nawait trx.rollback({ throwErrorOnInactiveTransaction: false }); // No error\n"})}),"\n",(0,s.jsx)(a.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Nested transactions never release the connection but only save points; only the top-level transaction releases it on commit/rollback."}),"\n",(0,s.jsxs)(a.li,{children:["Always pass the ",(0,s.jsx)(a.code,{children:"trx"})," object to model methods to ensure operations are part of the transaction."]}),"\n",(0,s.jsx)(a.li,{children:"Use isolation levels for advanced consistency requirements."}),"\n"]}),"\n",(0,s.jsx)(a.hr,{}),"\n",(0,s.jsx)(a.p,{children:"See also:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.a,{href:"/hysteria-orm/docs/databases/sql/advanced/cte",children:"CTE"})}),"\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.a,{href:"/hysteria-orm/docs/databases/sql/advanced/json",children:"JSON Columns"})}),"\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.a,{href:"/hysteria-orm/docs/databases/sql/advanced/sqlite-json-limitations",children:"SQLite JSON Limitations"})}),"\n"]})]})}function h(n={}){const{wrapper:a}={...(0,r.R)(),...n.components};return a?(0,s.jsx)(a,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,a,t)=>{t.d(a,{R:()=>i,x:()=>o});var e=t(6540);const s={},r=e.createContext(s);function i(n){const a=e.useContext(r);return e.useMemo((function(){return"function"==typeof n?n(a):{...a,...n}}),[a,n])}function o(n){let a;return a=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),e.createElement(r.Provider,{value:a},n.children)}}}]);
"use strict";(self.webpackChunkhysteria_orm_docs=self.webpackChunkhysteria_orm_docs||[]).push([[7538],{2479:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"databases/sql/relations/overview","title":"Relations Overview","description":"Hysteria ORM supports rich relation types between models:","source":"@site/docs/databases/sql/relations/overview.md","sourceDirName":"databases/sql/relations","slug":"/databases/sql/relations/overview","permalink":"/hysteria-orm/docs/databases/sql/relations/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/hysteria-orm/tree/main/website/docs/databases/sql/relations/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Relations Overview","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Create Migration Command","permalink":"/hysteria-orm/docs/databases/sql/cli/create-migration"},"next":{"title":"Advanced SQL Features: CTE","permalink":"/hysteria-orm/docs/databases/sql/advanced/cte"}}');var i=n(4848),t=n(8453);const l={title:"Relations Overview",sidebar_position:1},a="Relations Overview",d={},o=[{value:"Example Models",id:"example-models",level:2},{value:"Querying Relations",id:"querying-relations",level:2},{value:"Eager Loading",id:"eager-loading",level:3},{value:"Selecting columns",id:"selecting-columns",level:3},{value:"Nested Relations",id:"nested-relations",level:3},{value:"Filtering on Relations",id:"filtering-on-relations",level:3},{value:"Limiting and Offset",id:"limiting-and-offset",level:3},{value:"Advanced relation queries",id:"advanced-relation-queries",level:3},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"relations-overview",children:"Relations Overview"})}),"\n",(0,i.jsx)(s.p,{children:"Hysteria ORM supports rich relation types between models:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"belongsTo"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"hasOne"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"hasMany"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"manyToMany"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Relations are retrieved using batch loading, so one query is made for each relation only if ",(0,i.jsx)(s.code,{children:"load"})," is called.\nBe carefull, too many relation retrieve could slow down you overall query\nAnnotations and nested relations are typed inside the retrieved relations."]}),"\n",(0,i.jsx)(s.h2,{id:"example-models",children:"Example Models"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"class User extends Model {\n  @hasMany(() => Post, 'userId')\n  declare posts: Post[];\n\n  @manyToMany(() => Address, () => UserAddress, {\n    leftForeignKey: 'userId',\n    rightForeignKey: 'addressId',\n  })\n  declare addresses: Address[];\n}\n\nclass Post extends Model {\n  @column({ type: 'integer', primaryKey: true })\n  declare id: number;\n\n  @column({ type: 'integer' })\n  declare userId: number;\n\n  // Belongs to does not benefit from type inference by default for typescript limitations, it's adviced to use the generic type to avoid type errors\n  @belongsTo<typeof Post>(() => User, 'userId') // With the generic we are obligated to specify a model field\n  declare user: User;\n}\n\nclass Address extends Model {\n  @manyToMany(() => User, () => UserAddress, {\n    leftForeignKey: 'addressId',\n    rightForeignKey: 'userId',\n  })\n  declare users: User[];\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"querying-relations",children:"Querying Relations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Remember to always select the foreign key in the relation query builder, otherwise the relation will not be filled."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts').many();\n"})}),"\n",(0,i.jsx)(s.h3,{id:"selecting-columns",children:"Selecting columns"}),"\n",(0,i.jsxs)(s.p,{children:["In this case ",(0,i.jsx)(s.code,{children:"userId"})," must be selected in the relation query builder, otherwise the relation will not be filled."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts', (qb) =>\n  qb.select('id', 'title', 'userId')\n).many();\n"})}),"\n",(0,i.jsx)(s.h3,{id:"nested-relations",children:"Nested Relations"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts', (qb) =>\n  qb.load('user')\n).many();\n"})}),"\n",(0,i.jsx)(s.h3,{id:"filtering-on-relations",children:"Filtering on Relations"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts', (qb) =>\n  qb.where('title', 'Hello World')\n).many();\n"})}),"\n",(0,i.jsx)(s.h3,{id:"limiting-and-offset",children:"Limiting and Offset"}),"\n",(0,i.jsxs)(s.p,{children:["Limiting and offset are referred to the related models, so in this case 10 posts will be selected for each user skipping the first 10.\nAdding ",(0,i.jsx)(s.code,{children:"limit"})," or ",(0,i.jsx)(s.code,{children:"offset"})," will create a CTE to apply the limit and offset to the related models."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const users = await User.query().load('posts', (qb) =>\n  qb.where('title', 'Hello World').limit(10).offset(10)\n).many();\n"})}),"\n",(0,i.jsx)(s.h3,{id:"advanced-relation-queries",children:"Advanced relation queries"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:'const users = await User.query().load(\'posts\', (qb) =>\n  qb.annotate("max", "id", "maxId").load("user")\n).many();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Use ",(0,i.jsx)(s.code,{children:"load"})," for batch relation loading."]}),"\n",(0,i.jsx)(s.li,{children:"Use callbacks for nested and filtered relations."}),"\n",(0,i.jsx)(s.li,{children:"Always define foreign keys explicitly for clarity."}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.p,{children:["Next: ",(0,i.jsx)(s.a,{href:"/hysteria-orm/docs/databases/sql/advanced/cte",children:"Advanced SQL Features"})]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>a});var r=n(6540);const i={},t=r.createContext(i);function l(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);